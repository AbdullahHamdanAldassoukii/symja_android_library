package org.matheclipse.core.integrate.rubi;


import static org.matheclipse.core.expression.F.*;
import static org.matheclipse.core.integrate.rubi.UtilityFunctionCtors.*;
import static org.matheclipse.core.integrate.rubi.UtilityFunctions.*;

import org.matheclipse.core.interfaces.IAST;
import org.matheclipse.core.interfaces.IExpr;
import org.matheclipse.core.interfaces.ISymbol;
/** 
 * UtilityFunctions rules from the <a href="http://www.apmaths.uwo.ca/~arich/">Rubi -
 * rule-based integrator</a>.
 *  
 */
public class UtilityFunctions4 { 
  public static IAST RULES = List( 
ISetDelayed(SumFreeQ(u_),
    If(AtomQ(u),True,If(SumQ(u),False,Catch(CompoundExpression(Scan(Function(If(SumFreeQ(Slot1),Null,Throw(False))),u),True))))),
ISetDelayed(ExpandExpression(u_,x_Symbol),
    If(Or(Or(Or(Or(Or(Or(SumQ(u),MatchQ(u,Condition(Times(c_DEFAULT,Power(Plus(a_,Times(b_DEFAULT,Power(x,n_DEFAULT))),CN1)),And(FreeQ(List(a,b,c),x),IntIntegerQ(n))))),MatchQ(u,Condition(Times(c_DEFAULT,Power(x,m_DEFAULT),Power(Plus(a_,Times(b_DEFAULT,Power(x,n_DEFAULT))),p_DEFAULT)),And(And(FreeQ(List(a,b,c),x),IntIntegerQ(List(m,n,p))),ZeroQ(Plus(m,Times(CN1,n),C1)))))),MatchQ(u,Condition(Times(c_DEFAULT,Power(x,m_DEFAULT),Power(Plus(v_,Times(b_DEFAULT,Power(x,n_DEFAULT))),p_DEFAULT)),And(And(And(And(FreeQ(List(b,c),x),Not(AlgebraicFunctionQ(v,x))),IntIntegerQ(List(m,n,p))),Less(p,C0)),And(Less(C0,n),LessEqual(n,m)))))),MatchQ(u,Condition(Times(Power(x,m_),Power($(f_,Plus(a_DEFAULT,Times(b_DEFAULT,x))),n_DEFAULT)),And(And(FreeQ(List(a,b,m,n),x),MemberQ(List($s("Tan"),$s("Cot"),$s("Tanh"),$s("Coth")),f)),Not(And(IntIntegerQ(m),Greater(m,C0))))))),MatchQ(u,Condition(Times($(f_,Plus(a_DEFAULT,Times(b_DEFAULT,x),Times(c_DEFAULT,Power(x,C2)))),Power(x,CN1)),And(FreeQ(List(a,b,c),x),MemberQ(List($s("Sin"),$s("Cos"),$s("Sinh"),$s("Cosh")),f))))),MatchQ(u,Condition(Power(Plus(a_,Times(b_DEFAULT,Power($(f_,Plus(c_DEFAULT,Times($p(d,true),x))),C2))),n_),And(And(FreeQ(List(a,b),x),MemberQ(List($s("Sin"),$s("Cos"),$s("Sinh"),$s("Cosh")),f)),IntIntegerQ(n))))),u,Module(List($s("tmp"),$s("lst")),CompoundExpression(Set($s("tmp"),FindKernel(u,x)),If(And(NotFalseQ($s("tmp")),FunctionOfKernelQ(u,$s("tmp"),x)),Subst(ExpandExpression(Subst(u,$s("tmp"),x),x),x,$s("tmp")),CompoundExpression(Set($s("tmp"),FunctionOfTrigQ(u,x,x)),If(And(And($s("tmp"),Or(ContainsQ(u,$s("Sin"),x),ContainsQ(u,$s("Csc"),x))),FunctionOfQ(Sin(x),u,x)),ExpandTrigExpression(u,Sin(x),x),If(And(And($s("tmp"),Or(ContainsQ(u,$s("Cos"),x),ContainsQ(u,$s("Sec"),x))),FunctionOfQ(Cos(x),u,x)),ExpandTrigExpression(u,Cos(x),x),If(And(And($s("tmp"),Or(ContainsQ(u,$s("Tan"),x),ContainsQ(u,$s("Cot"),x))),FunctionOfQ(Tan(x),u,x)),ExpandTrigExpression(u,Tan(x),x),CompoundExpression(Set($s("tmp"),FunctionOfHyperbolicQ(u,x,x)),If(And(And($s("tmp"),Or(ContainsQ(u,$s("Sinh"),x),ContainsQ(u,$s("Csch"),x))),FunctionOfQ(Sinh(x),u,x)),ExpandTrigExpression(u,Sinh(x),x),If(And(And($s("tmp"),Or(ContainsQ(u,$s("Cosh"),x),ContainsQ(u,$s("Sech"),x))),FunctionOfQ(Cosh(x),u,x)),ExpandTrigExpression(u,Cosh(x),x),If(And(And($s("tmp"),Or(ContainsQ(u,$s("Tanh"),x),ContainsQ(u,$s("Coth"),x))),FunctionOfQ(Tanh(x),u,x)),ExpandTrigExpression(u,Tanh(x),x),Module(List(v),If(And(AlgebraicFunctionQ(u,x),Not(RationalFunctionQ(u,x))),If(GoodExpansionQ(u,Set(v,ExpandExpressionAux(u,x)),x),RegularizeTerm(v,x),u),If(GoodExpansionQ(u,Set(v,Apart(u,x)),x),RegularizeTerm(v,x),If(GoodExpansionQ(u,Set(v,Apart(u)),x),RegularizeTerm(v,x),If(GoodExpansionQ(u,Set(v,ExpandExpressionAux(u,x)),x),RegularizeTerm(v,x),If(TrigHyperbolicFreeQ(u,x),CompoundExpression(Set(v,Apart(u,x)),RegularizeTerm(If(GoodExpansionQ(u,v,x),v,u),x)),CompoundExpression(CompoundExpression(Set($s("tmp"),TryTrigReduceQ(u)),If($s("tmp"),Set($s("lst"),SplitFreeFactors(TrigReduce(u),x)))),If(And($s("tmp"),GoodExpansionQ(u,Set(v,Apart(Part($s("lst"),C2),x)),x)),Map(Function(RegularizeTerm(Times(Part($s("lst"),C1),Slot1),x)),v),If(And($s("tmp"),GoodExpansionQ(u,Set(v,Apart(Part($s("lst"),C2))),x)),Map(Function(RegularizeTerm(Times(Part($s("lst"),C1),Slot1),x)),v),If(And($s("tmp"),GoodExpansionQ(u,Set(v,ExpandExpressionAux(Part($s("lst"),C2),x)),x)),Map(Function(RegularizeTerm(Times(Part($s("lst"),C1),Slot1),x)),v),CompoundExpression(Set(v,SmartTrigExpand(u,x)),If(SumQ(v),RegularizeTerm(v,x),CompoundExpression(Set(v,TrigExpand(u)),If(And(SumQ(v),SumQ(Set(v,Simplify(v)))),RegularizeTerm(v,x),CompoundExpression(Set(v,Apart(u,x)),RegularizeTerm(If(GoodExpansionQ(u,v,x),v,u),x))))))))))))))))))))))))))))),
ISetDelayed(TryTrigReduceQ(u_),
    MatchQ(u,Condition(Times(v_,Power($(f_,w_),n_)),And(IntIntegerQ(n),MemberQ(List($s("Sin"),$s("Cos"),$s("Sinh"),$s("Cosh")),f))))),
ISetDelayed(ExpandTrigExpression(u_,v_,x_Symbol),
    Module(List(Set(w,TrigSimplify(Subst(ExpandExpression(SubstFor(v,u,x),x),x,v)))),If(SumQ(w),Map(Function(ExpandTrigExpressionAux(Slot1,x)),w),w))),
ISetDelayed(ExpandTrigExpressionAux(Times(u_,v_),x_Symbol),
    Condition(Map(Function(Times(u,Slot1)),v),And(And(SumQ(v),Not(FreeQ(u,x))),Not(FreeQ(v,x))))),
ISetDelayed(ExpandTrigExpressionAux(u_,x_Symbol),
    u),
ISetDelayed(GoodExpansionQ(u_,v_,x_Symbol),
    If(SumQ(v),If(IntPolynomialQ(u,x),True,If(RationalFunctionQ(u,x),If(RationalFunctionQ(v,x),Module(List(Set($s("lst"),RationalFunctionExponents(u,x))),Catch(CompoundExpression(Scan(Function(If(SimplerRationalFunctionQ($s("lst"),RationalFunctionExponents(Slot1,x)),Throw(False))),v),True))),False),True)),False)),
ISetDelayed(SimplerRationalFunctionQ($p("lst1"),$p("lst2")),
    And(And(LessEqual(Part($s("lst1"),C1),Part($s("lst2"),C1)),LessEqual(Part($s("lst1"),C2),Part($s("lst2"),C2))),Or(Less(Part($s("lst1"),C1),Part($s("lst2"),C1)),Less(Part($s("lst1"),C2),Part($s("lst2"),C2))))),
ISetDelayed(ExpandExpressionAux(Times(Plus(Times(Power(x_,k_DEFAULT),$p(e,true)),$p(d)),Power(Plus(Times(Power(x_,k_),b_DEFAULT),Times(Power(x_,j_),c_DEFAULT),a_),n_)),x_Symbol),
    Condition(Plus(Times(d,Power(Plus(a,Times(b,Power(x,k)),Times(c,Power(x,j))),n)),Times(e,Power(x,k),Power(Plus(a,Times(b,Power(x,k)),Times(c,Power(x,j))),n))),And(And(And(And(FreeQ(List(a,b,c,d,e),x),IntIntegerQ(List(n,k,j))),EvenQ(k)),Equal(j,Times(C2,k))),Less(n,CN1)))),
ISetDelayed(ExpandExpressionAux(Times(u_,v_),x_Symbol),
    Condition(Map(Function(Times(Slot1,v)),u),And(SumQ(u),Not(FreeQ(u,x))))),
ISetDelayed(ExpandExpressionAux(Times(Power(u_,n_),v_DEFAULT),x_Symbol),
    Condition(Module(List(Set(w,Expand(Power(u,n),x))),Condition(Map(Function(Times(Slot1,v)),w),SumQ(w))),And(And(And(SumQ(u),IntIntegerQ(n)),Greater(n,C0)),Not(FreeQ(u,x))))),
ISetDelayed(RegularizeTerm(Times(Power(Plus(Times(Power(x_,n_),b_DEFAULT),a_),CN1),c_DEFAULT,u_),x_Symbol),
    Condition(If(IntPolynomialQ(u,x),Module(List(k),Sum(RegularizeTerm(Times(c,Coefficient(u,x,k),Power(x,k),Power(Plus(a,Times(b,Power(x,n))),CN1)),x),List(k,C0,Exponent(u,x)))),Map(Function(RegularizeTerm(Times(c,Slot1,Power(Plus(a,Times(b,Power(x,n))),CN1)),x)),u)),And(And(And(And(FreeQ(List(a,b,c),x),IntIntegerQ(n)),Greater(n,C0)),SumQ(u)),Not(FreeQ(u,x))))),
ISetDelayed(RegularizeTerm(u_,x_Symbol),
    If(SumQ(u),Map(Function(RegularizeTerm(Slot1,x)),u),Module(List($s("lst1"),$s("lst2")),CompoundExpression(CompoundExpression(CompoundExpression(CompoundExpression(Set($s("lst1"),SplitFreeFactors(NormalForm(u,x),x)),Set($s("lst2"),SplitFreeFactors(Regularize(Part($s("lst1"),C2),x),x))),Set($s("lst2"),List(Times(Part($s("lst1"),C1),Part($s("lst2"),C1)),Part($s("lst2"),C2)))),Set($s("lst2"),List(Times(Simplify(Numerator(Part($s("lst2"),C1))),Power(Simplify(Denominator(Part($s("lst2"),C1))),CN1)),Part($s("lst2"),C2)))),If(SumQ(Part($s("lst2"),C2)),Map(Function(Times(Part($s("lst2"),C1),Slot1)),Part($s("lst2"),C2)),Times(Part($s("lst2"),C1),Part($s("lst2"),C2))))))),
ISetDelayed(ContainsQ(u_,f_,x_),
    Greater(Count(u,Condition($(f,Times(n_DEFAULT,x)),IntIntegerQ(n)),CInfinity),C0)),
ISetDelayed(FunctionOfKernelQ(u_,v_,x_),
    If(SameQ(u,v),True,If(AtomQ(u),UnsameQ(u,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfKernelQ(Slot1,v,x)),Throw(False))),u),True))))),
ISetDelayed(FindKernel(u_,x_),
    If(AlgebraicFunctionQ(u,x),False,If(And(SameQ(Length(u),C1),AlgebraicFunctionQ(Part(u,C1),x)),u,If(And(And(SameQ(Length(u),C2),AlgebraicFunctionQ(Part(u,C1),x)),FreeQ(Part(u,C2),x)),u,If(And(And(SameQ(Length(u),C2),AlgebraicFunctionQ(Part(u,C2),x)),FreeQ(Part(u,C1),x)),u,Module(List($s("tmp")),Catch(CompoundExpression(Scan(Function(If(NotFalseQ(Set($s("tmp"),FindKernel(Slot1,x))),Throw($s("tmp")))),u),False)))))))),
ISetDelayed(CommonNumericFactors($p("lst")),
    Module(List(Set($s("num"),Apply($s("GCD"),Map($s("Integrate::NumericFactor"),$s("lst"))))),Prepend(Map(Function(Times(Slot1,Power($s("num"),CN1))),$s("lst")),$s("num")))),
ISetDelayed(NumericFactor(u_),
    If(NumberQ(u),If(ZeroQ(Im(u)),u,If(ZeroQ(Re(u)),Im(u),C1)),If(PowerQ(u),If(And(RationalQ(Part(u,C1)),FractionQ(Part(u,C2))),If(Greater(Part(u,C2),C0),Power(Denominator(Part(u,C1)),CN1),Power(Denominator(Power(Part(u,C1),CN1)),CN1)),C1),If(ProductQ(u),Times(NumericFactor(First(u)),NumericFactor(Rest(u))),C1)))),
ISetDelayed(NonnumericFactors(u_),
    If(NumberQ(u),If(ZeroQ(Im(u)),C1,If(ZeroQ(Re(u)),CI,u)),If(PowerQ(u),If(And(RationalQ(Part(u,C1)),FractionQ(Part(u,C2))),Times(u,Power(NumericFactor(u),CN1)),u),If(ProductQ(u),Times(NonnumericFactors(First(u)),NonnumericFactors(Rest(u))),u)))),
ISetDelayed(ContentFactor($p("expn")),
    If(AtomQ($s("expn")),$s("expn"),If(ProductQ($s("expn")),Map($s("Integrate::ContentFactor"),$s("expn")),If(SumQ($s("expn")),Module(List(Set($s("lst"),CommonFactors(Apply($s("List"),$s("expn"))))),If(Or(SameQ(Part($s("lst"),C1),C1),SameQ(Part($s("lst"),C1),CN1)),$s("expn"),Times(Part($s("lst"),C1),Apply(Plus,Rest($s("lst")))))),$s("expn"))))),
ISetDelayed(CommonFactors($p("lst")),
    Module(List($s("lst1"),$s("lst2"),$s("lst3"),$s("lst4"),$s("common"),$s("base"),$s("num")),CompoundExpression(CompoundExpression(CompoundExpression(CompoundExpression(CompoundExpression(CompoundExpression(Set($s("lst1"),Map($s("Integrate::NonnumericFactors"),$s("lst"))),Set($s("lst2"),Map($s("Integrate::NumericFactor"),$s("lst")))),Set($s("num"),Apply($s("GCD"),$s("lst2")))),If(MapAnd(Function(Less(Slot1,C0)),$s("lst2")),Set($s("num"),Times(CN1,$s("num"))))),Set($s("common"),$s("num"))),Set($s("lst2"),Map(Function(Times(Slot1,Power($s("num"),CN1))),$s("lst2")))),While(True,CompoundExpression(CompoundExpression(Set($s("lst3"),Map($s("Integrate::LeadFactor"),$s("lst1"))),If(Apply($s("SameQ"),$s("lst3")),CompoundExpression(Set($s("common"),Times($s("common"),Part($s("lst3"),C1))),Set($s("lst1"),Map($s("Integrate::RemainingFactors"),$s("lst1")))),If(And(MapAnd(Function(And(And(LogQ(Slot1),IntIntegerQ(First(Slot1))),Greater(First(Slot1),C0))),$s("lst3")),MapAnd($s("Integrate::RationalQ"),Set($s("lst4"),Map(Function(FullSimplify(Times(Slot1,Power(First($s("lst3")),CN1)))),$s("lst3"))))),CompoundExpression(CompoundExpression(CompoundExpression(Set($s("num"),Apply($s("GCD"),$s("lst4"))),Set($s("common"),Times($s("common"),Log(Power(Part(First($s("lst3")),C1),$s("num")))))),Set($s("lst2"),Map2(Function(Times(Slot1,Slot2,Power($s("num"),CN1))),$s("lst2"),$s("lst4")))),Set($s("lst1"),Map($s("Integrate::RemainingFactors"),$s("lst1")))),If(And(Apply($s("SameQ"),Map($s("Integrate::LeadBase"),$s("lst1"))),MapAnd($s("Integrate::RationalQ"),Set($s("lst4"),Map($s("Integrate::LeadDegree"),$s("lst1"))))),CompoundExpression(CompoundExpression(CompoundExpression(CompoundExpression(Set($s("num"),Smallest($s("lst4"))),Set($s("base"),LeadBase(Part($s("lst1"),C1)))),If(Unequal($s("num"),C0),Set($s("common"),Times($s("common"),Power($s("base"),$s("num")))))),Set($s("lst2"),Map2(Function(Times(Slot1,Power($s("base"),Plus(Slot2,Times(CN1,$s("num")))))),$s("lst2"),$s("lst4")))),Set($s("lst1"),Map($s("Integrate::RemainingFactors"),$s("lst1")))),CompoundExpression(CompoundExpression(Set($s("num"),MostMainFactorPosition($s("lst3"))),Set($s("lst2"),ReplacePart($s("lst2"),Times(Part($s("lst3"),$s("num")),Part($s("lst2"),$s("num"))),$s("num")))),Set($s("lst1"),ReplacePart($s("lst1"),RemainingFactors(Part($s("lst1"),$s("num"))),$s("num")))))))),If(MapAnd(Function(SameQ(Slot1,C1)),$s("lst1")),Return(Prepend($s("lst2"),$s("common"))))))))),
ISetDelayed(MostMainFactorPosition($p("lst",$s("List"))),
    Module(List(Set($s("factor"),C1),Set($s("num"),C1)),CompoundExpression(Do(If(Greater(FactorOrder(Part($s("lst"),i),$s("factor")),C0),CompoundExpression(Set($s("factor"),Part($s("lst"),i)),Set($s("num"),i))),List(i,Length($s("lst")))),$s("num")))),
ISetDelayed(FactorOrder(u_,v_),
    If(SameQ(u,C1),If(SameQ(v,C1),C0,CN1),If(SameQ(v,C1),C1,Order(u,v)))),
ISetDelayed(Smallest($p("num1"),$p("num2")),
    If(Greater($s("num1"),C0),If(Greater($s("num2"),C0),Min($s("num1"),$s("num2")),C0),If(Greater($s("num2"),C0),C0,Max($s("num1"),$s("num2"))))),
ISetDelayed(Smallest($p("lst",$s("List"))),
    Module(List(Set($s("num"),Part($s("lst"),C1))),CompoundExpression(Scan(Function(Set($s("num"),Smallest($s("num"),Slot1))),Rest($s("lst"))),$s("num")))),
ISetDelayed(MonomialFactor(u_,x_Symbol),
    If(AtomQ(u),If(SameQ(u,x),List(C1,C1),List(C0,u)),If(PowerQ(u),If(IntIntegerQ(Part(u,C2)),Module(List(Set($s("lst"),MonomialFactor(Part(u,C1),x))),List(Times(Part($s("lst"),C1),Part(u,C2)),Power(Part($s("lst"),C2),Part(u,C2)))),If(And(SameQ(Part(u,C1),x),FreeQ(Part(u,C2),x)),List(Part(u,C2),C1),List(C0,u))),If(ProductQ(u),Module(List(Set($s("lst1"),MonomialFactor(First(u),x)),Set($s("lst2"),MonomialFactor(Rest(u),x))),List(Plus(Part($s("lst1"),C1),Part($s("lst2"),C1)),Times(Part($s("lst1"),C2),Part($s("lst2"),C2)))),If(SumQ(u),Module(List($s("lst"),$s("deg")),CompoundExpression(CompoundExpression(CompoundExpression(Set($s("lst"),Map(Function(MonomialFactor(Slot1,x)),Apply($s("List"),u))),Set($s("deg"),Part($s("lst"),C1,C1))),Scan(Function(Set($s("deg"),MinimumDegree($s("deg"),Part(Slot1,C1)))),Rest($s("lst")))),If(Or(ZeroQ($s("deg")),And(RationalQ($s("deg")),Less($s("deg"),C0))),List(C0,u),List($s("deg"),Apply(Plus,Map(Function(Times(Power(x,Plus(Part(Slot1,C1),Times(CN1,$s("deg")))),Part(Slot1,C2))),$s("lst"))))))),List(C0,u)))))),
ISetDelayed(MinimumDegree($p("deg1"),$p("deg2")),
    If(RationalQ($s("deg1")),If(RationalQ($s("deg2")),Min($s("deg1"),$s("deg2")),$s("deg1")),If(RationalQ($s("deg2")),$s("deg2"),Module(List(Set($s("deg"),Simplify(Plus($s("deg1"),Times(CN1,$s("deg2")))))),If(RationalQ($s("deg")),If(Greater($s("deg"),C0),$s("deg2"),$s("deg1")),If(OrderedQ(List($s("deg1"),$s("deg2"))),$s("deg1"),$s("deg2"))))))),
ISetDelayed(ConstantFactor(u_,x_Symbol),
    If(FreeQ(u,x),List(u,C1),If(AtomQ(u),List(C1,u),If(And(PowerQ(u),FreeQ(Part(u,C2),x)),Module(List(Set($s("lst"),ConstantFactor(Part(u,C1),x))),If(IntIntegerQ(Part(u,C2)),List(Power(Part($s("lst"),C1),Part(u,C2)),Power(Part($s("lst"),C2),Part(u,C2))),List(Power(PositiveFactors(Part($s("lst"),C1)),Part(u,C2)),Power(Times(NonpositiveFactors(Part($s("lst"),C1)),Part($s("lst"),C2)),Part(u,C2))))),If(ProductQ(u),Module(List(Set($s("lst"),Map(Function(ConstantFactor(Slot1,x)),Apply($s("List"),u)))),List(Apply(Times,Map($s("First"),$s("lst"))),Apply(Times,Map($s("Integrate::Second"),$s("lst"))))),If(SumQ(u),Module(List(Set($s("lst1"),Map(Function(ConstantFactor(Slot1,x)),Apply($s("List"),u)))),If(Apply($s("SameQ"),Map($s("Integrate::Second"),$s("lst1"))),List(Apply(Plus,Map($s("First"),$s("lst1"))),Part($s("lst1"),C1,C2)),Module(List(Set($s("lst2"),CommonFactors(Map($s("First"),$s("lst1"))))),List(First($s("lst2")),Apply(Plus,Map2(Times,Rest($s("lst2")),Map($s("Integrate::Second"),$s("lst1")))))))),List(C1,u))))))),
ISetDelayed(PositiveFactors(u_),
    If(ZeroQ(u),C1,If(RationalQ(u),Abs(u),If(PositiveQ(u),u,If(ProductQ(u),Map($s("Integrate::PositiveFactors"),u),C1))))),
ISetDelayed(NonpositiveFactors(u_),
    If(ZeroQ(u),u,If(RationalQ(u),Sign(u),If(PositiveQ(u),C1,If(ProductQ(u),Map($s("Integrate::NonpositiveFactors"),u),u))))),
ISetDelayed(FunctionOfLinear(u_,x_Symbol),
    Module(List(Set($s("lst"),FunctionOfLinear(u,False,False,x,False))),If(Or(Or(FalseQ($s("lst")),FalseQ(Part($s("lst"),C1))),And(SameQ(Part($s("lst"),C1),C0),SameQ(Part($s("lst"),C2),C1))),False,List(FunctionOfLinearSubst(u,Part($s("lst"),C1),Part($s("lst"),C2),x),Part($s("lst"),C1),Part($s("lst"),C2))))),
ISetDelayed(FunctionOfLinear(u_,a_,b_,x_,$p("flag")),
    If(FreeQ(u,x),List(a,b),If(CalculusQ(u),False,If(LinearQ(u,x),If(FalseQ(a),List(Coefficient(u,x,C0),Coefficient(u,x,C1)),Module(List(Set($s("lst"),CommonFactors(List(b,Coefficient(u,x,C1))))),If(And(ZeroQ(Coefficient(u,x,C0)),Not($s("flag"))),List(C0,Part($s("lst"),C1)),If(ZeroQ(Plus(Times(b,Coefficient(u,x,C0)),Times(CN1,a,Coefficient(u,x,C1)))),List(Times(a,Power(Part($s("lst"),C2),CN1)),Part($s("lst"),C1)),List(C0,C1))))),If(And(PowerQ(u),FreeQ(Part(u,C1),x)),FunctionOfLinear(Times(Log(Part(u,C1)),Part(u,C2)),a,b,x,False),Module(List($s("lst")),If(And(ProductQ(u),NonzeroQ(Part(Set($s("lst"),MonomialFactor(u,x)),C1))),If(And(And(And(False,IntIntegerQ(Part($s("lst"),C1))),Unequal(Part($s("lst"),C1),CN1)),FreeQ(Part($s("lst"),C2),x)),If(And(RationalQ(LeadFactor(Part($s("lst"),C2))),Less(LeadFactor(Part($s("lst"),C2)),C0)),FunctionOfLinear(Times(DivideDegreesOfFactors(Times(CN1,Part($s("lst"),C2)),Part($s("lst"),C1)),x),a,b,x,False),FunctionOfLinear(Times(DivideDegreesOfFactors(Part($s("lst"),C2),Part($s("lst"),C1)),x),a,b,x,False)),False),CompoundExpression(Set($s("lst"),List(a,b)),Catch(CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),FunctionOfLinear(Slot1,Part($s("lst"),C1),Part($s("lst"),C2),x,SumQ(u))),If(SameQ($s("lst"),False),Throw(False)))),u),$s("lst"))))))))))),
ISetDelayed(FunctionOfLinearSubst(u_,a_,b_,x_),
    If(FreeQ(u,x),u,If(LinearQ(u,x),Module(List(Set($s("tmp"),Coefficient(u,x,C1))),CompoundExpression(Set($s("tmp"),If(SameQ($s("tmp"),b),C1,Times($s("tmp"),Power(b,CN1)))),Plus(Coefficient(u,x,C0),Times(CN1,a,$s("tmp")),Times($s("tmp"),x)))),If(And(PowerQ(u),FreeQ(Part(u,C1),x)),Power(E,FullSimplify(FunctionOfLinearSubst(Times(Log(Part(u,C1)),Part(u,C2)),a,b,x))),Module(List($s("lst")),If(And(ProductQ(u),NonzeroQ(Part(Set($s("lst"),MonomialFactor(u,x)),C1))),If(And(RationalQ(LeadFactor(Part($s("lst"),C2))),Less(LeadFactor(Part($s("lst"),C2)),C0)),Times(CN1,Power(FunctionOfLinearSubst(Times(DivideDegreesOfFactors(Times(CN1,Part($s("lst"),C2)),Part($s("lst"),C1)),x),a,b,x),Part($s("lst"),C1))),Power(FunctionOfLinearSubst(Times(DivideDegreesOfFactors(Part($s("lst"),C2),Part($s("lst"),C1)),x),a,b,x),Part($s("lst"),C1))),Map(Function(FunctionOfLinearSubst(Slot1,a,b,x)),u))))))),
ISetDelayed(DivideDegreesOfFactors(u_,n_),
    If(ProductQ(u),Map(Function(Power(LeadBase(Slot1),Times(LeadDegree(Slot1),Power(n,CN1)))),u),Power(LeadBase(u),Times(LeadDegree(u),Power(n,CN1))))),
ISetDelayed(FunctionOfInverseLinear(u_,x_Symbol),
    FunctionOfInverseLinear(u,Null,x)),
ISetDelayed(FunctionOfInverseLinear(u_,$p("lst"),x_),
    If(FreeQ(u,x),$s("lst"),If(SameQ(u,x),False,If(QuotientOfLinearsQ(u,x),Module(List(Set($s("tmp"),Drop(QuotientOfLinearsParts(u,x),C2))),If(SameQ(Part($s("tmp"),C2),C0),False,If(SameQ($s("lst"),Null),$s("tmp"),If(ZeroQ(Plus(Times(Part($s("lst"),C1),Part($s("tmp"),C2)),Times(CN1,Part($s("lst"),C2),Part($s("tmp"),C1)))),$s("lst"),False)))),If(CalculusQ(u),False,Module(List(Set($s("tmp"),$s("lst"))),Catch(CompoundExpression(Scan(Function(If(FalseQ(Set($s("tmp"),FunctionOfInverseLinear(Slot1,$s("tmp"),x))),Throw(False))),u),$s("tmp"))))))))),
ISetDelayed(FunctionOfExponentialOfLinear(u_,x_Symbol),
    Module(List(Set($s("lst"),FunctionOfExponentialOfLinear(u,x,False,False,False)),a,b,f),If(Or(FalseQ($s("lst")),FalseQ(Part($s("lst"),C1))),False,CompoundExpression(CompoundExpression(CompoundExpression(CompoundExpression(Set(a,Part($s("lst"),C1)),Set(b,Part($s("lst"),C2))),Set(f,Part($s("lst"),C3))),If(And(MatchQ(u,Condition(Times(v_,Power(g_,Plus(c_DEFAULT,Times($p(d),x)))),And(FreeQ(List(c,d,g),x),Less(NumericFactor(d),C0)))),Greater(NumericFactor(b),C0)),CompoundExpression(Set(a,Times(CN1,a)),Set(b,Times(CN1,b))))),List(FunctionOfExponentialOfLinearSubst(u,a,b,f,x),a,b,f))))),
ISetDelayed(FunctionOfExponentialOfLinear(u_,x_,a_,b_,f_),
    If(FreeQ(u,x),List(a,b,f),If(Or(SameQ(u,x),CalculusQ(u)),False,If(And(And(PowerQ(u),FreeQ(Part(u,C1),x)),LinearQ(Part(u,C2),x)),FunctionOfExponentialOfLinearAux(a,b,f,Coefficient(Part(u,C2),x,C0),Coefficient(Part(u,C2),x,C1),Part(u,C1)),If(And(HyperbolicQ(u),LinearQ(Part(u,C1),x)),FunctionOfExponentialOfLinearAux(a,b,f,Coefficient(Part(u,C1),x,C0),Coefficient(Part(u,C1),x,C1),E),Module(List($s("lst")),If(And(And(PowerQ(u),FreeQ(Part(u,C1),x)),SumQ(Part(u,C2))),CompoundExpression(Set($s("lst"),FunctionOfExponentialOfLinear(Power(Part(u,C1),First(Part(u,C2))),x,a,b,f)),If(SameQ($s("lst"),False),False,FunctionOfExponentialOfLinear(Power(Part(u,C1),Rest(Part(u,C2))),x,Part($s("lst"),C1),Part($s("lst"),C2),Part($s("lst"),C3)))),CompoundExpression(Set($s("lst"),List(a,b,f)),Catch(CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),FunctionOfExponentialOfLinear(Slot1,x,Part($s("lst"),C1),Part($s("lst"),C2),Part($s("lst"),C3))),If(SameQ($s("lst"),False),Throw(False)))),u),$s("lst"))))))))))),
ISetDelayed(FunctionOfExponentialOfLinearAux(a_,b_,f_,c_,$p(d),g_),
    If(FalseQ(a),List(c,d,g),If(ZeroQ(Plus(Times(Log(f),NonnumericFactors(b)),Times(CN1,Log(g),NonnumericFactors(d)))),Module(List(Set($s("gcd"),GCD(NumericFactor(b),NumericFactor(d)))),CompoundExpression(If(And(Less(NumericFactor(b),C0),Less(NumericFactor(d),C0)),Set($s("gcd"),Times(CN1,$s("gcd")))),If(Equal($s("gcd"),NumericFactor(b)),List(a,b,f),If(Equal($s("gcd"),NumericFactor(d)),List(c,d,g),List(C0,Times($s("gcd"),NonnumericFactors(b)),f))))),False))),
ISetDelayed(FunctionOfExponentialOfLinearSubst(u_,a_,b_,f_,x_),
    If(FreeQ(u,x),u,If(And(And(PowerQ(u),FreeQ(Part(u,C1),x)),LinearQ(Part(u,C2),x)),Module(List(c,d,g),CompoundExpression(CompoundExpression(CompoundExpression(Set(c,Coefficient(Part(u,C2),x,C0)),Set(d,Coefficient(Part(u,C2),x,C1))),Set(g,Part(u,C1))),Times(Power(g,Plus(c,Times(CN1,a,d,Power(b,CN1)))),Power(x,Times(d,Log(g),Power(Times(b,Log(f)),CN1)))))),If(And(HyperbolicQ(u),LinearQ(Part(u,C1),x)),Module(List(c,d,$s("tmp")),CompoundExpression(CompoundExpression(CompoundExpression(Set(c,Coefficient(Part(u,C1),x,C0)),Set(d,Coefficient(Part(u,C1),x,C1))),Set($s("tmp"),Times(Power(E,Plus(c,Times(CN1,a,d,Power(b,CN1)))),Power(x,Times(d,Power(Times(b,Log(f)),CN1)))))),If(SinhQ(u),Plus(Times(Rational(C1,C2),$s("tmp")),Times(CN1,Power(Times(C2,$s("tmp")),CN1))),If(CoshQ(u),Plus(Times(Rational(C1,C2),$s("tmp")),Power(Times(C2,$s("tmp")),CN1)),If(TanhQ(u),Times(Plus($s("tmp"),Times(CN1,Power($s("tmp"),CN1))),Power(Plus($s("tmp"),Power($s("tmp"),CN1)),CN1)),If(CothQ(u),Times(Plus($s("tmp"),Power($s("tmp"),CN1)),Power(Plus($s("tmp"),Times(CN1,Power($s("tmp"),CN1))),CN1)),If(SechQ(u),Times(C2,Power(Plus($s("tmp"),Power($s("tmp"),CN1)),CN1)),Times(C2,Power(Plus($s("tmp"),Times(CN1,Power($s("tmp"),CN1))),CN1))))))))),If(And(And(PowerQ(u),FreeQ(Part(u,C1),x)),SumQ(Part(u,C2))),Times(FunctionOfExponentialOfLinearSubst(Power(Part(u,C1),First(Part(u,C2))),a,b,f,x),FunctionOfExponentialOfLinearSubst(Power(Part(u,C1),Rest(Part(u,C2))),a,b,f,x)),Map(Function(FunctionOfExponentialOfLinearSubst(Slot1,a,b,f,x)),u)))))),
ISetDelayed(FunctionOfTrig(u_,x_Symbol),
    Module(List(Set(v,FunctionOfTrig(u,Null,x))),If(SameQ(v,Null),False,v))),
ISetDelayed(FunctionOfTrig(u_,v_,x_),
    If(AtomQ(u),If(SameQ(u,x),False,v),If(And(TrigQ(u),LinearQ(Part(u,C1),x)),If(SameQ(v,Null),Part(u,C1),Module(List(Set(a,Coefficient(v,x,C0)),Set(b,Coefficient(v,x,C1)),Set(c,Coefficient(Part(u,C1),x,C0)),Set(d,Coefficient(Part(u,C1),x,C1))),If(And(ZeroQ(Plus(Times(a,d),Times(CN1,b,c))),RationalQ(Times(b,Power(d,CN1)))),Plus(Times(a,Power(Numerator(Times(b,Power(d,CN1))),CN1)),Times(b,x,Power(Numerator(Times(b,Power(d,CN1))),CN1))),False))),If(CalculusQ(u),False,Module(List(Set(w,v)),Catch(CompoundExpression(Scan(Function(If(FalseQ(Set(w,FunctionOfTrig(Slot1,w,x))),Throw(False))),u),w))))))),
ISetDelayed(FunctionOfHyperbolic(u_,x_Symbol),
    Module(List(Set(v,FunctionOfHyperbolic(u,Null,x))),If(SameQ(v,Null),False,v))),
ISetDelayed(FunctionOfHyperbolic(u_,v_,x_),
    If(AtomQ(u),If(SameQ(u,x),False,v),If(And(HyperbolicQ(u),LinearQ(Part(u,C1),x)),If(SameQ(v,Null),Part(u,C1),Module(List(Set(a,Coefficient(v,x,C0)),Set(b,Coefficient(v,x,C1)),Set(c,Coefficient(Part(u,C1),x,C0)),Set(d,Coefficient(Part(u,C1),x,C1))),If(And(ZeroQ(Plus(Times(a,d),Times(CN1,b,c))),RationalQ(Times(b,Power(d,CN1)))),Plus(Times(a,Power(Numerator(Times(b,Power(d,CN1))),CN1)),Times(b,x,Power(Numerator(Times(b,Power(d,CN1))),CN1))),False))),If(CalculusQ(u),False,Module(List(Set(w,v)),Catch(CompoundExpression(Scan(Function(If(FalseQ(Set(w,FunctionOfHyperbolic(Slot1,w,x))),Throw(False))),u),w))))))),
ISetDelayed(FunctionOfQ(v_,u_,x_Symbol,$p("PureFlag")),
    If(FreeQ(u,x),False,If(AtomQ(v),True,If(And(PowerQ(v),FreeQ(Part(v,C2),x)),FunctionOfPowerQ(u,Part(v,C1),Part(v,C2),x),If($s("PureFlag"),If(Or(SinQ(v),CscQ(v)),PureFunctionOfSinQ(u,Part(v,C1),x),If(Or(CosQ(v),SecQ(v)),PureFunctionOfCosQ(u,Part(v,C1),x),If(TanQ(v),PureFunctionOfTanQ(u,Part(v,C1),x),If(CotQ(v),PureFunctionOfCotQ(u,Part(v,C1),x),If(Or(SinhQ(v),CschQ(v)),PureFunctionOfSinhQ(u,Part(v,C1),x),If(Or(CoshQ(v),SechQ(v)),PureFunctionOfCoshQ(u,Part(v,C1),x),If(TanhQ(v),PureFunctionOfTanhQ(u,Part(v,C1),x),If(CothQ(v),PureFunctionOfCothQ(u,Part(v,C1),x),FunctionOfExpnQ(u,v,x))))))))),If(Or(SinQ(v),CscQ(v)),FunctionOfSinQ(u,Part(v,C1),x),If(Or(CosQ(v),SecQ(v)),FunctionOfCosQ(u,Part(v,C1),x),If(Or(TanQ(v),CotQ(v)),FunctionOfTanQ(u,Part(v,C1),x),If(Or(SinhQ(v),CschQ(v)),FunctionOfSinhQ(u,Part(v,C1),x),If(Or(CoshQ(v),SechQ(v)),FunctionOfCoshQ(u,Part(v,C1),x),If(Or(TanhQ(v),CothQ(v)),FunctionOfTanhQ(u,Part(v,C1),x),FunctionOfExpnQ(u,v,x)))))))))))),
ISetDelayed(FunctionOfExpnQ(u_,v_,x_),
    If(SameQ(u,v),True,If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,Catch(CompoundExpression(Scan(Function(If(FunctionOfExpnQ(Slot1,v,x),Null,Throw(False))),u),True)))))),
ISetDelayed(FunctionOfPowerQ(u_,$p("bas"),$p("deg"),x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(And(PowerQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,$s("bas"))))),FreeQ(Part(u,C2),x)),If(RationalQ($s("deg")),If(RationalQ(Part(u,C2)),And(IntIntegerQ(Times(Part(u,C2),Power($s("deg"),CN1))),Or(Greater($s("deg"),C0),Less(Part(u,C2),C0))),False),IntIntegerQ(Simplify(Times(Part(u,C2),Power($s("deg"),CN1))))),Catch(CompoundExpression(Scan(Function(If(FunctionOfPowerQ(Slot1,$s("bas"),$s("deg"),x),Null,Throw(False))),u),True)))))),
ISetDelayed(FindTrigFactor($p("func1"),$p("func2"),u_,v_,$p("flag")),
    If(SameQ(u,C1),False,If(And(And(And(Or(SameQ(Head(LeadBase(u)),$s("func1")),SameQ(Head(LeadBase(u)),$s("func2"))),OddQ(LeadDegree(u))),IntegerQuotientQ(Part(LeadBase(u),C1),v)),Or($s("flag"),NonzeroQ(Plus(Part(LeadBase(u),C1),Times(CN1,v))))),List(Part(LeadBase(u),C1),RemainingFactors(u)),Module(List(Set($s("lst"),FindTrigFactor($s("func1"),$s("func2"),RemainingFactors(u),v,$s("flag")))),If(FalseQ($s("lst")),False,List(Part($s("lst"),C1),Times(LeadFactor(u),Part($s("lst"),C2)))))))),
ISetDelayed(PureFunctionOfSinQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),Or(SinQ(u),CscQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfSinQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfCosQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),Or(CosQ(u),SecQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfCosQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfTanQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),Or(TanQ(u),CotQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfTanQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfCotQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),CotQ(u),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfCotQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(FunctionOfSinQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),If(OddQuotientQ(Part(u,C1),v),Or(SinQ(u),CscQ(u)),Or(CosQ(u),SecQ(u))),If(And(And(IntegerPowerQ(u),TrigQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfSinQ(Part(u,C1),v,x)),If(ProductQ(u),If(And(And(And(CosQ(Part(u,C1)),SinQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,Rational(C1,C2),v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,Rational(C1,C2),v)))),FunctionOfSinQ(Drop(u,C2),v,x),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sin"),$s("Csc"),u,v,False)),If(And(NotFalseQ($s("lst")),EvenQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinQ(Times(Cos(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Cos"),$s("Sec"),u,v,False)),If(And(NotFalseQ($s("lst")),OddQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinQ(Times(Cos(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tan"),$s("Cot"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfSinQ(Times(Cos(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinQ(Slot1,v,x)),Throw(False))),u),True)))))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfCosQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(CosQ(u),SecQ(u)),If(And(And(IntegerPowerQ(u),TrigQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfCosQ(Part(u,C1),v,x)),If(ProductQ(u),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sin"),$s("Csc"),u,v,False)),If(NotFalseQ($s("lst")),FunctionOfCosQ(Times(Sin(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tan"),$s("Cot"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfCosQ(Times(Sin(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCosQ(Slot1,v,x)),Throw(False))),u),True))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCosQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfTanQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(Or(TanQ(u),CotQ(u)),EvenQuotientQ(Part(u,C1),v)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),TrigQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),True,If(ProductQ(u),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(And(Equal(Length($s("lst")),C2),OddTrigPowerQ(Part($s("lst"),C1),v,x)),OddTrigPowerQ(Part($s("lst"),C2),v,x)))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(OddTrigPowerQ(u_,v_,x_),
    If(Or(Or(Or(SinQ(u),CosQ(u)),SecQ(u)),CscQ(u)),OddQuotientQ(Part(u,C1),v),If(PowerQ(u),And(OddQ(Part(u,C2)),OddTrigPowerQ(Part(u,C1),v,x)),If(ProductQ(u),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(Equal(Length($s("lst")),C1),OddTrigPowerQ(Part($s("lst"),C1),v,x)))),False)))),
ISetDelayed(FunctionOfTanWeight(u_,v_,x_),
    If(AtomQ(u),C0,If(CalculusQ(u),C0,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),If(And(TanQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),C1,If(And(CotQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),CN1,C0)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),TrigQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(Or(Or(TanQ(Part(u,C1)),CosQ(Part(u,C1))),SecQ(Part(u,C1))),C1,CN1),If(ProductQ(u),If(Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanQ(Slot1,v,x)),Throw(False))),u),True)),Apply(Plus,Map(Function(FunctionOfTanWeight(Slot1,v,x)),Apply($s("List"),u))),C0),Apply(Plus,Map(Function(FunctionOfTanWeight(Slot1,v,x)),Apply($s("List"),u))))))))),
ISetDelayed(FunctionOfTrigQ(u_,v_,x_Symbol),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),True,Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTrigQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfSinhQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),Or(SinhQ(u),CschQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfSinhQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfCoshQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),Or(CoshQ(u),SechQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfCoshQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfTanhQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),Or(TanhQ(u),CothQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfTanhQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfCothQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),CothQ(u),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfCothQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(FunctionOfSinhQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),If(OddQuotientQ(Part(u,C1),v),Or(SinhQ(u),CschQ(u)),Or(CoshQ(u),SechQ(u))),If(And(And(IntegerPowerQ(u),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfSinhQ(Part(u,C1),v,x)),If(ProductQ(u),If(And(And(And(CoshQ(Part(u,C1)),SinhQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,Rational(C1,C2),v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,Rational(C1,C2),v)))),FunctionOfSinhQ(Drop(u,C2),v,x),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sinh"),$s("Csch"),u,v,False)),If(And(NotFalseQ($s("lst")),EvenQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Cosh"),$s("Sech"),u,v,False)),If(And(NotFalseQ($s("lst")),OddQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tanh"),$s("Coth"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinhQ(Slot1,v,x)),Throw(False))),u),True)))))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinhQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfCoshQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(CoshQ(u),SechQ(u)),If(And(And(IntegerPowerQ(u),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfCoshQ(Part(u,C1),v,x)),If(ProductQ(u),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sinh"),$s("Csch"),u,v,False)),If(NotFalseQ($s("lst")),FunctionOfCoshQ(Times(Sinh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tanh"),$s("Coth"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfCoshQ(Times(Sinh(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCoshQ(Slot1,v,x)),Throw(False))),u),True))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCoshQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfTanhQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(Or(TanhQ(u),CothQ(u)),EvenQuotientQ(Part(u,C1),v)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),True,If(ProductQ(u),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(And(Equal(Length($s("lst")),C2),OddHyperbolicPowerQ(Part($s("lst"),C1),v,x)),OddHyperbolicPowerQ(Part($s("lst"),C2),v,x)))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(OddHyperbolicPowerQ(u_,v_,x_),
    If(Or(Or(Or(SinhQ(u),CoshQ(u)),SechQ(u)),CschQ(u)),OddQuotientQ(Part(u,C1),v),If(PowerQ(u),And(OddQ(Part(u,C2)),OddHyperbolicPowerQ(Part(u,C1),v,x)),If(ProductQ(u),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(Equal(Length($s("lst")),C1),OddHyperbolicPowerQ(Part($s("lst"),C1),v,x)))),False)))),
ISetDelayed(FunctionOfTanhWeight(u_,v_,x_),
    If(AtomQ(u),C0,If(CalculusQ(u),C0,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),If(And(TanhQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),C1,If(And(CothQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),CN1,C0)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(Or(Or(TanhQ(Part(u,C1)),CoshQ(Part(u,C1))),SechQ(Part(u,C1))),C1,CN1),If(ProductQ(u),If(Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Throw(False))),u),True)),Apply(Plus,Map(Function(FunctionOfTanhWeight(Slot1,v,x)),Apply($s("List"),u))),C0),Apply(Plus,Map(Function(FunctionOfTanhWeight(Slot1,v,x)),Apply($s("List"),u))))))))),
ISetDelayed(FunctionOfHyperbolicQ(u_,v_,x_Symbol),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),True,Catch(CompoundExpression(Scan(Function(If(FunctionOfHyperbolicQ(Slot1,v,x),Null,Throw(False))),u),True)))))),
ISetDelayed(IntegerQuotientQ(u_,v_),
    Or(Or(SameQ(u,v),ZeroQ(Plus(u,Times(CN1,v)))),IntIntegerQ(Times(u,Power(v,CN1))))),
ISetDelayed(OddQuotientQ(u_,v_),
    Or(Or(SameQ(u,v),ZeroQ(Plus(u,Times(CN1,v)))),OddQ(Times(u,Power(v,CN1))))),
ISetDelayed(EvenQuotientQ(u_,v_),
    EvenQ(Times(u,Power(v,CN1)))),
ISetDelayed(FunctionOfDensePolynomialsQ(u_,x_Symbol),
    If(FreeQ(u,x),True,If(IntPolynomialQ(u,x),Greater(Length(Exponent(u,x,$s("List"))),C1),Catch(CompoundExpression(Scan(Function(If(FunctionOfDensePolynomialsQ(Slot1,x),Null,Throw(False))),u),True))))),
ISetDelayed(FunctionOfLog(u_,x_Symbol),
    Module(List(Set($s("lst"),FunctionOfLog(u,False,False,x))),If(Or(FalseQ($s("lst")),FalseQ(Part($s("lst"),C2))),False,$s("lst")))),
ISetDelayed(FunctionOfLog(u_,v_,n_,x_),
    If(AtomQ(u),If(SameQ(u,x),False,List(u,v,n)),If(CalculusQ(u),False,Module(List($s("lst")),If(And(And(LogQ(u),NotFalseQ(Set($s("lst"),BinomialTest(Part(u,C1),x)))),ZeroQ(Part($s("lst"),C1))),If(Or(FalseQ(v),SameQ(Part(u,C1),v)),List(x,Part(u,C1),Part($s("lst"),C3)),False),CompoundExpression(Set($s("lst"),List(C0,v,n)),Catch(List(Map(Function(CompoundExpression(Set($s("lst"),FunctionOfLog(Slot1,Part($s("lst"),C2),Part($s("lst"),C3),x)),If(SameQ($s("lst"),False),Throw(False),Part($s("lst"),C1)))),u),Part($s("lst"),C2),Part($s("lst"),C3))))))))),
ISetDelayed(FunctionOfProductLog(u_,x_Symbol),
    Module(List(Set($s("lst"),FunctionOfProductLog(u,False,False,x))),If(Or(FalseQ($s("lst")),FalseQ(Part($s("lst"),C2))),False,$s("lst")))),
ISetDelayed(FunctionOfProductLog(u_,v_,n_,x_),
    If(AtomQ(u),If(SameQ(u,x),False,List(u,v,n)),If(CalculusQ(u),False,Module(List($s("lst")),If(And(And(ProductLogQ(u),NotFalseQ(Set($s("lst"),BinomialTest(Part(u,C1),x)))),ZeroQ(Part($s("lst"),C1))),If(Or(FalseQ(v),SameQ(Part(u,C1),v)),List(x,Part(u,C1),Part($s("lst"),C3)),False),CompoundExpression(Set($s("lst"),List(C0,v,n)),Catch(List(Map(Function(CompoundExpression(Set($s("lst"),FunctionOfProductLog(Slot1,Part($s("lst"),C2),Part($s("lst"),C3),x)),If(SameQ($s("lst"),False),Throw(False),Part($s("lst"),C1)))),u),Part($s("lst"),C2),Part($s("lst"),C3))))))))),
ISetDelayed(PowerVariableExpn(u_,m_,x_Symbol),
    If(IntIntegerQ(m),Module(List(Set($s("lst"),PowerVariableDegree(u,m,C1,x))),If(FalseQ($s("lst")),False,List(Times(Power(x,Times(m,Power(Part($s("lst"),C1),CN1))),PowerVariableSubst(u,Part($s("lst"),C1),x)),Part($s("lst"),C1),Part($s("lst"),C2)))),False)),
ISetDelayed(PowerVariableDegree(u_,m_,c_,x_Symbol),
    If(FreeQ(u,x),List(m,c),If(Or(AtomQ(u),CalculusQ(u)),False,If(And(PowerQ(u),FreeQ(Times(Part(u,C1),Power(x,CN1)),x)),If(Or(ZeroQ(m),And(SameQ(m,Part(u,C2)),SameQ(c,Times(Part(u,C1),Power(x,CN1))))),List(Part(u,C2),Times(Part(u,C1),Power(x,CN1))),If(And(And(And(IntIntegerQ(Part(u,C2)),IntIntegerQ(m)),Greater(GCD(m,Part(u,C2)),C1)),SameQ(c,Times(Part(u,C1),Power(x,CN1)))),List(GCD(m,Part(u,C2)),c),False)),Catch(Module(List(Set($s("lst"),List(m,c))),CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),PowerVariableDegree(Slot1,Part($s("lst"),C1),Part($s("lst"),C2),x)),If(SameQ($s("lst"),False),Throw(False)))),u),$s("lst")))))))),
ISetDelayed(PowerVariableSubst(u_,m_,x_Symbol),
    If(Or(Or(FreeQ(u,x),AtomQ(u)),CalculusQ(u)),u,If(And(PowerQ(u),FreeQ(Times(Part(u,C1),Power(x,CN1)),x)),Power(x,Times(Part(u,C2),Power(m,CN1))),Map(Function(PowerVariableSubst(Slot1,m,x)),u)))),
ISetDelayed(FunctionOfSquareRootOfQuadratic(u_,x_Symbol),
    If(MatchQ(u,Condition(Times(Power(x,m_DEFAULT),Power(Plus(a_,Times(b_DEFAULT,Power(x,n_DEFAULT))),p_)),FreeQ(List(a,b,m,n,p),x))),False,Module(List(Set($s("tmp"),FunctionOfSquareRootOfQuadratic(u,False,x))),If(Or(FalseQ($s("tmp")),FalseQ(Part($s("tmp"),C1))),False,CompoundExpression(Set($s("tmp"),Part($s("tmp"),C1)),Module(List(Set(a,Coefficient($s("tmp"),x,C0)),Set(b,Coefficient($s("tmp"),x,C1)),Set(c,Coefficient($s("tmp"),x,C2)),$s("sqrt"),q,r),If(And(ZeroQ(a),ZeroQ(b)),False,If(PosQ(c),CompoundExpression(CompoundExpression(CompoundExpression(Set($s("sqrt"),Rt(c,C2)),Set(q,Plus(Times(a,$s("sqrt")),Times(b,x),Times($s("sqrt"),Power(x,C2))))),Set(r,Plus(b,Times(C2,$s("sqrt"),x)))),List(Simplify(Times(SquareRootOfQuadraticSubst(u,Times(q,Power(r,CN1)),Times(Plus(Times(CN1,a),Power(x,C2)),Power(r,CN1)),x),q,Power(Power(r,C2),CN1))),Simplify(Plus(Times($s("sqrt"),x),Sqrt($s("tmp")))),C2)),If(PosQ(a),CompoundExpression(CompoundExpression(CompoundExpression(Set($s("sqrt"),Rt(a,C2)),Set(q,Plus(Times(c,$s("sqrt")),Times(CN1,b,x),Times($s("sqrt"),Power(x,C2))))),Set(r,Plus(c,Times(CN1,Power(x,C2))))),List(Simplify(Times(SquareRootOfQuadraticSubst(u,Times(q,Power(r,CN1)),Times(Plus(Times(CN1,b),Times(C2,$s("sqrt"),x)),Power(r,CN1)),x),q,Power(Power(r,C2),CN1))),Simplify(Times(Plus(Times(CN1,$s("sqrt")),Sqrt($s("tmp"))),Power(x,CN1))),C1)),CompoundExpression(Set($s("sqrt"),Rt(Plus(Power(b,C2),Times(CN1,C4,a,c)),C2)),If(ZeroQ($s("sqrt")),False,CompoundExpression(Set(r,Plus(c,Times(CN1,Power(x,C2)))),List(Simplify(Times(CN1,$s("sqrt"),SquareRootOfQuadraticSubst(u,Times(CN1,$s("sqrt"),x,Power(r,CN1)),Times(CN1,Plus(Times(b,c),Times(c,$s("sqrt")),Times(Plus(Times(CN1,b),$s("sqrt")),Power(x,C2))),Power(Times(C2,c,r),CN1)),x),x,Power(Power(r,C2),CN1))),FullSimplify(Times(C2,c,Sqrt($s("tmp")),Power(Plus(b,Times(CN1,$s("sqrt")),Times(C2,c,x)),CN1))),C3))))))))))))),
ISetDelayed(FunctionOfSquareRootOfQuadratic(u_,v_,x_Symbol),
    If(Or(AtomQ(u),FreeQ(u,x)),List(v),If(And(PowerQ(u),FreeQ(Part(u,C2),x)),If(And(And(And(FractionQ(Part(u,C2)),Equal(Denominator(Part(u,C2)),C2)),IntPolynomialQ(Part(u,C1),x)),Equal(Exponent(Part(u,C1),x),C2)),If(Or(FalseQ(v),SameQ(Part(u,C1),v)),List(Part(u,C1)),False),FunctionOfSquareRootOfQuadratic(Part(u,C1),v,x)),If(Or(ProductQ(u),SumQ(u)),Catch(Module(List(Set($s("lst"),List(v))),CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),FunctionOfSquareRootOfQuadratic(Slot1,Part($s("lst"),C1),x)),If(SameQ($s("lst"),False),Throw(False)))),u),$s("lst")))),False)))),
ISetDelayed(SquareRootOfQuadraticSubst(u_,$p("vv"),$p("xx"),x_Symbol),
    If(Or(AtomQ(u),FreeQ(u,x)),If(SameQ(u,x),$s("xx"),u),If(And(PowerQ(u),FreeQ(Part(u,C2),x)),If(And(And(And(FractionQ(Part(u,C2)),Equal(Denominator(Part(u,C2)),C2)),IntPolynomialQ(Part(u,C1),x)),Equal(Exponent(Part(u,C1),x),C2)),Power($s("vv"),Numerator(Part(u,C2))),Power(SquareRootOfQuadraticSubst(Part(u,C1),$s("vv"),$s("xx"),x),Part(u,C2))),Map(Function(SquareRootOfQuadraticSubst(Slot1,$s("vv"),$s("xx"),x)),u)))),
ISetDelayed(RegularizeSubst(u_,x_,w_),
    Module(List(Set($s("lst"),ConstantFactor(Regularize(Subst(u,x,w),x),x))),Times(Part($s("lst"),C1),Part($s("lst"),C2)))),
ISetDelayed(Subst(u_,v_,w_),
    Condition(If(SameQ(u,v),w,If(AtomQ(u),u,If(PowerQ(u),If(And(And(PowerQ(v),SameQ(Part(u,C1),Part(v,C1))),SumQ(Part(u,C2))),Times(Subst(Power(Part(u,C1),First(Part(u,C2))),v,w),Subst(Power(Part(u,C1),Rest(Part(u,C2))),v,w)),Power(Subst(Part(u,C1),v,w),Subst(Part(u,C2),v,w))),If(And(SubstQ(u),Or(SameQ(Part(u,C2),v),FreeQ(Part(u,C1),v))),Subst(Part(u,C1),Part(u,C2),Subst(Part(u,C3),v,w)),Map(Function(Subst(Slot1,v,w)),u))))),Or(Or(AtomQ(u),And(SubstQ(u),Or(SameQ(Part(u,C2),v),FreeQ(Part(u,C1),v)))),Not(Or(And(CalculusQ(u),Not(FreeQ(v,Part(u,C2)))),MemberQ(List($s("Pattern"),$s("Defer"),$s("Hold"),$s("HoldForm")),Head(u))))))),
ISetDelayed(SubstFor(v_,u_,x_),
    If(AtomQ(v),Subst(u,v,x),If(And(PowerQ(v),FreeQ(Part(v,C2),x)),SubstForPower(u,Part(v,C1),Part(v,C2),x),If(SinQ(v),SubstForTrig(u,x,Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),Part(v,C1),x),If(CosQ(v),SubstForTrig(u,Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),x,Part(v,C1),x),If(TanQ(v),SubstForTrig(u,Times(x,Power(Sqrt(Plus(C1,Power(x,C2))),CN1)),Power(Sqrt(Plus(C1,Power(x,C2))),CN1),Part(v,C1),x),If(CotQ(v),SubstForTrig(u,Power(Sqrt(Plus(C1,Power(x,C2))),CN1),Times(x,Power(Sqrt(Plus(C1,Power(x,C2))),CN1)),Part(v,C1),x),If(SecQ(v),SubstForTrig(u,Power(Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),CN1),Power(x,CN1),Part(v,C1),x),If(CscQ(v),SubstForTrig(u,Power(x,CN1),Power(Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),CN1),Part(v,C1),x),If(SinhQ(v),SubstForHyperbolic(u,x,Sqrt(Plus(C1,Power(x,C2))),Part(v,C1),x),If(CoshQ(v),SubstForHyperbolic(u,Sqrt(Plus(CN1,Power(x,C2))),x,Part(v,C1),x),If(TanhQ(v),SubstForHyperbolic(u,Times(x,Power(Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),CN1)),Power(Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),CN1),Part(v,C1),x),If(CothQ(v),SubstForHyperbolic(u,Power(Sqrt(Plus(CN1,Power(x,C2))),CN1),Times(x,Power(Sqrt(Plus(CN1,Power(x,C2))),CN1)),Part(v,C1),x),If(SechQ(v),SubstForHyperbolic(u,Power(Sqrt(Plus(CN1,Power(x,C2))),CN1),Power(x,CN1),Part(v,C1),x),If(CschQ(v),SubstForHyperbolic(u,Power(x,CN1),Power(Sqrt(Plus(C1,Power(x,C2))),CN1),Part(v,C1),x),SubstForExpn(u,v,x)))))))))))))))),
ISetDelayed(SubstForExpn(u_,v_,x_),
    If(SameQ(u,v),x,If(AtomQ(u),u,Map(Function(SubstForExpn(Slot1,v,x)),u)))),
ISetDelayed(SubstForPower(u_,$p("bas"),$p("deg"),x_),
    If(AtomQ(u),u,If(And(And(And(PowerQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,$s("bas"))))),FreeQ(Part(u,C2),x)),IntIntegerQ(Simplify(Times(Part(u,C2),Power($s("deg"),CN1))))),Power(x,Times(Part(u,C2),Power($s("deg"),CN1))),Map(Function(SubstForPower(Slot1,$s("bas"),$s("deg"),x)),u)))),
ISetDelayed(SubstForTrig(u_,$p("sin"),$p("cos"),v_,x_),
    If(AtomQ(u),u,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),If(Or(SameQ(Part(u,C1),v),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),If(SinQ(u),$s("sin"),If(CosQ(u),$s("cos"),If(TanQ(u),Times($s("sin"),Power($s("cos"),CN1)),If(CotQ(u),Times($s("cos"),Power($s("sin"),CN1)),If(SecQ(u),Power($s("cos"),CN1),Power($s("sin"),CN1)))))),Map(Function(SubstForTrig(Slot1,$s("sin"),$s("cos"),v,x)),ReplaceAll(TrigExpand($(Head(u),Times(Part(u,C1),Power(v,CN1),x))),Rule(x,v)))),If(And(And(And(And(ProductQ(u),CosQ(Part(u,C1))),SinQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,Rational(C1,C2),v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,Rational(C1,C2),v)))),Times(Rational(C1,C2),$s("sin"),SubstForTrig(Drop(u,C2),$s("sin"),$s("cos"),v,x)),Map(Function(SubstForTrig(Slot1,$s("sin"),$s("cos"),v,x)),u))))),
ISetDelayed(SubstForHyperbolic(u_,$p("sinh"),$p("cosh"),v_,x_),
    If(AtomQ(u),u,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),If(Or(SameQ(Part(u,C1),v),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),If(SinhQ(u),$s("sinh"),If(CoshQ(u),$s("cosh"),If(TanhQ(u),Times($s("sinh"),Power($s("cosh"),CN1)),If(CothQ(u),Times($s("cosh"),Power($s("sinh"),CN1)),If(SechQ(u),Power($s("cosh"),CN1),Power($s("sinh"),CN1)))))),Map(Function(SubstForHyperbolic(Slot1,$s("sinh"),$s("cosh"),v,x)),ReplaceAll(TrigExpand($(Head(u),Times(Part(u,C1),Power(v,CN1),x))),Rule(x,v)))),If(And(And(And(And(ProductQ(u),CoshQ(Part(u,C1))),SinhQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,Rational(C1,C2),v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,Rational(C1,C2),v)))),Times(Rational(C1,C2),$s("sinh"),SubstForHyperbolic(Drop(u,C2),$s("sinh"),$s("cosh"),v,x)),Map(Function(SubstForHyperbolic(Slot1,$s("sinh"),$s("cosh"),v,x)),u)))))
  );
}
