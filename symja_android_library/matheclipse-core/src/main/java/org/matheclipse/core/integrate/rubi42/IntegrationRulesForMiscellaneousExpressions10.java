package org.matheclipse.core.integrate.rubi42;


import static org.matheclipse.core.expression.F.*;
import static org.matheclipse.core.integrate.rubi42.UtilityFunctionCtors.*;
import static org.matheclipse.core.integrate.rubi42.UtilityFunctions.*;

import org.matheclipse.core.interfaces.IAST;
import org.matheclipse.core.interfaces.IExpr;
import org.matheclipse.core.interfaces.ISymbol;
/** 
 * IntegrationRules rules from the <a href="http://www.apmaths.uwo.ca/~arich/">Rubi -
 * rule-based integrator</a>.
 *  
 */
public class IntegrationRulesForMiscellaneousExpressions10 { 
  public static IAST RULES = List( 
SetDelayed(FunctionOfSinhQ($p(u),$p(v),$p(x)),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),If(OddQuotientQ(Part(u,C1),v),Or(SinhQ(u),CschQ(u)),Or(CoshQ(u),SechQ(u))),If(And(And(IntegerPowerQ(u),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfSinhQ(Part(u,C1),v,x)),If(ProductQ(u),If(And(And(And(CoshQ(Part(u,C1)),SinhQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,C1D2,v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,C1D2,v)))),FunctionOfSinhQ(Drop(u,C2),v,x),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sinh"),$s("Csch"),u,v,False)),If(And(NotFalseQ($s("lst")),EvenQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Cosh"),$s("Sech"),u,v,False)),If(And(NotFalseQ($s("lst")),OddQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tanh"),$s("Coth"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinhQ(Slot1,v,x)),Throw(False))),u),True)))))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinhQ(Slot1,v,x)),Throw(False))),u),True)))))))),
SetDelayed(FunctionOfCoshQ($p(u),$p(v),$p(x)),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(CoshQ(u),SechQ(u)),If(And(And(IntegerPowerQ(u),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfCoshQ(Part(u,C1),v,x)),If(ProductQ(u),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sinh"),$s("Csch"),u,v,False)),If(NotFalseQ($s("lst")),FunctionOfCoshQ(Times(Sinh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tanh"),$s("Coth"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfCoshQ(Times(Sinh(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCoshQ(Slot1,v,x)),Throw(False))),u),True))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCoshQ(Slot1,v,x)),Throw(False))),u),True)))))))),
SetDelayed(FunctionOfTanhQ($p(u),$p(v),$p(x)),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(Or(TanhQ(u),CothQ(u)),EvenQuotientQ(Part(u,C1),v)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),True,If(ProductQ(u),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(And(Equal(Length($s("lst")),C2),OddHyperbolicPowerQ(Part($s("lst"),C1),v,x)),OddHyperbolicPowerQ(Part($s("lst"),C2),v,x)))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Throw(False))),u),True)))))))),
SetDelayed(OddHyperbolicPowerQ($p(u),$p(v),$p(x)),
    If(Or(Or(Or(SinhQ(u),CoshQ(u)),SechQ(u)),CschQ(u)),OddQuotientQ(Part(u,C1),v),If(PowerQ(u),And(OddQ(Part(u,C2)),OddHyperbolicPowerQ(Part(u,C1),v,x)),If(ProductQ(u),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(Equal(Length($s("lst")),C1),OddHyperbolicPowerQ(Part($s("lst"),C1),v,x)))),False)))),
SetDelayed(FunctionOfTanhWeight($p(u),$p(v),$p(x)),
    If(AtomQ(u),C0,If(CalculusQ(u),C0,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),If(And(TanhQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),C1,If(And(CothQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),CN1,C0)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(Or(Or(TanhQ(Part(u,C1)),CoshQ(Part(u,C1))),SechQ(Part(u,C1))),C1,CN1),If(ProductQ(u),If(Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Throw(False))),u),True)),Apply($s("Plus"),Map(Function(FunctionOfTanhWeight(Slot1,v,x)),Apply($s("List"),u))),C0),Apply($s("Plus"),Map(Function(FunctionOfTanhWeight(Slot1,v,x)),Apply($s("List"),u))))))))),
SetDelayed(FunctionOfHyperbolicQ($p(u),$p(v),$p(x,SymbolHead)),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),True,Catch(CompoundExpression(Scan(Function(If(FunctionOfHyperbolicQ(Slot1,v,x),Null,Throw(False))),u),True)))))),
SetDelayed(IntegerQuotientQ($p(u),$p(v)),
    IntegerQ(Simplify(Times(u,Power(v,CN1))))),
SetDelayed(OddQuotientQ($p(u),$p(v)),
    OddQ(Simplify(Times(u,Power(v,CN1))))),
SetDelayed(EvenQuotientQ($p(u),$p(v)),
    EvenQ(Simplify(Times(u,Power(v,CN1))))),
SetDelayed(FunctionOfDensePolynomialsQ($p(u),$p(x,SymbolHead)),
    If(FreeQ(u,x),True,If(PolynomialQ(u,x),Greater(Length(Exponent(u,x,$s("List"))),C1),Catch(CompoundExpression(Scan(Function(If(FunctionOfDensePolynomialsQ(Slot1,x),Null,Throw(False))),u),True))))),
SetDelayed(FunctionOfLog($p(u),$p(x,SymbolHead)),
    Module(List(Set($s("lst"),FunctionOfLog(u,False,False,x))),If(Or(FalseQ($s("lst")),FalseQ(Part($s("lst"),C2))),False,$s("lst")))),
SetDelayed(FunctionOfLog($p(u),$p(v),$p(n),$p(x)),
    If(AtomQ(u),If(SameQ(u,x),False,List(u,v,n)),If(CalculusQ(u),False,Module(List($s("lst")),If(And(And(LogQ(u),NotFalseQ(Set($s("lst"),BinomialTest(Part(u,C1),x)))),ZeroQ(Part($s("lst"),C1))),If(Or(FalseQ(v),SameQ(Part(u,C1),v)),List(x,Part(u,C1),Part($s("lst"),C3)),False),CompoundExpression(Set($s("lst"),List(C0,v,n)),Catch(List(Map(Function(CompoundExpression(Set($s("lst"),FunctionOfLog(Slot1,Part($s("lst"),C2),Part($s("lst"),C3),x)),If(FalseQ($s("lst")),Throw(False),Part($s("lst"),C1)))),u),Part($s("lst"),C2),Part($s("lst"),C3))))))))),
SetDelayed(PowerVariableExpn($p(u),$p(m),$p(x,SymbolHead)),
    If(IntegerQ(m),Module(List(Set($s("lst"),PowerVariableDegree(u,m,C1,x))),If(FalseQ($s("lst")),False,List(Times(Power(x,Times(m,Power(Part($s("lst"),C1),CN1))),PowerVariableSubst(u,Part($s("lst"),C1),x)),Part($s("lst"),C1),Part($s("lst"),C2)))),False)),
SetDelayed(PowerVariableDegree($p(u),$p(m),$p(c),$p(x,SymbolHead)),
    If(FreeQ(u,x),List(m,c),If(Or(AtomQ(u),CalculusQ(u)),False,If(And(PowerQ(u),FreeQ(Times(Part(u,C1),Power(x,CN1)),x)),If(Or(ZeroQ(m),And(SameQ(m,Part(u,C2)),SameQ(c,Times(Part(u,C1),Power(x,CN1))))),List(Part(u,C2),Times(Part(u,C1),Power(x,CN1))),If(And(And(And(IntegerQ(Part(u,C2)),IntegerQ(m)),Greater(GCD(m,Part(u,C2)),C1)),SameQ(c,Times(Part(u,C1),Power(x,CN1)))),List(GCD(m,Part(u,C2)),c),False)),Catch(Module(List(Set($s("lst"),List(m,c))),CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),PowerVariableDegree(Slot1,Part($s("lst"),C1),Part($s("lst"),C2),x)),If(FalseQ($s("lst")),Throw(False)))),u),$s("lst")))))))),
SetDelayed(PowerVariableSubst($p(u),$p(m),$p(x,SymbolHead)),
    If(Or(Or(FreeQ(u,x),AtomQ(u)),CalculusQ(u)),u,If(And(PowerQ(u),FreeQ(Times(Part(u,C1),Power(x,CN1)),x)),Power(x,Times(Part(u,C2),Power(m,CN1))),Map(Function(PowerVariableSubst(Slot1,m,x)),u)))),
SetDelayed(EulerIntegrandQ(Power(Plus(Times(Power($p(u),$p(n)),$p(b,true)),Times($p(a,true),$p(x))),$p(p)),$p(x,SymbolHead)),
    Condition(True,And(And(And(FreeQ(List(a,b),x),IntegerQ(Plus(n,C1D2))),QuadraticQ(u,x)),Or(Not(RationalQ(p)),And(NegativeIntegerQ(p),Not(BinomialQ(u,x))))))),
SetDelayed(EulerIntegrandQ(Times(Power(Plus(Times(Power($p(u),$p(n)),$p(b,true)),Times($p(a,true),$p(x))),$p(p)),Power($p(v),$p(m,true))),$p(x,SymbolHead)),
    Condition(True,And(And(And(And(FreeQ(List(a,b),x),ZeroQ(Plus(u,Times(CN1,v)))),IntegersQ(Times(C2,m),Plus(n,C1D2))),QuadraticQ(u,x)),Or(Not(RationalQ(p)),And(NegativeIntegerQ(p),Not(BinomialQ(u,x))))))),
SetDelayed(EulerIntegrandQ(Times(Power(Plus(Times(Power($p(u),$p(n)),$p(b,true)),Times($p(a,true),$p(x))),$p(p)),Power($p(v),$p(m,true))),$p(x,SymbolHead)),
    Condition(True,And(And(And(And(FreeQ(List(a,b),x),ZeroQ(Plus(u,Times(CN1,v)))),IntegersQ(Times(C2,m),Plus(n,C1D2))),QuadraticQ(u,x)),Or(Not(RationalQ(p)),And(NegativeIntegerQ(p),Not(BinomialQ(u,x))))))),
SetDelayed(EulerIntegrandQ(Times(Power($p(u),$p(n)),Power($p(v),$p(p))),$p(x,SymbolHead)),
    Condition(True,And(And(And(And(NegativeIntegerQ(p),IntegerQ(Plus(n,C1D2))),QuadraticQ(u,x)),QuadraticQ(v,x)),Not(BinomialQ(v,x))))),
SetDelayed(EulerIntegrandQ($p(u),$p(x,SymbolHead)),
    False),
SetDelayed(FunctionOfSquareRootOfQuadratic($p(u),$p(x,SymbolHead)),
    If(MatchQ(u,Condition(Times(Power(x,$p(m,true)),Power(Plus($p(a),Times($p(b,true),Power(x,$p(n,true)))),$p(p))),FreeQ(List(a,b,m,n,p),x))),False,Module(List(Set($s("tmp"),FunctionOfSquareRootOfQuadratic(u,False,x))),If(Or(FalseQ($s("tmp")),FalseQ(Part($s("tmp"),C1))),False,CompoundExpression(Set($s("tmp"),Part($s("tmp"),C1)),Module(List(Set(a,Coefficient($s("tmp"),x,C0)),Set(b,Coefficient($s("tmp"),x,C1)),Set(c,Coefficient($s("tmp"),x,C2)),$s("sqrt"),q,r),If(Or(And(ZeroQ(a),ZeroQ(b)),ZeroQ(Plus(Power(b,C2),Times(CN1,C4,a,c)))),False,If(PosQ(c),CompoundExpression(CompoundExpression(CompoundExpression(Set($s("sqrt"),Rt(c,C2)),Set(q,Plus(Times(a,$s("sqrt")),Times(b,x),Times($s("sqrt"),Power(x,C2))))),Set(r,Plus(b,Times(C2,$s("sqrt"),x)))),List(Simplify(Times(SquareRootOfQuadraticSubst(u,Times(q,Power(r,CN1)),Times(Plus(Times(CN1,a),Power(x,C2)),Power(r,CN1)),x),q,Power(Power(r,C2),CN1))),Simplify(Plus(Times($s("sqrt"),x),Sqrt($s("tmp")))),C2)),If(PosQ(a),CompoundExpression(CompoundExpression(CompoundExpression(Set($s("sqrt"),Rt(a,C2)),Set(q,Plus(Times(c,$s("sqrt")),Times(CN1,b,x),Times($s("sqrt"),Power(x,C2))))),Set(r,Plus(c,Times(CN1,Power(x,C2))))),List(Simplify(Times(SquareRootOfQuadraticSubst(u,Times(q,Power(r,CN1)),Times(Plus(Times(CN1,b),Times(C2,$s("sqrt"),x)),Power(r,CN1)),x),q,Power(Power(r,C2),CN1))),Simplify(Times(Plus(Times(CN1,$s("sqrt")),Sqrt($s("tmp"))),Power(x,CN1))),C1)),CompoundExpression(CompoundExpression(Set($s("sqrt"),Rt(Plus(Power(b,C2),Times(CN1,C4,a,c)),C2)),Set(r,Plus(c,Times(CN1,Power(x,C2))))),List(Simplify(Times(CN1,$s("sqrt"),SquareRootOfQuadraticSubst(u,Times(CN1,$s("sqrt"),x,Power(r,CN1)),Times(CN1,Plus(Times(b,c),Times(c,$s("sqrt")),Times(Plus(Times(CN1,b),$s("sqrt")),Power(x,C2))),Power(Times(C2,c,r),CN1)),x),x,Power(Power(r,C2),CN1))),FullSimplify(Times(C2,c,Sqrt($s("tmp")),Power(Plus(b,Times(CN1,$s("sqrt")),Times(C2,c,x)),CN1))),C3))))))))))),
SetDelayed(FunctionOfSquareRootOfQuadratic($p(u),$p(v),$p(x,SymbolHead)),
    If(Or(AtomQ(u),FreeQ(u,x)),List(v),If(And(PowerQ(u),FreeQ(Part(u,C2),x)),If(And(And(And(FractionQ(Part(u,C2)),Equal(Denominator(Part(u,C2)),C2)),PolynomialQ(Part(u,C1),x)),Equal(Exponent(Part(u,C1),x),C2)),If(Or(FalseQ(v),SameQ(Part(u,C1),v)),List(Part(u,C1)),False),FunctionOfSquareRootOfQuadratic(Part(u,C1),v,x)),If(Or(ProductQ(u),SumQ(u)),Catch(Module(List(Set($s("lst"),List(v))),CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),FunctionOfSquareRootOfQuadratic(Slot1,Part($s("lst"),C1),x)),If(FalseQ($s("lst")),Throw(False)))),u),$s("lst")))),False)))),
SetDelayed(SquareRootOfQuadraticSubst($p(u),$p("vv"),$p("xx"),$p(x,SymbolHead)),
    If(Or(AtomQ(u),FreeQ(u,x)),If(SameQ(u,x),$s("xx"),u),If(And(PowerQ(u),FreeQ(Part(u,C2),x)),If(And(And(And(FractionQ(Part(u,C2)),Equal(Denominator(Part(u,C2)),C2)),PolynomialQ(Part(u,C1),x)),Equal(Exponent(Part(u,C1),x),C2)),Power($s("vv"),Numerator(Part(u,C2))),Power(SquareRootOfQuadraticSubst(Part(u,C1),$s("vv"),$s("xx"),x),Part(u,C2))),Map(Function(SquareRootOfQuadraticSubst(Slot1,$s("vv"),$s("xx"),x)),u)))),
SetDelayed(Subst($p(u),$p(x,SymbolHead),$p(w)),
    SimplifyAntiderivative(SubstAux(u,x,w),x)),
SetDelayed(Subst($p(u),$p(x),$p(w)),
    SubstAux(u,x,w)),
SetDelayed(SubstAux($p(u),$p(v),$p(w)),
    If(SameQ(u,v),w,If(AtomQ(u),u,If(PowerQ(u),If(And(And(PowerQ(v),SameQ(Part(u,C1),Part(v,C1))),SumQ(Part(u,C2))),Times(SubstAux(Power(Part(u,C1),First(Part(u,C2))),v,w),SubstAux(Power(Part(u,C1),Rest(Part(u,C2))),v,w)),Power(SubstAux(Part(u,C1),v,w),SubstAux(Part(u,C2),v,w))),If(SameQ(Head(u),Defer($s("Integrate::Subst"))),If(Or(SameQ(Part(u,C2),v),FreeQ(Part(u,C1),v)),SubstAux(Part(u,C1),Part(u,C2),SubstAux(Part(u,C3),v,w)),$(Defer($s("Integrate::Subst")),u,v,w)),If(SameQ(Head(u),Defer($s("Integrate::Dist"))),$(Defer($s("Integrate::Dist")),SubstAux(Part(u,C1),v,w),SubstAux(Part(u,C2),v,w),Part(u,C3)),If(Or(And(CalculusQ(u),Not(FreeQ(v,Part(u,C2)))),And(HeldFormQ(u),UnsameQ(Head(u),Defer($s("AppellF1"))))),$(Defer($s("Integrate::Subst")),u,v,w),Map(Function(SubstAux(Slot1,v,w)),u)))))))),
SetDelayed(SimplifyAntiderivative(Times($p(c),$p(u)),$p(x,SymbolHead)),
    Condition(Times(c,SimplifyAntiderivative(u,x)),FreeQ(c,x))),
SetDelayed(SimplifyAntiderivative(Log(Times($p(c),$p(u))),$p(x,SymbolHead)),
    Condition(SimplifyAntiderivative(Log(u),x),FreeQ(c,x))),
SetDelayed(SimplifyAntiderivative(Log(Power($p(u),$p(n))),$p(x,SymbolHead)),
    Condition(Times(n,SimplifyAntiderivative(Log(u),x)),FreeQ(n,x))),
SetDelayed(SimplifyAntiderivative(Log(Power($p(f),$p(u))),$p(x,SymbolHead)),
    Condition(Times(Log(f),SimplifyAntiderivative(u,x)),FreeQ(f,x))),
SetDelayed(SimplifyAntiderivative(ArcTan(Tan($p(u))),$p(x,SymbolHead)),
    SimplifyAntiderivative(u,x)),
SetDelayed(SimplifyAntiderivative(ArcTan(Cot($p(u))),$p(x,SymbolHead)),
    Times(CN1,SimplifyAntiderivative(u,x))),
SetDelayed(SimplifyAntiderivative(ArcTan(Times(Complex(C0,$p(n)),Tanh($p(u)))),$p(x,SymbolHead)),
    Condition(Times(Complex(C0,n),SimplifyAntiderivative(u,x)),OneQ(Power(n,C2)))),
SetDelayed(SimplifyAntiderivative(ArcTan(Times(Complex(C0,$p(n)),Coth($p(u)))),$p(x,SymbolHead)),
    Condition(Times(Complex(C0,n),SimplifyAntiderivative(u,x)),OneQ(Power(n,C2)))),
SetDelayed(SimplifyAntiderivative(ArcCot(Tan($p(u))),$p(x,SymbolHead)),
    Times(CN1,SimplifyAntiderivative(u,x))),
SetDelayed(SimplifyAntiderivative(ArcCot(Cot($p(u))),$p(x,SymbolHead)),
    SimplifyAntiderivative(u,x)),
SetDelayed(SimplifyAntiderivative(ArcCot(Times(Complex(C0,$p(n)),Tanh($p(u)))),$p(x,SymbolHead)),
    Condition(Times(CN1,Complex(C0,n),SimplifyAntiderivative(u,x)),OneQ(Power(n,C2)))),
SetDelayed(SimplifyAntiderivative(ArcCot(Times(Complex(C0,$p(n)),Coth($p(u)))),$p(x,SymbolHead)),
    Condition(Times(CN1,Complex(C0,n),SimplifyAntiderivative(u,x)),OneQ(Power(n,C2)))),
SetDelayed(SimplifyAntiderivative(ArcTanh(Tanh($p(u))),$p(x,SymbolHead)),
    SimplifyAntiderivative(u,x)),
SetDelayed(SimplifyAntiderivative(ArcTanh(Coth($p(u))),$p(x,SymbolHead)),
    SimplifyAntiderivative(u,x)),
SetDelayed(SimplifyAntiderivative(ArcCoth(Tanh($p(u))),$p(x,SymbolHead)),
    SimplifyAntiderivative(u,x)),
SetDelayed(SimplifyAntiderivative(ArcCoth(Coth($p(u))),$p(x,SymbolHead)),
    SimplifyAntiderivative(u,x)),
SetDelayed(SimplifyAntiderivative($p(u),$p(x,SymbolHead)),
    If(FreeQ(u,x),C0,If(LogQ(u),Log(RemoveContent(Part(u,C1),x)),If(SumQ(u),Map(Function(SimplifyAntiderivative(Slot1,x)),u),u)))),
SetDelayed(SubstFor($p(w),$p(v),$p(u),$p(x)),
    SimplifyIntegrand(Times(w,SubstFor(v,u,x)),x)),
SetDelayed(SubstFor($p(v),$p(u),$p(x)),
    If(AtomQ(v),Subst(u,v,x),If(Not(InertTrigFreeQ(u)),SubstFor(v,ActivateTrig(u),x),If(And(PowerQ(v),FreeQ(Part(v,C2),x)),SubstForPower(u,Part(v,C1),Part(v,C2),x),If(Not(OneQ(FreeFactors(v,x))),SubstFor(NonfreeFactors(v,x),u,Times(x,Power(FreeFactors(v,x),CN1))),If(SinQ(v),SubstForTrig(u,x,Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),Part(v,C1),x),If(CosQ(v),SubstForTrig(u,Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),x,Part(v,C1),x),If(TanQ(v),SubstForTrig(u,Times(x,Power(Sqrt(Plus(C1,Power(x,C2))),CN1)),Power(Sqrt(Plus(C1,Power(x,C2))),CN1),Part(v,C1),x),If(CotQ(v),SubstForTrig(u,Power(Sqrt(Plus(C1,Power(x,C2))),CN1),Times(x,Power(Sqrt(Plus(C1,Power(x,C2))),CN1)),Part(v,C1),x),If(SecQ(v),SubstForTrig(u,Power(Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),CN1),Power(x,CN1),Part(v,C1),x),If(CscQ(v),SubstForTrig(u,Power(x,CN1),Power(Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),CN1),Part(v,C1),x),If(SinhQ(v),SubstForHyperbolic(u,x,Sqrt(Plus(C1,Power(x,C2))),Part(v,C1),x),If(CoshQ(v),SubstForHyperbolic(u,Sqrt(Plus(CN1,Power(x,C2))),x,Part(v,C1),x),If(TanhQ(v),SubstForHyperbolic(u,Times(x,Power(Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),CN1)),Power(Sqrt(Plus(C1,Times(CN1,Power(x,C2)))),CN1),Part(v,C1),x),If(CothQ(v),SubstForHyperbolic(u,Power(Sqrt(Plus(CN1,Power(x,C2))),CN1),Times(x,Power(Sqrt(Plus(CN1,Power(x,C2))),CN1)),Part(v,C1),x),If(SechQ(v),SubstForHyperbolic(u,Power(Sqrt(Plus(CN1,Power(x,C2))),CN1),Power(x,CN1),Part(v,C1),x),If(CschQ(v),SubstForHyperbolic(u,Power(x,CN1),Power(Sqrt(Plus(C1,Power(x,C2))),CN1),Part(v,C1),x),SubstForExpn(u,v,x)))))))))))))))))),
SetDelayed(SubstForExpn($p(u),$p(v),$p(w)),
    If(SameQ(u,v),w,If(AtomQ(u),u,Map(Function(SubstForExpn(Slot1,v,w)),u)))),
SetDelayed(SubstForPower($p(u),$p("bas"),$p("deg"),$p(x)),
    If(AtomQ(u),u,If(And(And(And(PowerQ(u),ZeroQ(Plus(Part(u,C1),Times(CN1,$s("bas"))))),FreeQ(Part(u,C2),x)),IntegerQ(Simplify(Times(Part(u,C2),Power($s("deg"),CN1))))),Power(x,Times(Part(u,C2),Power($s("deg"),CN1))),Map(Function(SubstForPower(Slot1,$s("bas"),$s("deg"),x)),u)))),
SetDelayed(SubstForTrig($p(u),$p("sin"),$p("cos"),$p(v),$p(x)),
    If(AtomQ(u),u,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),If(Or(SameQ(Part(u,C1),v),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),If(SinQ(u),$s("§sin"),If(CosQ(u),$s("§cos"),If(TanQ(u),Times($s("§sin"),Power($s("§cos"),CN1)),If(CotQ(u),Times($s("§cos"),Power($s("§sin"),CN1)),If(SecQ(u),Power($s("§cos"),CN1),Power($s("§sin"),CN1)))))),Map(Function(SubstForTrig(Slot1,$s("§sin"),$s("§cos"),v,x)),ReplaceAll(TrigExpand($(Head(u),Times(Simplify(Times(Part(u,C1),Power(v,CN1))),x))),Rule(x,v)))),If(And(And(And(And(ProductQ(u),CosQ(Part(u,C1))),SinQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,C1D2,v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,C1D2,v)))),Times(C1D2,$s("§sin"),SubstForTrig(Drop(u,C2),$s("§sin"),$s("§cos"),v,x)),Map(Function(SubstForTrig(Slot1,$s("§sin"),$s("§cos"),v,x)),u))))),
SetDelayed(SubstForHyperbolic($p(u),$p("sinh"),$p("cosh"),$p(v),$p(x)),
    If(AtomQ(u),u,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),If(Or(SameQ(Part(u,C1),v),ZeroQ(Plus(Part(u,C1),Times(CN1,v)))),If(SinhQ(u),$s("sinh"),If(CoshQ(u),$s("cosh"),If(TanhQ(u),Times($s("sinh"),Power($s("cosh"),CN1)),If(CothQ(u),Times($s("cosh"),Power($s("sinh"),CN1)),If(SechQ(u),Power($s("cosh"),CN1),Power($s("sinh"),CN1)))))),Map(Function(SubstForHyperbolic(Slot1,$s("sinh"),$s("cosh"),v,x)),ReplaceAll(TrigExpand($(Head(u),Times(Simplify(Times(Part(u,C1),Power(v,CN1))),x))),Rule(x,v)))),If(And(And(And(And(ProductQ(u),CoshQ(Part(u,C1))),SinhQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,C1D2,v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,C1D2,v)))),Times(C1D2,$s("sinh"),SubstForHyperbolic(Drop(u,C2),$s("sinh"),$s("cosh"),v,x)),Map(Function(SubstForHyperbolic(Slot1,$s("sinh"),$s("cosh"),v,x)),u))))),
SetDelayed(SubstForFractionalPowerOfLinear($p(u),$p(x,SymbolHead)),
    Module(List(Set($s("lst"),FractionalPowerOfLinear(u,C1,False,x)),n,a,b,$s("tmp")),If(Or(FalseQ($s("lst")),FalseQ(Part($s("lst"),C2))),False,CompoundExpression(CompoundExpression(CompoundExpression(CompoundExpression(CompoundExpression(Set(n,Part($s("lst"),C1)),Set(a,Coefficient(Part($s("lst"),C2),x,C0))),Set(b,Coefficient(Part($s("lst"),C2),x,C1))),Set($s("tmp"),Times(Power(x,Plus(n,Times(CN1,C1))),SubstForFractionalPower(u,Part($s("lst"),C2),n,Plus(Times(CN1,a,Power(b,CN1)),Times(Power(x,n),Power(b,CN1))),x)))),Set($s("tmp"),SplitFreeFactors(Simplify($s("tmp")),x))),List(Part($s("tmp"),C2),n,Part($s("lst"),C2),Times(Part($s("tmp"),C1),Power(b,CN1)))))))
  );
}
