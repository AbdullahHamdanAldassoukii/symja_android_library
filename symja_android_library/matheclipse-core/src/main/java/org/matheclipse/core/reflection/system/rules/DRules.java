package org.matheclipse.core.reflection.system.rules;

import static org.matheclipse.core.expression.F.*;
import org.matheclipse.core.interfaces.IAST;

/**
 * <p>Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.</p>
 * <p>See GIT repository at: <a href="https://bitbucket.org/axelclk/symja_android_library">bitbucket.org/axelclk/symja_android_library under the tools directory</a>.</p>
 */
public interface DRules {
  /**
   * <ul>
   * <li>index 0 - number of equal rules in <code>RULES</code></li>
	 * </ul>
	 */
  final public static int[] SIZES = { 0, 38 };

  final public static IAST RULES = List(
    IInit(D, SIZES),
    // D(ArcCos(x_),x_):=D(x,x)*(-1)*(1-x^2)^Rational(-1,2)
    ISetDelayed(D(ArcCos(x_),x_),
      Times(D(x,x),CN1,Power(Plus(C1,Negate(Sqr(x))),CN1D2))),
    // D(ArcCosh(x_),x_):=D(x,x)*(x^2+(-1)*1)^Rational(-1,2)
    ISetDelayed(D(ArcCosh(x_),x_),
      Times(D(x,x),Power(Plus(Sqr(x),Negate(C1)),CN1D2))),
    // D(ArcCot(x_),x_):=(D(x,x)*(-1))/(1+x^2)
    ISetDelayed(D(ArcCot(x_),x_),
      Times(D(x,x),CN1,Power(Plus(C1,Sqr(x)),-1))),
    // D(ArcCoth(x_),x_):=D(x,x)/(1-x^2)
    ISetDelayed(D(ArcCoth(x_),x_),
      Times(D(x,x),Power(Plus(C1,Negate(Sqr(x))),-1))),
    // D(ArcCsc(x_),x_):=(-D(x,x)*1*(1-1/x^2)^Rational(-1,2))/x^2
    ISetDelayed(D(ArcCsc(x_),x_),
      Times(CN1,D(x,x),C1,Power(x,-2),Power(Plus(C1,Negate(Power(x,-2))),CN1D2))),
    // D(ArcCsch(x_),x_):=(D(x,x)*(-1)*(1+x^2)^Rational(-1,2))/Abs(x)
    ISetDelayed(D(ArcCsch(x_),x_),
      Times(D(x,x),CN1,Power(Abs(x),-1),Power(Plus(C1,Sqr(x)),CN1D2))),
    // D(ArcSin(x_),x_):=D(x,x)*(1-x^2)^Rational(-1,2)
    ISetDelayed(D(ArcSin(x_),x_),
      Times(D(x,x),Power(Plus(C1,Negate(Sqr(x))),CN1D2))),
    // D(ArcSinh(x_),x_):=D(x,x)*(1+x^2)^Rational(-1,2)
    ISetDelayed(D(ArcSinh(x_),x_),
      Times(D(x,x),Power(Plus(C1,Sqr(x)),CN1D2))),
    // D(ArcTan(x_),x_):=D(x,x)/(1+x^2)
    ISetDelayed(D(ArcTan(x_),x_),
      Times(D(x,x),Power(Plus(C1,Sqr(x)),-1))),
    // D(ArcTanh(x_),x_):=D(x,x)/(1-x^2)
    ISetDelayed(D(ArcTanh(x_),x_),
      Times(D(x,x),Power(Plus(C1,Negate(Sqr(x))),-1))),
    // D(ArcSec(x_),x_):=(D(x,x)*(1-1/x^2)^Rational(-1,2))/x^2
    ISetDelayed(D(ArcSec(x_),x_),
      Times(D(x,x),Power(x,-2),Power(Plus(C1,Negate(Power(x,-2))),CN1D2))),
    // D(ArcSech(x_),x_):=(D(x,x)*(-1)*(1-x^2)^Rational(-1,2))/x
    ISetDelayed(D(ArcSech(x_),x_),
      Times(D(x,x),CN1,Power(x,-1),Power(Plus(C1,Negate(Sqr(x))),CN1D2))),
    // D(Ceiling(x_),x_):=0
    ISetDelayed(D(Ceiling(x_),x_),
      C0),
    // D(Erf(x_),x_):=D(x,x)*2*1/(E^x^2*Sqrt(Pi))
    ISetDelayed(D(Erf(x_),x_),
      Times(D(x,x),C2,Power(E,Negate(Sqr(x))),Power(Pi,CN1D2))),
    // D(Erfc(x_),x_):=D(x,x)*-2*1/(E^x^2*Sqrt(Pi))
    ISetDelayed(D(Erfc(x_),x_),
      Times(D(x,x),CN2,Power(E,Negate(Sqr(x))),Power(Pi,CN1D2))),
    // D(Erfi(x_),x_):=D(x,x)*2*E^x^2/Sqrt(Pi)
    ISetDelayed(D(Erfi(x_),x_),
      Times(D(x,x),C2,Power(E,Sqr(x)),Power(Pi,CN1D2))),
    // D(Floor(x_),x_):=0
    ISetDelayed(D(Floor(x_),x_),
      C0),
    // D(FractionalPart(x_),x_):=D(x,x)*1
    ISetDelayed(D(FractionalPart(x_),x_),
      Times(D(x,x),C1)),
    // D(FresnelC(x_),x_):=D(x,x)*Cos(Rational(1,2)*Pi*x^2)
    ISetDelayed(D(FresnelC(x_),x_),
      Times(D(x,x),Cos(Times(C1D2,Pi,Sqr(x))))),
    // D(FresnelS(x_),x_):=D(x,x)*Sin(Rational(1,2)*Pi*x^2)
    ISetDelayed(D(FresnelS(x_),x_),
      Times(D(x,x),Sin(Times(C1D2,Pi,Sqr(x))))),
    // D(Gamma(x_),x_):=D(x,x)*Gamma(x)*PolyGamma(x)
    ISetDelayed(D(Gamma(x_),x_),
      Times(D(x,x),Gamma(x),PolyGamma(x))),
    // D(IntegerPart(x_),x_):=0
    ISetDelayed(D(IntegerPart(x_),x_),
      C0),
    // D(InverseErf(x_),x_):=D(x,x)*Rational(1,2)*Sqrt(Pi)*E^InverseErf(x)^2
    ISetDelayed(D(InverseErf(x_),x_),
      Times(D(x,x),C1D2,Sqrt(Pi),Power(E,Sqr(InverseErf(x))))),
    // D(Log(x_),x_):=D(x,x)/x
    ISetDelayed(D(Log(x_),x_),
      Times(D(x,x),Power(x,-1))),
    // D(PolyGamma(x_),x_):=D(x,x)*PolyGamma(1,x)
    ISetDelayed(D(PolyGamma(x_),x_),
      Times(D(x,x),PolyGamma(C1,x))),
    // D(Cot(x_),x_):=D(x,x)*(-1)*Csc(x)^2
    ISetDelayed(D(Cot(x_),x_),
      Times(D(x,x),CN1,Sqr(Csc(x)))),
    // D(Coth(x_),x_):=(D(x,x)*(-1))/Sinh(x)^2
    ISetDelayed(D(Coth(x_),x_),
      Times(D(x,x),CN1,Power(Sinh(x),-2))),
    // D(Cos(x_),x_):=D(x,x)*(-1)*Sin(x)
    ISetDelayed(D(Cos(x_),x_),
      Times(D(x,x),CN1,Sin(x))),
    // D(Cosh(x_),x_):=D(x,x)*Sinh(x)
    ISetDelayed(D(Cosh(x_),x_),
      Times(D(x,x),Sinh(x))),
    // D(Csc(x_),x_):=D(x,x)*(-1)*Cot(x)*Csc(x)
    ISetDelayed(D(Csc(x_),x_),
      Times(D(x,x),CN1,Cot(x),Csc(x))),
    // D(Csch(x_),x_):=D(x,x)*(-1)*Coth(x)*Csch(x)
    ISetDelayed(D(Csch(x_),x_),
      Times(D(x,x),CN1,Coth(x),Csch(x))),
    // D(Round(x_),x_):=0
    ISetDelayed(D(Round(x_),x_),
      C0),
    // D(Sin(x_),x_):=D(x,x)*Cos(x)
    ISetDelayed(D(Sin(x_),x_),
      Times(D(x,x),Cos(x))),
    // D(Sinh(x_),x_):=D(x,x)*Cosh(x)
    ISetDelayed(D(Sinh(x_),x_),
      Times(D(x,x),Cosh(x))),
    // D(Tan(x_),x_):=D(x,x)*Sec(x)^2
    ISetDelayed(D(Tan(x_),x_),
      Times(D(x,x),Sqr(Sec(x)))),
    // D(Tanh(x_),x_):=D(x,x)*Sech(x)^2
    ISetDelayed(D(Tanh(x_),x_),
      Times(D(x,x),Sqr(Sech(x)))),
    // D(Sec(x_),x_):=D(x,x)*Sec(x)*Tan(x)
    ISetDelayed(D(Sec(x_),x_),
      Times(D(x,x),Sec(x),Tan(x))),
    // D(Sech(x_),x_):=D(x,x)*(-1)*Tanh(x)*Sech(x)
    ISetDelayed(D(Sech(x_),x_),
      Times(D(x,x),CN1,Tanh(x),Sech(x)))
  );
}
