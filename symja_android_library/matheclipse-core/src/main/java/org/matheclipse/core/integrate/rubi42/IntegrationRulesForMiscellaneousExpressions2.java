package org.matheclipse.core.integrate.rubi42;


import static org.matheclipse.core.expression.F.*;
import static org.matheclipse.core.integrate.rubi42.UtilityFunctionCtors.*;
import static org.matheclipse.core.integrate.rubi42.UtilityFunctions.*;

import org.matheclipse.core.interfaces.IAST;
import org.matheclipse.core.interfaces.IExpr;
import org.matheclipse.core.interfaces.ISymbol;
/** 
 * IntegrationRules rules from the <a href="http://www.apmaths.uwo.ca/~arich/">Rubi -
 * rule-based integrator</a>.
 *  
 */
public class IntegrationRulesForMiscellaneousExpressions2 { 
  public static IAST RULES = List( 
SetDelayed(Map2($p("func"),$p("lst1"),$p("lst2")),
    Module(List(i),ReapList(Do(Sow($($s("func"),Part($s("lst1"),i),Part($s("lst2"),i))),List(i,Length($s("lst1"))))))),
SetDelayed(ReapList($p(u)),
    Module(List(Set($s("lst"),Part(Reap(u),C2))),If(SameQ($s("lst"),List()),$s("lst"),Part($s("lst"),C1)))),
SetDelayed(MapAnd($p(f),$p("lst")),
    Catch(CompoundExpression(Scan(Function(If($(f,Slot1),Null,Throw(False))),$s("lst")),True))),
SetDelayed(MapAnd($p(f),$p("lst"),$p(x)),
    Catch(CompoundExpression(Scan(Function(If($(f,Slot1,x),Null,Throw(False))),$s("lst")),True))),
SetDelayed(MapOr($p(f),$p("lst")),
    Catch(CompoundExpression(Scan(Function(If($(f,Slot1),Throw(True),Null)),$s("lst")),False))),
SetDelayed(NotIntegrableQ($p(u),$p(x,SymbolHead)),
    Or(MatchQ(u,Condition(Times(Power(x,$p(m)),Power(Log(Plus($p(a),Times($p(b,true),x))),$p(n))),And(And(And(FreeQ(List(a,b),x),IntegersQ(m,n)),Less(m,C0)),Less(n,C0)))),MatchQ(u,Condition($($p(f),Times(Power(x,$p(m,true)),Log(Plus($p(a,true),Times($p(b,true),x))))),And(And(FreeQ(List(a,b),x),IntegerQ(m)),Or(TrigQ(f),HyperbolicQ(f))))))),
SetDelayed(ZeroQ($p(u)),
    Quiet(PossibleZeroQ(u))),
SetDelayed(NonzeroQ($p(u)),
    Not(Quiet(PossibleZeroQ(u)))),
SetDelayed(ZeroQ($ps("u")),
    Catch(CompoundExpression(Scan(Function(If(ZeroQ(Slot1),Null,Throw(False))),List(u)),True))),
SetDelayed(OneQ($p(u)),
    PossibleZeroQ(Plus(u,Times(CN1,C1)))),
SetDelayed(OneQ($ps("u")),
    Catch(CompoundExpression(Scan(Function(If(OneQ(Slot1),Null,Throw(False))),List(u)),True))),
SetDelayed(RealNumericQ($p(u)),
    And(NumericQ(u),PossibleZeroQ(Im(N(u))))),
SetDelayed(ImaginaryNumericQ($p(u)),
    And(And(NumericQ(u),PossibleZeroQ(Re(N(u)))),Not(PossibleZeroQ(Im(N(u)))))),
SetDelayed(PositiveQ($p(u)),
    Module(List(Set(v,Simplify(u))),And(RealNumericQ(v),Greater(Re(N(v)),C0)))),
SetDelayed(PositiveOrZeroQ($p(u)),
    Module(List(Set(v,Simplify(u))),And(RealNumericQ(v),GreaterEqual(Re(N(v)),C0)))),
SetDelayed(NegativeQ($p(u)),
    Module(List(Set(v,Simplify(u))),And(RealNumericQ(v),Less(Re(N(v)),C0)))),
SetDelayed(NegativeOrZeroQ($p(u)),
    Module(List(Set(v,Simplify(u))),And(RealNumericQ(v),LessEqual(Re(N(v)),C0)))),
SetDelayed(IntegersQ($ps("u")),
    Catch(CompoundExpression(Scan(Function(If(IntegerQ(Slot1),Null,Throw(False))),List(u)),True))),
SetDelayed(PositiveIntegerQ($ps("u")),
    Catch(CompoundExpression(Scan(Function(If(And(IntegerQ(Slot1),Greater(Slot1,C0)),Null,Throw(False))),List(u)),True))),
SetDelayed(NegativeIntegerQ($ps("u")),
    Catch(CompoundExpression(Scan(Function(If(And(IntegerQ(Slot1),Less(Slot1,C0)),Null,Throw(False))),List(u)),True))),
SetDelayed(FractionQ($ps("u")),
    Catch(CompoundExpression(Scan(Function(If(SameQ(Head(Slot1),$s("Rational")),Null,Throw(False))),List(u)),True))),
SetDelayed(RationalQ($ps("u")),
    Catch(CompoundExpression(Scan(Function(If(Or(IntegerQ(Slot1),SameQ(Head(Slot1),$s("Rational"))),Null,Throw(False))),List(u)),True))),
SetDelayed(FractionOrNegativeQ($ps("u")),
    Catch(CompoundExpression(Scan(Function(If(Or(FractionQ(Slot1),And(IntegerQ(Slot1),Less(Slot1,C0))),Null,Throw(False))),List(u)),True))),
SetDelayed(SqrtNumberQ(Power($p(m),$p(n))),
    Or(And(IntegerQ(n),SqrtNumberQ(m)),And(IntegerQ(Plus(n,Times(CN1,C1D2))),RationalQ(m)))),
SetDelayed(SqrtNumberQ(Times($p(u),$p(v))),
    And(SqrtNumberQ(u),SqrtNumberQ(v))),
SetDelayed(SqrtNumberQ($p(u)),
    Or(RationalQ(u),SameQ(u,CI))),
SetDelayed(SqrtNumberSumQ($p(u)),
    Or(And(And(SumQ(u),SqrtNumberQ(First(u))),SqrtNumberQ(Rest(u))),And(And(ProductQ(u),SqrtNumberQ(First(u))),SqrtNumberSumQ(Rest(u))))),
SetDelayed(NiceSqrtQ($p(u)),
    And(Not(NegativeQ(u)),NiceSqrtAuxQ(u))),
SetDelayed(NiceSqrtAuxQ($p(u)),
    If(RationalQ(u),Greater(u,C0),If(PowerQ(u),EvenQ(Part(u,C2)),If(ProductQ(u),And(NiceSqrtAuxQ(First(u)),NiceSqrtAuxQ(Rest(u))),If(SumQ(u),$(Function(And(NonsumQ(Slot1),NiceSqrtAuxQ(Slot1))),Simplify(u)),False))))),
SetDelayed(PerfectSquareQ($p(u)),
    If(RationalQ(u),And(And(Greater(u,C0),Unequal(u,C1)),RationalQ(Sqrt(u))),If(PowerQ(u),EvenQ(Part(u,C2)),If(ProductQ(u),And(PerfectSquareQ(First(u)),PerfectSquareQ(Rest(u))),If(SumQ(u),$(Function(And(NonsumQ(Slot1),PerfectSquareQ(Slot1))),Simplify(u)),False))))),
SetDelayed(FalseQ($p(u)),
    SameQ(u,False)),
SetDelayed(NotFalseQ($p(u)),
    UnsameQ(u,False)),
SetDelayed(SumQ($p(u)),
    SameQ(Head(u),$s("Plus"))),
SetDelayed(NonsumQ($p(u)),
    UnsameQ(Head(u),$s("Plus"))),
SetDelayed(ProductQ($p(u)),
    SameQ(Head(u),$s("Times"))),
SetDelayed(PowerQ($p(u)),
    SameQ(Head(u),$s("Power"))),
SetDelayed(IntegerPowerQ($p(u)),
    And(PowerQ(u),IntegerQ(Part(u,C2)))),
SetDelayed(PositiveIntegerPowerQ($p(u)),
    And(And(PowerQ(u),IntegerQ(Part(u,C2))),Greater(Part(u,C2),C0))),
SetDelayed(FractionalPowerQ($p(u)),
    And(PowerQ(u),FractionQ(Part(u,C2)))),
SetDelayed(RationalPowerQ($p(u)),
    And(PowerQ(u),RationalQ(Part(u,C2)))),
SetDelayed(SqrtQ($p(u)),
    And(PowerQ(u),SameQ(Part(u,C2),C1D2))),
SetDelayed(ExpQ($p(u)),
    And(PowerQ(u),SameQ(Part(u,C1),E))),
SetDelayed(ImaginaryQ($p(u)),
    And(SameQ(Head(u),$s("Complex")),SameQ(Re(u),C0))),
SetDelayed(FractionalPowerFreeQ($p(u)),
    If(AtomQ(u),True,If(And(FractionalPowerQ(u),Not(AtomQ(Part(u,C1)))),False,Catch(CompoundExpression(Scan(Function(If(FractionalPowerFreeQ(Slot1),Null,Throw(False))),u),True))))),
SetDelayed(ComplexFreeQ($p(u)),
    If(AtomQ(u),UnsameQ(Head(u),$s("Complex")),Catch(CompoundExpression(Scan(Function(If(ComplexFreeQ(Slot1),Null,Throw(False))),u),True)))),
SetDelayed(LogQ($p(u)),
    SameQ(Head(u),$s("Log"))),
SetDelayed(SinQ($p(u)),
    SameQ(Head(u),$s("Sin"))),
SetDelayed(CosQ($p(u)),
    SameQ(Head(u),$s("Cos"))),
SetDelayed(TanQ($p(u)),
    SameQ(Head(u),$s("Tan")))
  );
}
