package org.matheclipse.core.integrate.rubi;


import static org.matheclipse.core.expression.F.*;
import static org.matheclipse.core.integrate.rubi.UtilityFunctionCtors.*;
import static org.matheclipse.core.integrate.rubi.UtilityFunctions.*;

import org.matheclipse.core.interfaces.IAST;
import org.matheclipse.core.interfaces.IExpr;
import org.matheclipse.core.interfaces.ISymbol;
/** 
 * UtilityFunctions rules from the <a href="http://www.apmaths.uwo.ca/~arich/">Rubi -
 * rule-based integrator</a>.
 *  
 */
public class UtilityFunctions0 { 
  public static IAST RULES = List( 
SetDelayed(MakeList($p("n",$s("Integer")),u_),
    If(Equal(n,C0),List(),Append(MakeList(Plus(n,Times(CN1,C1)),u),u))),
SetDelayed(Second(u_),
    Part(u,C2)),
SetDelayed(Map2($p("func"),$p("lst1"),$p("lst2")),
    ReapList(Do(Sow($($s("func"),Part($s("lst1"),i),Part($s("lst2"),i))),List(i,Length($s("lst1")))))),
SetDelayed(ReapList(u_),
    Module(List(Set($s("lst"),Part(Reap(u),C2))),If(SameQ($s("lst"),List()),$s("lst"),Part($s("lst"),C1)))),
SetDelayed(MapAnd(f_,$p("lst")),
    Catch(CompoundExpression(Scan(Function(If($(f,Slot1),Null,Throw(False))),$s("lst")),True))),
SetDelayed(MapAnd(f_,$p("lst"),x_),
    Catch(CompoundExpression(Scan(Function(If($(f,Slot1,x),Null,Throw(False))),$s("lst")),True))),
SetDelayed(MapOr(f_,$p("lst")),
    Catch(CompoundExpression(Scan(Function(If($(f,Slot1),Throw(True),Null)),$s("lst")),False))),
SetDelayed(NotIntegrableQ(u_,$p("x",$s("Symbol"))),
    Or(MatchQ(u,Condition(Times(Power(x,m_),Power(Log(Plus(a_,Times($p("b",true),x))),n_)),And(And(And(FreeQ(List(a,b),x),IntIntegerQ(List(m,n))),Less(m,C0)),Less(n,C0)))),MatchQ(u,Condition($(f_,Times(Power(x,$p("m",true)),Log(Plus($p("a",true),Times($p("b",true),x))))),And(And(FreeQ(List(a,b),x),IntIntegerQ(m)),Or(TrigQ(f),HyperbolicQ(f))))))),
SetDelayed(ZeroQ(u_),
    PossibleZeroQ(u)),
SetDelayed(NonzeroQ(u_),
    Not(PossibleZeroQ(u))),
SetDelayed(RealNumericQ(u_),
    And(NumericQ(u),PossibleZeroQ(Im(N(u))))),
SetDelayed(ImaginaryNumericQ(u_),
    And(And(NumericQ(u),PossibleZeroQ(Re(N(u)))),Not(PossibleZeroQ(Im(N(u)))))),
SetDelayed(PositiveQ(u_),
    Module(List(Set(v,Simplify(u))),And(RealNumericQ(v),Greater(Re(N(v)),C0)))),
SetDelayed(PositiveOrZeroQ(u_),
    Module(List(Set(v,Simplify(u))),And(RealNumericQ(v),GreaterEqual(Re(N(v)),C0)))),
SetDelayed(NegativeQ(u_),
    Module(List(Set(v,Simplify(u))),And(RealNumericQ(v),Less(Re(N(v)),C0)))),
SetDelayed(NegativeOrZeroQ(u_),
    Module(List(Set(v,Simplify(u))),And(RealNumericQ(v),LessEqual(Re(N(v)),C0)))),
SetDelayed(FractionQ(u_),
    If(ListQ(u),MapAnd($s("Integrate::FractionQ"),u),SameQ(Head(u),$s("Rational")))),
SetDelayed(RationalQ(Plus(u_,Times(m_,Plus(n_,v_)))),
    And(And(RationalQ(m),RationalQ(n)),RationalQ(Plus(u,Times(m,v))))),
SetDelayed(RationalQ(u_),
    If(ListQ(u),MapAnd($s("Integrate::RationalQ"),u),Or(IntIntegerQ(u),SameQ(Head(u),$s("Rational"))))),
SetDelayed(HalfIntegerQ(u_),
    If(ListQ(u),MapAnd($s("Integrate::HalfIntegerQ"),u),And(FractionQ(u),Equal(Denominator(u),C2)))),
SetDelayed(FractionOrNegativeQ(u_),
    If(ListQ(u),MapAnd($s("Integrate::FractionOrNegativeQ"),u),Or(FractionQ(u),And(IntIntegerQ(u),Less(u,C0))))),
SetDelayed(SqrtNumberQ(Power(m_,n_)),
    Or(And(IntIntegerQ(n),SqrtNumberQ(m)),And(HalfIntegerQ(n),RationalQ(m)))),
SetDelayed(SqrtNumberQ(Times(u_,v_)),
    And(SqrtNumberQ(u),SqrtNumberQ(v))),
SetDelayed(SqrtNumberQ(u_),
    Or(RationalQ(u),SameQ(u,CI))),
SetDelayed(SqrtNumberSumQ(u_),
    And(And(SumQ(u),SqrtNumberQ(First(u))),SqrtNumberQ(Rest(u)))),
SetDelayed(FalseQ(u_),
    SameQ(u,False)),
SetDelayed(NotFalseQ(u_),
    UnsameQ(u,False)),
SetDelayed(SumQ(u_),
    SameQ(Head(u),$s("Plus"))),
SetDelayed(NonsumQ(u_),
    UnsameQ(Head(u),$s("Plus"))),
SetDelayed(ProductQ(u_),
    SameQ(Head(u),$s("Times"))),
SetDelayed(PowerQ(u_),
    SameQ(Head(u),$s("Power"))),
SetDelayed(IntegerPowerQ(u_),
    And(PowerQ(u),IntIntegerQ(Part(u,C2)))),
SetDelayed(PositiveIntegerPowerQ(u_),
    And(And(PowerQ(u),IntIntegerQ(Part(u,C2))),Greater(Part(u,C2),C0))),
SetDelayed(FractionalPowerQ(u_),
    And(PowerQ(u),FractionQ(Part(u,C2)))),
SetDelayed(RationalPowerQ(u_),
    And(PowerQ(u),RationalQ(Part(u,C2)))),
SetDelayed(SqrtQ(u_),
    And(PowerQ(u),SameQ(Part(u,C2),C1D2))),
SetDelayed(ExpQ(u_),
    And(PowerQ(u),SameQ(Part(u,C1),E))),
SetDelayed(ImaginaryQ(u_),
    And(SameQ(Head(u),$s("Complex")),SameQ(Re(u),C0))),
SetDelayed(FractionalPowerFreeQ(u_),
    If(AtomQ(u),True,If(And(FractionalPowerQ(u),Not(AtomQ(Part(u,C1)))),False,Catch(CompoundExpression(Scan(Function(If(FractionalPowerFreeQ(Slot1),Null,Throw(False))),u),True))))),
SetDelayed(ComplexFreeQ(u_),
    If(AtomQ(u),UnsameQ(Head(u),$s("Complex")),Catch(CompoundExpression(Scan(Function(If(ComplexFreeQ(Slot1),Null,Throw(False))),u),True)))),
SetDelayed(LogQ(u_),
    SameQ(Head(u),$s("Log"))),
SetDelayed(ProductLogQ(u_),
    SameQ(Head(u),$s("ProductLog"))),
SetDelayed(SinQ(u_),
    SameQ(Head(u),$s("Sin"))),
SetDelayed(CosQ(u_),
    SameQ(Head(u),$s("Cos"))),
SetDelayed(TanQ(u_),
    SameQ(Head(u),$s("Tan"))),
SetDelayed(CotQ(u_),
    SameQ(Head(u),$s("Cot"))),
SetDelayed(SecQ(u_),
    SameQ(Head(u),$s("Sec"))),
SetDelayed(CscQ(u_),
    SameQ(Head(u),$s("Csc"))),
SetDelayed(SinhQ(u_),
    SameQ(Head(u),$s("Sinh"))),
SetDelayed(CoshQ(u_),
    SameQ(Head(u),$s("Cosh"))),
SetDelayed(TanhQ(u_),
    SameQ(Head(u),$s("Tanh"))),
SetDelayed(CothQ(u_),
    SameQ(Head(u),$s("Coth"))),
SetDelayed(SechQ(u_),
    SameQ(Head(u),$s("Sech"))),
SetDelayed(CschQ(u_),
    SameQ(Head(u),$s("Csch"))),
SetDelayed(TrigQ(u_),
    MemberQ(List($s("Sin"),$s("Cos"),$s("Tan"),$s("Cot"),$s("Sec"),$s("Csc")),If(AtomQ(u),u,Head(u)))),
SetDelayed(InverseTrigQ(u_),
    MemberQ(List($s("ArcSin"),$s("ArcCos"),$s("ArcTan"),$s("ArcCot"),$s("ArcSec"),$s("ArcCsc")),If(AtomQ(u),u,Head(u)))),
SetDelayed(HyperbolicQ(u_),
    MemberQ(List($s("Sinh"),$s("Cosh"),$s("Tanh"),$s("Coth"),$s("Sech"),$s("Csch")),If(AtomQ(u),u,Head(u)))),
SetDelayed(InverseHyperbolicQ(u_),
    MemberQ(List($s("ArcSinh"),$s("ArcCosh"),$s("ArcTanh"),$s("ArcCoth"),$s("ArcSech"),$s("ArcCsch")),If(AtomQ(u),u,Head(u)))),
SetDelayed(SinCosQ(f_),
    MemberQ(List($s("Sin"),$s("Cos"),$s("Sec"),$s("Csc")),f)),
SetDelayed(SinhCoshQ(f_),
    MemberQ(List($s("Sinh"),$s("Cosh"),$s("Sech"),$s("Csch")),f)),
SetDelayed(CalculusQ(u_),
    MemberQ(List($s("D"),$s("Integrate"),$s("Sum"),$s("Product"),$s("Int"),$s("Dif"),$s("Integrate::Subst")),Head(u))),
SetDelayed(CalculusFreeQ(u_,x_),
    If(AtomQ(u),True,If(Or(Or(And(CalculusQ(u),SameQ(Part(u,C2),x)),SameQ(Head(u),$s("Pattern"))),SameQ(Head(u),$s("Defer"))),False,Catch(CompoundExpression(Scan(Function(If(CalculusFreeQ(Slot1,x),Null,Throw(False))),u),True))))),
SetDelayed(SubstQ(u_),
    SameQ(Head(u),$s("Integrate::Subst"))),
SetDelayed(InverseFunctionQ(u_),
    Or(Or(Or(LogQ(u),InverseTrigQ(u)),InverseHyperbolicQ(u)),SameQ(Head(u),$s("Integrate::Mods")))),
SetDelayed(TrigHyperbolicFreeQ(u_,$p("x",$s("Symbol"))),
    If(AtomQ(u),True,If(Or(Or(TrigQ(u),HyperbolicQ(u)),CalculusQ(u)),FreeQ(u,x),Catch(CompoundExpression(Scan(Function(If(TrigHyperbolicFreeQ(Slot1,x),Null,Throw(False))),u),True))))),
SetDelayed(InverseFunctionFreeQ(u_,$p("x",$s("Symbol"))),
    If(AtomQ(u),True,If(Or(InverseFunctionQ(u),CalculusQ(u)),FreeQ(u,x),Catch(CompoundExpression(Scan(Function(If(InverseFunctionFreeQ(Slot1,x),Null,Throw(False))),u),True))))),
SetDelayed(NegativeCoefficientQ(u_),
    If(SumQ(u),NegativeCoefficientQ(First(u)),MatchQ(u,Condition(Times(m_,$p("v",true)),And(RationalQ(m),Less(m,C0)))))),
SetDelayed(RealQ(u_),
    Condition(MapAnd($s("Integrate::RealQ"),u),ListQ(u))),
SetDelayed(RealQ(u_),
    Condition(PossibleZeroQ(Im(N(u))),NumericQ(u))),
SetDelayed(RealQ(Power(u_,v_)),
    And(And(RealQ(u),RealQ(v)),Or(IntIntegerQ(v),PositiveOrZeroQ(u)))),
SetDelayed(RealQ(Times(u_,v_)),
    And(RealQ(u),RealQ(v))),
SetDelayed(RealQ(Plus(u_,v_)),
    And(RealQ(u),RealQ(v))),
SetDelayed(RealQ($(f_,u_)),
    If(MemberQ(List($s("Sin"),$s("Cos"),$s("Tan"),$s("Cot"),$s("Sec"),$s("Csc"),$s("ArcTan"),$s("ArcCot"),$s("Erf")),f),RealQ(u),If(MemberQ(List($s("ArcSin"),$s("ArcCos")),f),LE(CN1,u,C1),If(SameQ(f,$s("Log")),PositiveOrZeroQ(u),False)))),
SetDelayed(RealQ(u_),
    False),
SetDelayed(PosQ(u_),
    If(PossibleZeroQ(u),False,If(NumericQ(u),If(NumberQ(u),If(PossibleZeroQ(Re(u)),Greater(Im(u),C0),Greater(Re(u),C0)),Module(List(Set(v,N(u))),If(PossibleZeroQ(Re(v)),Greater(Im(v),C0),Greater(Re(v),C0)))),Module(List(Set(v,Simplify(u))),If(NumericQ(v),PosQ(v),If(And(PowerQ(v),IntIntegerQ(Part(v,C2))),PosQ(Part(v,C1)),If(ProductQ(v),If(RationalQ(First(v)),If(Greater(First(v),C0),PosQ(Rest(v)),NegQ(Rest(v))),PosQ(First(v))),If(SumQ(v),PosQ(First(v)),Not(MatchQ(v,Times(CN1,$p((ISymbol)null)))))))))))),
SetDelayed(NegQ(u_),
    If(PossibleZeroQ(u),False,Not(PosQ(u)))),
SetDelayed(LeadTerm(u_),
    If(SumQ(u),First(u),u)),
SetDelayed(RemainingTerms(u_),
    If(SumQ(u),Rest(u),C0)),
SetDelayed(LeadFactor(u_),
    If(ProductQ(u),LeadFactor(First(u)),If(ImaginaryQ(u),If(SameQ(Im(u),C1),u,LeadFactor(Im(u))),u))),
SetDelayed(RemainingFactors(u_),
    If(ProductQ(u),Times(RemainingFactors(First(u)),Rest(u)),If(ImaginaryQ(u),If(SameQ(Im(u),C1),C1,Times(CI,RemainingFactors(Im(u)))),C1))),
SetDelayed(LeadBase(u_),
    Module(List(Set(v,LeadFactor(u))),If(PowerQ(v),Part(v,C1),v))),
SetDelayed(LeadDegree(u_),
    Module(List(Set(v,LeadFactor(u))),If(PowerQ(v),Part(v,C2),C1))),
SetDelayed(LT(u_,v_),
    And(And(RealNumericQ(u),RealNumericQ(v)),Less(Re(N(u)),Re(N(v))))),
SetDelayed(LT(u_,v_,w_),
    And(LT(u,v),LT(v,w))),
SetDelayed(LE(u_,v_),
    And(And(RealNumericQ(u),RealNumericQ(v)),LessEqual(Re(N(u)),Re(N(v))))),
SetDelayed(LE(u_,v_,w_),
    And(LE(u,v),LE(v,w))),
SetDelayed(GT(u_,v_),
    And(And(RealNumericQ(u),RealNumericQ(v)),Greater(Re(N(u)),Re(N(v))))),
SetDelayed(GT(u_,v_,w_),
    And(GT(u,v),GT(v,w))),
SetDelayed(GE(u_,v_),
    And(And(RealNumericQ(u),RealNumericQ(v)),GreaterEqual(Re(N(u)),Re(N(v))))),
SetDelayed(GE(u_,v_,w_),
    And(GE(u,v),GE(v,w))),
SetDelayed(IndependentQ(u_,$p("x",$s("Symbol"))),
    FreeQ(u,x)),
SetDelayed(SplitFreeFactors(u_,$p("x",$s("Symbol"))),
    If(ProductQ(u),Map(Function(If(FreeQ(Slot1,x),List(Slot1,C1),List(C1,Slot1))),u),If(FreeQ(u,x),List(u,C1),List(C1,u)))),
SetDelayed(SplitFreeTerms(u_,$p("x",$s("Symbol"))),
    If(SumQ(u),Map(Function(SplitFreeTerms(Slot1,x)),u),If(FreeQ(u,x),List(u,C0),List(C0,u)))),
SetDelayed(SplitFactorsOfTerms(u_,$p("x",$s("Symbol"))),
    Module(List(Set($s("lst"),SplitFreeTerms(u,x)),v,w),CompoundExpression(CompoundExpression(CompoundExpression(Set(v,Part($s("lst"),C1)),Set(w,Part($s("lst"),C2))),If(ZeroQ(w),Set($s("lst"),List()),If(SumQ(w),CompoundExpression(CompoundExpression(Set($s("lst"),Map(Function(SplitFreeFactors(Slot1,x)),Apply($s("List"),w))),Set($s("lst"),Map(Function(Prepend(SplitFreeFactors(Regularize(Part(Slot1,C2),x),x),Part(Slot1,C1))),$s("lst")))),Set($s("lst"),Map(Function(List(Times(Part(Slot1,C1),Part(Slot1,C2)),Part(Slot1,C3))),$s("lst")))),CompoundExpression(CompoundExpression(Set($s("lst"),SplitFreeFactors(w,x)),Set($s("lst"),Prepend(SplitFreeFactors(Regularize(Part($s("lst"),C2),x),x),Part($s("lst"),C1)))),Set($s("lst"),List(List(Times(Part($s("lst"),C1),Part($s("lst"),C2)),Part($s("lst"),C3)))))))),If(ZeroQ(v),$s("lst"),Prepend($s("lst"),List(C1,v)))))),
SetDelayed(SplitMonomialTerms(u_,$p("x",$s("Symbol"))),
    Map(Function(If(Or(FreeQ(Slot1,x),MatchQ(Slot1,Condition(Times($p("a",true),Power(x,$p("n",true))),FreeQ(List(a,n),x)))),List(Slot1,C0),List(C0,Slot1))),u)),
SetDelayed(LinearQ(u_,$p("x",$s("Symbol"))),
    And(IntPolynomialQ(u,x),SameQ(Exponent(u,x),C1))),
SetDelayed(QuadraticQ(u_,$p("x",$s("Symbol"))),
    And(IntPolynomialQ(u,x),SameQ(Exponent(u,x),C2))),
SetDelayed(MonomialQ(u_,$p("x",$s("Symbol"))),
    MatchQ(u,Condition(Power(x,$p("n",true)),FreeQ(n,x)))),
SetDelayed(BinomialQ(u_,$p("x",$s("Symbol"))),
    NotFalseQ(BinomialTest(u,x)))
  );
}
