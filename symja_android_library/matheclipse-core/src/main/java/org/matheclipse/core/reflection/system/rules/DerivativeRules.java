package org.matheclipse.core.reflection.system.rules;

import static org.matheclipse.core.expression.F.*;
import org.matheclipse.core.interfaces.IAST;

/**
 * <p>Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.</p>
 * <p>See GIT repository at: <a href="https://bitbucket.org/axelclk/symja_android_library">bitbucket.org/axelclk/symja_android_library under the tools directory</a>.</p>
 */
public interface DerivativeRules {
  final public static IAST RULES1 = List(
    // ArcCos->(-1/Sqrt(1-#1^2)&)
    Rule(ArcCos,
      Function(Negate(Power(Plus(C1,Negate(Sqr(Slot1))),CN1D2)))),
    // ArcCosh->(1/Sqrt(#1^2+(-1)*1)&)
    Rule(ArcCosh,
      Function(Power(Plus(Sqr(Slot1),Negate(C1)),CN1D2))),
    // ArcCot->(1/(-1-#1^2)&)
    Rule(ArcCot,
      Function(Negate(Power(Plus(C1,Sqr(Slot1)),-1)))),
    // ArcCoth->(1/(1-#1^2)&)
    Rule(ArcCoth,
      Function(Power(Plus(C1,Negate(Sqr(Slot1))),-1))),
    // ArcCsc->(-1/(#1^2*Sqrt(1-1/#1^2))&)
    Rule(ArcCsc,
      Function(Times(CN1,Power(Slot1,-2),Power(Plus(C1,Negate(Power(Slot1,-2))),CN1D2)))),
    // ArcCsch->(-1/(Abs(#1)*Sqrt(1+#1^2))&)
    Rule(ArcCsch,
      Function(Times(CN1,Power(Abs(Slot1),-1),Power(Plus(C1,Sqr(Slot1)),CN1D2)))),
    // ArcSin->(1/Sqrt(1-#1^2)&)
    Rule(ArcSin,
      Function(Power(Plus(C1,Negate(Sqr(Slot1))),CN1D2))),
    // ArcSinh->(1/Sqrt(1+#1^2)&)
    Rule(ArcSinh,
      Function(Power(Plus(C1,Sqr(Slot1)),CN1D2))),
    // ArcTan->(1/(1+#1^2)&)
    Rule(ArcTan,
      Function(Power(Plus(C1,Sqr(Slot1)),-1))),
    // ArcTanh->(1/(1-#1^2)&)
    Rule(ArcTanh,
      Function(Power(Plus(C1,Negate(Sqr(Slot1))),-1))),
    // ArcSec->(1/(#1^2*Sqrt(1-1/#1^2))&)
    Rule(ArcSec,
      Function(Times(Power(Slot1,-2),Power(Plus(C1,Negate(Power(Slot1,-2))),CN1D2)))),
    // ArcSech->(-1/(#1*Sqrt(1-#1^2))&)
    Rule(ArcSech,
      Function(Times(CN1,Power(Slot1,-1),Power(Plus(C1,Negate(Sqr(Slot1))),CN1D2)))),
    // Ceiling->(0&)
    Rule(Ceiling,
      Function(C0)),
    // Erf->(2*1/(E^#1^2*Sqrt(Pi))&)
    Rule(Erf,
      Function(Times(C2,Power(E,Negate(Sqr(Slot1))),Power(Pi,CN1D2)))),
    // Erfc->(-2*1/(E^#1^2*Sqrt(Pi))&)
    Rule(Erfc,
      Function(Times(CN2,Power(E,Negate(Sqr(Slot1))),Power(Pi,CN1D2)))),
    // Erfi->(2*E^#1^2/Sqrt(Pi)&)
    Rule(Erfi,
      Function(Times(C2,Power(E,Sqr(Slot1)),Power(Pi,CN1D2)))),
    // Floor->(0&)
    Rule(Floor,
      Function(C0)),
    // FractionalPart->(1&)
    Rule(FractionalPart,
      Function(C1)),
    // FresnelC->(Cos(1/2*Pi*#1^2)&)
    Rule(FresnelC,
      Function(Cos(Times(C1D2,Pi,Sqr(Slot1))))),
    // FresnelS->(Sin(1/2*Pi*#1^2)&)
    Rule(FresnelS,
      Function(Sin(Times(C1D2,Pi,Sqr(Slot1))))),
    // Gamma->(Gamma(#1)*PolyGamma(#1)&)
    Rule(Gamma,
      Function(Times(Gamma(Slot1),PolyGamma(Slot1)))),
    // IntegerPart->(0&)
    Rule(IntegerPart,
      Function(C0)),
    // InverseErf->(1/2*Sqrt(Pi)*E^InverseErf(x)^2&)
    Rule(InverseErf,
      Function(Times(C1D2,Sqrt(Pi),Power(E,Sqr(InverseErf(x)))))),
    // Log->(1/#1&)
    Rule(Log,
      Function(Power(Slot1,-1))),
    // PolyGamma->(PolyGamma(1,#1)&)
    Rule(PolyGamma,
      Function(PolyGamma(C1,Slot1))),
    // Cot->(-Csc(#1)^2&)
    Rule(Cot,
      Function(Negate(Sqr(Csc(Slot1))))),
    // Coth->(-1/Sinh(#1)^2&)
    Rule(Coth,
      Function(Negate(Power(Sinh(Slot1),-2)))),
    // Cos->(-Sin(#1)&)
    Rule(Cos,
      Function(Negate(Sin(Slot1)))),
    // Cosh->(Sinh(#1)&)
    Rule(Cosh,
      Function(Sinh(Slot1))),
    // Csc->(-Cot(#1)*Csc(#1)&)
    Rule(Csc,
      Function(Times(CN1,Cot(Slot1),Csc(Slot1)))),
    // Csch->(-Coth(#1)*Csch(#1)&)
    Rule(Csch,
      Function(Times(CN1,Coth(Slot1),Csch(Slot1)))),
    // Round->(0&)
    Rule(Round,
      Function(C0)),
    // Sin->(Cos(#1)&)
    Rule(Sin,
      Function(Cos(Slot1))),
    // Sinh->(Cosh(#1)&)
    Rule(Sinh,
      Function(Cosh(Slot1))),
    // Tan->(Sec(#1)^2&)
    Rule(Tan,
      Function(Sqr(Sec(Slot1)))),
    // Tanh->(Sech(#1)^2&)
    Rule(Tanh,
      Function(Sqr(Sech(Slot1)))),
    // Sec->(Sec(#1)*Tan(#1)&)
    Rule(Sec,
      Function(Times(Sec(Slot1),Tan(Slot1)))),
    // Sech->(-Tanh(#1)*Sech(#1)&)
    Rule(Sech,
      Function(Times(CN1,Tanh(Slot1),Sech(Slot1))))
  );
  final public static IAST RULES2 = List(
    // ArcSin->(#1/(1-#1^2)^(3/2)&)
    Rule(ArcSin,
      Function(Times(Slot1,Power(Plus(C1,Negate(Sqr(Slot1))),QQ(-3L,2L))))),
    // Gamma->(Gamma(#1)*PolyGamma(#1)^2+Gamma(#1)*PolyGamma(1,#1)&)
    Rule(Gamma,
      Function(Plus(Times(Gamma(Slot1),Sqr(PolyGamma(Slot1))),Times(Gamma(Slot1),PolyGamma(C1,Slot1))))),
    // Log->(-1/#1^2&)
    Rule(Log,
      Function(Negate(Power(Slot1,-2)))),
    // PolyGamma->(PolyGamma(2,#1)&)
    Rule(PolyGamma,
      Function(PolyGamma(C2,Slot1))),
    // Cot->(2*Csc(#1)^2*Cot(#1)&)
    Rule(Cot,
      Function(Times(C2,Sqr(Csc(Slot1)),Cot(Slot1)))),
    // Tan->(2*Sec(#1)^2*Tan(#1)&)
    Rule(Tan,
      Function(Times(C2,Sqr(Sec(Slot1)),Tan(Slot1))))
  );
  final public static IAST RULES3 = List(
    // Log->(((-1)^(#2+(-1)*1)*(#2+(-1)*1)!)/#1^#2&)
    Rule(Log,
      Function(Times(Power(CN1,Plus(Slot2,Negate(C1))),Factorial(Plus(Slot2,Negate(C1))),Power(Slot1,Negate(Slot2))))),
    // PolyGamma->(PolyGamma(#2,#1)&)
    Rule(PolyGamma,
      Function(PolyGamma(Slot2,Slot1))),
    // Cos->(Cos(#1+1/2*Pi*#2)&)
    Rule(Cos,
      Function(Cos(Plus(Slot1,Times(C1D2,Pi,Slot2))))),
    // Sin->(Sin(#1+1/2*Pi*#2)&)
    Rule(Sin,
      Function(Sin(Plus(Slot1,Times(C1D2,Pi,Slot2)))))
  );
  final public static IAST RULES4 = List(
    // {BesselJ,0,1}->(1/2*(BesselJ(-1+#1,#2)-BesselJ(1+#1,#2))&)
    Rule(List(BesselJ,C0,C1),
      Function(Times(C1D2,Plus(BesselJ(Plus(CN1,Slot1),Slot2),Negate(BesselJ(Plus(C1,Slot1),Slot2)))))),
    // {Power,1,0}->(#2/#1^(1-#2)&)
    Rule(List(Power,C1,C0),
      Function(Times(Power(Slot1,Plus(CN1,Slot2)),Slot2))),
    // {Power,0,1}->(Log(#1)*#1^#2&)
    Rule(List(Power,C0,C1),
      Function(Times(Log(Slot1),Power(Slot1,Slot2)))),
    // {Power,1,1}->(#1^(-1+#2)+(Log(#1)*#2)/#1^(1-#2)&)
    Rule(List(Power,C1,C1),
      Function(Plus(Power(Slot1,Plus(CN1,Slot2)),Times(Log(Slot1),Power(Slot1,Plus(CN1,Slot2)),Slot2)))),
    // {ProductLog,0,1}->(ProductLog(#1,#2)/#2*(1+ProductLog(#1,#2))&)
    Rule(List(ProductLog,C0,C1),
      Function(Times(ProductLog(Slot1,Slot2),Power(Slot2,-1),Plus(C1,ProductLog(Slot1,Slot2)))))
  );
}
