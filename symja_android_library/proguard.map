cc.redberry.concurrent.OutputPortUnsafe -> a:
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.DummySolutionProvider -> b:
    int[] solution -> a
    int[] currentRemainder -> b
    boolean tick() -> a
    int[] currentRemainders() -> a
    java.lang.Object take() -> a
    boolean equal(java.lang.Object,java.lang.Object) -> a
    void checkArgument(boolean) -> a
    void checkArgument(boolean,java.lang.String,java.lang.Object[]) -> a
    void checkState(boolean,java.lang.Object) -> a
    java.lang.Object checkNotNull(java.lang.Object) -> a
    java.lang.Object checkNotNull(java.lang.Object,java.lang.Object) -> a
    java.lang.String format(java.lang.String,java.lang.Object[]) -> a
    java.util.HashSet newHashSet(java.lang.Iterable) -> a
    java.util.HashSet newHashSet(java.util.Iterator) -> a
    com.google.common.collect.Sets$SetView difference(java.util.Set,java.util.Set) -> a
    boolean equalsImpl(java.util.Set,java.lang.Object) -> a
    boolean removeAllImpl(java.util.Set,java.util.Collection) -> a
    int checkNonNegative(java.lang.String,int) -> a
    long checkNonNegative(java.lang.String,long) -> a
    void checkRoundingUnnecessary(boolean) -> b
    void checkInRange(boolean) -> c
    java.util.List map(java.util.List,edu.jas.structure.UnaryFunctor) -> a
    org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction) -> a
    boolean isBracketing(org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    void verifyInterval(double,double) -> a
    java.lang.Object[] flatten(java.lang.Object[]) -> a
    double erf(double) -> a
    double erfInv(double) -> b
    java.text.NumberFormat getDefaultNumberFormat(java.util.Locale) -> a
    java.lang.StringBuffer formatDouble(double,java.text.NumberFormat,java.lang.StringBuffer,java.text.FieldPosition) -> a
    boolean checkOrder$5183600(double[],int,boolean,boolean) -> a
    void checkOrder(double[]) -> a
    java.lang.Object[] buildArray(org.apache.commons.math3.Field,int) -> a
    java.lang.Object[][] buildArray(org.apache.commons.math3.Field,int,int) -> a
    boolean verifyValues(double[],int,int,boolean) -> a
    int hash(double) -> a
    void checkNotNull(java.lang.Object,org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> a
    void checkNotNull(java.lang.Object) -> a
    org.apache.commons.math3.linear.FieldMatrix list2Matrix(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST matrix2List(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.linear.RealMatrix list2RealMatrix(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST realMatrix2List(org.apache.commons.math3.linear.RealMatrix) -> a
    org.apache.commons.math3.linear.FieldVector list2Vector(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST vector2List(org.apache.commons.math3.linear.FieldVector) -> a
    org.matheclipse.core.interfaces.IAST asList(int[]) -> a
    int checkPowerExponent(org.matheclipse.core.interfaces.IAST) -> a
    int checkIntType(org.matheclipse.core.interfaces.IAST,int,int) -> a
    int checkIntType(org.matheclipse.core.interfaces.IExpr,int) -> a
    org.matheclipse.core.interfaces.IAST checkRange(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IAST checkRange(org.matheclipse.core.interfaces.IAST,int,int) -> a
    org.matheclipse.core.interfaces.IAST checkSize(org.matheclipse.core.interfaces.IAST,int) -> b
    org.matheclipse.core.interfaces.IAST checkSymbolOrSymbolList(org.matheclipse.core.interfaces.IAST,int) -> c
    org.matheclipse.core.interfaces.ISymbol checkSymbolType(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IAST checkASTUpRuleType(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST checkASTType(org.matheclipse.core.interfaces.IAST,int) -> d
    org.matheclipse.core.interfaces.IAST checkASTType(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.expression.ComplexNum cos(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.expression.ComplexNum cosh(org.matheclipse.core.expression.ComplexNum) -> b
    org.matheclipse.core.expression.ComplexNum log(org.matheclipse.core.expression.ComplexNum) -> c
    org.matheclipse.core.expression.ComplexNum sin(org.matheclipse.core.expression.ComplexNum) -> d
    org.matheclipse.core.expression.ComplexNum sinh(org.matheclipse.core.expression.ComplexNum) -> e
    org.matheclipse.core.expression.ComplexNum sqrt1z(org.matheclipse.core.expression.ComplexNum) -> f
    org.matheclipse.core.expression.ComplexNum tan(org.matheclipse.core.expression.ComplexNum) -> g
    com.google.common.base.Predicate isTrue(org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Predicate isTrue(org.matheclipse.core.eval.EvalEngine,org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Predicate in(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST flatten(org.matheclipse.core.interfaces.IAST) -> a
    boolean flatten(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    boolean flatten(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,int) -> a
    void sort(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST threadList(org.matheclipse.core.interfaces.IAST,int,int) -> b
    boolean convertTerm2Coefficients(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[]) -> a
    org.matheclipse.core.interfaces.IAST quarticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST cubicSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST createSet(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IAST quadraticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST biQuadraticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
cc.redberry.core.math.frobenius.FinalSolutionProvider -> c:
    boolean $assertionsDisabled -> a
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.FrobeniusSolver -> d:
    cc.redberry.concurrent.OutputPortUnsafe provider -> a
    int[] take() -> a
    boolean assertEq(int[]) -> a
    java.lang.Object take() -> a
    double cosh(double) -> a
    int hash(double) -> a
    double sinh(double) -> b
cc.redberry.core.math.frobenius.SingleSolutionProvider -> e:
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.SolutionProvider -> f:
    boolean tick() -> a
    int[] currentRemainders() -> a
cc.redberry.core.math.frobenius.SolutionProviderAbstract -> g:
    cc.redberry.core.math.frobenius.SolutionProvider provider -> a
    int position -> a
    int[] coefficients -> a
    int[] currentSolution -> b
    int currentCounter -> b
    int[] currentRemainder -> c
    boolean tick() -> a
    int[] currentRemainders() -> a
cc.redberry.core.math.frobenius.TotalSolutionProvider -> h:
    cc.redberry.core.math.frobenius.SolutionProvider[] providers -> a
    boolean inited -> a
    boolean $assertionsDisabled -> b
    java.lang.Object take() -> a
com.google.common.base.Function -> i:
    java.lang.Object apply(java.lang.Object) -> a
com.google.common.base.Joiner -> j:
    java.lang.String separator -> a
    com.google.common.base.Joiner on(java.lang.String) -> a
    com.google.common.base.Joiner useForNull(java.lang.String) -> b
com.google.common.base.Joiner$1 -> k:
    com.google.common.base.Joiner useForNull(java.lang.String) -> b
com.google.common.base.Joiner$MapJoiner -> l:
com.google.common.base.Predicate -> m:
    boolean apply(java.lang.Object) -> a
com.google.common.base.Predicates -> n:
    com.google.common.base.Predicate not(com.google.common.base.Predicate) -> a
    com.google.common.base.Predicate in(java.util.Collection) -> a
com.google.common.base.Predicates$InPredicate -> o:
    java.util.Collection target -> a
    boolean apply(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.base.Predicates$NotPredicate -> p:
    com.google.common.base.Predicate predicate -> a
    boolean apply(java.lang.Object) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.google.common.collect.AbstractIterator -> q:
    int state$1572a20f -> a
    java.lang.Object next -> a
    java.lang.Object computeNext() -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.AbstractIterator$1 -> r:
    int[] $SwitchMap$com$google$common$collect$AbstractIterator$State -> a
com.google.common.collect.AbstractIterator$State -> s:
    int READY$1572a20f -> a
    int NOT_READY$1572a20f -> b
    int DONE$1572a20f -> c
    int FAILED$1572a20f -> d
    int[] $VALUES$12ff0e74 -> a
    int[] values$55dd66eb() -> a
com.google.common.collect.AbstractListMultimap -> t:
    java.util.List createCollection() -> a
    java.util.List get(java.lang.Object) -> a
    boolean put(java.lang.Object,java.lang.Object) -> a
    java.util.Map asMap() -> a
    boolean equals(java.lang.Object) -> equals
    java.util.Collection get(java.lang.Object) -> a
    java.util.Collection createCollection() -> a
com.google.common.collect.AbstractMapBasedMultimap -> u:
    java.util.Map map -> a
    int totalSize -> a
    java.util.Collection createCollection() -> a
    int size() -> a
    boolean put(java.lang.Object,java.lang.Object) -> a
    void clear() -> a
    java.util.Collection get(java.lang.Object) -> a
    java.util.Collection wrapCollection(java.lang.Object,java.util.Collection) -> a
    java.util.List wrapList(java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> a
    java.util.Set createKeySet() -> a
    java.util.Collection values() -> b
    java.util.Collection entries() -> c
    java.util.Iterator entryIterator() -> a
    java.util.Map createAsMap() -> b
    java.util.Map access$000(com.google.common.collect.AbstractMapBasedMultimap) -> a
    java.util.Iterator access$100(com.google.common.collect.AbstractMapBasedMultimap,java.util.Collection) -> a
    int access$210(com.google.common.collect.AbstractMapBasedMultimap) -> a
    int access$208(com.google.common.collect.AbstractMapBasedMultimap) -> b
    int access$212(com.google.common.collect.AbstractMapBasedMultimap,int) -> a
    int access$220(com.google.common.collect.AbstractMapBasedMultimap,int) -> b
    java.util.List access$300(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> a
    int access$400(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object) -> a
com.google.common.collect.AbstractMapBasedMultimap$AsMap -> v:
    java.util.Map submap -> a
    java.util.Set entrySet -> a
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    java.util.Set entrySet() -> entrySet
    boolean containsKey(java.lang.Object) -> containsKey
    java.util.Set keySet() -> keySet
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    void clear() -> clear
    java.lang.Object remove(java.lang.Object) -> remove
    java.lang.Object get(java.lang.Object) -> get
com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapEntries -> w:
    com.google.common.collect.AbstractMapBasedMultimap$AsMap this$1 -> a
    java.util.Map map() -> a
    java.util.Iterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapIterator -> x:
    java.util.Iterator delegateIterator -> a
    java.util.Collection collection -> a
    com.google.common.collect.AbstractMapBasedMultimap$AsMap this$1 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
com.google.common.collect.AbstractMapBasedMultimap$EntryIterator -> y:
    java.util.Iterator keyIterator -> a
    java.lang.Object key -> a
    java.util.Collection collection -> a
    java.util.Iterator valueIterator -> b
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    void findValueIteratorAndKey() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
com.google.common.collect.AbstractMapBasedMultimap$KeySet -> z:
    java.util.Map subMap -> a
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    java.util.Map map() -> a
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
    boolean containsAll(java.util.Collection) -> containsAll
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.google.common.collect.AbstractMapBasedMultimap$KeySet$1 -> A:
    java.util.Map$Entry entry -> a
    java.util.Iterator val$entryIterator -> a
    com.google.common.collect.AbstractMapBasedMultimap$KeySet this$1 -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapBasedMultimap$RandomAccessWrappedList -> B:
com.google.common.collect.AbstractMapBasedMultimap$SortedAsMap -> C:
    java.util.SortedSet sortedKeySet -> a
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.Comparator comparator() -> comparator
    java.lang.Object firstKey() -> firstKey
    java.lang.Object lastKey() -> lastKey
    java.util.SortedMap headMap(java.lang.Object) -> headMap
    java.util.SortedMap subMap(java.lang.Object,java.lang.Object) -> subMap
    java.util.SortedMap tailMap(java.lang.Object) -> tailMap
    java.util.Set keySet() -> keySet
com.google.common.collect.AbstractMapBasedMultimap$SortedKeySet -> D:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.Comparator comparator() -> comparator
    java.lang.Object first() -> first
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.lang.Object last() -> last
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection -> E:
    java.lang.Object key -> a
    java.util.Collection delegate -> a
    com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection ancestor -> a
    java.util.Collection ancestorDelegate -> b
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    void refreshIfEmpty() -> a
    void removeIfEmpty() -> b
    void addToMap() -> c
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    boolean add(java.lang.Object) -> add
    boolean addAll(java.util.Collection) -> addAll
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    void clear() -> clear
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator -> F:
    java.util.Iterator delegateIterator -> a
    java.util.Collection originalDelegate -> a
    com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection this$1 -> a
    void validateIterator() -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapBasedMultimap$WrappedList -> G:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.List getListDelegate() -> a
    boolean addAll(int,java.util.Collection) -> addAll
    java.lang.Object get(int) -> get
    java.lang.Object set(int,java.lang.Object) -> set
    void add(int,java.lang.Object) -> add
    java.lang.Object remove(int) -> remove
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.util.ListIterator listIterator() -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.List subList(int,int) -> subList
com.google.common.collect.AbstractMapBasedMultimap$WrappedList$WrappedListIterator -> H:
    com.google.common.collect.AbstractMapBasedMultimap$WrappedList this$1 -> a
    java.util.ListIterator getDelegateListIterator() -> a
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
    void set(java.lang.Object) -> set
    void add(java.lang.Object) -> add
com.google.common.collect.AbstractMapBasedMultimap$WrappedSet -> I:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    boolean removeAll(java.util.Collection) -> removeAll
com.google.common.collect.AbstractMapBasedMultimap$WrappedSortedSet -> J:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.SortedSet getSortedSetDelegate() -> a
    java.util.Comparator comparator() -> comparator
    java.lang.Object first() -> first
    java.lang.Object last() -> last
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
com.google.common.collect.AbstractMapEntry -> K:
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.AbstractMultimap -> L:
    java.util.Collection entries -> a
    java.util.Set keySet -> a
    java.util.Collection values -> b
    java.util.Map asMap -> a
    boolean containsValue(java.lang.Object) -> a
    boolean containsEntry(java.lang.Object,java.lang.Object) -> b
    boolean remove(java.lang.Object,java.lang.Object) -> c
    boolean put(java.lang.Object,java.lang.Object) -> a
    java.util.Collection entries() -> c
    java.util.Iterator entryIterator() -> a
    java.util.Set keySet() -> b
    java.util.Set createKeySet() -> a
    java.util.Collection values() -> b
    java.util.Map asMap() -> a
    java.util.Map createAsMap() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.AbstractMultimap$1 -> M:
    com.google.common.collect.AbstractMultimap this$0 -> a
    com.google.common.collect.Multimap multimap() -> a
    java.util.Iterator iterator() -> iterator
com.google.common.collect.AbstractMultimap$2 -> N:
    com.google.common.collect.AbstractMultimap this$0 -> a
    com.google.common.collect.Multimap multimap() -> a
    java.util.Iterator iterator() -> iterator
com.google.common.collect.AbstractMultimap$3 -> O:
    com.google.common.collect.AbstractMultimap this$0 -> a
    java.util.Map map() -> a
com.google.common.collect.ArrayListMultimap -> P:
    int expectedValuesPerKey -> a
    com.google.common.collect.ArrayListMultimap create() -> a
    java.util.List createCollection() -> a
    boolean equals(java.lang.Object) -> equals
    java.util.Map asMap() -> a
    boolean put(java.lang.Object,java.lang.Object) -> a
    java.util.List get(java.lang.Object) -> a
    java.util.Collection entries() -> c
    java.util.Collection values() -> b
    void clear() -> a
    int size() -> a
    java.util.Collection createCollection() -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    java.util.Set keySet() -> b
    boolean remove(java.lang.Object,java.lang.Object) -> c
    boolean containsEntry(java.lang.Object,java.lang.Object) -> b
    boolean containsValue(java.lang.Object) -> a
com.google.common.collect.Collections2 -> Q:
    com.google.common.base.Joiner STANDARD_JOINER -> a
    boolean safeContains(java.util.Collection,java.lang.Object) -> a
    java.util.Collection cast(java.lang.Iterable) -> a
com.google.common.collect.ImmutableEntry -> R:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
com.google.common.collect.Iterators -> S:
    com.google.common.collect.UnmodifiableListIterator EMPTY_LIST_ITERATOR -> a
    java.util.Iterator EMPTY_MODIFIABLE_ITERATOR -> a
    com.google.common.collect.UnmodifiableIterator emptyIterator() -> a
    java.util.Iterator emptyModifiableIterator() -> a
    com.google.common.collect.UnmodifiableIterator unmodifiableIterator(java.util.Iterator) -> a
    int size(java.util.Iterator) -> a
    java.util.Iterator concat(java.util.Iterator,java.util.Iterator) -> a
    com.google.common.collect.UnmodifiableIterator filter(java.util.Iterator,com.google.common.base.Predicate) -> a
    void clear(java.util.Iterator) -> a
    void checkRemove(boolean) -> a
com.google.common.collect.Iterators$1 -> T:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
com.google.common.collect.Iterators$2 -> U:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.Iterators$3 -> V:
    java.util.Iterator val$iterator -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.Iterators$5 -> W:
    java.util.Iterator current -> a
    java.util.Iterator removeFrom -> b
    java.util.Iterator val$inputs -> c
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.Iterators$7 -> X:
    java.util.Iterator val$unfiltered -> a
    com.google.common.base.Predicate val$predicate -> a
    java.lang.Object computeNext() -> a
com.google.common.collect.ListMultimap -> Y:
com.google.common.collect.Maps -> Z:
    int capacity(int) -> a
    java.util.Map$Entry immutableEntry(java.lang.Object,java.lang.Object) -> a
    java.lang.Object safeGet(java.util.Map,java.lang.Object) -> a
    boolean safeContainsKey(java.util.Map,java.lang.Object) -> a
    java.lang.Object safeRemove(java.util.Map,java.lang.Object) -> b
    java.util.Iterator keyIterator(java.util.Iterator) -> a
    java.util.Iterator valueIterator(java.util.Iterator) -> b
com.google.common.collect.Maps$7 -> aa:
    java.lang.Object transform(java.lang.Object) -> a
com.google.common.collect.Maps$8 -> ab:
    java.lang.Object transform(java.lang.Object) -> a
com.google.common.collect.Maps$EntrySet -> ac:
    java.util.Map map() -> a
    int size() -> size
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean isEmpty() -> isEmpty
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.Maps$KeySet -> ad:
    java.util.Map map() -> a
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
com.google.common.collect.Multimap -> ae:
    int size() -> a
    boolean containsValue(java.lang.Object) -> a
    boolean containsEntry(java.lang.Object,java.lang.Object) -> b
    boolean remove(java.lang.Object,java.lang.Object) -> c
    void clear() -> a
    java.util.Collection get(java.lang.Object) -> a
    java.util.Collection entries() -> c
    java.util.Map asMap() -> a
com.google.common.collect.Multimaps$Entries -> af:
    com.google.common.collect.Multimap multimap() -> a
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
com.google.common.collect.Multimaps$EntrySet -> ag:
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.google.common.collect.Multimaps$Values -> ah:
    com.google.common.collect.Multimap multimap -> a
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    void clear() -> clear
com.google.common.collect.Multiset -> ai:
    java.util.Set elementSet() -> a
com.google.common.collect.SetMultimap -> aj:
com.google.common.collect.Sets$1 -> ak:
    java.util.Set val$set1 -> a
    java.util.Set val$set2minus1 -> b
    java.util.Set val$set2 -> c
    int size() -> size
    boolean isEmpty() -> isEmpty
    java.util.Iterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
com.google.common.collect.Sets$2 -> al:
    java.util.Set val$set1 -> a
    com.google.common.base.Predicate val$inSet2 -> a
    java.util.Set val$set2 -> b
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
com.google.common.collect.Sets$3 -> am:
    java.util.Set val$set1 -> a
    com.google.common.base.Predicate val$notInSet2 -> a
    java.util.Set val$set2 -> b
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
com.google.common.collect.Sets$ImprovedAbstractSet -> an:
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.Sets$SetView -> ao:
com.google.common.collect.TransformedIterator -> ap:
    java.util.Iterator backingIterator -> a
    java.lang.Object transform(java.lang.Object) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.UnmodifiableIterator -> aq:
    void remove() -> remove
com.google.common.collect.UnmodifiableListIterator -> ar:
    void add(java.lang.Object) -> add
    void set(java.lang.Object) -> set
com.google.common.math.BigIntegerMath -> as:
    java.math.BigInteger SQRT2_PRECOMPUTED_BITS -> a
    boolean isPowerOfTwo(java.math.BigInteger) -> a
    java.math.BigInteger sqrt(java.math.BigInteger,java.math.RoundingMode) -> a
    java.math.BigInteger sqrtFloor(java.math.BigInteger) -> a
    java.math.BigInteger sqrtApproxWithDoubles(java.math.BigInteger) -> b
    java.math.BigInteger factorial(int) -> a
    java.math.BigInteger listProduct(java.util.List,int,int) -> a
    java.math.BigInteger binomial(int,int) -> a
com.google.common.math.BigIntegerMath$1 -> at:
    int[] $SwitchMap$java$math$RoundingMode -> a
com.google.common.math.DoubleMath -> au:
    double roundIntermediate(double,java.math.RoundingMode) -> a
    int roundToInt(double,java.math.RoundingMode) -> a
    long roundToLong(double,java.math.RoundingMode) -> a
    java.math.BigInteger roundToBigInteger(double,java.math.RoundingMode) -> a
    boolean isMathematicalInteger(double) -> a
com.google.common.math.DoubleMath$1 -> av:
    int[] $SwitchMap$java$math$RoundingMode -> a
com.google.common.math.DoubleUtils -> aw:
    long getSignificand(double) -> a
    boolean isFinite(double) -> a
    double bigToDouble(java.math.BigInteger) -> a
com.google.common.math.IntMath -> ax:
    int log2(int,java.math.RoundingMode) -> a
    int sqrt(int,java.math.RoundingMode) -> b
    int divide(int,int,java.math.RoundingMode) -> a
com.google.common.math.IntMath$1 -> ay:
    int[] $SwitchMap$java$math$RoundingMode -> a
com.google.common.math.LongMath -> az:
    long[] factorials -> a
    int[] biggestBinomials -> a
    int[] biggestSimpleBinomials -> b
    int log2(long,java.math.RoundingMode) -> a
    long sqrt(long,java.math.RoundingMode) -> a
    long binomial(int,int) -> a
    long multiplyFraction(long,long,long) -> a
com.google.common.math.LongMath$1 -> aA:
    int[] $SwitchMap$java$math$RoundingMode -> a
edu.jas.arith.BigComplex -> aB:
    edu.jas.arith.BigRational re -> a
    edu.jas.arith.BigRational im -> b
    org.apache.log4j.Logger logger -> a
    edu.jas.arith.BigComplex ZERO -> a
    edu.jas.arith.BigComplex ONE -> b
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.arith.BigComplex) -> a
    int signum() -> a
    edu.jas.arith.BigComplex norm() -> a
    edu.jas.arith.BigComplex multiply(edu.jas.arith.BigComplex) -> b
    edu.jas.arith.BigComplex inverse() -> b
    edu.jas.arith.BigComplex divide(edu.jas.arith.BigComplex) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.BigDecimal -> aC:
    java.math.BigDecimal val -> a
    java.math.MathContext DEFAULT_CONTEXT -> a
    java.math.MathContext context -> b
    edu.jas.arith.BigDecimal ZERO -> a
    edu.jas.arith.BigDecimal ONE -> b
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.arith.BigDecimal) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int signum() -> a
    edu.jas.arith.BigDecimal divide(edu.jas.arith.BigDecimal) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.BigInteger -> aD:
    java.math.BigInteger val -> a
    edu.jas.arith.BigInteger ZERO -> a
    edu.jas.arith.BigInteger ONE -> b
    boolean nonNegative -> a
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.arith.BigInteger valueOf(java.math.BigInteger) -> a
    edu.jas.arith.BigInteger fromInteger(long) -> a
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.arith.BigInteger) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.BigInteger abs() -> a
    edu.jas.arith.BigInteger negate() -> b
    int signum() -> a
    edu.jas.arith.BigInteger subtract(edu.jas.arith.BigInteger) -> a
    edu.jas.arith.BigInteger divide(edu.jas.arith.BigInteger) -> b
    edu.jas.arith.BigInteger remainder(edu.jas.arith.BigInteger) -> c
    edu.jas.arith.BigInteger gcd(edu.jas.arith.BigInteger) -> d
    edu.jas.arith.BigInteger multiply(edu.jas.arith.BigInteger) -> e
    edu.jas.arith.BigRational getRational() -> a
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.BigIntegerIterator -> aE:
    java.math.BigInteger curr -> a
    boolean nonNegative -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.BigInteger next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.BigRational -> aF:
    java.math.BigInteger num -> a
    java.math.BigInteger den -> b
    edu.jas.arith.BigRational ZERO -> a
    edu.jas.arith.BigRational ONE -> b
    boolean nonNegative -> a
    boolean duplicates -> b
    boolean isFinite() -> a
    edu.jas.arith.BigRational getRational() -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.arith.BigRational valueOf(java.math.BigInteger) -> a
    edu.jas.arith.BigRational valueOf(long) -> a
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.BigRational RNRED(java.math.BigInteger,java.math.BigInteger) -> b
    edu.jas.arith.BigRational reduction(java.math.BigInteger,java.math.BigInteger) -> a
    int compareTo(edu.jas.arith.BigRational) -> a
    edu.jas.arith.BigRational subtract(edu.jas.arith.BigRational) -> a
    edu.jas.arith.BigRational inverse() -> b
    edu.jas.arith.BigRational negate() -> c
    edu.jas.arith.BigRational multiply(edu.jas.arith.BigRational) -> b
    edu.jas.arith.BigRational divide(edu.jas.arith.BigRational) -> c
    edu.jas.arith.BigRational random(int,java.util.Random) -> a
    int signum() -> a
    edu.jas.arith.BigRational sum(edu.jas.arith.BigRational) -> d
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.BigRational$1 -> aG:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.arith.BigRationalIterator -> aH:
    edu.jas.arith.BigRational curr -> a
    edu.jas.arith.BigInteger den -> a
    edu.jas.arith.BigInteger num -> b
    java.util.Iterator denit -> a
    java.util.Iterator numit -> b
    java.util.List denlist -> a
    java.util.List numlist -> b
    java.util.Iterator denlistit -> c
    java.util.Iterator numlistit -> d
    boolean nonNegative -> a
    long level -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.BigRational next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.BigRationalUniqueIterator -> aI:
    java.util.Set unique -> a
    java.util.Iterator ratit -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.BigRational next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModInteger -> aJ:
    edu.jas.arith.ModIntegerRing ring -> a
    java.math.BigInteger val -> a
    edu.jas.arith.BigInteger getSymmetricInteger() -> a
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.arith.ModInteger) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int signum() -> a
    edu.jas.arith.ModInteger subtract(edu.jas.arith.ModInteger) -> a
    edu.jas.arith.ModInteger divide(edu.jas.arith.ModInteger) -> c
    edu.jas.arith.ModInteger inverse() -> a
    edu.jas.arith.ModInteger multiply(edu.jas.arith.ModInteger) -> b
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.arith.ModIntegerIterator -> aK:
    java.math.BigInteger curr -> a
    edu.jas.arith.ModIntegerRing ring -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.ModInteger next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModIntegerRing -> aL:
    java.math.BigInteger modul -> a
    int isField -> a
    edu.jas.arith.BigInteger getIntegerModul() -> a
    edu.jas.arith.ModInteger getZERO() -> a
    edu.jas.arith.ModInteger getONE() -> b
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.arith.ModInteger fromInteger(java.math.BigInteger) -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.ModLong -> aM:
    edu.jas.arith.ModLongRing ring -> a
    long val -> a
    edu.jas.arith.BigInteger getSymmetricInteger() -> a
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.arith.ModLong) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int signum() -> a
    edu.jas.arith.ModLong subtract(edu.jas.arith.ModLong) -> a
    edu.jas.arith.ModLong divide(edu.jas.arith.ModLong) -> c
    edu.jas.arith.ModLong inverse() -> a
    edu.jas.arith.ModLong multiply(edu.jas.arith.ModLong) -> b
    long gcd(long,long) -> a
    long[] hegcd(long,long) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.arith.ModLongIterator -> aN:
    long curr -> a
    edu.jas.arith.ModLongRing ring -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.ModLong next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModLongRing -> aO:
    long modul -> a
    int isField -> a
    java.math.BigInteger MAX_LONG -> a
    edu.jas.arith.BigInteger getIntegerModul() -> a
    edu.jas.arith.ModLong getZERO() -> a
    edu.jas.arith.ModLong getONE() -> b
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.arith.ModLong fromInteger(long) -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.Modular -> aP:
    edu.jas.arith.BigInteger getSymmetricInteger() -> a
edu.jas.arith.ModularNotInvertibleException -> aQ:
    edu.jas.structure.GcdRingElem f -> a
    edu.jas.structure.GcdRingElem f1 -> b
    edu.jas.structure.GcdRingElem f2 -> c
    java.lang.String toString() -> toString
edu.jas.arith.ModularRingFactory -> aR:
    edu.jas.arith.BigInteger getIntegerModul() -> a
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
edu.jas.arith.PrimeList -> aS:
    java.util.List SMALL_LIST -> a
    java.util.List LOW_LIST -> b
    java.util.List MEDIUM_LIST -> c
    java.util.List LARGE_LIST -> d
    java.util.List MERSENNE_LIST -> e
    java.util.List val -> f
    java.math.BigInteger last -> a
    java.math.BigInteger getLongPrime(int,int) -> a
    java.math.BigInteger getMersennePrime(int) -> b
    java.lang.String toString() -> toString
    int size() -> a
    java.math.BigInteger get(int) -> a
    java.util.Iterator iterator() -> iterator
edu.jas.arith.PrimeList$1 -> aT:
    int index -> a
    edu.jas.arith.PrimeList this$0 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.PrimeList$2 -> aU:
    int[] $SwitchMap$edu$jas$arith$PrimeList$Range -> a
edu.jas.arith.PrimeList$Range -> aV:
    int small$2289dd20 -> a
    int low$2289dd20 -> b
    int medium$2289dd20 -> c
    int large$2289dd20 -> d
    int mersenne$2289dd20 -> e
    int[] $VALUES$744f6e9b -> a
    int[] values$40345266() -> a
edu.jas.arith.Rational -> aW:
    edu.jas.arith.BigRational getRational() -> a
edu.jas.gb.AbstractPair -> aX:
    edu.jas.poly.ExpVector e -> a
    edu.jas.poly.GenPolynomial pi -> a
    edu.jas.poly.GenPolynomial pj -> b
    int i -> a
    int j -> b
    int s -> c
    void maxIndex(int) -> a
    java.lang.String toString() -> toString
edu.jas.gb.GroebnerBase -> aY:
    java.util.List GB(int,java.util.List) -> a
edu.jas.gb.GroebnerBaseAbstract -> aZ:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.gb.Reduction red -> a
    edu.jas.gb.PairList strategy -> a
    java.lang.String toString() -> toString
    int commonZeroTest(java.util.List) -> a
    java.util.List minimalGB(java.util.List) -> a
edu.jas.gb.GroebnerBaseSeq -> ba:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.util.List GB(int,java.util.List) -> a
edu.jas.gb.OrderedPairlist -> bb:
    java.util.List P -> a
    java.util.SortedMap pairlist -> a
    java.util.List red -> b
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.gb.Reduction reduction -> a
    boolean oneInGB -> a
    boolean useCriterion4 -> b
    int putCount -> a
    int remCount -> b
    int moduleVars -> c
    org.apache.log4j.Logger logger -> a
    edu.jas.gb.PairList create(int,edu.jas.poly.GenPolynomialRing) -> a
    java.lang.String toString() -> toString
    int put(edu.jas.poly.GenPolynomial) -> a
    edu.jas.gb.Pair removeNext() -> a
    boolean hasNext() -> a
    int putOne() -> a
    boolean criterion3(int,int,edu.jas.poly.ExpVector) -> a
edu.jas.gb.Pair -> bc:
    int n -> c
    boolean toZero -> a
    boolean useCriterion4 -> b
    boolean useCriterion3 -> c
    java.lang.String toString() -> toString
    void setZero() -> a
    boolean equals(java.lang.Object) -> equals
    int compareTo(edu.jas.gb.Pair) -> a
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
edu.jas.gb.PairList -> bd:
    edu.jas.gb.PairList create(int,edu.jas.poly.GenPolynomialRing) -> a
    int put(edu.jas.poly.GenPolynomial) -> a
    int putOne() -> a
    edu.jas.gb.Pair removeNext() -> a
    boolean hasNext() -> a
edu.jas.gb.Reduction -> be:
    edu.jas.poly.GenPolynomial SPolynomial(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    boolean moduleCriterion(int,edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    boolean criterion4(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> a
    boolean isTopReducible(java.util.List,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> a
    java.util.List irreducibleSet(java.util.List) -> a
edu.jas.gb.ReductionAbstract -> bf:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial SPolynomial(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    boolean moduleCriterion(int,edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    boolean criterion4(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> a
    boolean isTopReducible(java.util.List,edu.jas.poly.GenPolynomial) -> a
    java.util.List irreducibleSet(java.util.List) -> a
edu.jas.gb.ReductionSeq -> bg:
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> a
edu.jas.gbufd.GroebnerBasePartial -> bh:
    org.apache.log4j.Logger logger -> a
    edu.jas.gb.GroebnerBaseAbstract bb -> a
    edu.jas.gb.GroebnerBaseAbstract rbb -> b
    java.util.List GB(int,java.util.List) -> a
    java.util.List partialPermutation(java.lang.String[],java.lang.String[]) -> a
    java.util.List getPermutation(java.lang.String[],java.lang.String[]) -> b
    int indexOf(java.lang.String,java.lang.String[]) -> a
    java.lang.String[] remainingVars(java.lang.String[],java.lang.String[]) -> a
    edu.jas.poly.OptimizedPolynomialList partialGB(java.util.List,java.lang.String[]) -> a
edu.jas.gbufd.GroebnerBasePseudoRecSeq -> bi:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> a
    edu.jas.gb.Reduction red$d5bfccb -> b
    edu.jas.structure.AbelianGroupFactory cofac$5b76095 -> a
    edu.jas.structure.AbelianGroupFactory baseCofac$5b76095 -> b
    java.util.List GB(int,java.util.List) -> a
    java.util.List minimalGB(java.util.List) -> a
edu.jas.gbufd.PseudoReductionSeq -> bj:
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> a
edu.jas.kern.ComputerThreads -> bk:
    boolean NO_THREADS -> a
    int N_CPUS -> a
    java.util.concurrent.ExecutorService pool -> a
    java.util.concurrent.ExecutorService getPool() -> a
edu.jas.kern.PreemptStatus -> bl:
    boolean allowPreempt -> a
    boolean isAllowed() -> a
edu.jas.kern.PreemptingException -> bm:
edu.jas.kern.PrettyPrint -> bn:
    boolean toDo -> a
    boolean isTrue() -> a
edu.jas.kern.Scripting -> bo:
    int script$36effdbf -> a
    int getLang$69093ba2() -> a
edu.jas.kern.Scripting$Lang -> bp:
    int Python$36effdbf -> a
    int Ruby$36effdbf -> b
    int[] $VALUES$7450ff44 -> a
    int[] values$15230c85() -> a
edu.jas.kern.TimeStatus -> bq:
    boolean allowTime -> a
    long limitTime -> a
    long startTime -> b
    java.util.concurrent.Callable callBack -> a
    void checkTime(java.lang.String) -> a
edu.jas.poly.AlgToPoly -> br:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.AlgebToCompl -> bs:
    edu.jas.poly.ComplexRing cfac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.AlgebraicNotInvertibleException -> bt:
    edu.jas.poly.GenPolynomial f -> a
    edu.jas.poly.GenPolynomial f1 -> b
    edu.jas.poly.GenPolynomial f2 -> c
    java.lang.String toString() -> toString
edu.jas.poly.AlgebraicNumber -> bu:
    edu.jas.poly.AlgebraicNumberRing ring -> a
    edu.jas.poly.GenPolynomial val -> a
    int isunit -> a
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.poly.AlgebraicNumber) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int signum() -> a
    edu.jas.poly.AlgebraicNumber inverse() -> a
    edu.jas.poly.AlgebraicNumber multiply(edu.jas.poly.AlgebraicNumber) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.poly.AlgebraicNumberIterator -> bv:
    java.util.Iterator iter -> a
    java.util.List powers -> a
    edu.jas.poly.AlgebraicNumberRing aring -> a
    org.apache.log4j.Logger logger -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.AlgebraicNumberRing -> bw:
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.poly.GenPolynomial modul -> a
    int isField -> a
    edu.jas.poly.AlgebraicNumber getZERO() -> a
    edu.jas.poly.AlgebraicNumber getONE() -> b
    edu.jas.poly.AlgebraicNumber getGenerator() -> c
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    void setField(boolean) -> a
    int getField() -> a
    java.math.BigInteger characteristic() -> a
    edu.jas.poly.AlgebraicNumber fromInteger(long) -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    long totalExtensionDegree() -> a
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.AlgebraicNumberRing$1 -> bx:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.poly.AnyToComplex -> by:
    edu.jas.poly.ComplexRing cfac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.CoeffToAlg -> bz:
    edu.jas.poly.AlgebraicNumberRing afac -> a
    edu.jas.poly.GenPolynomial zero -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.ComplToAlgeb -> bA:
    edu.jas.poly.AlgebraicNumberRing afac -> a
    edu.jas.poly.AlgebraicNumber I -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.Complex -> bB:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.ComplexRing ring -> a
    edu.jas.structure.RingElem re -> a
    edu.jas.structure.RingElem im -> b
    edu.jas.structure.RingElem getRe() -> a
    edu.jas.structure.RingElem getIm() -> b
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isIMAG() -> a
    boolean isUnit() -> f
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.poly.Complex) -> a
    int signum() -> a
    edu.jas.poly.Complex sum(edu.jas.poly.Complex) -> a
    edu.jas.poly.Complex subtract(edu.jas.poly.Complex) -> b
    edu.jas.poly.Complex negate() -> b
    edu.jas.poly.Complex norm() -> a
    edu.jas.poly.Complex multiply(edu.jas.poly.Complex) -> c
    edu.jas.poly.Complex inverse() -> c
    edu.jas.poly.Complex divide(edu.jas.poly.Complex) -> d
    edu.jas.poly.Complex[] quotientRemainder(edu.jas.poly.Complex) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.poly.ComplexRing -> bC:
    edu.jas.structure.AbelianGroupFactory ring$5b76095 -> a
    boolean isFinite() -> a
    edu.jas.poly.Complex getZERO() -> a
    edu.jas.poly.Complex getONE() -> b
    edu.jas.poly.Complex getIMAG() -> c
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.poly.Complex fromInteger(long) -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.DistToRec -> bD:
    edu.jas.poly.GenPolynomialRing fac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.EvalMain -> bE:
    edu.jas.structure.AbelianGroupFactory cfac$5b76095 -> a
    edu.jas.structure.RingElem a -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.EvalMainPol -> bF:
    edu.jas.poly.GenPolynomialRing cfac -> a
    edu.jas.structure.RingElem a -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.ExpVector -> bG:
    int hash -> a
    int storunit$4c0a7abc -> b
    edu.jas.poly.ExpVector create(int) -> a
    edu.jas.poly.ExpVector create(int,int,long) -> a
    edu.jas.poly.ExpVector create(long[]) -> a
    edu.jas.poly.ExpVector create(java.util.Collection) -> a
    edu.jas.poly.ExpVector copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> b
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> a
    java.lang.String varsToString(java.lang.String[]) -> b
    java.lang.String toScript() -> a
    java.lang.String toScript(java.lang.String[]) -> c
    java.lang.String toScriptFactory() -> b
    int indexVar(java.lang.String,java.lang.String[]) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isZERO() -> d
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector EVRAND(int,long,float,java.util.Random) -> a
    int signum() -> a
    long totalDeg() -> a
    long maxDeg() -> b
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int EVILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int EVILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int EVIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> b
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int EVIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> b
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int EVRILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> c
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int EVRILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> c
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int EVRIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> d
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int EVRIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> d
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int EVIWLC(long[][],edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVector$1 -> bH:
    int[] $SwitchMap$edu$jas$poly$ExpVector$StorUnit -> a
edu.jas.poly.ExpVector$StorUnit -> bI:
    int LONG$4c0a7abc -> a
    int INT$4c0a7abc -> b
    int SHORT$4c0a7abc -> c
    int BYTE$4c0a7abc -> d
    int[] $VALUES$6e403c49 -> a
    int[] values$10d7c10a() -> a
edu.jas.poly.ExpVectorByte -> bJ:
    byte[] val -> a
    edu.jas.poly.ExpVectorByte copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorByte abs() -> b
    edu.jas.poly.ExpVectorByte negate() -> c
    edu.jas.poly.ExpVectorByte sum(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVectorByte subtract(edu.jas.poly.ExpVector) -> b
    int signum() -> a
    long totalDeg() -> a
    long maxDeg() -> b
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector copy() -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorInteger -> bK:
    int[] val -> a
    edu.jas.poly.ExpVectorInteger copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorInteger abs() -> b
    edu.jas.poly.ExpVectorInteger negate() -> c
    edu.jas.poly.ExpVectorInteger sum(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVectorInteger subtract(edu.jas.poly.ExpVector) -> b
    int signum() -> a
    long totalDeg() -> a
    long maxDeg() -> b
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector copy() -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorLong -> bL:
    long[] val -> a
    edu.jas.poly.ExpVectorLong copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorLong abs() -> b
    edu.jas.poly.ExpVectorLong negate() -> c
    edu.jas.poly.ExpVectorLong sum(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVectorLong subtract(edu.jas.poly.ExpVector) -> b
    int signum() -> a
    long totalDeg() -> a
    long maxDeg() -> b
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector copy() -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorPair -> bM:
    edu.jas.poly.ExpVector e1 -> a
    edu.jas.poly.ExpVector e2 -> b
    long totalDeg() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isMultiple(edu.jas.poly.ExpVectorPair) -> a
edu.jas.poly.ExpVectorShort -> bN:
    short[] val -> a
    edu.jas.poly.ExpVectorShort copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorShort abs() -> b
    edu.jas.poly.ExpVectorShort negate() -> c
    edu.jas.poly.ExpVectorShort sum(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVectorShort subtract(edu.jas.poly.ExpVector) -> b
    int signum() -> a
    long totalDeg() -> a
    long maxDeg() -> b
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector copy() -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.FromInteger -> bO:
    edu.jas.structure.AbelianGroupFactory ring$5b76095 -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.FromIntegerPoly -> bP:
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.poly.FromInteger fi -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.GenPolynomial -> bQ:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.SortedMap val -> a
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    edu.jas.poly.GenPolynomialRing factory() -> a
    edu.jas.poly.GenPolynomial copy() -> a
    int length() -> b
    java.util.SortedMap getMap() -> a
    void doPutToMap(edu.jas.poly.ExpVector,edu.jas.structure.RingElem) -> a
    void doRemoveFromMap(edu.jas.poly.ExpVector,edu.jas.structure.RingElem) -> b
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> a
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    boolean isConstant() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.poly.GenPolynomial) -> a
    int signum() -> a
    java.util.Map$Entry leadingMonomial() -> a
    edu.jas.poly.ExpVector leadingExpVector() -> a
    edu.jas.poly.ExpVector trailingExpVector() -> b
    edu.jas.structure.RingElem leadingBaseCoefficient() -> a
    edu.jas.structure.RingElem trailingBaseCoefficient() -> b
    edu.jas.structure.RingElem coefficient(edu.jas.poly.ExpVector) -> a
    long degree(int) -> a
    long degree() -> a
    edu.jas.poly.ExpVector degreeVector() -> c
    edu.jas.structure.RingElem maxNorm() -> c
    edu.jas.structure.RingElem sumNorm() -> d
    edu.jas.poly.GenPolynomial sum(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial sum(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial sum(edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial subtract(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial subtract(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> b
    edu.jas.poly.GenPolynomial subtract(edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenPolynomial subtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial negate() -> b
    edu.jas.poly.GenPolynomial abs() -> c
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem) -> c
    edu.jas.poly.GenPolynomial monic() -> d
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> c
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial divide(edu.jas.structure.RingElem) -> d
    edu.jas.poly.GenPolynomial[] quotientRemainder(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial remainder(edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial[] egcd(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial[] hegcd(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial extend(edu.jas.poly.GenPolynomialRing,int,long) -> a
    edu.jas.poly.GenPolynomial extendLower(edu.jas.poly.GenPolynomialRing,int,long) -> b
    java.util.Map contract(edu.jas.poly.GenPolynomialRing) -> a
    java.util.Iterator coefficientIterator() -> a
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.poly.GenPolynomialIterator -> bR:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.Iterator eviter -> a
    java.util.List powers -> a
    java.util.List coeffiter -> b
    java.util.Iterator itercoeff -> b
    edu.jas.poly.GenPolynomial current -> a
    boolean hasNext() -> hasNext
    edu.jas.poly.GenPolynomial next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.GenPolynomialMonomialIterator -> bS:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.Iterator iter -> a
    edu.jas.poly.GenPolynomial current -> a
    boolean hasNext() -> hasNext
    edu.jas.poly.GenPolynomial next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.GenPolynomialRing -> bT:
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    int nvar -> a
    edu.jas.poly.TermOrder tord -> a
    java.lang.String[] vars -> a
    java.util.Set knownVars -> a
    edu.jas.poly.GenPolynomial ZERO -> a
    edu.jas.poly.GenPolynomial ONE -> b
    edu.jas.poly.ExpVector evzero -> a
    java.util.Random random -> a
    int isField -> b
    org.apache.log4j.Logger logger -> a
    boolean checkPreempt -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String[] getVars() -> a
    java.lang.String[] setVars(java.lang.String[]) -> a
    java.lang.String varsToString() -> b
    edu.jas.structure.RingElem getZEROCoefficient() -> a
    edu.jas.structure.RingElem getONECoefficient() -> b
    edu.jas.poly.GenPolynomial getZERO() -> a
    edu.jas.poly.GenPolynomial getONE() -> b
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.poly.GenPolynomial valueOf(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial fromInteger(long) -> a
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenPolynomial univariate(int) -> a
    edu.jas.poly.GenPolynomial univariate(int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> a
    boolean isFinite() -> a
    java.util.List univariateList() -> a
    java.util.List univariateList(int,long) -> a
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenPolynomialRing contract(int) -> a
    edu.jas.poly.GenPolynomialRing recursive(int) -> b
    edu.jas.poly.PolynomialComparator getComparator() -> a
    java.lang.String[] newVars(java.lang.String,int) -> a
    void addVars(java.lang.String[]) -> a
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.GenPolynomialRing$1 -> bU:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.poly.GenPolynomialTokenizer -> bV:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.lang.String[] vars -> a
    int nvars -> a
    edu.jas.poly.TermOrder tord -> a
    java.io.StreamTokenizer tok -> a
    java.io.Reader reader -> a
    edu.jas.structure.AbelianGroupFactory fac$5b76095 -> a
    edu.jas.poly.GenPolynomialRing pfac -> a
    edu.jas.poly.GenSolvablePolynomialRing spfac -> a
    edu.jas.poly.GenPolynomial nextPolynomial() -> a
    long nextExponent() -> a
    edu.jas.poly.GenSolvablePolynomial nextSolvablePolynomial() -> a
    boolean digit(char) -> a
edu.jas.poly.GenSolvablePolynomial -> bW:
    edu.jas.poly.GenSolvablePolynomialRing ring -> a
    org.apache.log4j.Logger logger -> a
    boolean $assertionsDisabled -> a
    edu.jas.poly.GenSolvablePolynomialRing factory() -> a
    edu.jas.poly.GenSolvablePolynomial copy() -> a
    boolean equals(java.lang.Object) -> equals
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.GenSolvablePolynomial) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> b
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenSolvablePolynomial monic() -> b
    edu.jas.poly.GenSolvablePolynomial[] quotientRemainder(edu.jas.poly.GenSolvablePolynomial) -> a
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> c
    edu.jas.poly.GenPolynomial monic() -> d
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem) -> c
    edu.jas.poly.GenPolynomial copy() -> a
    edu.jas.poly.GenPolynomialRing factory() -> a
    edu.jas.structure.ElemFactory factory() -> a
edu.jas.poly.GenSolvablePolynomialRing -> bX:
    edu.jas.poly.RelationTable table -> a
    edu.jas.poly.GenSolvablePolynomial ZERO -> a
    edu.jas.poly.GenSolvablePolynomial ONE -> b
    org.apache.log4j.Logger logger -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.GenSolvablePolynomial getZERO() -> a
    edu.jas.poly.GenSolvablePolynomial getONE() -> b
    boolean isCommutative() -> b
    edu.jas.poly.GenSolvablePolynomial fromInteger(long) -> a
    edu.jas.poly.GenSolvablePolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenSolvablePolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenSolvablePolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int,long) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int,int,long) -> a
    java.util.List univariateList() -> a
    java.util.List univariateList(int,long) -> a
    edu.jas.poly.GenSolvablePolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenSolvablePolynomialRing contract(int) -> a
    edu.jas.poly.GenPolynomialRing recursive(int) -> b
    edu.jas.poly.GenPolynomialRing contract(int) -> a
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int) -> a
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenPolynomial fromInteger(long) -> a
    edu.jas.poly.GenPolynomial getONE() -> b
    edu.jas.poly.GenPolynomial getZERO() -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.GenSolvablePolynomialRing$1 -> bY:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.poly.ImagPartComplex -> bZ:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.InvalidExpressionException -> ca:
edu.jas.poly.ModSymToInt -> cb:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.Monomial -> cc:
    edu.jas.poly.ExpVector e -> a
    edu.jas.structure.RingElem c -> a
    java.lang.String toString() -> toString
edu.jas.poly.OptimizedPolynomialList -> cd:
    java.util.List perm -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
edu.jas.poly.OrderedPolynomialList -> ce:
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.List sort(edu.jas.poly.GenPolynomialRing,java.util.List) -> a
edu.jas.poly.OrderedPolynomialList$1 -> cf:
    java.util.Comparator val$evc -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.PolyIterator -> cg:
    java.util.Iterator ms -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.PolyUtil -> ch:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    edu.jas.poly.GenPolynomial recursive(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial distribute(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> b
    java.util.List recursive(edu.jas.poly.GenPolynomialRing,java.util.List) -> a
    java.util.List distribute(edu.jas.poly.GenPolynomialRing,java.util.List) -> b
    edu.jas.poly.GenPolynomial integerFromModularCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> c
    java.util.List integerFromModularCoefficients(edu.jas.poly.GenPolynomialRing,java.util.List) -> c
    edu.jas.poly.GenPolynomial integerFromRationalCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> d
    java.lang.Object[] integerFromRationalCoefficientsFactor(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial fromIntegerCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> e
    java.util.List fromIntegerCoefficients(edu.jas.poly.GenPolynomialRing,java.util.List) -> d
    edu.jas.poly.GenPolynomial realPartFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial imaginaryPartFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> g
    edu.jas.poly.GenPolynomial complexFromAny(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> h
    edu.jas.poly.GenPolynomial fromAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> i
    edu.jas.poly.GenPolynomial convertToAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> j
    edu.jas.poly.GenPolynomial complexFromAlgebraic(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> k
    edu.jas.poly.GenPolynomial algebraicFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> l
    edu.jas.poly.GenPolynomial chineseRemainder(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial monic(edu.jas.poly.GenPolynomial) -> a
    java.util.List monic(java.util.List) -> a
    java.util.List leadingExpVector(java.util.List) -> b
    edu.jas.poly.GenPolynomial baseSparsePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial baseDensePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial basePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial[] basePseudoQuotientRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial baseRecursiveDivide(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial recursivePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial recursiveSparsePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial recursiveDensePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> g
    edu.jas.poly.GenPolynomial recursivePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> h
    edu.jas.poly.GenPolynomial coefficientPseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> i
    edu.jas.poly.GenPolynomial coefficientBasePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> c
    edu.jas.poly.GenPolynomial baseDeriviative(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveDeriviative(edu.jas.poly.GenPolynomial) -> c
    edu.jas.arith.BigInteger factorBound(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial evaluateMainRecursive(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenPolynomial evaluateMain(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    java.util.List evaluateMain(edu.jas.poly.GenPolynomialRing,java.util.List,edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem evaluateMain$eff16fa(edu.jas.structure.AbelianGroupFactory,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    java.util.List evaluateMain$444d866c(edu.jas.structure.AbelianGroupFactory,java.util.List,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial evaluateFirstRec(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial substituteMain(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> j
    edu.jas.poly.GenPolynomial substituteUnivariate(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> k
    edu.jas.poly.GenPolynomial seriesOfTaylor(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenPolynomial interpolate(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial interpolate(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial switchVariables(edu.jas.poly.GenPolynomial) -> d
    long coeffMaxDegree(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial map(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.UnaryFunctor) -> a
    edu.jas.poly.GenPolynomial removeUnusedUpperVariables(edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial removeUnusedLowerVariables(edu.jas.poly.GenPolynomial) -> f
edu.jas.poly.PolyUtil$1 -> ci:
    edu.jas.poly.GenPolynomialRing val$fac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolyUtil$2 -> cj:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolyUtil$4 -> ck:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolynomialComparator -> cl:
    edu.jas.poly.TermOrder tord -> a
    boolean reverse -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.PolynomialList -> cm:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.List list -> b
    boolean equals(java.lang.Object) -> equals
    int compareTo(edu.jas.poly.PolynomialList) -> a
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.RatToInt -> cn:
    java.math.BigInteger lcm -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RatToIntFactor -> co:
    java.math.BigInteger lcm -> a
    java.math.BigInteger gcd -> b
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RealPartComplex -> cp:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RecSolvablePolynomial -> cq:
    edu.jas.poly.RecSolvablePolynomialRing ring -> a
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    edu.jas.poly.RecSolvablePolynomial copy() -> a
    boolean equals(java.lang.Object) -> equals
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.RecSolvablePolynomial) -> a
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.RecSolvablePolynomial multiplyLeft(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.RecSolvablePolynomial shift(edu.jas.poly.RecSolvablePolynomial,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> b
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenSolvablePolynomial copy() -> a
    edu.jas.poly.GenSolvablePolynomialRing factory() -> a
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> c
    edu.jas.poly.GenPolynomial copy() -> a
    edu.jas.poly.GenPolynomialRing factory() -> a
    edu.jas.structure.ElemFactory factory() -> a
edu.jas.poly.RecSolvablePolynomialRing -> cr:
    edu.jas.poly.RelationTable coeffTable -> b
    edu.jas.poly.RecSolvablePolynomial ZERO -> a
    edu.jas.poly.RecSolvablePolynomial ONE -> b
    org.apache.log4j.Logger logger -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isCommutative() -> b
    edu.jas.poly.RecSolvablePolynomial fromInteger(long) -> a
    edu.jas.poly.RecSolvablePolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.RecSolvablePolynomial random(int,java.util.Random) -> a
    edu.jas.poly.RecSolvablePolynomial random(int,int,int,float) -> a
    edu.jas.poly.RecSolvablePolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.RecSolvablePolynomial parse(java.lang.String) -> a
    edu.jas.poly.RecSolvablePolynomial parse(java.io.Reader) -> a
    edu.jas.poly.RecSolvablePolynomial univariate(int) -> a
    edu.jas.poly.RecSolvablePolynomial univariate(int,long) -> a
    edu.jas.poly.RecSolvablePolynomial univariate(int,int,long) -> a
    edu.jas.poly.RecSolvablePolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.RecSolvablePolynomialRing contract(int) -> a
    edu.jas.poly.GenSolvablePolynomialRing contract(int) -> a
    edu.jas.poly.GenSolvablePolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int,int,long) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int,long) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int) -> a
    edu.jas.poly.GenSolvablePolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenSolvablePolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenSolvablePolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenSolvablePolynomial fromInteger(long) -> a
    edu.jas.poly.GenSolvablePolynomial getONE() -> b
    edu.jas.poly.GenSolvablePolynomial getZERO() -> a
    edu.jas.poly.GenPolynomialRing contract(int) -> a
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int) -> a
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenPolynomial fromInteger(long) -> a
    edu.jas.poly.GenPolynomial getONE() -> b
    edu.jas.poly.GenPolynomial getZERO() -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.RecSolvablePolynomialRing$1 -> cs:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.poly.RecToDist -> ct:
    edu.jas.poly.GenPolynomialRing fac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RelationTable -> cu:
    java.util.Map table -> a
    edu.jas.poly.GenSolvablePolynomialRing ring -> a
    boolean coeffTable -> a
    org.apache.log4j.Logger logger -> a
    boolean debug -> b
    boolean equals(java.lang.Object) -> equals
    java.util.Map fromListDeg2(java.util.List) -> a
    boolean equalMaps(java.util.Map,java.util.Map) -> a
    int hashCode() -> hashCode
    boolean isEmpty() -> a
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> a
    java.lang.String toScript() -> a
    void update(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,edu.jas.poly.GenSolvablePolynomial) -> a
    edu.jas.poly.TableRelation lookup(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    java.util.List makeKey(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int size() -> a
    void extend(edu.jas.poly.RelationTable) -> a
    void contract(edu.jas.poly.RelationTable) -> b
    void recursive(edu.jas.poly.RelationTable) -> c
edu.jas.poly.TableRelation -> cv:
    edu.jas.poly.ExpVector e -> a
    edu.jas.poly.ExpVector f -> b
    edu.jas.poly.GenSolvablePolynomial p -> a
    java.lang.String toString() -> toString
edu.jas.poly.TermOrder -> cw:
    int evord -> a
    int evord2 -> b
    int evbeg1 -> c
    int evend1 -> d
    int evbeg2 -> e
    int evend2 -> f
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    long[][] weight -> a
    edu.jas.poly.TermOrder$EVComparator horder -> a
    edu.jas.poly.TermOrder$EVComparator lorder -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    edu.jas.poly.TermOrder extend(int,int) -> a
    edu.jas.poly.TermOrder contract(int,int) -> b
    edu.jas.poly.TermOrder$EVComparator access$000(edu.jas.poly.TermOrder) -> a
    long[][] access$100(edu.jas.poly.TermOrder) -> a
    int access$200(edu.jas.poly.TermOrder) -> a
    int access$300(edu.jas.poly.TermOrder) -> b
    int access$400(edu.jas.poly.TermOrder) -> c
    int access$500(edu.jas.poly.TermOrder) -> d
edu.jas.poly.TermOrder$1 -> cx:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$10 -> cy:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$11 -> cz:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$12 -> cA:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$13 -> cB:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$14 -> cC:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$15 -> cD:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$16 -> cE:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$17 -> cF:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$18 -> cG:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$19 -> cH:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$2 -> cI:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$20 -> cJ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$21 -> cK:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$22 -> cL:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$23 -> cM:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$24 -> cN:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$25 -> cO:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$26 -> cP:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$27 -> cQ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$28 -> cR:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$29 -> cS:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$3 -> cT:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$30 -> cU:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$31 -> cV:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$32 -> cW:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$33 -> cX:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$34 -> cY:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$35 -> cZ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$36 -> da:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$37 -> db:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$38 -> dc:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$39 -> dd:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$4 -> de:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$40 -> df:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$41 -> dg:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$42 -> dh:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$43 -> di:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$44 -> dj:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$45 -> dk:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$46 -> dl:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$47 -> dm:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$48 -> dn:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$49 -> do:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$5 -> dp:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$50 -> dq:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$51 -> dr:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$52 -> ds:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$53 -> dt:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$54 -> du:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$55 -> dv:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$56 -> dw:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$57 -> dx:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$58 -> dy:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$59 -> dz:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$6 -> dA:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$60 -> dB:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$61 -> dC:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$62 -> dD:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$63 -> dE:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$64 -> dF:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$65 -> dG:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$66 -> dH:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$67 -> dI:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$68 -> dJ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$69 -> dK:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$7 -> dL:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$70 -> dM:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$8 -> dN:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$9 -> dO:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$EVComparator -> dP:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrderOptimization -> dQ:
    org.apache.log4j.Logger logger -> a
    java.util.List degreeMatrix(edu.jas.poly.GenPolynomial) -> a
    java.util.List expVectorAdd(java.util.List,edu.jas.poly.ExpVector) -> a
    java.util.List optimalPermutation(java.util.List) -> b
    java.util.List inversePermutation(java.util.List) -> a
    java.lang.String[] stringArrayPermutation(java.util.List,java.lang.String[]) -> a
    long[] longArrayPermutation(java.util.List,long[]) -> a
    edu.jas.poly.GenPolynomial permutation(java.util.List,edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    java.util.List permutation(java.util.List,edu.jas.poly.GenPolynomialRing,java.util.List) -> a
    edu.jas.poly.GenPolynomialRing permutation(java.util.List,edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.poly.OptimizedPolynomialList optimizeTermOrder(edu.jas.poly.GenPolynomialRing,java.util.List) -> a
edu.jas.ps.Coefficients -> dR:
    java.util.HashMap coeffCache -> a
    edu.jas.structure.RingElem get(int) -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.Multiply -> dS:
    edu.jas.structure.RingElem x -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ps.Negate -> dT:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ps.PolynomialTaylorFunction -> dU:
    edu.jas.poly.GenPolynomial pol -> a
    java.lang.String toString() -> toString
    edu.jas.ps.TaylorFunction deriviative() -> a
    edu.jas.structure.RingElem evaluate(edu.jas.structure.RingElem) -> a
edu.jas.ps.Subtract -> dV:
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.ps.Sum -> dW:
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.ps.TaylorFunction -> dX:
    edu.jas.ps.TaylorFunction deriviative() -> a
    edu.jas.structure.RingElem evaluate(edu.jas.structure.RingElem) -> a
edu.jas.ps.UnivPowerSeries -> dY:
    edu.jas.ps.UnivPowerSeriesRing ring -> a
    edu.jas.ps.Coefficients lazyCoeffs -> a
    int truncate -> a
    int order -> b
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    edu.jas.structure.RingElem coefficient(int) -> a
    edu.jas.ps.UnivPowerSeries shift(int) -> a
    edu.jas.ps.UnivPowerSeries map(edu.jas.structure.UnaryFunctor) -> a
    edu.jas.ps.UnivPowerSeries zip(edu.jas.structure.BinaryFunctor,edu.jas.ps.UnivPowerSeries) -> a
    edu.jas.ps.UnivPowerSeries multiply(edu.jas.structure.RingElem) -> a
    edu.jas.ps.UnivPowerSeries negate() -> a
    int order() -> b
    int signum() -> a
    int compareTo(edu.jas.ps.UnivPowerSeries) -> a
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isUnit() -> f
    edu.jas.ps.UnivPowerSeries multiply(edu.jas.ps.UnivPowerSeries) -> a
    edu.jas.ps.UnivPowerSeries inverse() -> b
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.ps.UnivPowerSeries$3 -> dZ:
    int val$k -> a
    edu.jas.ps.UnivPowerSeries this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeries$6 -> ea:
    edu.jas.structure.UnaryFunctor val$f -> a
    edu.jas.ps.UnivPowerSeries this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeries$7 -> eb:
    edu.jas.structure.BinaryFunctor val$f -> a
    edu.jas.ps.UnivPowerSeries val$ps -> a
    edu.jas.ps.UnivPowerSeries this$0 -> b
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeries$8 -> ec:
    edu.jas.ps.UnivPowerSeries val$ps -> a
    edu.jas.ps.UnivPowerSeries this$0 -> b
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeries$9 -> ed:
    edu.jas.ps.UnivPowerSeries this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeriesRing -> ee:
    int truncate -> a
    java.lang.String var -> a
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    edu.jas.ps.UnivPowerSeries ONE -> a
    edu.jas.ps.UnivPowerSeries ZERO -> b
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.ps.UnivPowerSeries seriesOfTaylor(edu.jas.ps.TaylorFunction,edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.ps.UnivPowerSeriesRing$1 -> ef:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeriesRing$10 -> eg:
    edu.jas.ps.TaylorFunction der -> a
    long k -> a
    long n -> b
    edu.jas.ps.TaylorFunction val$f -> b
    edu.jas.structure.RingElem val$a -> a
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeriesRing$2 -> eh:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeriesRing$9 -> ei:
    java.util.Random val$rnd -> a
    float val$d -> a
    int val$k -> a
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.root.Boundary -> ej:
    edu.jas.root.Rectangle rect -> a
    edu.jas.poly.GenPolynomial A -> a
    edu.jas.poly.GenPolynomial[] polys -> a
    edu.jas.poly.GenPolynomialRing rfac -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
edu.jas.root.ComplexRoots -> ek:
edu.jas.root.ComplexRootsAbstract -> el:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.Squarefree engine -> a
    edu.jas.poly.Complex rootBound(edu.jas.poly.GenPolynomial) -> a
    long complexRootCount(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> a
    java.util.List complexRoots(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> a
    java.util.List complexRoots(edu.jas.poly.GenPolynomial) -> a
    edu.jas.root.Rectangle complexRootRefinement(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.arith.BigRational) -> a
    edu.jas.poly.Complex[] copyOfComplex(edu.jas.poly.Complex[],int) -> a
edu.jas.root.ComplexRootsSturm -> em:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    long complexRootCount(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> a
    long windingNumber(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> b
    java.util.List complexRoots(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> a
edu.jas.root.InvalidBoundaryException -> en:
edu.jas.root.Rectangle -> eo:
    edu.jas.poly.Complex[] corners -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    edu.jas.root.Rectangle exchangeSW(edu.jas.poly.Complex) -> a
    edu.jas.root.Rectangle exchangeNE(edu.jas.poly.Complex) -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
edu.jas.root.RootUtil -> ep:
    org.apache.log4j.Logger logger -> a
    long signVar(java.util.List) -> a
edu.jas.structure.AbelianGroupElem -> eq:
    boolean isZERO() -> d
    int signum() -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem abs() -> a
edu.jas.structure.AbelianGroupFactory -> er:
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
edu.jas.structure.BinaryFunctor -> es:
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.structure.ElemFactory -> et:
    boolean isFinite() -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element parse(java.lang.String) -> a
    java.lang.String toScript() -> a
edu.jas.structure.Element -> eu:
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.ElemFactory factory() -> a
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
edu.jas.structure.GcdRingElem -> ev:
edu.jas.structure.MonoidElem -> ew:
    boolean isONE() -> e
    boolean isUnit() -> f
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem inverse() -> a
edu.jas.structure.MonoidFactory -> ex:
    edu.jas.structure.MonoidElem getONE() -> b
    boolean isCommutative() -> b
edu.jas.structure.NotInvertibleException -> ey:
edu.jas.structure.Power -> ez:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.structure.AbelianGroupFactory fac$5b76095 -> a
    edu.jas.structure.RingElem positivePower(edu.jas.structure.RingElem,long) -> a
    edu.jas.structure.RingElem positivePower(edu.jas.structure.RingElem,java.math.BigInteger) -> a
    edu.jas.structure.RingElem power$51197664(edu.jas.structure.AbelianGroupFactory,edu.jas.structure.RingElem,long) -> a
    edu.jas.structure.RingElem modPower(edu.jas.structure.RingElem,java.math.BigInteger,edu.jas.structure.RingElem) -> a
    long logarithm(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem multiply$1095d1b3(edu.jas.structure.AbelianGroupFactory,java.util.List) -> a
edu.jas.structure.RingElem -> eA:
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
edu.jas.structure.UnaryFunctor -> eB:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ufd.FactorAbsolute -> eC:
    org.apache.log4j.Logger logger -> b
    java.lang.String toString() -> toString
edu.jas.ufd.FactorAbstract -> eD:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> a
    edu.jas.ufd.SquarefreeAbstract sengine -> a
    java.lang.String toString() -> toString
    boolean isIrreducible(edu.jas.poly.GenPolynomial) -> a
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.List removeOnce(java.util.List,java.util.List) -> a
    java.util.SortedMap baseFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap factors(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> c
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.List) -> a
    java.util.List normalizeFactorization(java.util.List) -> a
edu.jas.ufd.FactorAlgebraic -> eE:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    edu.jas.ufd.FactorAbstract factorCoeff -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
edu.jas.ufd.FactorComplex -> eF:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    edu.jas.ufd.FactorAbstract factorAlgeb -> a
    edu.jas.poly.AlgebraicNumberRing afac -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
edu.jas.ufd.FactorFactory -> eG:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.arith.ModIntegerRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.arith.ModLongRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation$146bcd55() -> a
    edu.jas.ufd.FactorAbstract getImplementation$17dd3501() -> b
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.poly.AlgebraicNumberRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation$7fca19ae(edu.jas.structure.AbelianGroupFactory) -> a
edu.jas.ufd.FactorInteger -> eH:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    edu.jas.ufd.FactorAbstract mfactor -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract mengine -> b
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.BitSet factorDegrees(java.util.List,int) -> a
    long degreeSum(java.util.List) -> a
    java.util.List searchFactorsMonic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,java.util.List,java.util.BitSet) -> a
    java.util.List searchFactorsNonMonic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,java.util.List,java.util.BitSet) -> b
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.List factorsSquarefreeHensel(edu.jas.poly.GenPolynomial) -> c
    boolean testSeparate(java.util.List,edu.jas.arith.BigInteger) -> a
edu.jas.ufd.FactorModular -> eI:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    java.util.SortedMap baseDistinctDegreeFactors(edu.jas.poly.GenPolynomial) -> d
    java.util.List baseEqualDegreeFactors(edu.jas.poly.GenPolynomial,long) -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
edu.jas.ufd.FactorQuotient -> eJ:
    org.apache.log4j.Logger logger -> b
    edu.jas.ufd.FactorAbstract nengine -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> a
edu.jas.ufd.FactorRational -> eK:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    edu.jas.ufd.FactorAbstract iengine -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> a
edu.jas.ufd.Factorization -> eL:
    boolean isIrreducible(edu.jas.poly.GenPolynomial) -> a
edu.jas.ufd.GCDFactory -> eM:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getImplementation$d0d9f36() -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getImplementation$5730d517(edu.jas.structure.AbelianGroupFactory) -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getProxy$5730d517(edu.jas.structure.AbelianGroupFactory) -> b
edu.jas.ufd.GCDProxy -> eN:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract e1 -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract e2 -> b
    java.util.concurrent.ExecutorService pool -> a
    java.lang.String toString() -> toString
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
    boolean access$000(edu.jas.ufd.GCDProxy) -> a
    org.apache.log4j.Logger access$100() -> a
edu.jas.ufd.GCDProxy$1 -> eO:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$10 -> eP:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$11 -> eQ:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$12 -> eR:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$2 -> eS:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$3 -> eT:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$4 -> eU:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$5 -> eV:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$6 -> eW:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$7 -> eX:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$8 -> eY:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$9 -> eZ:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GreatestCommonDivisor -> fa:
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
edu.jas.ufd.GreatestCommonDivisorAbstract -> fb:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.lang.String toString() -> toString
    edu.jas.structure.GcdRingElem baseContent(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial basePrimitivePart(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveContent(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursivePrimitivePart(edu.jas.poly.GenPolynomial) -> c
    edu.jas.structure.GcdRingElem baseRecursiveContent(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial baseRecursivePrimitivePart(edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial,edu.jas.structure.GcdRingElem) -> a
    edu.jas.structure.GcdRingElem gcd(edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem) -> a
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial recursiveResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> g
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial[] baseGcdDiophant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> a
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,java.util.List) -> a
edu.jas.ufd.GreatestCommonDivisorModEval -> fc:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract mufd -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
edu.jas.ufd.GreatestCommonDivisorModular -> fd:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract mufd -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract iufd -> b
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
edu.jas.ufd.GreatestCommonDivisorPrimitive -> fe:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
edu.jas.ufd.GreatestCommonDivisorSimple -> ff:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
edu.jas.ufd.GreatestCommonDivisorSubres -> fg:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.structure.GcdRingElem power$24a636e(edu.jas.structure.AbelianGroupFactory,edu.jas.structure.GcdRingElem,long) -> a
    edu.jas.poly.GenPolynomial power$4f9faa70(edu.jas.structure.AbelianGroupFactory,edu.jas.poly.GenPolynomial,long) -> a
edu.jas.ufd.HenselApprox -> fh:
    edu.jas.poly.GenPolynomial A -> a
    edu.jas.poly.GenPolynomial B -> b
    edu.jas.poly.GenPolynomial Am -> c
    edu.jas.poly.GenPolynomial Bm -> d
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
edu.jas.ufd.HenselMultUtil -> fi:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.util.List liftDiophant(java.util.List,edu.jas.poly.GenPolynomial,java.util.List,long,long) -> a
    java.util.List liftHensel(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,java.util.List,java.util.List,long,java.util.List) -> a
edu.jas.ufd.HenselUtil -> fj:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    edu.jas.ufd.HenselApprox liftHenselQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.ufd.HenselApprox liftHenselQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial[] liftExtendedEuclidean(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftExtendedEuclidean(java.util.List,long) -> a
    java.util.List liftDiophant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftDiophant(java.util.List,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftDiophant(java.util.List,long,long) -> a
    boolean isExtendedEuclideanLift(java.util.List,java.util.List) -> a
    boolean isDiophantLift(java.util.List,java.util.List,edu.jas.poly.GenPolynomial) -> a
    java.util.List liftHenselMonic(edu.jas.poly.GenPolynomial,java.util.List,long) -> a
edu.jas.ufd.NoLiftingException -> fk:
edu.jas.ufd.PolyUfdUtil -> fl:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial integralFromQuotientCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial quotientFromIntegralCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> b
    java.util.List quotientFromIntegralCoefficients(edu.jas.poly.GenPolynomialRing,java.util.Collection) -> a
    edu.jas.poly.GenPolynomial substituteConvertToAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,long) -> a
    edu.jas.poly.GenPolynomial norm(edu.jas.poly.GenPolynomial,long) -> a
    void ensureFieldProperty(edu.jas.poly.AlgebraicNumberRing) -> a
    edu.jas.poly.GenPolynomial substituteKronecker(edu.jas.poly.GenPolynomial,long) -> b
    edu.jas.poly.GenPolynomial backSubstituteKronecker(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,long) -> b
edu.jas.ufd.Quotient -> fm:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.QuotientRing ring -> a
    edu.jas.poly.GenPolynomial num -> a
    edu.jas.poly.GenPolynomial den -> b
    boolean isZERO() -> d
    boolean isONE() -> e
    boolean isUnit() -> f
    boolean isConstant() -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.ufd.Quotient) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.ufd.Quotient sum(edu.jas.ufd.Quotient) -> c
    edu.jas.ufd.Quotient negate() -> a
    int signum() -> a
    edu.jas.ufd.Quotient divide(edu.jas.ufd.Quotient) -> a
    edu.jas.ufd.Quotient inverse() -> b
    edu.jas.ufd.Quotient multiply(edu.jas.ufd.Quotient) -> b
    edu.jas.ufd.Quotient multiply(edu.jas.poly.GenPolynomial) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.ufd.QuotientRing -> fn:
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.ufd.GreatestCommonDivisor engine -> a
    boolean ufdGCD -> a
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    boolean isFinite() -> a
    edu.jas.ufd.Quotient getZERO() -> a
    edu.jas.ufd.Quotient getONE() -> b
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.ufd.Squarefree -> fo:
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
edu.jas.ufd.SquarefreeAbstract -> fp:
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> a
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap normalizeFactorization(java.util.SortedMap) -> a
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> a
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.SquarefreeFactory -> fq:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.SquarefreeAbstract getImplementation(edu.jas.arith.BigRational) -> a
    edu.jas.ufd.SquarefreeAbstract getImplementation(edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.ufd.SquarefreeAbstract getImplementationPoly(edu.jas.poly.GenPolynomialRing) -> b
    edu.jas.ufd.SquarefreeAbstract getImplementation$2123d3d8(edu.jas.structure.AbelianGroupFactory) -> a
edu.jas.ufd.SquarefreeFieldChar0 -> fr:
    org.apache.log4j.Logger logger -> a
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    java.lang.String toString() -> toString
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.SquarefreeFieldCharP -> fs:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    edu.jas.poly.AlgebraicNumberRing aCoFac -> a
    edu.jas.ufd.QuotientRing qCoFac -> a
    java.lang.String toString() -> toString
    edu.jas.poly.GenPolynomial baseSquarefreePart(edu.jas.poly.GenPolynomial) -> d
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> c
edu.jas.ufd.SquarefreeFiniteFieldCharP -> ft:
    org.apache.log4j.Logger logger -> a
    java.util.SortedMap rootCharacteristic(edu.jas.structure.GcdRingElem) -> b
    edu.jas.structure.GcdRingElem coeffRootCharacteristic(edu.jas.structure.GcdRingElem) -> a
    java.util.SortedMap rootCharacteristic(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> c
edu.jas.ufd.SquarefreeInfiniteAlgebraicFieldCharP -> fu:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.SquarefreeAbstract aengine -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.AlgebraicNumber) -> a
    java.util.SortedMap rootCharacteristic(edu.jas.poly.AlgebraicNumber) -> b
    edu.jas.poly.GenPolynomial rootCharacteristic(edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> c
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.SquarefreeInfiniteFieldCharP -> fv:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.SquarefreeAbstract qengine -> a
    java.util.SortedMap squarefreeFactors(edu.jas.ufd.Quotient) -> a
    java.util.SortedMap rootCharacteristic(edu.jas.ufd.Quotient) -> b
    edu.jas.poly.GenPolynomial rootCharacteristic(edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> c
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.SquarefreeRingChar0 -> fw:
    org.apache.log4j.Logger logger -> a
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    java.lang.String toString() -> toString
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.TrialParts -> fx:
    java.util.List evalPoints -> a
    edu.jas.poly.GenPolynomial univPoly -> a
    java.util.List univFactors -> b
    java.util.List ldcfFactors -> c
    java.util.List ldcfEval -> d
    java.lang.String toString() -> toString
edu.jas.util.CartesianOneProductInfiniteIterator -> fy:
    java.util.Iterator compit -> a
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.CartesianProduct -> fz:
    java.util.List comps -> a
    java.util.Iterator iterator() -> iterator
edu.jas.util.CartesianProductInfinite -> fA:
    java.util.List comps -> a
    java.util.Iterator iterator() -> iterator
edu.jas.util.CartesianProductIterator -> fB:
    java.util.List comps -> a
    java.util.List compit -> b
    java.util.List current -> c
    boolean empty -> a
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.CartesianTwoProductInfiniteIteratorList -> fC:
    java.util.Iterator compit0 -> a
    java.util.Iterator compit1 -> b
    java.util.List fincomps0 -> a
    java.util.List fincomps1 -> b
    java.util.Iterator fincompit0 -> c
    java.util.Iterator fincompit1 -> d
    java.util.List current -> c
    boolean empty -> a
    long level -> a
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.KsubSet -> fD:
    java.util.List set -> a
    int k -> a
    java.util.Iterator iterator() -> iterator
edu.jas.util.KsubSetIterator -> fE:
    java.util.List set -> a
    int k -> a
    java.util.List rest -> b
    java.lang.Object current -> a
    java.util.Iterator recIter -> a
    java.util.Iterator iter -> b
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.LongIterable -> fF:
    boolean nonNegative -> a
    long upperBound -> a
    java.util.Iterator iterator() -> iterator
edu.jas.util.LongIterator -> fG:
    long current -> a
    boolean empty -> a
    boolean nonNegative -> b
    long upperBound -> b
    boolean hasNext() -> hasNext
    java.lang.Long next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.OneSubSetIterator -> fH:
    java.util.List set -> a
    java.util.Iterator iter -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.ZeroSubSetIterator -> fI:
    boolean hasNext -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.vector.BasicLinAlg -> fJ:
    org.apache.log4j.Logger logger -> a
    java.util.List vectorAdd(java.util.List,java.util.List) -> a
org.apache.commons.math3.Field -> fK:
    java.lang.Object getZero() -> a
    java.lang.Object getOne() -> b
    java.lang.Class getRuntimeClass() -> a
org.apache.commons.math3.FieldElement -> fL:
    java.lang.Object add(java.lang.Object) -> a
    java.lang.Object subtract(java.lang.Object) -> b
    java.lang.Object negate() -> a
    java.lang.Object multiply(java.lang.Object) -> c
    java.lang.Object divide(java.lang.Object) -> d
    java.lang.Object reciprocal() -> b
    org.apache.commons.math3.Field getField() -> a
org.apache.commons.math3.analysis.BivariateFunction -> fM:
    double value(double,double) -> a
org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction -> fN:
    org.apache.commons.math3.analysis.MultivariateMatrixFunction jacobian() -> a
org.apache.commons.math3.analysis.DifferentiableUnivariateFunction -> fO:
org.apache.commons.math3.analysis.FunctionUtils$13 -> fP:
    org.apache.commons.math3.analysis.BivariateFunction val$f -> a
    double val$fixed -> a
    double value(double) -> a
org.apache.commons.math3.analysis.FunctionUtils$18 -> fQ:
    org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction val$f -> a
    double[] value(double[]) -> a
    org.apache.commons.math3.analysis.MultivariateMatrixFunction jacobian() -> a
org.apache.commons.math3.analysis.FunctionUtils$18$1 -> fR:
    org.apache.commons.math3.analysis.FunctionUtils$18 this$0 -> a
    double[][] value(double[]) -> a
org.apache.commons.math3.analysis.FunctionUtils$19 -> fS:
    org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction val$f -> a
    double[] value(double[]) -> a
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure[] value(org.apache.commons.math3.analysis.differentiation.DerivativeStructure[]) -> a
org.apache.commons.math3.analysis.MultivariateMatrixFunction -> fT:
    double[][] value(double[]) -> a
org.apache.commons.math3.analysis.MultivariateVectorFunction -> fU:
    double[] value(double[]) -> a
org.apache.commons.math3.analysis.ParametricUnivariateFunction -> fV:
    double value(double,double[]) -> a
    double[] gradient(double,double[]) -> a
org.apache.commons.math3.analysis.UnivariateFunction -> fW:
    double value(double) -> a
org.apache.commons.math3.analysis.differentiation.DSCompiler -> fX:
    java.util.concurrent.atomic.AtomicReference compilers -> a
    int parameters -> a
    int order -> b
    int[][] sizes -> a
    int[][] derivativesIndirection -> b
    int[] lowerIndirection -> a
    int[][][] multIndirection -> a
    int[][][] compIndirection -> b
    org.apache.commons.math3.analysis.differentiation.DSCompiler getCompiler(int,int) -> a
    int[][] compileSizes(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[][] compileDerivativesIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[] compileLowerIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[][][] compileMultiplicationIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler,int[]) -> a
    int[][][] compileCompositionIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler,int[][],int[][]) -> a
    int getPartialDerivativeIndex(int,int,int[][],int[]) -> a
    int convertIndex(int,int,int[][],int,int,int[][]) -> a
    int getSize() -> a
    void multiply(double[],int,double[],int,double[],int) -> a
    void pow(double[],int,int,double[],int) -> a
    void checkCompatibility(org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
org.apache.commons.math3.analysis.differentiation.DerivativeStructure -> fY:
    org.apache.commons.math3.analysis.differentiation.DSCompiler compiler -> a
    double[] data -> a
    int getFreeParameters() -> a
    int getOrder() -> b
    double getPartialDerivative(int[]) -> a
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure add(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> a
    org.apache.commons.math3.Field getField() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object reciprocal() -> b
    java.lang.Object divide(java.lang.Object) -> d
    java.lang.Object multiply(java.lang.Object) -> c
    java.lang.Object negate() -> a
    java.lang.Object subtract(java.lang.Object) -> b
    java.lang.Object add(java.lang.Object) -> a
    org.apache.commons.math3.analysis.differentiation.DSCompiler access$000(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> a
org.apache.commons.math3.analysis.differentiation.DerivativeStructure$1 -> fZ:
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure this$0 -> a
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction -> ga:
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure[] value(org.apache.commons.math3.analysis.differentiation.DerivativeStructure[]) -> a
org.apache.commons.math3.analysis.integration.BaseAbstractUnivariateIntegrator -> gb:
    org.apache.commons.math3.util.Incrementor iterations -> a
    double absoluteAccuracy -> a
    double relativeAccuracy -> b
    int minimalIterationCount -> a
    org.apache.commons.math3.util.Incrementor evaluations -> b
    org.apache.commons.math3.analysis.UnivariateFunction function -> a
    double min -> c
    double max -> d
    double computeObjectiveValue(double) -> a
    double integrate(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.RombergIntegrator -> gc:
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.SimpsonIntegrator -> gd:
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.TrapezoidIntegrator -> ge:
    double s -> e
    double stage(org.apache.commons.math3.analysis.integration.BaseAbstractUnivariateIntegrator,int) -> a
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.UnivariateIntegrator -> gf:
    double integrate(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
org.apache.commons.math3.analysis.integration.gauss.BaseRuleFactory -> gg:
    java.util.Map pointsAndWeights -> a
    java.util.Map pointsAndWeightsDouble -> b
    org.apache.commons.math3.util.Pair getRule(int) -> a
    org.apache.commons.math3.util.Pair getRuleInternal(int) -> b
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.GaussIntegrator -> gh:
    double[] points -> a
    double[] weights -> b
    double integrate(org.apache.commons.math3.analysis.UnivariateFunction) -> a
org.apache.commons.math3.analysis.integration.gauss.GaussIntegratorFactory -> gi:
    org.apache.commons.math3.analysis.integration.gauss.BaseRuleFactory legendre -> a
    org.apache.commons.math3.analysis.integration.gauss.GaussIntegrator legendre(int,double,double) -> a
    org.apache.commons.math3.util.Pair transform(org.apache.commons.math3.util.Pair,double,double) -> a
org.apache.commons.math3.analysis.integration.gauss.HermiteRuleFactory -> gj:
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.LegendreHighPrecisionRuleFactory -> gk:
    java.math.MathContext mContext -> a
    java.math.BigDecimal two -> a
    java.math.BigDecimal minusOne -> b
    java.math.BigDecimal oneHalf -> c
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.LegendreRuleFactory -> gl:
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.interpolation.SplineInterpolator -> gm:
    org.apache.commons.math3.analysis.UnivariateFunction interpolate(double[],double[]) -> a
org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator -> gn:
    org.apache.commons.math3.analysis.UnivariateFunction interpolate(double[],double[]) -> a
org.apache.commons.math3.analysis.polynomials.PolynomialFunction -> go:
    double[] coefficients -> a
    double value(double) -> a
    double evaluate(double[],double) -> a
    java.lang.String toString() -> toString
    java.lang.String toString(double) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction -> gp:
    double[] knots -> a
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction[] polynomials -> a
    int n -> a
    double value(double) -> a
org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver -> gq:
org.apache.commons.math3.analysis.solvers.AllowedSolution -> gr:
    int ANY_SIDE$37d0779 -> a
    int LEFT_SIDE$37d0779 -> b
    int RIGHT_SIDE$37d0779 -> c
    int BELOW_SIDE$37d0779 -> d
    int ABOVE_SIDE$37d0779 -> e
    int[] $VALUES$1fdc434c -> a
    int[] values$267468cd() -> a
org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver -> gs:
    double functionValueAccuracy -> a
    double absoluteAccuracy -> b
    double relativeAccuracy -> c
    org.apache.commons.math3.util.Incrementor evaluations -> a
    double searchMin -> d
    double searchMax -> e
    double searchStart -> f
    org.apache.commons.math3.analysis.UnivariateFunction function -> a
    double computeObjectiveValue(double) -> a
    void setup(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double) -> a
    double doSolve() -> a
    void verifySequence(double,double,double) -> a
    void verifyBracketing(double,double) -> a
    void incrementEvaluationCount() -> a
org.apache.commons.math3.analysis.solvers.BaseSecantSolver -> gt:
    int allowed$37d0779 -> a
    int method$31c873c3 -> b
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.BaseSecantSolver$1 -> gu:
    int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$BaseSecantSolver$Method -> a
    int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$AllowedSolution -> b
org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method -> gv:
    int REGULA_FALSI$31c873c3 -> a
    int ILLINOIS$31c873c3 -> b
    int PEGASUS$31c873c3 -> c
    int[] $VALUES$69504202 -> a
    int[] values$d90a97d() -> a
org.apache.commons.math3.analysis.solvers.BisectionSolver -> gw:
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.BrentSolver -> gx:
    double doSolve() -> a
    double brent(double,double,double,double) -> a
org.apache.commons.math3.analysis.solvers.IllinoisSolver -> gy:
org.apache.commons.math3.analysis.solvers.MullerSolver -> gz:
    double doSolve() -> a
    double solve(double,double,double,double) -> a
org.apache.commons.math3.analysis.solvers.PegasusSolver -> gA:
org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver -> gB:
org.apache.commons.math3.analysis.solvers.RiddersSolver -> gC:
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.SecantSolver -> gD:
    double doSolve() -> a
org.apache.commons.math3.complex.Complex -> gE:
    org.apache.commons.math3.complex.Complex NaN -> c
    org.apache.commons.math3.complex.Complex INF -> d
    org.apache.commons.math3.complex.Complex ONE -> a
    org.apache.commons.math3.complex.Complex ZERO -> b
    double imaginary -> a
    double real -> b
    boolean isNaN -> a
    boolean isInfinite -> b
    org.apache.commons.math3.complex.Complex add(org.apache.commons.math3.complex.Complex) -> a
    org.apache.commons.math3.complex.Complex conjugate() -> a
    org.apache.commons.math3.complex.Complex divide(org.apache.commons.math3.complex.Complex) -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex) -> c
    org.apache.commons.math3.complex.Complex negate() -> b
    org.apache.commons.math3.complex.Complex subtract(org.apache.commons.math3.complex.Complex) -> d
    org.apache.commons.math3.complex.Complex pow(org.apache.commons.math3.complex.Complex) -> e
    org.apache.commons.math3.complex.Complex createComplex(double,double) -> a
    java.lang.String toString() -> toString
    org.apache.commons.math3.Field getField() -> a
    java.lang.Object reciprocal() -> b
    java.lang.Object divide(java.lang.Object) -> d
    java.lang.Object multiply(java.lang.Object) -> c
    java.lang.Object negate() -> a
    java.lang.Object subtract(java.lang.Object) -> b
    java.lang.Object add(java.lang.Object) -> a
org.apache.commons.math3.complex.ComplexField -> gF:
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
org.apache.commons.math3.complex.ComplexField$LazyHolder -> gG:
    org.apache.commons.math3.complex.ComplexField INSTANCE -> a
    org.apache.commons.math3.complex.ComplexField access$000() -> a
org.apache.commons.math3.exception.ConvergenceException -> gH:
org.apache.commons.math3.exception.DimensionMismatchException -> gI:
org.apache.commons.math3.exception.MathArithmeticException -> gJ:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathIllegalArgumentException -> gK:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathIllegalNumberException -> gL:
    java.lang.Integer INTEGER_ZERO -> a
org.apache.commons.math3.exception.MathIllegalStateException -> gM:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathInternalError -> gN:
org.apache.commons.math3.exception.MathUnsupportedOperationException -> gO:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MaxCountExceededException -> gP:
    java.lang.Number max -> a
org.apache.commons.math3.exception.MultiDimensionMismatchException -> gQ:
org.apache.commons.math3.exception.NoBracketingException -> gR:
org.apache.commons.math3.exception.NoDataException -> gS:
org.apache.commons.math3.exception.NonMonotonicSequenceException -> gT:
org.apache.commons.math3.exception.NotPositiveException -> gU:
org.apache.commons.math3.exception.NotStrictlyPositiveException -> gV:
org.apache.commons.math3.exception.NullArgumentException -> gW:
org.apache.commons.math3.exception.NumberIsTooLargeException -> gX:
org.apache.commons.math3.exception.NumberIsTooSmallException -> gY:
org.apache.commons.math3.exception.OutOfRangeException -> gZ:
org.apache.commons.math3.exception.TooManyEvaluationsException -> ha:
org.apache.commons.math3.exception.TooManyIterationsException -> hb:
org.apache.commons.math3.exception.ZeroException -> hc:
org.apache.commons.math3.exception.util.ExceptionContext -> hd:
    java.util.List msgPatterns -> a
    java.util.List msgArguments -> b
    void addMessage(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.String getMessage(java.util.Locale) -> a
org.apache.commons.math3.exception.util.Localizable -> he:
    java.lang.String getLocalizedString(java.util.Locale) -> a
org.apache.commons.math3.exception.util.LocalizedFormats -> hf:
    org.apache.commons.math3.exception.util.LocalizedFormats ARGUMENT_OUTSIDE_DOMAIN -> ap
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SIZE_EXCEEDS_MAX_VARIABLES -> aq
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1 -> ar
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SUMS_TO_ZERO -> as
    org.apache.commons.math3.exception.util.LocalizedFormats ASSYMETRIC_EIGEN_NOT_SUPPORTED -> at
    org.apache.commons.math3.exception.util.LocalizedFormats AT_LEAST_ONE_COLUMN -> a
    org.apache.commons.math3.exception.util.LocalizedFormats AT_LEAST_ONE_ROW -> b
    org.apache.commons.math3.exception.util.LocalizedFormats BANDWIDTH -> au
    org.apache.commons.math3.exception.util.LocalizedFormats BINOMIAL_INVALID_PARAMETERS_ORDER -> av
    org.apache.commons.math3.exception.util.LocalizedFormats BINOMIAL_NEGATIVE_PARAMETER -> aw
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> ax
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_0TH_ROOT_OF_UNITY -> ay
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA -> az
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA -> aA
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N -> aB
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS -> aC
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR -> aD
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_COMPLEX -> aE
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR -> aF
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_OBJECT_TO_FRACTION -> aG
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> aH
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR -> aI
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_RETRIEVE_AT_NEGATIVE_INDEX -> aJ
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_SET_AT_NEGATIVE_INDEX -> aK
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY -> aL
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_TRANSFORM_TO_DOUBLE -> aM
    org.apache.commons.math3.exception.util.LocalizedFormats CARDAN_ANGLES_SINGULARITY -> aN
    org.apache.commons.math3.exception.util.LocalizedFormats CLASS_DOESNT_IMPLEMENT_COMPARABLE -> aO
    org.apache.commons.math3.exception.util.LocalizedFormats CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT -> aP
    org.apache.commons.math3.exception.util.LocalizedFormats COLUMN_INDEX_OUT_OF_RANGE -> aQ
    org.apache.commons.math3.exception.util.LocalizedFormats COLUMN_INDEX -> c
    org.apache.commons.math3.exception.util.LocalizedFormats CONSTRAINT -> aR
    org.apache.commons.math3.exception.util.LocalizedFormats CONTINUED_FRACTION_INFINITY_DIVERGENCE -> d
    org.apache.commons.math3.exception.util.LocalizedFormats CONTINUED_FRACTION_NAN_DIVERGENCE -> e
    org.apache.commons.math3.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR -> aS
    org.apache.commons.math3.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_ONE -> aT
    org.apache.commons.math3.exception.util.LocalizedFormats CONVERGENCE_FAILED -> f
    org.apache.commons.math3.exception.util.LocalizedFormats CROSSING_BOUNDARY_LOOPS -> aU
    org.apache.commons.math3.exception.util.LocalizedFormats CROSSOVER_RATE -> aV
    org.apache.commons.math3.exception.util.LocalizedFormats CUMULATIVE_PROBABILITY_RETURNED_NAN -> aW
    org.apache.commons.math3.exception.util.LocalizedFormats DIFFERENT_ROWS_LENGTHS -> aX
    org.apache.commons.math3.exception.util.LocalizedFormats DIFFERENT_ORIG_AND_PERMUTED_DATA -> aY
    org.apache.commons.math3.exception.util.LocalizedFormats DIGEST_NOT_INITIALIZED -> aZ
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_2x2 -> g
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_SIMPLE -> h
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH -> ba
    org.apache.commons.math3.exception.util.LocalizedFormats DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN -> bb
    org.apache.commons.math3.exception.util.LocalizedFormats DISTRIBUTION_NOT_LOADED -> bc
    org.apache.commons.math3.exception.util.LocalizedFormats DUPLICATED_ABSCISSA_DIVISION_BY_ZERO -> bd
    org.apache.commons.math3.exception.util.LocalizedFormats ELITISM_RATE -> be
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_CLUSTER_IN_K_MEANS -> bf
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_INTERPOLATION_SAMPLE -> bg
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY -> i
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_SELECTED_COLUMN_INDEX_ARRAY -> bh
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_SELECTED_ROW_INDEX_ARRAY -> bi
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_STRING_FOR_IMAGINARY_CHARACTER -> bj
    org.apache.commons.math3.exception.util.LocalizedFormats ENDPOINTS_NOT_AN_INTERVAL -> j
    org.apache.commons.math3.exception.util.LocalizedFormats EQUAL_VERTICES_IN_SIMPLEX -> bk
    org.apache.commons.math3.exception.util.LocalizedFormats EULER_ANGLES_SINGULARITY -> bl
    org.apache.commons.math3.exception.util.LocalizedFormats EVALUATION -> bm
    org.apache.commons.math3.exception.util.LocalizedFormats EXPANSION_FACTOR_SMALLER_THAN_ONE -> bn
    org.apache.commons.math3.exception.util.LocalizedFormats FACTORIAL_NEGATIVE_PARAMETER -> bo
    org.apache.commons.math3.exception.util.LocalizedFormats FAILED_BRACKETING -> bp
    org.apache.commons.math3.exception.util.LocalizedFormats FAILED_FRACTION_CONVERSION -> k
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_COLUMNS_NOT_INITIALIZED_YET -> l
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_ELEMENT_NOT_ZERO -> bq
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_ROWS_NOT_INITIALIZED_YET -> m
    org.apache.commons.math3.exception.util.LocalizedFormats FRACTION_CONVERSION_OVERFLOW -> n
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION_NOT_DIFFERENTIABLE -> br
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION_NOT_POLYNOMIAL -> bs
    org.apache.commons.math3.exception.util.LocalizedFormats GCD_OVERFLOW_32_BITS -> bt
    org.apache.commons.math3.exception.util.LocalizedFormats GCD_OVERFLOW_64_BITS -> bu
    org.apache.commons.math3.exception.util.LocalizedFormats HOLE_BETWEEN_MODELS_TIME_RANGES -> bv
    org.apache.commons.math3.exception.util.LocalizedFormats ILL_CONDITIONED_OPERATOR -> bw
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_LARGER_THAN_MAX -> bx
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_NOT_POSITIVE -> by
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_OUT_OF_RANGE -> bz
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX -> o
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_FINITE_NUMBER -> bA
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_BOUND -> bB
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_ELEMENT -> bC
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_ARRAY_ELEMENT -> bD
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_VALUE_CONVERSION -> p
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_CAPACITY_NOT_POSITIVE -> bE
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_COLUMN_AFTER_FINAL_COLUMN -> q
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_ROW_AFTER_FINAL_ROW -> r
    org.apache.commons.math3.exception.util.LocalizedFormats INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE -> bF
    org.apache.commons.math3.exception.util.LocalizedFormats INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES -> bG
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DATA -> bH
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DATA_FOR_T_STATISTIC -> bI
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DIMENSION -> bJ
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSION -> s
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE -> bK
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_ROWS_AND_COLUMNS -> bL
    org.apache.commons.math3.exception.util.LocalizedFormats INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS -> bM
    org.apache.commons.math3.exception.util.LocalizedFormats INTERNAL_ERROR -> t
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BINARY_DIGIT -> bN
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BINARY_CHROMOSOME -> bO
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BRACKETING_PARAMETERS -> bP
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_FIXED_LENGTH_CHROMOSOME -> bQ
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS -> bR
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_ITERATIONS_LIMITS -> bS
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_MAX_ITERATIONS -> bT
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_DATA_REGRESSION -> bU
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_REGRESSION_ARRAY -> bV
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_REGRESSION_OBSERVATION -> bW
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_ROUNDING_METHOD -> bX
    org.apache.commons.math3.exception.util.LocalizedFormats ITERATOR_EXHAUSTED -> bY
    org.apache.commons.math3.exception.util.LocalizedFormats ITERATIONS -> u
    org.apache.commons.math3.exception.util.LocalizedFormats LCM_OVERFLOW_32_BITS -> bZ
    org.apache.commons.math3.exception.util.LocalizedFormats LCM_OVERFLOW_64_BITS -> ca
    org.apache.commons.math3.exception.util.LocalizedFormats LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE -> cb
    org.apache.commons.math3.exception.util.LocalizedFormats LOESS_EXPECTS_AT_LEAST_ONE_POINT -> cc
    org.apache.commons.math3.exception.util.LocalizedFormats LOWER_BOUND_NOT_BELOW_UPPER_BOUND -> cd
    org.apache.commons.math3.exception.util.LocalizedFormats LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT -> ce
    org.apache.commons.math3.exception.util.LocalizedFormats MAP_MODIFIED_WHILE_ITERATING -> cf
    org.apache.commons.math3.exception.util.LocalizedFormats EVALUATIONS -> v
    org.apache.commons.math3.exception.util.LocalizedFormats MAX_COUNT_EXCEEDED -> w
    org.apache.commons.math3.exception.util.LocalizedFormats MAX_ITERATIONS_EXCEEDED -> cg
    org.apache.commons.math3.exception.util.LocalizedFormats MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION -> ch
    org.apache.commons.math3.exception.util.LocalizedFormats MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS -> ci
    org.apache.commons.math3.exception.util.LocalizedFormats MUTATION_RATE -> cj
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_ELEMENT_AT_INDEX -> ck
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_VALUE_CONVERSION -> x
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_BRIGHTNESS_EXPONENT -> cl
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_COMPLEX_MODULE -> cm
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_2D_INDEX -> cn
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_INDEX -> co
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_SUCCESSES -> cp
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SUCCESSES -> cq
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_TRIALS -> cr
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_INTERPOLATION_POINTS -> cs
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_TRIALS -> ct
    org.apache.commons.math3.exception.util.LocalizedFormats ROBUSTNESS_ITERATIONS -> cu
    org.apache.commons.math3.exception.util.LocalizedFormats START_POSITION -> y
    org.apache.commons.math3.exception.util.LocalizedFormats NON_CONVERGENT_CONTINUED_FRACTION -> z
    org.apache.commons.math3.exception.util.LocalizedFormats NON_INVERTIBLE_TRANSFORM -> cv
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_MICROSPHERE_ELEMENTS -> cw
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_POLYNOMIAL_DEGREE -> cx
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_ABSCISSA -> cy
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_ORDINATE -> cz
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_WEIGHT -> cA
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SQUARE_MATRIX -> A
    org.apache.commons.math3.exception.util.LocalizedFormats NORM -> cB
    org.apache.commons.math3.exception.util.LocalizedFormats NORMALIZE_INFINITE -> cC
    org.apache.commons.math3.exception.util.LocalizedFormats NORMALIZE_NAN -> cD
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ADDITION_COMPATIBLE_MATRICES -> cE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_DECREASING_NUMBER_OF_POINTS -> cF
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_DECREASING_SEQUENCE -> B
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS -> cG
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION -> C
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_INCREASING_NUMBER_OF_POINTS -> cH
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_INCREASING_SEQUENCE -> D
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_MULTIPLICATION_COMPATIBLE_MATRICES -> cI
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_DEFINITE_MATRIX -> cJ
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_DEFINITE_MATRIX -> cK
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_DEFINITE_OPERATOR -> cL
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SELF_ADJOINT_OPERATOR -> cM
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SQUARE_OPERATOR -> cN
    org.apache.commons.math3.exception.util.LocalizedFormats DEGREES_OF_FREEDOM -> cO
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_DEGREES_OF_FREEDOM -> cP
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_ELEMENT_AT_INDEX -> cQ
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_EXPONENT -> cR
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE -> cS
    org.apache.commons.math3.exception.util.LocalizedFormats BASE -> cT
    org.apache.commons.math3.exception.util.LocalizedFormats EXPONENT -> cU
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_LENGTH -> cV
    org.apache.commons.math3.exception.util.LocalizedFormats LENGTH -> E
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_MEAN -> cW
    org.apache.commons.math3.exception.util.LocalizedFormats MEAN -> cX
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_NUMBER_OF_SAMPLES -> F
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SAMPLES -> cY
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_PERMUTATION -> cZ
    org.apache.commons.math3.exception.util.LocalizedFormats PERMUTATION_SIZE -> da
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_POISSON_MEAN -> db
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_POPULATION_SIZE -> dc
    org.apache.commons.math3.exception.util.LocalizedFormats POPULATION_SIZE -> dd
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_ROW_DIMENSION -> de
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SAMPLE_SIZE -> df
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SCALE -> dg
    org.apache.commons.math3.exception.util.LocalizedFormats SCALE -> dh
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SHAPE -> di
    org.apache.commons.math3.exception.util.LocalizedFormats SHAPE -> dj
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_STANDARD_DEVIATION -> dk
    org.apache.commons.math3.exception.util.LocalizedFormats STANDARD_DEVIATION -> dl
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_UPPER_BOUND -> dm
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_WINDOW_SIZE -> dn
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO -> do
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO_CONSIDER_PADDING -> G
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO_PLUS_ONE -> dp
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS -> dq
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_SEQUENCE -> H
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_KNOT_VALUES -> dr
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS -> ds
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_SEQUENCE -> I
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SUBTRACTION_COMPATIBLE_MATRICES -> dt
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SUPPORTED_IN_DIMENSION_N -> du
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SYMMETRIC_MATRIX -> dv
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SYMMETRIC_MATRIX -> J
    org.apache.commons.math3.exception.util.LocalizedFormats NO_BIN_SELECTED -> dw
    org.apache.commons.math3.exception.util.LocalizedFormats NO_CONVERGENCE_WITH_ANY_START_POINT -> dx
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DATA -> K
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DEGREES_OF_FREEDOM -> dy
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DENSITY_FOR_THIS_DISTRIBUTION -> dz
    org.apache.commons.math3.exception.util.LocalizedFormats NO_FEASIBLE_SOLUTION -> L
    org.apache.commons.math3.exception.util.LocalizedFormats NO_OPTIMUM_COMPUTED_YET -> dA
    org.apache.commons.math3.exception.util.LocalizedFormats NO_REGRESSORS -> dB
    org.apache.commons.math3.exception.util.LocalizedFormats NO_RESULT_AVAILABLE -> dC
    org.apache.commons.math3.exception.util.LocalizedFormats NO_SUCH_MATRIX_ENTRY -> dD
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_NOT_ALLOWED -> dE
    org.apache.commons.math3.exception.util.LocalizedFormats NULL_NOT_ALLOWED -> M
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED -> dF
    org.apache.commons.math3.exception.util.LocalizedFormats COVARIANCE_MATRIX -> dG
    org.apache.commons.math3.exception.util.LocalizedFormats DENOMINATOR -> N
    org.apache.commons.math3.exception.util.LocalizedFormats DENOMINATOR_FORMAT -> dH
    org.apache.commons.math3.exception.util.LocalizedFormats FRACTION -> O
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION -> P
    org.apache.commons.math3.exception.util.LocalizedFormats IMAGINARY_FORMAT -> dI
    org.apache.commons.math3.exception.util.LocalizedFormats INPUT_ARRAY -> Q
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR -> R
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR_FORMAT -> dJ
    org.apache.commons.math3.exception.util.LocalizedFormats OBJECT_TRANSFORMATION -> dK
    org.apache.commons.math3.exception.util.LocalizedFormats REAL_FORMAT -> dL
    org.apache.commons.math3.exception.util.LocalizedFormats WHOLE_FORMAT -> dM
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_LARGE -> S
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_SMALL -> T
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_LARGE_BOUND_EXCLUDED -> U
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_SMALL_BOUND_EXCLUDED -> V
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE -> dN
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR_OVERFLOW_AFTER_MULTIPLY -> dO
    org.apache.commons.math3.exception.util.LocalizedFormats N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED -> dP
    org.apache.commons.math3.exception.util.LocalizedFormats OBSERVED_COUNTS_ALL_ZERO -> dQ
    org.apache.commons.math3.exception.util.LocalizedFormats OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY -> dR
    org.apache.commons.math3.exception.util.LocalizedFormats BOBYQA_BOUND_DIFFERENCE_CONDITION -> dS
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUNDS_QUANTILE_VALUE -> W
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUNDS_CONFIDENCE_LEVEL -> dT
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUND_SIGNIFICANCE_LEVEL -> dU
    org.apache.commons.math3.exception.util.LocalizedFormats SIGNIFICANCE_LEVEL -> dV
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_ORDER_ABSCISSA_ARRAY -> dW
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_ROOT_OF_UNITY_INDEX -> dX
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE -> dY
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_SIMPLE -> X
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_LEFT -> dZ
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_RIGHT -> ea
    org.apache.commons.math3.exception.util.LocalizedFormats OUTLINE_BOUNDARY_LOOP_OPEN -> eb
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW -> ec
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_FRACTION -> ed
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_ADDITION -> ee
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_SUBTRACTION -> ef
    org.apache.commons.math3.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD -> eg
    org.apache.commons.math3.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD -> eh
    org.apache.commons.math3.exception.util.LocalizedFormats PERMUTATION_EXCEEDS_N -> ei
    org.apache.commons.math3.exception.util.LocalizedFormats POLYNOMIAL -> ej
    org.apache.commons.math3.exception.util.LocalizedFormats POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS -> ek
    org.apache.commons.math3.exception.util.LocalizedFormats POPULATION_LIMIT_NOT_POSITIVE -> el
    org.apache.commons.math3.exception.util.LocalizedFormats POWER_NEGATIVE_PARAMETERS -> em
    org.apache.commons.math3.exception.util.LocalizedFormats PROPAGATION_DIRECTION_MISMATCH -> en
    org.apache.commons.math3.exception.util.LocalizedFormats RANDOMKEY_MUTATION_WRONG_CLASS -> eo
    org.apache.commons.math3.exception.util.LocalizedFormats ROOTS_OF_UNITY_NOT_COMPUTED_YET -> ep
    org.apache.commons.math3.exception.util.LocalizedFormats ROTATION_MATRIX_DIMENSIONS -> eq
    org.apache.commons.math3.exception.util.LocalizedFormats ROW_INDEX_OUT_OF_RANGE -> er
    org.apache.commons.math3.exception.util.LocalizedFormats ROW_INDEX -> Y
    org.apache.commons.math3.exception.util.LocalizedFormats SAME_SIGN_AT_ENDPOINTS -> Z
    org.apache.commons.math3.exception.util.LocalizedFormats SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE -> es
    org.apache.commons.math3.exception.util.LocalizedFormats SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE -> et
    org.apache.commons.math3.exception.util.LocalizedFormats SIMPLEX_NEED_ONE_POINT -> eu
    org.apache.commons.math3.exception.util.LocalizedFormats SIMPLE_MESSAGE -> ev
    org.apache.commons.math3.exception.util.LocalizedFormats SINGULAR_MATRIX -> aa
    org.apache.commons.math3.exception.util.LocalizedFormats SINGULAR_OPERATOR -> ew
    org.apache.commons.math3.exception.util.LocalizedFormats SUBARRAY_ENDS_AFTER_ARRAY_END -> ab
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_LARGE_CUTOFF_SINGULAR_VALUE -> ex
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_LARGE_TOURNAMENT_ARITY -> ey
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY -> ez
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_MANY_REGRESSORS -> eA
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_COST_RELATIVE_TOLERANCE -> ac
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_INTEGRATION_INTERVAL -> eB
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_ORTHOGONALITY_TOLERANCE -> ad
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE -> ae
    org.apache.commons.math3.exception.util.LocalizedFormats TRUST_REGION_STEP_FAILED -> eC
    org.apache.commons.math3.exception.util.LocalizedFormats TWO_OR_MORE_CATEGORIES_REQUIRED -> eD
    org.apache.commons.math3.exception.util.LocalizedFormats TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED -> eE
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH -> eF
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM -> eG
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS -> eH
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_ORTHOGONOLIZE_MATRIX -> eI
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN -> af
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_SOLVE_SINGULAR_PROBLEM -> eJ
    org.apache.commons.math3.exception.util.LocalizedFormats UNBOUNDED_SOLUTION -> ag
    org.apache.commons.math3.exception.util.LocalizedFormats UNKNOWN_MODE -> eK
    org.apache.commons.math3.exception.util.LocalizedFormats UNKNOWN_PARAMETER -> eL
    org.apache.commons.math3.exception.util.LocalizedFormats UNMATCHED_ODE_IN_EXPANDED_SET -> eM
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_PARSE_AS_TYPE -> eN
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_PARSE -> eO
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_3D_VECTOR -> eP
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_COMPLEX_NUMBER -> eQ
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_REAL_VECTOR -> eR
    org.apache.commons.math3.exception.util.LocalizedFormats UNSUPPORTED_EXPANSION_MODE -> eS
    org.apache.commons.math3.exception.util.LocalizedFormats UNSUPPORTED_OPERATION -> ah
    org.apache.commons.math3.exception.util.LocalizedFormats ARITHMETIC_EXCEPTION -> ai
    org.apache.commons.math3.exception.util.LocalizedFormats ILLEGAL_STATE -> aj
    org.apache.commons.math3.exception.util.LocalizedFormats USER_EXCEPTION -> eT
    org.apache.commons.math3.exception.util.LocalizedFormats URL_CONTAINS_NO_DATA -> eU
    org.apache.commons.math3.exception.util.LocalizedFormats VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC -> eV
    org.apache.commons.math3.exception.util.LocalizedFormats VECTOR_LENGTH_MISMATCH -> eW
    org.apache.commons.math3.exception.util.LocalizedFormats VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT -> ak
    org.apache.commons.math3.exception.util.LocalizedFormats WEIGHT_AT_LEAST_ONE_NON_ZERO -> eX
    org.apache.commons.math3.exception.util.LocalizedFormats WRONG_BLOCK_LENGTH -> eY
    org.apache.commons.math3.exception.util.LocalizedFormats WRONG_NUMBER_OF_POINTS -> eZ
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_POINTS -> al
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_DENOMINATOR -> am
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_DENOMINATOR_IN_FRACTION -> fa
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_FRACTION_TO_DIVIDE_BY -> fb
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM -> an
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_AXIS -> fc
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR -> fd
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NOT_ALLOWED -> ao
    java.lang.String sourceFormat -> a
    java.lang.String getLocalizedString(java.util.Locale) -> a
org.apache.commons.math3.fraction.BigFraction -> hg:
    org.apache.commons.math3.fraction.BigFraction ONE -> a
    org.apache.commons.math3.fraction.BigFraction ZERO -> b
    org.apache.commons.math3.fraction.BigFraction MINUS_ONE -> c
    java.math.BigInteger numerator -> a
    java.math.BigInteger denominator -> b
    org.apache.commons.math3.fraction.BigFraction add(org.apache.commons.math3.fraction.BigFraction) -> a
    int compareTo(org.apache.commons.math3.fraction.BigFraction) -> a
    org.apache.commons.math3.fraction.BigFraction divide(org.apache.commons.math3.fraction.BigFraction) -> b
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    float floatValue() -> floatValue
    int hashCode() -> hashCode
    int intValue() -> intValue
    long longValue() -> longValue
    org.apache.commons.math3.fraction.BigFraction multiply(org.apache.commons.math3.fraction.BigFraction) -> c
    org.apache.commons.math3.fraction.BigFraction negate() -> a
    org.apache.commons.math3.fraction.BigFraction reciprocal() -> b
    org.apache.commons.math3.fraction.BigFraction reduce() -> c
    org.apache.commons.math3.fraction.BigFraction subtract(org.apache.commons.math3.fraction.BigFraction) -> d
    java.lang.String toString() -> toString
    org.apache.commons.math3.Field getField() -> a
    java.lang.Object reciprocal() -> b
    java.lang.Object divide(java.lang.Object) -> d
    java.lang.Object multiply(java.lang.Object) -> c
    java.lang.Object negate() -> a
    java.lang.Object subtract(java.lang.Object) -> b
    java.lang.Object add(java.lang.Object) -> a
    int compareTo(java.lang.Object) -> compareTo
org.apache.commons.math3.fraction.BigFractionField -> hh:
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
org.apache.commons.math3.fraction.BigFractionField$LazyHolder -> hi:
    org.apache.commons.math3.fraction.BigFractionField INSTANCE -> a
    org.apache.commons.math3.fraction.BigFractionField access$000() -> a
org.apache.commons.math3.fraction.FractionConversionException -> hj:
org.apache.commons.math3.linear.AbstractFieldMatrix -> hk:
    org.apache.commons.math3.Field field -> a
    org.apache.commons.math3.Field extractField(org.apache.commons.math3.FieldElement[][]) -> a
    org.apache.commons.math3.Field getField() -> a
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.FieldMatrix scalarMultiply(org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.FieldElement[][] getData() -> a
    org.apache.commons.math3.FieldElement[] getRow(int) -> a
    void setRow(int,org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.FieldElement getEntry(int,int) -> a
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> a
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.linear.FieldVector operate(org.apache.commons.math3.linear.FieldVector) -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void checkRowIndex(int) -> a
    void checkColumnIndex(int) -> b
    void checkMultiplicationCompatible(org.apache.commons.math3.linear.FieldMatrix) -> a
org.apache.commons.math3.linear.AbstractRealMatrix -> hl:
    org.apache.commons.math3.linear.RealMatrixFormat DEFAULT_FORMAT -> a
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> a
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    org.apache.commons.math3.linear.RealVector getRowVector(int) -> a
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> a
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> b
    double[] getRow(int) -> a
    org.apache.commons.math3.linear.RealMatrix transpose() -> a
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
    org.apache.commons.math3.linear.RealVector operate(org.apache.commons.math3.linear.RealVector) -> a
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> a
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
org.apache.commons.math3.linear.AbstractRealMatrix$5 -> hm:
    org.apache.commons.math3.linear.RealMatrix val$out -> a
    void visit(int,int,double) -> a
org.apache.commons.math3.linear.AnyMatrix -> hn:
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
org.apache.commons.math3.linear.Array2DRowFieldMatrix -> ho:
    org.apache.commons.math3.FieldElement[][] data -> a
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.FieldMatrix copy() -> a
    org.apache.commons.math3.FieldElement[][] getData() -> a
    org.apache.commons.math3.FieldElement getEntry(int,int) -> a
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> a
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> b
    int getRowDimension() -> a
    int getColumnDimension() -> b
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.FieldElement[][] copyOut() -> b
org.apache.commons.math3.linear.Array2DRowRealMatrix -> hp:
    double[][] data -> a
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix copy() -> b
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> a
    double[][] copyOut() -> b
org.apache.commons.math3.linear.ArrayFieldVector -> hq:
    org.apache.commons.math3.FieldElement[] data -> a
    org.apache.commons.math3.Field field -> a
    org.apache.commons.math3.FieldElement[] getData() -> a
    org.apache.commons.math3.FieldElement dotProduct(org.apache.commons.math3.linear.FieldVector) -> a
    org.apache.commons.math3.FieldElement getEntry(int) -> a
    int getDimension() -> a
    void checkVectorDimensions(int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.linear.ArrayRealVector -> hr:
    org.apache.commons.math3.linear.RealVectorFormat DEFAULT_FORMAT -> a
    double[] data -> a
    org.apache.commons.math3.linear.ArrayRealVector copy() -> a
    org.apache.commons.math3.linear.RealVector mapMultiplyToSelf(double) -> a
    double dotProduct(org.apache.commons.math3.linear.RealVector) -> a
    double getEntry(int) -> a
    int getDimension() -> a
    void setEntry(int,double) -> a
    double[] toArray() -> a
    java.lang.String toString() -> toString
    void checkVectorDimensions(org.apache.commons.math3.linear.RealVector) -> a
    void checkVectorDimensions(int) -> a
    boolean isNaN() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.linear.RealVector mapToSelf(org.apache.commons.math3.analysis.UnivariateFunction) -> a
    org.apache.commons.math3.linear.RealVector copy() -> a
    org.apache.commons.math3.linear.RealVector subtract(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.linear.BlockFieldMatrix -> hs:
    org.apache.commons.math3.FieldElement[][] blocks -> a
    int rows -> a
    int columns -> b
    int blockRows -> c
    int blockColumns -> d
    org.apache.commons.math3.FieldElement[][] toBlocksLayout(org.apache.commons.math3.FieldElement[][]) -> a
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.FieldMatrix copy() -> a
    org.apache.commons.math3.linear.FieldMatrix scalarMultiply(org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.FieldElement[][] getData() -> a
    org.apache.commons.math3.FieldElement[] getRow(int) -> a
    void setRow(int,org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.FieldElement getEntry(int,int) -> a
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> a
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> b
    int getRowDimension() -> a
    int getColumnDimension() -> b
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> a
    int blockHeight(int) -> a
    int blockWidth(int) -> b
org.apache.commons.math3.linear.BlockRealMatrix -> ht:
    double[][] blocks -> a
    int rows -> a
    int columns -> b
    int blockRows -> c
    int blockColumns -> d
    double[][] toBlocksLayout(double[][]) -> a
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> a
    org.apache.commons.math3.linear.BlockRealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    org.apache.commons.math3.linear.RealVector getRowVector(int) -> a
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> a
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> b
    double[] getRow(int) -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> a
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> b
    int blockHeight(int) -> a
    int blockWidth(int) -> b
    org.apache.commons.math3.linear.RealMatrix copy() -> b
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix transpose() -> a
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
org.apache.commons.math3.linear.DecompositionSolver -> hu:
    double[][] lu -> a
    int[] pivot -> a
    boolean singular -> a
    boolean isNonSingular() -> a
    org.apache.commons.math3.linear.RealMatrix getInverse() -> a
    org.apache.commons.math3.linear.RealMatrix solve(org.apache.commons.math3.linear.RealMatrix) -> a
org.apache.commons.math3.linear.DiagonalMatrix -> hv:
    double[] data -> a
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix copy() -> b
    org.apache.commons.math3.linear.DiagonalMatrix multiply(org.apache.commons.math3.linear.DiagonalMatrix) -> a
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
    double[][] getData() -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
org.apache.commons.math3.linear.EigenDecomposition -> hw:
    byte maxIter -> a
    double[] main -> b
    double[] secondary -> c
    org.apache.commons.math3.linear.TriDiagonalTransformer transformer -> a
    double[] realEigenvalues -> a
    double[] imagEigenvalues -> d
    org.apache.commons.math3.linear.ArrayRealVector[] eigenvectors -> a
    org.apache.commons.math3.linear.RealMatrix cachedV -> a
    org.apache.commons.math3.linear.RealMatrix cachedVt -> b
    boolean isSymmetric -> a
    double[] getRealEigenvalues() -> a
    double[] getImagEigenvalues() -> b
    void findEigenVectors(double[][]) -> a
    org.apache.commons.math3.linear.SchurTransformer transformToSchur(org.apache.commons.math3.linear.RealMatrix) -> a
    org.apache.commons.math3.complex.Complex cdiv(double,double,double,double) -> a
    void findEigenVectorsFromSchur(org.apache.commons.math3.linear.SchurTransformer) -> a
org.apache.commons.math3.linear.FieldDecompositionSolver -> hx:
    org.apache.commons.math3.Field field -> a
    org.apache.commons.math3.FieldElement[][] lu -> a
    int[] pivot -> a
    boolean singular -> a
    org.apache.commons.math3.linear.FieldVector solve(org.apache.commons.math3.linear.FieldVector) -> a
    boolean isNonSingular() -> a
    org.apache.commons.math3.linear.FieldMatrix getInverse() -> a
    org.apache.commons.math3.linear.ArrayFieldVector solve(org.apache.commons.math3.linear.ArrayFieldVector) -> a
    org.apache.commons.math3.linear.FieldMatrix solve(org.apache.commons.math3.linear.FieldMatrix) -> a
org.apache.commons.math3.linear.FieldLUDecomposition -> hy:
    org.apache.commons.math3.Field field -> a
    org.apache.commons.math3.FieldElement[][] lu -> a
    int[] pivot -> a
    boolean even -> a
    boolean singular -> b
    org.apache.commons.math3.linear.FieldMatrix cachedL -> a
    org.apache.commons.math3.linear.FieldMatrix cachedU -> b
    int[] getPivot() -> a
    org.apache.commons.math3.linear.FieldDecompositionSolver getSolver() -> a
org.apache.commons.math3.linear.FieldMatrix -> hz:
    org.apache.commons.math3.Field getField() -> a
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.FieldMatrix copy() -> a
    org.apache.commons.math3.linear.FieldMatrix scalarMultiply(org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.FieldElement[][] getData() -> a
    org.apache.commons.math3.FieldElement[] getRow(int) -> a
    void setRow(int,org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.FieldElement getEntry(int,int) -> a
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> a
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> b
    org.apache.commons.math3.linear.FieldVector operate(org.apache.commons.math3.linear.FieldVector) -> a
org.apache.commons.math3.linear.FieldVector -> hA:
    org.apache.commons.math3.FieldElement[] getData() -> a
    org.apache.commons.math3.FieldElement dotProduct(org.apache.commons.math3.linear.FieldVector) -> a
    org.apache.commons.math3.FieldElement getEntry(int) -> a
    int getDimension() -> a
org.apache.commons.math3.linear.HessenbergTransformer -> hB:
    double[][] householderVectors -> a
    double[] ort -> a
    org.apache.commons.math3.linear.RealMatrix cachedP -> a
    org.apache.commons.math3.linear.RealMatrix cachedH -> b
    org.apache.commons.math3.linear.RealMatrix getP() -> a
    org.apache.commons.math3.linear.RealMatrix getH() -> b
    void transform() -> a
org.apache.commons.math3.linear.LUDecomposition -> hC:
    double[][] lu -> a
    int[] pivot -> a
    boolean even -> a
    boolean singular -> b
org.apache.commons.math3.linear.MatrixDimensionMismatchException -> hD:
org.apache.commons.math3.linear.MatrixUtils -> hE:
    org.apache.commons.math3.linear.RealMatrix createRealMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix createRealMatrix(double[][]) -> a
    org.apache.commons.math3.linear.RealMatrix createRealIdentityMatrix(int) -> a
    org.apache.commons.math3.linear.RealMatrix createRealDiagonalMatrix(double[]) -> a
    boolean isSymmetric(org.apache.commons.math3.linear.RealMatrix,double) -> a
    void checkMatrixIndex(org.apache.commons.math3.linear.AnyMatrix,int,int) -> a
    void checkRowIndex(org.apache.commons.math3.linear.AnyMatrix,int) -> a
    void checkColumnIndex(org.apache.commons.math3.linear.AnyMatrix,int) -> b
    void checkSubMatrixIndex(org.apache.commons.math3.linear.AnyMatrix,int,int,int,int) -> a
    void checkMultiplicationCompatible(org.apache.commons.math3.linear.AnyMatrix,org.apache.commons.math3.linear.AnyMatrix) -> a
org.apache.commons.math3.linear.NonSquareMatrixException -> hF:
org.apache.commons.math3.linear.RealLinearOperator -> hG:
org.apache.commons.math3.linear.RealMatrix -> hH:
    org.apache.commons.math3.linear.RealMatrix copy() -> b
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> a
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
    double[][] getData() -> a
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> a
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> b
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    org.apache.commons.math3.linear.RealMatrix transpose() -> a
    double[] operate(double[]) -> a
    org.apache.commons.math3.linear.RealVector operate(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.linear.RealMatrixFormat -> hI:
    java.lang.String prefix -> a
    java.lang.String suffix -> b
    java.lang.String rowPrefix -> c
    java.lang.String rowSuffix -> d
    java.lang.String rowSeparator -> e
    java.lang.String columnSeparator -> f
    java.text.NumberFormat format -> a
    org.apache.commons.math3.linear.RealMatrixFormat getInstance(java.util.Locale) -> a
    java.lang.StringBuffer format(org.apache.commons.math3.linear.RealMatrix,java.lang.StringBuffer,java.text.FieldPosition) -> a
org.apache.commons.math3.linear.RealMatrixPreservingVisitor -> hJ:
    void visit(int,int,double) -> a
org.apache.commons.math3.linear.RealVector -> hK:
    int getDimension() -> a
    double getEntry(int) -> a
    void setEntry(int,double) -> a
    boolean isNaN() -> a
    void checkVectorDimensions(org.apache.commons.math3.linear.RealVector) -> a
    void checkVectorDimensions(int) -> a
    org.apache.commons.math3.linear.RealVector subtract(org.apache.commons.math3.linear.RealVector) -> a
    org.apache.commons.math3.linear.RealVector copy() -> a
    double dotProduct(org.apache.commons.math3.linear.RealVector) -> a
    org.apache.commons.math3.linear.RealVector mapMultiply(double) -> b
    org.apache.commons.math3.linear.RealVector mapMultiplyToSelf(double) -> a
    double[] toArray() -> a
    java.util.Iterator iterator() -> a
    org.apache.commons.math3.linear.RealVector mapToSelf(org.apache.commons.math3.analysis.UnivariateFunction) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.linear.RealVector$1 -> hL:
    int i -> a
    org.apache.commons.math3.linear.RealVector$Entry e -> a
    int val$dim -> b
    org.apache.commons.math3.linear.RealVector this$0 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.apache.commons.math3.linear.RealVector$Entry -> hM:
    int index -> a
    org.apache.commons.math3.linear.RealVector this$0 -> a
    double getValue() -> a
org.apache.commons.math3.linear.RealVectorFormat -> hN:
    java.lang.String prefix -> a
    java.lang.String suffix -> b
    java.lang.String separator -> c
    java.text.NumberFormat format -> a
    java.lang.StringBuffer format(org.apache.commons.math3.linear.RealVector,java.lang.StringBuffer,java.text.FieldPosition) -> a
org.apache.commons.math3.linear.SchurTransformer -> hO:
    double[][] matrixP -> a
    double[][] matrixT -> b
    org.apache.commons.math3.linear.RealMatrix cachedP -> a
    org.apache.commons.math3.linear.RealMatrix cachedT -> b
    double epsilon -> a
    org.apache.commons.math3.linear.RealMatrix getT() -> a
    void transform() -> a
org.apache.commons.math3.linear.SchurTransformer$ShiftInfo -> hP:
    double x -> a
    double y -> b
    double w -> c
    double exShift -> d
org.apache.commons.math3.linear.SingularMatrixException -> hQ:
org.apache.commons.math3.linear.SingularValueDecomposition -> hR:
    double[] singularValues -> a
    int m -> a
    int n -> b
    boolean transposed -> a
    org.apache.commons.math3.linear.RealMatrix cachedU -> a
    org.apache.commons.math3.linear.RealMatrix cachedS -> b
    org.apache.commons.math3.linear.RealMatrix cachedV -> c
org.apache.commons.math3.linear.TriDiagonalTransformer -> hS:
    double[][] householderVectors -> a
    double[] main -> a
    double[] secondary -> b
    org.apache.commons.math3.linear.RealMatrix cachedQ -> a
    org.apache.commons.math3.linear.RealMatrix cachedQt -> b
    org.apache.commons.math3.linear.RealMatrix getQT() -> a
    void transform() -> a
org.apache.commons.math3.optim.BaseMultivariateOptimizer -> hT:
    double[] start -> a
    double[] lowerBound -> b
    double[] upperBound -> c
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.BaseOptimizer -> hU:
    org.apache.commons.math3.util.Incrementor evaluations -> a
    org.apache.commons.math3.util.Incrementor iterations -> b
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object doOptimize() -> a
    void incrementIterationCount() -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.BaseOptimizer$MaxEvalCallback -> hV:
    void trigger(int) -> a
org.apache.commons.math3.optim.BaseOptimizer$MaxIterCallback -> hW:
    void trigger(int) -> a
org.apache.commons.math3.optim.InitialGuess -> hX:
    double[] init -> a
    double[] getInitialGuess() -> a
org.apache.commons.math3.optim.MaxEval -> hY:
    int maxEval -> a
org.apache.commons.math3.optim.MaxIter -> hZ:
    int maxIter -> a
org.apache.commons.math3.optim.PointValuePair -> ia:
    double[] getPoint() -> a
org.apache.commons.math3.optim.SimpleBounds -> ib:
    double[] lower -> a
    double[] upper -> b
    double[] getLower() -> a
    double[] getUpper() -> b
org.apache.commons.math3.optim.linear.LinearConstraint -> ic:
    org.apache.commons.math3.linear.RealVector coefficients -> a
    org.apache.commons.math3.optim.linear.Relationship relationship -> a
    double value -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.optim.linear.LinearConstraintSet -> id:
    java.util.Set linearConstraints -> a
org.apache.commons.math3.optim.linear.LinearObjectiveFunction -> ie:
    org.apache.commons.math3.linear.RealVector coefficients -> a
    double constantTerm -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.optim.linear.LinearOptimizer -> if:
    org.apache.commons.math3.optim.linear.LinearObjectiveFunction function -> a
    java.util.Collection linearConstraints -> a
    boolean nonNegative -> a
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.linear.NoFeasibleSolutionException -> ig:
org.apache.commons.math3.optim.linear.NonNegativeConstraint -> ih:
    boolean isRestricted -> a
org.apache.commons.math3.optim.linear.PivotSelectionRule -> ii:
    org.apache.commons.math3.optim.linear.PivotSelectionRule DANTZIG -> a
    org.apache.commons.math3.optim.linear.PivotSelectionRule BLAND -> b
org.apache.commons.math3.optim.linear.Relationship -> ij:
    org.apache.commons.math3.optim.linear.Relationship EQ -> a
    org.apache.commons.math3.optim.linear.Relationship LEQ -> b
    org.apache.commons.math3.optim.linear.Relationship GEQ -> c
    java.lang.String stringValue -> a
    org.apache.commons.math3.optim.linear.Relationship[] $VALUES -> a
    org.apache.commons.math3.optim.linear.Relationship[] values() -> a
    java.lang.String toString() -> toString
org.apache.commons.math3.optim.linear.Relationship$1 -> ik:
    int[] $SwitchMap$org$apache$commons$math3$optim$linear$Relationship -> a
org.apache.commons.math3.optim.linear.SimplexSolver -> il:
    double epsilon -> a
    int maxUlps -> a
    double cutOff -> b
    org.apache.commons.math3.optim.linear.PivotSelectionRule pivotSelection -> a
    org.apache.commons.math3.optim.linear.SolutionCallback solutionCallback -> a
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void doIteration(org.apache.commons.math3.optim.linear.SimplexTableau) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object doOptimize() -> a
org.apache.commons.math3.optim.linear.SimplexTableau -> im:
    org.apache.commons.math3.optim.linear.LinearObjectiveFunction f -> a
    java.util.List constraints -> a
    boolean restrictToNonNegative -> a
    java.util.List columnLabels -> b
    org.apache.commons.math3.linear.Array2DRowRealMatrix tableau -> a
    int numDecisionVariables -> b
    int numSlackVariables -> c
    int numArtificialVariables -> a
    double epsilon -> a
    int maxUlps -> d
    int[] basicVariables -> b
    int[] basicRows -> a
    void initializeColumnLabels() -> b
    org.apache.commons.math3.linear.Array2DRowRealMatrix createTableau(boolean) -> a
    java.util.List normalizeConstraints(java.util.Collection) -> a
    int getNumObjectiveFunctions() -> a
    int getConstraintTypeCounts(org.apache.commons.math3.optim.linear.Relationship) -> a
    double getInvertedCoefficientSum(org.apache.commons.math3.linear.RealVector) -> a
    java.lang.Integer getBasicRow(int) -> a
    void initializeBasicVariables(int) -> a
    void dropPhase1Objective() -> a
    void copyArray(double[],double[]) -> a
    boolean isOptimal() -> a
    org.apache.commons.math3.optim.PointValuePair getSolution() -> a
    void performRowOperations(int,int) -> a
    double getEntry(int,int) -> a
    int getSlackVariableOffset() -> d
    int getArtificialVariableOffset() -> b
    int getRhsOffset() -> c
    int getOriginalNumDecisionVariables() -> e
    double[] getRow(int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.optim.linear.SolutionCallback -> in:
org.apache.commons.math3.optim.linear.UnboundedSolutionException -> io:
org.apache.commons.math3.optim.nonlinear.scalar.GoalType -> ip:
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType MAXIMIZE -> a
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType MINIMIZE -> b
org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer -> iq:
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal -> a
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction -> ir:
    org.apache.commons.math3.analysis.ParametricUnivariateFunction f -> a
    org.apache.commons.math3.optimization.fitting.CurveFitter this$0 -> a
    double[] value(double[]) -> a
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure[] value(org.apache.commons.math3.analysis.differentiation.DerivativeStructure[]) -> a
    boolean getValue() -> a
org.apache.commons.math3.optimization.BaseMultivariateVectorOptimizer -> is:
    org.apache.commons.math3.optimization.PointVectorValuePair optimize(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,double[],double[],double[]) -> a
org.apache.commons.math3.optimization.ConvergenceChecker -> it:
    boolean converged$51f99816() -> a
org.apache.commons.math3.optimization.InitialGuess -> iu:
    double[] init -> a
    double[] getInitialGuess() -> a
org.apache.commons.math3.optimization.PointVectorValuePair -> iv:
    double[] getPoint() -> a
    java.lang.Object getValue() -> a
org.apache.commons.math3.optimization.Target -> iw:
    double[] target -> a
    double[] getTarget() -> a
org.apache.commons.math3.optimization.Weight -> ix:
    org.apache.commons.math3.linear.RealMatrix weightMatrix -> a
org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateVectorOptimizer -> iy:
    org.apache.commons.math3.util.Incrementor evaluations -> a
    org.apache.commons.math3.optimization.ConvergenceChecker checker -> a
    double[] target -> a
    org.apache.commons.math3.linear.RealMatrix weightMatrix -> a
    double[] weight -> b
    double[] start -> c
    org.apache.commons.math3.analysis.MultivariateVectorFunction function -> a
    double[] computeObjectiveValue(double[]) -> a
    org.apache.commons.math3.optimization.PointVectorValuePair optimize(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,double[],double[],double[]) -> a
    org.apache.commons.math3.optimization.PointVectorValuePair optimizeInternal$4b638827(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    double[] getStartPoint() -> a
    org.apache.commons.math3.linear.RealMatrix getWeight() -> a
    double[] getTarget() -> b
    org.apache.commons.math3.optimization.PointVectorValuePair doOptimize() -> a
    void setUp() -> a
org.apache.commons.math3.optimization.fitting.CurveFitter -> iz:
    org.apache.commons.math3.analysis.DifferentiableUnivariateFunction oldOptimizer$11dadcd7 -> a
    cc.redberry.core.math.frobenius.SolutionProvider optimizer$4f2d0069 -> a
    java.util.List observations -> a
    void addObservedPoint(double,double,double) -> a
org.apache.commons.math3.optimization.fitting.CurveFitter$OldTheoreticalValuesFunction -> iA:
    org.apache.commons.math3.analysis.ParametricUnivariateFunction f -> a
    org.apache.commons.math3.optimization.fitting.CurveFitter this$0 -> a
    org.apache.commons.math3.analysis.MultivariateMatrixFunction jacobian() -> a
    double[] value(double[]) -> a
org.apache.commons.math3.optimization.fitting.CurveFitter$OldTheoreticalValuesFunction$1 -> iB:
    org.apache.commons.math3.optimization.fitting.CurveFitter$OldTheoreticalValuesFunction this$1 -> a
    double[][] value(double[]) -> a
org.apache.commons.math3.optimization.fitting.PolynomialFitter -> iC:
    int degree -> a
org.apache.commons.math3.optimization.fitting.WeightedObservedPoint -> iD:
    double weight -> a
    double x -> b
    double y -> c
org.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer -> iE:
    double[] point -> a
    org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction jF -> a
    int jacobianEvaluations -> a
    org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt -> a
    double computeCost(double[]) -> a
    void setUp() -> a
    double[] computeResiduals(double[]) -> b
    org.apache.commons.math3.optimization.PointVectorValuePair optimize(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,double[],double[],double[]) -> a
org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer -> iF:
    int solvedCols -> b
    double[] diagR -> b
    double[] jacNorm -> c
    double[] beta -> d
    int[] permutation -> a
    int rank -> c
    double lmPar -> a
    double[] lmDir -> e
    double initialStepBoundFactor -> b
    double costRelativeTolerance -> c
    double parRelativeTolerance -> d
    double orthoTolerance -> e
    double qrRankingThreshold -> f
    double[] weightedResidual -> f
    double[][] weightedJacobian -> a
    org.apache.commons.math3.optimization.PointVectorValuePair doOptimize() -> a
org.apache.commons.math3.special.Gamma -> iG:
    double[] LANCZOS -> a
    double HALF_LOG_2_PI -> a
    double logGamma(double) -> a
    double regularizedGammaP(double,double,double,int) -> a
    double logGamma1p(double) -> b
org.apache.commons.math3.special.Gamma$1 -> iH:
    double val$a -> a
    double getA(int,double) -> a
    double getB$255dfbe(int) -> a
org.apache.commons.math3.stat.StatUtils -> iI:
    org.apache.commons.math3.stat.descriptive.moment.GeometricMean GEOMETRIC_MEAN -> a
    double geometricMean(double[]) -> a
org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic -> iJ:
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
    void clear() -> a
    double getResult() -> a
    void increment(double) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic -> iK:
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic -> iL:
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
org.apache.commons.math3.stat.descriptive.UnivariateStatistic -> iM:
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.moment.FirstMoment -> iN:
    long n -> a
    double m1 -> a
    double dev -> b
    double nDev -> c
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
org.apache.commons.math3.stat.descriptive.moment.GeometricMean -> iO:
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic sumOfLogs -> a
    void increment(double) -> a
    double getResult() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
    long getN() -> a
org.apache.commons.math3.stat.descriptive.moment.Mean -> iP:
    org.apache.commons.math3.stat.descriptive.moment.FirstMoment moment -> a
    boolean incMoment -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.moment.SecondMoment -> iQ:
    double m2 -> d
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
org.apache.commons.math3.stat.descriptive.moment.Variance -> iR:
    org.apache.commons.math3.stat.descriptive.moment.SecondMoment moment -> a
    boolean incMoment -> a
    boolean isBiasCorrected -> b
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Max -> iS:
    long n -> a
    double value -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Min -> iT:
    long n -> a
    double value -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile -> iU:
    double quantile -> a
    int[] cachedPivots -> a
    double evaluate(double[],int,int) -> a
    double select(double[],int[],int) -> a
org.apache.commons.math3.stat.descriptive.summary.Product -> iV:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.summary.Sum -> iW:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.summary.SumOfLogs -> iX:
    int n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.summary.SumOfSquares -> iY:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.transform.DftNormalization -> iZ:
    int STANDARD$1f30b0a8 -> a
    int UNITARY$1f30b0a8 -> b
    int[] $VALUES$289551dd -> a
    int[] values$86c13e2() -> a
org.apache.commons.math3.transform.FastFourierTransformer -> ja:
    double[] W_SUB_N_R -> a
    double[] W_SUB_N_I -> b
    int normalization$1f30b0a8 -> a
    boolean $assertionsDisabled -> a
    void normalizeTransformedData$394e5a16(double[][],int,int) -> a
org.apache.commons.math3.transform.FastFourierTransformer$1 -> jb:
    int[] $SwitchMap$org$apache$commons$math3$transform$DftNormalization -> a
org.apache.commons.math3.transform.TransformUtils -> jc:
    org.apache.commons.math3.complex.Complex[] createComplexArray(double[][]) -> a
org.apache.commons.math3.util.ContinuedFraction -> jd:
    double getA(int,double) -> a
    double getB$255dfbe(int) -> a
    double evaluate(double,double,int) -> a
org.apache.commons.math3.util.FastMath -> je:
    double[][] LN_QUICK_COEF -> a
    double[][] LN_HI_PREC_COEF -> b
    double[] SINE_TABLE_A -> a
    double[] SINE_TABLE_B -> b
    double[] COSINE_TABLE_A -> c
    double[] COSINE_TABLE_B -> d
    double[] TANGENT_TABLE_A -> e
    double[] TANGENT_TABLE_B -> f
    long[] RECIP_2PI -> a
    long[] PI_O_4_BITS -> b
    double[] EIGHTHS -> g
    double doubleHighPart(double) -> j
    double sqrt(double) -> a
    double signum(double) -> b
    double exp(double) -> c
    double exp(double,double,double[]) -> a
    double log(double) -> d
    double log(double,double[]) -> a
    double log1p(double) -> e
    double pow(double,int) -> a
    double sinQ(double,double) -> e
    double cosQ(double,double) -> f
    void reducePayneHanek(double,double[]) -> a
    double sin(double) -> f
    double cos(double) -> g
    double atan(double,double,boolean) -> a
    double atan2(double,double) -> a
    int abs(int) -> a
    long abs(long) -> a
    double abs(double) -> h
    double scalb(double,int) -> b
    double floor(double) -> i
    int min(int,int) -> a
    double min(double,double) -> b
    int max(int,int) -> b
    double max(double,double) -> c
    double hypot(double,double) -> d
    double copySign(double,double) -> g
    int getExponent(double) -> a
    int getExponent(float) -> a
org.apache.commons.math3.util.FastMath$CodyWaite -> jf:
    int finalK -> a
    double finalRemA -> a
    double finalRemB -> b
org.apache.commons.math3.util.FastMath$ExpFracTable -> jg:
    double[] EXP_FRAC_TABLE_A -> a
    double[] EXP_FRAC_TABLE_B -> b
    double[] access$200() -> a
    double[] access$300() -> b
org.apache.commons.math3.util.FastMath$ExpIntTable -> jh:
    double[] EXP_INT_TABLE_A -> a
    double[] EXP_INT_TABLE_B -> b
    double[] access$000() -> a
    double[] access$100() -> b
org.apache.commons.math3.util.FastMath$lnMant -> ji:
    double[][] LN_MANT -> a
    double[][] access$400() -> a
org.apache.commons.math3.util.FastMathLiteralArrays -> jj:
    double[] EXP_INT_A -> a
    double[] EXP_INT_B -> b
    double[] EXP_FRAC_A -> c
    double[] EXP_FRAC_B -> d
    double[][] LN_MANT -> a
    double[] loadExpIntA() -> a
    double[] loadExpIntB() -> b
    double[] loadExpFracA() -> c
    double[] loadExpFracB() -> d
    double[][] loadLnMant() -> a
org.apache.commons.math3.util.Incrementor -> jk:
    int maximalCount -> a
    int count -> b
    org.apache.commons.math3.util.Incrementor$MaxCountExceededCallback maxCountCallback -> a
    void incrementCount() -> a
org.apache.commons.math3.util.Incrementor$1 -> jl:
    void trigger(int) -> a
org.apache.commons.math3.util.Incrementor$MaxCountExceededCallback -> jm:
    void trigger(int) -> a
org.apache.commons.math3.util.MathArrays$3 -> jn:
    int[] $SwitchMap$org$apache$commons$math3$util$MathArrays$OrderDirection -> a
    int[] $SwitchMap$org$apache$commons$math3$util$MathArrays$Position -> b
org.apache.commons.math3.util.MathArrays$OrderDirection -> jo:
    int INCREASING$37efe540 -> a
    int DECREASING$37efe540 -> b
    int[] $VALUES$50371d45 -> a
    int[] values$121350fa() -> a
org.apache.commons.math3.util.MathArrays$Position -> jp:
    int HEAD$748fd098 -> a
    int TAIL$748fd098 -> b
    int[] $VALUES$2890f0d3 -> a
    int[] values$75deba52() -> a
org.apache.commons.math3.util.Pair -> jq:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.Object getValue() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.apache.commons.math3.util.Precision -> jr:
    double EPSILON -> a
    double SAFE_MIN -> b
    int compareTo(double,double,double) -> a
    boolean equalsIncludingNaN(float,float) -> a
    boolean equals(double,double) -> a
    boolean equalsIncludingNaN(double,double) -> b
    boolean equals(double,double,double) -> a
    boolean equals(double,double,int) -> a
org.matheclipse.combinatoric.AbstractListStepVisitor -> js:
    java.util.List list -> a
    java.lang.Object[] array -> a
    void toIntArray(java.util.List,int,int) -> a
    boolean visit(int[][]) -> a
    int[] getMultisetArray() -> a
org.matheclipse.combinatoric.IStepVisitor -> jt:
    boolean visit(int[][]) -> a
    int[] getMultisetArray() -> a
org.matheclipse.combinatoric.MultisetCombinationIterator -> ju:
    int[] result -> a
    int[] multiset -> b
    int n -> a
    int k -> b
    int[] next() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.combinatoric.MultisetPartitionsIterator -> jv:
    int n -> a
    int[] multiset -> a
    int[][] result -> a
    org.matheclipse.combinatoric.RosenNumberPartitionIterator rosen -> a
    org.matheclipse.combinatoric.IStepVisitor handler -> a
    boolean execute() -> a
    void recursiveMultisetCombination(int[],int[],int) -> a
org.matheclipse.combinatoric.NumberPartitionsIterator -> jw:
    int[][] result -> a
    org.matheclipse.combinatoric.RosenNumberPartitionIterator rosen -> a
    org.matheclipse.combinatoric.IStepVisitor handler -> a
org.matheclipse.combinatoric.RosenIterator -> jx:
    int n -> a
    int k -> b
    int[] a -> a
    long count -> a
    long count(int,int) -> a
    boolean hasNext() -> hasNext
    int[] next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.combinatoric.RosenNumberPartitionIterator -> jy:
    int[] next() -> a
    java.lang.Object next() -> next
org.matheclipse.combinatoric.StopException -> jz:
org.matheclipse.commons.math.analysis.solvers.AbstractDifferentiableUnivariateSolver -> jA:
    org.apache.commons.math3.analysis.UnivariateFunction functionDerivative -> b
    double computeDerivativeObjectiveValue(double) -> b
    void setup(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
org.matheclipse.commons.math.analysis.solvers.DifferentiableUnivariateFunction -> jB:
    org.apache.commons.math3.analysis.UnivariateFunction derivative() -> a
org.matheclipse.commons.math.analysis.solvers.NewtonSolver -> jC:
    double doSolve() -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm -> jD:
    org.apache.commons.math3.linear.FieldMatrix rowReducedMatrix -> a
    org.apache.commons.math3.linear.FieldMatrix nullSpaceCache -> b
    int matrixRankCache -> a
    org.apache.commons.math3.FieldElement zero -> a
    org.apache.commons.math3.FieldElement one -> b
    int numRows -> b
    int numCols -> c
    org.apache.commons.math3.FieldElement getCoordinate(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex) -> a
    void swapRow(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex) -> a
    void multiplyAdd(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix rowReduce() -> a
    int getMatrixRank() -> a
    void scaleRow(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.apache.commons.math3.FieldElement) -> a
org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex -> jE:
    int row -> a
    int col -> b
    java.lang.String toString() -> toString
org.matheclipse.core.basic.Config -> jF:
    boolean PARSER_USE_LOWERCASE_SYMBOLS -> a
    boolean SERVER_MODE -> b
    double DOUBLE_EPSILON -> a
    double DOUBLE_TOLERANCE -> b
org.matheclipse.core.boole.QuineMcCluskyFormula -> jG:
    java.util.List termList -> a
    java.util.List originalTermList -> b
    org.matheclipse.core.interfaces.IAST variables -> a
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr toExpr() -> a
    void reduceToPrimeImplicants() -> a
    void reducePrimeImplicantsToSubset() -> b
    int extractEssentialImplicant(boolean[][]) -> a
    void extractImplicant(boolean[][],int) -> a
    int extractLargestImplicant(boolean[][]) -> b
org.matheclipse.core.boole.QuineMcCluskyTerm -> jH:
    byte[] varVals -> a
    java.lang.String toString() -> toString
    org.matheclipse.core.boole.QuineMcCluskyTerm combine(org.matheclipse.core.boole.QuineMcCluskyTerm) -> a
    int countValues(byte) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void addBytes(java.util.ArrayList,java.util.ArrayList) -> a
org.matheclipse.core.builtin.constant.Catalan -> org.matheclipse.core.builtin.constant.Catalan:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.ComplexInfinity -> org.matheclipse.core.builtin.constant.ComplexInfinity:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.constant.Degree -> org.matheclipse.core.builtin.constant.Degree:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.constant.E -> org.matheclipse.core.builtin.constant.E:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.EulerGamma -> org.matheclipse.core.builtin.constant.EulerGamma:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.Glaisher -> org.matheclipse.core.builtin.constant.Glaisher:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.GoldenRatio -> org.matheclipse.core.builtin.constant.GoldenRatio:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.I -> org.matheclipse.core.builtin.constant.I:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
org.matheclipse.core.builtin.constant.Infinity -> org.matheclipse.core.builtin.constant.Infinity:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.constant.Khinchin -> org.matheclipse.core.builtin.constant.Khinchin:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.Pi -> org.matheclipse.core.builtin.constant.Pi:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.function.Append -> org.matheclipse.core.builtin.function.Append:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.AppendTo -> org.matheclipse.core.builtin.function.AppendTo:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.AppendTo$AppendToFunction -> jI:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.Apply -> org.matheclipse.core.builtin.function.Apply:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Array -> org.matheclipse.core.builtin.function.Array:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArray(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Array$ArrayIterator -> jJ:
    int fCurrent -> a
    int fFrom -> b
    int fTo -> c
    boolean setUp() -> a
    void tearDown() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.builtin.function.AtomQ -> org.matheclipse.core.builtin.function.AtomQ:
    org.matheclipse.core.builtin.function.AtomQ CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.Attributes -> org.matheclipse.core.builtin.function.Attributes:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Blank -> org.matheclipse.core.builtin.function.Blank:
    org.matheclipse.core.builtin.function.Blank CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Block -> org.matheclipse.core.builtin.function.Block:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Break -> org.matheclipse.core.builtin.function.Break:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Cases -> org.matheclipse.core.builtin.function.Cases:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Cases$CasesPatternMatcherFunctor -> jK:
    org.matheclipse.core.patternmatching.PatternMatcher matcher -> a
    org.matheclipse.core.interfaces.IAST resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.Cases$CasesRulesFunctor -> jL:
    com.google.common.base.Function function -> a
    org.matheclipse.core.interfaces.IAST resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.Catch -> org.matheclipse.core.builtin.function.Catch:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Clear -> org.matheclipse.core.builtin.function.Clear:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.ClearAll -> org.matheclipse.core.builtin.function.ClearAll:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Condition -> org.matheclipse.core.builtin.function.Condition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean checkCondition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Continue -> org.matheclipse.core.builtin.function.Continue:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Defer -> org.matheclipse.core.builtin.function.Defer:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Definition -> org.matheclipse.core.builtin.function.Definition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Delete -> org.matheclipse.core.builtin.function.Delete:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.DeleteCases -> org.matheclipse.core.builtin.function.DeleteCases:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.DeleteCases$CasesPatternMatcherFunctor -> jM:
    org.matheclipse.core.patternmatching.PatternMatcher matcher -> a
    org.matheclipse.core.interfaces.IAST resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.DeleteCases$CasesRulesFunctor -> jN:
    com.google.common.base.Function function -> a
    org.matheclipse.core.interfaces.IAST resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.Depth -> org.matheclipse.core.builtin.function.Depth:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    int depth(org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.builtin.function.Do -> org.matheclipse.core.builtin.function.Do:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Do$DoIterator -> jO:
    java.util.List fIterList -> a
    int fIndex -> a
    org.matheclipse.core.interfaces.IExpr doIt(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.builtin.function.Drop -> org.matheclipse.core.builtin.function.Drop:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.First -> org.matheclipse.core.builtin.function.First:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.FixedPoint -> org.matheclipse.core.builtin.function.FixedPoint:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Flatten -> org.matheclipse.core.builtin.function.Flatten:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Fold -> org.matheclipse.core.builtin.function.Fold:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateNestList(org.matheclipse.core.interfaces.IAST) -> c
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.FoldList -> org.matheclipse.core.builtin.function.FoldList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateNestList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IAST foldLeft(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int,int,org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.For -> org.matheclipse.core.builtin.function.For:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.FreeQ -> org.matheclipse.core.builtin.function.FreeQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.FullForm -> org.matheclipse.core.builtin.function.FullForm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Head -> org.matheclipse.core.builtin.function.Head:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.If -> org.matheclipse.core.builtin.function.If:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Insert -> org.matheclipse.core.builtin.function.Insert:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.JavaForm -> org.matheclipse.core.builtin.function.JavaForm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Last -> org.matheclipse.core.builtin.function.Last:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.LeafCount -> org.matheclipse.core.builtin.function.LeafCount:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    int leafCount(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.builtin.function.LeafCount$LeafCountVisitor -> jP:
    int fHeadOffset -> a
    int visit(org.matheclipse.core.interfaces.IFraction) -> a
    int visit(org.matheclipse.core.interfaces.IComplex) -> a
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    int visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Length -> org.matheclipse.core.builtin.function.Length:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.MemberQ -> org.matheclipse.core.builtin.function.MemberQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Module -> org.matheclipse.core.builtin.function.Module:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean checkModuleCondition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.IExpr evalModule(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> a
    void rememberVariables(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.EvalEngine,java.lang.String,java.util.Map) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.N -> org.matheclipse.core.builtin.function.N:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Nest -> org.matheclipse.core.builtin.function.Nest:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.NestList -> org.matheclipse.core.builtin.function.NestList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.NestWhile -> org.matheclipse.core.builtin.function.NestWhile:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.NestWhileList -> org.matheclipse.core.builtin.function.NestWhileList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.NumberQ -> org.matheclipse.core.builtin.function.NumberQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.NumericQ -> org.matheclipse.core.builtin.function.NumericQ:
    org.matheclipse.core.builtin.function.NumericQ CONST -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.Position -> org.matheclipse.core.builtin.function.Position:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST position(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.LevelSpec,com.google.common.base.Predicate,org.matheclipse.core.generic.interfaces.IPositionConverter,int) -> a
    org.matheclipse.core.interfaces.IAST position(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.util.LevelSpec) -> a
org.matheclipse.core.builtin.function.Prepend -> org.matheclipse.core.builtin.function.Prepend:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.PrependTo -> org.matheclipse.core.builtin.function.PrependTo:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.PrependTo$PrependToFunction -> jQ:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.Print -> org.matheclipse.core.builtin.function.Print:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Quiet -> org.matheclipse.core.builtin.function.Quiet:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Reap -> org.matheclipse.core.builtin.function.Reap:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Rest -> org.matheclipse.core.builtin.function.Rest:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Return -> org.matheclipse.core.builtin.function.Return:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Riffle -> org.matheclipse.core.builtin.function.Riffle:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.RotateLeft -> org.matheclipse.core.builtin.function.RotateLeft:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.RotateRight -> org.matheclipse.core.builtin.function.RotateRight:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.SetAttributes -> org.matheclipse.core.builtin.function.SetAttributes:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Sow -> org.matheclipse.core.builtin.function.Sow:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Switch -> org.matheclipse.core.builtin.function.Switch:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Throw -> org.matheclipse.core.builtin.function.Throw:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.TimeConstrained -> org.matheclipse.core.builtin.function.TimeConstrained:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Unevaluated -> org.matheclipse.core.builtin.function.Unevaluated:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Unique -> org.matheclipse.core.builtin.function.Unique:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.ValueQ -> org.matheclipse.core.builtin.function.ValueQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.builtin.function.Which -> org.matheclipse.core.builtin.function.Which:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.While -> org.matheclipse.core.builtin.function.While:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.convert.AST2Expr -> jR:
    java.lang.String[] FUNCTION_STRINGS -> a
    java.util.Map PREDEFINED_SYMBOLS_MAP -> a
    java.lang.String[] ALIASES_STRINGS -> b
    org.matheclipse.core.interfaces.IExpr[] ALIASES_SYMBOLS -> a
    java.util.Map PREDEFINED_ALIASES_MAP -> b
    org.matheclipse.core.convert.AST2Expr CONST -> a
    org.matheclipse.core.convert.AST2Expr CONST_LC -> b
    boolean fLowercaseEnabled -> a
    org.matheclipse.core.interfaces.IExpr convert(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.core.interfaces.IExpr rewriteLessGreaterAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.convert.ConversionException -> jS:
org.matheclipse.core.convert.Expr2Object -> jT:
    int MAX_POLYNOMIAL -> a
    double[] toDoubleVector(org.matheclipse.core.interfaces.IAST) -> a
    double[] toPolynomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    java.util.Map toPolynomialMap(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    void addCoefficient(java.util.Map,double,int) -> a
org.matheclipse.core.convert.ExprVariables -> jU:
    java.util.Set set -> a
    boolean add(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IAST getVarList() -> a
    java.util.List getArrayList() -> a
    boolean isSize(int) -> a
org.matheclipse.core.convert.ExprVariables$VariablesVisitor -> jV:
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.convert.JASConvert -> jW:
    edu.jas.structure.AbelianGroupFactory fRingFactory$5b76095 -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    edu.jas.poly.GenPolynomialRing fBigIntegerPolyFactory -> b
    java.util.List fVariables -> a
    edu.jas.poly.GenPolynomial expr2JAS(org.matheclipse.core.interfaces.IExpr) -> a
    edu.jas.poly.GenPolynomial numericExpr2JAS(org.matheclipse.core.interfaces.IExpr) -> b
    edu.jas.poly.GenPolynomial expr2Poly(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    edu.jas.poly.GenPolynomial fraction2Poly(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object[] factorTerms(edu.jas.poly.GenPolynomial) -> a
    org.matheclipse.core.interfaces.IExpr integerPoly2Expr(edu.jas.poly.GenPolynomial) -> a
    org.matheclipse.core.interfaces.IAST poly2Expr(edu.jas.poly.GenPolynomial,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST rationalPoly2Expr(edu.jas.poly.GenPolynomial) -> a
    org.matheclipse.core.interfaces.IComplex jas2Complex(edu.jas.poly.Complex) -> a
org.matheclipse.core.convert.JASConvert$RatToRatFactor -> jX:
    java.math.BigInteger lcm -> a
    java.math.BigInteger gcd -> b
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
org.matheclipse.core.convert.JASIExpr -> jY:
    edu.jas.structure.AbelianGroupFactory fRingFactory$5b76095 -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    java.util.List fVariables -> a
    edu.jas.poly.GenPolynomial expr2IExprJAS(org.matheclipse.core.interfaces.IExpr) -> a
    edu.jas.poly.GenPolynomial expr2IExprPoly(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST exprPoly2Expr(edu.jas.poly.GenPolynomial,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.convert.JASModInteger -> jZ:
    edu.jas.arith.ModLongRing fRingFactory -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    java.util.List fVariables -> a
    edu.jas.poly.GenPolynomial expr2JAS(org.matheclipse.core.interfaces.IExpr) -> a
    edu.jas.poly.GenPolynomial expr2Poly(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IAST modLongPoly2Expr(edu.jas.poly.GenPolynomial) -> a
    edu.jas.arith.ModLongRing option2ModLongRing(org.matheclipse.core.interfaces.ISignedNumber) -> a
org.matheclipse.core.convert.Object2Expr -> ka:
    org.matheclipse.core.interfaces.IExpr convertComplex(org.apache.commons.math3.complex.Complex[]) -> a
org.matheclipse.core.eval.CoreCallbackFunction -> kb:
    org.matheclipse.core.eval.CoreCallbackFunction CONST -> a
    double evaluate$5bc7c9e6(org.matheclipse.parser.client.ast.FunctionNode,double[]) -> a
org.matheclipse.core.eval.EvalComplex -> org.matheclipse.core.eval.EvalComplex:
org.matheclipse.core.eval.EvalDouble -> org.matheclipse.core.eval.EvalDouble:
    double eval(double[],int,org.matheclipse.core.interfaces.IExpr) -> eval
    double evalAST(double[],int,org.matheclipse.core.interfaces.IAST) -> evalAST
    double evalSymbol(org.matheclipse.core.interfaces.ISymbol) -> evalSymbol
org.matheclipse.core.eval.EvalEngine -> kc:
    java.util.Map fUserVariableMap -> a
    java.util.IdentityHashMap fLocalVariableStackMap -> a
    boolean fStopRequested -> f
    int fRecursionCounter -> a
    boolean fNumericMode -> a
    boolean fEvalLHSMode -> b
    boolean fTraceMode -> c
    org.matheclipse.core.eval.TraceStack fTraceStack -> a
    java.io.PrintStream fOutPrintStream -> a
    int fRecursionLimit -> b
    int fIterationLimit -> c
    int fAnonymousCounter -> d
    boolean fPackageMode -> g
    int fModuleCounter -> e
    boolean fRelaxedSyntax -> d
    org.matheclipse.core.interfaces.IAST reapList -> a
    java.util.Set fModifiedVariablesList -> a
    java.util.List fOutList -> a
    org.matheclipse.core.interfaces.IExpr fAnswer -> a
    boolean fOutListDisabled -> h
    boolean fQuietMode -> e
    java.lang.ThreadLocal instance -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.IExpr) -> b
    java.lang.String getNextCounter() -> a
    java.util.Stack localStack(org.matheclipse.core.interfaces.ISymbol) -> a
    java.util.Stack localStackCreate(org.matheclipse.core.interfaces.ISymbol) -> b
    void set(org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.IAST threadASTListArgs(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.eval.EvalEngine get() -> a
    boolean addModifiedVariable(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean addOut(org.matheclipse.core.interfaces.IExpr) -> a
    void addRules(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST endTrace() -> a
    org.matheclipse.core.interfaces.IAST evalArgs(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr evalASTBuiltinFunction(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evalLoop(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST evalSetAttributes(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IAST evalTrace(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> a
    boolean evalTrue(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr evaluateNull(org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IExpr evalWithoutNumericReset(org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST flattenSequences(org.matheclipse.core.interfaces.IAST) -> c
    int getIterationLimit() -> a
    java.util.Map getLocalVariableStackMap() -> a
    java.util.List getOutList() -> a
    int getRecursionLimit() -> b
    void removeUserVariables(java.util.Map) -> a
    int incModuleCounter() -> c
    boolean isPackageMode() -> a
    org.matheclipse.core.interfaces.IExpr parse(java.lang.String) -> a
    void setPackageMode(boolean) -> a
    void setRecursionLimit(int) -> a
    java.lang.String toString() -> toString
org.matheclipse.core.eval.EvalEngine$1 -> kd:
    int fID -> a
    java.lang.Object initialValue() -> initialValue
org.matheclipse.core.eval.EvalUtilities -> ke:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.eval.MathMLUtilities -> kf:
    org.matheclipse.core.eval.EvalEngine fEvalEngine -> a
    void startRequest() -> a
org.matheclipse.core.eval.MathUtils -> org.matheclipse.core.eval.MathUtils:
    java.lang.Double[][] rom -> a
    double romberg(int,int) -> a
    double arcLength(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> arcLength
    double integrate(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> integrate
    double integrate(java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> integrate
    double getFunctionVal(java.lang.String,double) -> getFunctionVal
    double getFunctionVal(java.lang.String,java.lang.String,java.lang.String) -> getFunctionVal
    java.lang.String getFunctionVal(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[]) -> getFunctionVal
    boolean isValid(java.lang.String,java.lang.String[]) -> isValid
    boolean[] isValid(java.lang.String[],java.lang.String[]) -> isValid
    java.lang.String getDerivative(java.lang.String,java.lang.String[],java.lang.String) -> getDerivative
    java.lang.String getPowerSeries(java.lang.String,java.lang.String,java.lang.String,int) -> getPowerSeries
    java.lang.String tangentLine(java.lang.String,java.lang.String,java.lang.String) -> tangentLine
    double surfaceArea(java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> surfaceArea
    java.lang.String evaluate(java.lang.String,java.lang.String) -> evaluate
    java.lang.String evaluate(java.lang.String,org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr parse(java.lang.String,org.matheclipse.core.interfaces.IAST) -> parse
org.matheclipse.core.eval.Namespace -> kg:
    java.util.ArrayList fNamespacesString -> a
    java.util.Map fPackageNamespaceMap -> a
    void setEvaluator(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.eval.Range -> kh:
    org.matheclipse.core.interfaces.IAST fList -> a
    int fStart -> a
    int fEnd -> b
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,java.util.Collection,com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IExpr foldLeft(org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IExpr) -> a
    java.util.Iterator iterator() -> iterator
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> a
    java.util.Collection rotateLeft(java.util.Collection,int) -> a
    java.util.Collection rotateRight(java.util.Collection,int) -> b
    int size() -> a
    org.matheclipse.core.interfaces.IAST sort(org.matheclipse.core.generic.ExprComparator) -> a
    java.util.List toList(java.util.List) -> a
org.matheclipse.core.eval.Range$RangeIterator -> ki:
    int fCurrrent -> a
    org.matheclipse.core.eval.Range fRange -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.eval.SymjaInterpreter -> kj:
    java.lang.String codeString -> a
    java.io.PrintStream outStream -> a
    java.lang.String interpreter(java.lang.String) -> a
    java.lang.String interpreter(org.matheclipse.core.interfaces.IAST) -> a
    void printException(java.lang.Appendable,java.lang.Throwable) -> a
org.matheclipse.core.eval.SystemNamespace -> kk:
    org.matheclipse.core.eval.Namespace DEFAULT -> a
org.matheclipse.core.eval.TraceStack -> kl:
    java.util.Stack fStack -> a
    com.google.common.base.Predicate fMatcher -> a
    org.matheclipse.core.interfaces.IAST fList -> b
    org.matheclipse.core.interfaces.IAST fTraceList -> a
    void pushList() -> a
    void popList() -> b
    void add(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.eval.exception.BooleanFunctionConversionException -> km:
org.matheclipse.core.eval.exception.BreakException -> org.matheclipse.core.eval.exception.BreakException:
org.matheclipse.core.eval.exception.ConditionException -> org.matheclipse.core.eval.exception.ConditionException:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.ContinueException -> org.matheclipse.core.eval.exception.ContinueException:
org.matheclipse.core.eval.exception.DimensionException -> org.matheclipse.core.eval.exception.DimensionException:
org.matheclipse.core.eval.exception.DivisionByZero -> org.matheclipse.core.eval.exception.DivisionByZero:
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.FlowControlException -> org.matheclipse.core.eval.exception.FlowControlException:
org.matheclipse.core.eval.exception.IndeterminateException -> org.matheclipse.core.eval.exception.IndeterminateException:
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.IterationLimitExceeded -> org.matheclipse.core.eval.exception.IterationLimitExceeded:
    int fLimit -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    java.lang.String getMessage() -> getMessage
    void throwIt(int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.eval.exception.JASConversionException -> kn:
org.matheclipse.core.eval.exception.NonNegativeIntegerExpected -> org.matheclipse.core.eval.exception.NonNegativeIntegerExpected:
    int fCurrent -> a
    org.matheclipse.core.interfaces.IAST fExpr -> a
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.PoolMemoryExceededException -> org.matheclipse.core.eval.exception.PoolMemoryExceededException:
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.RecursionLimitExceeded -> org.matheclipse.core.eval.exception.RecursionLimitExceeded:
    int fLimit -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    java.lang.String getMessage() -> getMessage
    void throwIt(int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.eval.exception.ReturnException -> org.matheclipse.core.eval.exception.ReturnException:
    org.matheclipse.core.interfaces.IExpr value -> a
org.matheclipse.core.eval.exception.RuleCreationError -> org.matheclipse.core.eval.exception.RuleCreationError:
    org.matheclipse.core.interfaces.IExpr fLHS -> a
    org.matheclipse.core.interfaces.IExpr fRHS -> b
    org.matheclipse.core.interfaces.IExpr fCondition -> c
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.ThrowException -> org.matheclipse.core.eval.exception.ThrowException:
    org.matheclipse.core.interfaces.IExpr value -> a
org.matheclipse.core.eval.exception.TimeExceeded -> org.matheclipse.core.eval.exception.TimeExceeded:
org.matheclipse.core.eval.exception.UnsupportedParameterException -> org.matheclipse.core.eval.exception.UnsupportedParameterException:
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.WrappedException -> org.matheclipse.core.eval.exception.WrappedException:
    java.lang.Throwable fThrowable -> a
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.WrongArgumentType -> org.matheclipse.core.eval.exception.WrongArgumentType:
    int fPosition -> a
    org.matheclipse.core.interfaces.IExpr fArg -> a
    org.matheclipse.core.interfaces.IAST fExpr -> a
    java.lang.String fMessage -> a
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.WrongNumberOfArguments -> org.matheclipse.core.eval.exception.WrongNumberOfArguments:
    int fAllowed -> a
    int fCurrent -> b
    org.matheclipse.core.interfaces.IAST fExpr -> a
    int fTextNumber -> c
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.interfaces.AbstractArg1 -> org.matheclipse.core.eval.interfaces.AbstractArg1:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1IntArg(org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.eval.interfaces.AbstractArg12 -> org.matheclipse.core.eval.interfaces.AbstractArg12:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.interfaces.AbstractArg2 -> org.matheclipse.core.eval.interfaces.AbstractArg2:
    org.matheclipse.core.interfaces.IExpr binaryOperator(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr eComFraArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.interfaces.AbstractArgMultiple -> org.matheclipse.core.eval.interfaces.AbstractArgMultiple:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> a
    void setUpHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr binaryOperator(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.eval.interfaces.AbstractCoreFunctionEvaluator -> org.matheclipse.core.eval.interfaces.AbstractCoreFunctionEvaluator:
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.interfaces.AbstractFunctionEvaluator -> org.matheclipse.core.eval.interfaces.AbstractFunctionEvaluator:
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean isNegativeExpression(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getPureImaginaryPart(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr[] getPeriodicParts(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.eval.interfaces.AbstractMatrix1Expr -> org.matheclipse.core.eval.interfaces.AbstractMatrix1Expr:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.expression.ExprFieldElement matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.eval.interfaces.AbstractMatrix1Matrix -> org.matheclipse.core.eval.interfaces.AbstractMatrix1Matrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.apache.commons.math3.linear.FieldMatrix matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.linear.RealMatrix realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.eval.interfaces.AbstractNonOrderlessArgMultiple -> org.matheclipse.core.eval.interfaces.AbstractNonOrderlessArgMultiple:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.interfaces.AbstractSymbolEvaluator -> org.matheclipse.core.eval.interfaces.AbstractSymbolEvaluator:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.eval.interfaces.AbstractTrigArg1 -> org.matheclipse.core.eval.interfaces.AbstractTrigArg1:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalArg1(org.matheclipse.core.interfaces.IExpr) -> c
org.matheclipse.core.eval.interfaces.ICoreFunctionEvaluator -> org.matheclipse.core.eval.interfaces.ICoreFunctionEvaluator:
org.matheclipse.core.eval.interfaces.IFunctionEvaluator -> org.matheclipse.core.eval.interfaces.IFunctionEvaluator:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.eval.interfaces.INumeric -> ko:
    double evalReal(double[],int,int) -> a
org.matheclipse.core.eval.interfaces.ISignedNumberConstant -> kp:
    double evalReal() -> a
org.matheclipse.core.eval.interfaces.ISymbolEvaluator -> org.matheclipse.core.eval.interfaces.ISymbolEvaluator:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.eval.util.AbstractSequence -> kq:
    int fStartOffset -> a
    int fEndOffset -> b
    int fStep -> c
    int getStep() -> a
org.matheclipse.core.eval.util.IIndexFunction -> kr:
    java.lang.Object evaluate(int[]) -> a
org.matheclipse.core.eval.util.ISequence -> ks:
    int getEnd() -> b
    int getStart() -> c
    int getStep() -> a
    void setListSize(int) -> a
org.matheclipse.core.eval.util.IndexFunctionDiagonal -> kt:
    org.matheclipse.core.interfaces.IExpr[] fValues -> a
    java.lang.Object evaluate(int[]) -> a
org.matheclipse.core.eval.util.IndexTableGenerator -> ku:
    int[] fIndexArray -> a
    org.matheclipse.core.interfaces.IAST fPrototypeList -> a
    org.matheclipse.core.eval.util.IIndexFunction fFunction -> a
    int fIndex -> a
    int[] fCurrentIndex -> b
    org.matheclipse.core.interfaces.IExpr table() -> a
org.matheclipse.core.eval.util.Iterator -> kv:
    org.matheclipse.core.interfaces.IExpr count -> a
    boolean fNumericMode -> a
    org.matheclipse.core.eval.EvalEngine evalEngine -> a
    org.matheclipse.core.interfaces.IExpr maxCount -> b
    org.matheclipse.core.interfaces.IExpr start -> c
    org.matheclipse.core.interfaces.IExpr step -> d
    org.matheclipse.core.expression.Symbol variable -> a
    boolean hasNext() -> hasNext
    boolean setUp() -> a
    void tearDown() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.eval.util.LevelSpec -> kw:
    int fFromLevel -> a
    int fToLevel -> b
    int fFromDepth -> c
    int fToDepth -> d
    int fCurrentLevel -> e
    int fCurrentDepth -> f
    int getCurrentLevel() -> a
    void setFromLevelAsCurrent() -> a
    void incCurrentLevel() -> b
    void decCurrentLevel() -> c
    boolean isInRange() -> a
    int getCurrentDepth() -> b
    void setCurrentDepth(int) -> a
org.matheclipse.core.eval.util.LevelSpecification -> kx:
org.matheclipse.core.eval.util.ListSizeSequence -> ky:
    int fHeadOffset -> c
    int fListSize -> d
    void setListSize(int) -> a
    int getStart() -> c
    int getEnd() -> b
org.matheclipse.core.eval.util.Options -> kz:
    org.matheclipse.core.interfaces.IAST fDefaultOptionsList -> a
    org.matheclipse.core.interfaces.IAST fCurrentOptionsList -> b
    org.matheclipse.core.interfaces.IExpr getOption(java.lang.String) -> a
org.matheclipse.core.eval.util.Sequence -> kA:
org.matheclipse.core.eval.util.TableGenerator -> kB:
    java.util.List fIterList -> a
    org.matheclipse.core.interfaces.IExpr fDefaultValue -> a
    org.matheclipse.core.interfaces.IAST fPrototypeList -> a
    org.matheclipse.core.generic.interfaces.IArrayFunction fFunction -> a
    int fIndex -> a
    org.matheclipse.core.interfaces.IExpr[] fCurrentIndex -> a
    org.matheclipse.core.interfaces.IExpr table() -> a
org.matheclipse.core.eval.util.WrongSequenceException -> kC:
org.matheclipse.core.expression.AST -> kD:
    int fEvalFlags -> c
    int fPatternMatchingHashValue -> d
    org.matheclipse.core.interfaces.IAST clone() -> a
    org.matheclipse.core.interfaces.IAST cloneSet(int,org.matheclipse.core.interfaces.IExpr) -> a
    boolean equalsFromPosition(int,org.matheclipse.core.expression.AST,int) -> a
    org.matheclipse.core.interfaces.ISymbol topHead() -> a
    int hierarchy() -> b
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> b
    int getEvalFlags() -> c
    void setEvalFlags(int) -> a
    void addEvalFlags(int) -> b
    org.matheclipse.core.interfaces.IAST addOneIdentity(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr getOneIdentity(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isEvalFlagOn(int) -> a
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr inverse() -> a
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> c
    boolean isList() -> a
    boolean isSequence() -> b
    boolean isListOfLists() -> c
    boolean isDirectedInfinity() -> g
    boolean isInfinity() -> h
    boolean isNegative() -> i
    boolean isNegativeInfinity() -> j
    boolean isPlus() -> k
    boolean isPower() -> l
    boolean isTimes() -> m
    boolean isSin() -> n
    boolean isCos() -> o
    boolean isSlot() -> p
    boolean isSlotSequence() -> q
    boolean isOne() -> r
    boolean isMinusOne() -> s
    boolean isZero() -> t
    boolean isTrue() -> u
    boolean isFalse() -> v
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> c
    int[] isMatrix() -> a
    int isVector() -> d
    boolean isFraction() -> w
    boolean isPattern() -> x
    boolean isPatternExpr() -> y
    boolean isPatternSequence() -> z
    boolean isPositive() -> A
    boolean isCondition() -> B
    boolean isModule() -> C
    boolean isSymbol() -> D
    boolean isConstant() -> E
    boolean isComplex() -> F
    boolean isComplexNumeric() -> G
    boolean isInteger() -> H
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> a
    boolean isNumIntValue() -> I
    boolean isRational() -> J
    boolean isSignedNumber() -> K
    boolean isNot() -> L
    boolean isNumeric() -> M
    boolean isNumericFunction() -> N
    boolean isRealFunction() -> O
    boolean isNumber() -> P
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST map(com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> c
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> b
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> d
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IAST[] split(com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IAST[] split(com.google.common.base.Function) -> a
    boolean isAST() -> Q
    boolean isOrderlessAST() -> R
    boolean isFlatAST() -> S
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> d
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> a
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> b
    boolean isRuleAST() -> T
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    boolean isFree(com.google.common.base.Predicate,boolean) -> a
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> b
    boolean isMember(com.google.common.base.Predicate,boolean) -> b
    boolean isFunction() -> U
    int compareToTimes(org.matheclipse.core.expression.AST) -> a
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    int compareToAST(org.matheclipse.core.expression.AST) -> b
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> a
    int patternHashCode() -> e
    boolean isAtom() -> V
    org.matheclipse.core.interfaces.IAST copyHead() -> b
    org.matheclipse.core.interfaces.IAST copyUntil(int) -> a
    java.lang.String fullFormString() -> c
    java.lang.String internalFormString(boolean,int) -> a
    void internalFormOrderless(org.matheclipse.core.interfaces.IAST,java.lang.StringBuffer,java.lang.String,boolean,int) -> a
    java.lang.String toString() -> toString
    java.lang.String toFullFormString() -> d
    boolean addAll(java.util.List) -> a
    boolean addAll(java.util.List,int,int) -> a
    org.matheclipse.core.expression.ASTRange args() -> a
    org.matheclipse.core.expression.ASTRange range(int) -> a
    org.matheclipse.core.expression.ASTRange range(int,int) -> a
    org.matheclipse.core.expression.AST newInstance(int,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.ISymbol,org.apache.commons.math3.complex.Complex[]) -> a
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr power(java.lang.Integer) -> a
    org.matheclipse.core.interfaces.IExpr getAt(int) -> a
    java.lang.Object asType(java.lang.Class) -> a
    org.matheclipse.core.interfaces.IAST getAST(int) -> b
    boolean isZERO() -> d
    int signum() -> a
    edu.jas.structure.ElemFactory factory() -> a
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isONE() -> e
    boolean isUnit() -> f
    boolean isValue() -> W
    org.matheclipse.core.interfaces.IExpr head() -> b
    java.util.Iterator iterator() -> iterator
    org.matheclipse.core.interfaces.IExpr arg1() -> c
    org.matheclipse.core.interfaces.IExpr arg2() -> d
    org.matheclipse.core.interfaces.IExpr arg3() -> e
    org.matheclipse.core.interfaces.IExpr last() -> f
    org.matheclipse.core.interfaces.IAST append(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST prepend(org.matheclipse.core.interfaces.IExpr) -> c
    java.lang.Object clone() -> clone
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
org.matheclipse.core.expression.AST$ASTIterator -> kE:
    org.matheclipse.core.generic.util.HMArrayList _table -> a
    int _currentIndex -> a
    int _start -> b
    int _end -> c
    int _nextIndex -> d
    boolean hasNext() -> hasNext
    int nextIndex() -> nextIndex
    boolean hasPrevious() -> hasPrevious
    int previousIndex() -> previousIndex
    void remove() -> remove
    void add(java.lang.Object) -> add
    void set(java.lang.Object) -> set
    java.lang.Object previous() -> previous
    java.lang.Object next() -> next
    org.matheclipse.core.generic.util.HMArrayList access$002(org.matheclipse.core.expression.AST$ASTIterator,org.matheclipse.core.generic.util.HMArrayList) -> a
    int access$102(org.matheclipse.core.expression.AST$ASTIterator,int) -> a
    int access$202(org.matheclipse.core.expression.AST$ASTIterator,int) -> b
    int access$302(org.matheclipse.core.expression.AST$ASTIterator,int) -> c
    int access$402(org.matheclipse.core.expression.AST$ASTIterator,int) -> d
org.matheclipse.core.expression.ASTRange -> kF:
    java.util.List toList() -> a
org.matheclipse.core.expression.ComplexNum -> kG:
    org.matheclipse.core.expression.ComplexNum I -> a
    org.matheclipse.core.expression.ComplexNum NaN -> b
    org.matheclipse.core.expression.ComplexNum ONE -> c
    org.apache.commons.math3.complex.Complex fComplex -> a
    org.matheclipse.core.expression.ComplexNum newInstance(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.expression.ComplexNum valueOf(double,double) -> a
    double getImaginaryPart() -> a
    double getRealPart() -> b
    boolean isZero() -> t
    int hierarchy() -> b
    org.matheclipse.core.interfaces.IComplexNum add(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.expression.ComplexNum add(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IComplexNum multiply(org.matheclipse.core.interfaces.IComplexNum) -> b
    org.matheclipse.core.interfaces.IComplexNum pow(org.matheclipse.core.interfaces.IComplexNum) -> c
    org.matheclipse.core.interfaces.IComplexNum conjugate() -> a
    org.matheclipse.core.expression.ComplexNum divide(org.matheclipse.core.expression.ComplexNum) -> b
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> a
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> a
    double dabs() -> c
    double getImaginary() -> d
    double getReal() -> e
    int hashCode() -> hashCode
    boolean isNaN() -> X
    org.matheclipse.core.expression.ComplexNum multiply(org.matheclipse.core.expression.ComplexNum) -> c
    org.matheclipse.core.expression.ComplexNum negate() -> a
    org.matheclipse.core.interfaces.INumber opposite() -> a
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr inverse() -> a
    org.matheclipse.core.expression.ComplexNum subtract(org.matheclipse.core.expression.ComplexNum) -> d
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> c
    java.lang.String toString() -> toString
    int complexSign() -> c
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol head() -> b
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    boolean equalsInt(int) -> a
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> a
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> b
    org.matheclipse.core.interfaces.IExpr negate() -> c
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.IExpr eabs() -> d
org.matheclipse.core.expression.ComplexSym -> kH:
    org.apache.commons.math3.fraction.BigFraction _real -> a
    org.apache.commons.math3.fraction.BigFraction _imaginary -> b
    int fHashValue -> a
    org.matheclipse.core.expression.ComplexSym valueOf(java.math.BigInteger,java.math.BigInteger) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(org.apache.commons.math3.fraction.BigFraction,org.apache.commons.math3.fraction.BigFraction) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IComplex conjugate() -> a
    org.matheclipse.core.interfaces.IExpr eabs() -> d
    org.matheclipse.core.interfaces.IComplex add(org.matheclipse.core.interfaces.IComplex) -> a
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.INumber numericNumber() -> b
    org.apache.commons.math3.fraction.BigFraction getImaginaryPart() -> a
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> a
    org.apache.commons.math3.fraction.BigFraction getRealPart() -> b
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> b
    int hashCode() -> hashCode
    int hierarchy() -> b
    boolean isZero() -> t
    org.matheclipse.core.interfaces.IComplex multiply(org.matheclipse.core.interfaces.IComplex) -> b
    org.matheclipse.core.interfaces.IComplex pow(int) -> a
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.INumber opposite() -> a
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr inverse() -> a
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> c
    java.lang.String internalFormString(boolean,int) -> a
    org.matheclipse.core.interfaces.INumber normalize() -> c
    int complexSign() -> c
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol head() -> b
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    boolean equalsInt(int) -> a
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
org.matheclipse.core.expression.ExprField -> kI:
    org.matheclipse.core.expression.ExprField CONST -> a
    org.matheclipse.core.expression.ExprFieldElement ONE -> a
    org.matheclipse.core.expression.ExprFieldElement ZERO -> b
    org.matheclipse.core.expression.ExprFieldElement getOne() -> a
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
org.matheclipse.core.expression.ExprFieldElement -> kJ:
    org.matheclipse.core.interfaces.IExpr val -> a
    org.matheclipse.core.expression.ExprFieldElement add(org.matheclipse.core.expression.ExprFieldElement) -> a
    boolean equals(java.lang.Object) -> equals
    org.apache.commons.math3.Field getField() -> a
    int hashCode() -> hashCode
    org.matheclipse.core.expression.ExprFieldElement multiply(org.matheclipse.core.expression.ExprFieldElement) -> b
    org.matheclipse.core.expression.ExprFieldElement subtract(org.matheclipse.core.expression.ExprFieldElement) -> c
    java.lang.String toString() -> toString
    java.lang.Object reciprocal() -> b
    java.lang.Object divide(java.lang.Object) -> d
    java.lang.Object multiply(java.lang.Object) -> c
    java.lang.Object negate() -> a
    java.lang.Object subtract(java.lang.Object) -> b
    java.lang.Object add(java.lang.Object) -> a
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.expression.ExprImpl -> kK:
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr inverse() -> a
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr power(java.lang.Integer) -> a
    org.matheclipse.core.interfaces.IExpr getAt(int) -> a
    java.lang.Object asType(java.lang.Class) -> a
    org.matheclipse.core.interfaces.ISymbol head() -> b
    org.matheclipse.core.interfaces.ISymbol topHead() -> a
    boolean isConstant() -> E
    boolean isDirectedInfinity() -> g
    boolean isInfinity() -> h
    boolean isNegative() -> i
    boolean isNegativeInfinity() -> j
    boolean isList() -> a
    boolean isSequence() -> b
    boolean isListOfLists() -> c
    boolean isTrue() -> u
    boolean isFalse() -> v
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> c
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> a
    int[] isMatrix() -> a
    boolean isValue() -> W
    int isVector() -> d
    boolean isAST() -> Q
    boolean isOrderlessAST() -> R
    boolean isFlatAST() -> S
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> d
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> a
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> b
    boolean isPlus() -> k
    boolean isPower() -> l
    boolean isRuleAST() -> T
    boolean isTimes() -> m
    boolean isSin() -> n
    boolean isCos() -> o
    boolean isOne() -> r
    boolean isMinusOne() -> s
    boolean isZero() -> t
    boolean isSlot() -> p
    boolean isSlotSequence() -> q
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    boolean isFree(com.google.common.base.Predicate,boolean) -> a
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> b
    boolean isMember(com.google.common.base.Predicate,boolean) -> b
    boolean isFunction() -> U
    boolean isPattern() -> x
    boolean isPatternExpr() -> y
    boolean isPatternSequence() -> z
    boolean isPositive() -> A
    boolean isCondition() -> B
    boolean isModule() -> C
    boolean isSymbol() -> D
    boolean isComplex() -> F
    boolean isComplexNumeric() -> G
    boolean isFraction() -> w
    boolean isInteger() -> H
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> a
    boolean isNumIntValue() -> I
    boolean isRational() -> J
    boolean isSignedNumber() -> K
    boolean isNot() -> L
    boolean isNumeric() -> M
    boolean isNumericFunction() -> N
    boolean isRealFunction() -> O
    boolean isNumber() -> P
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> b
    boolean isAtom() -> V
    java.lang.String fullFormString() -> c
    java.lang.String internalFormString(boolean,int) -> a
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> c
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> d
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> b
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.visit.VisitorReplaceAll) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> a
    boolean isZERO() -> d
    int signum() -> a
    edu.jas.structure.ElemFactory factory() -> a
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isONE() -> e
    boolean isUnit() -> f
    org.matheclipse.core.interfaces.IExpr negate() -> c
    org.matheclipse.core.interfaces.IExpr head() -> b
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
org.matheclipse.core.expression.ExprRingFactory -> kL:
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    boolean isFinite() -> a
    java.lang.String toScript() -> a
    boolean isCommutative() -> b
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
org.matheclipse.core.expression.F -> kM:
    boolean isSystemStarted -> b
    boolean isSystemInitialized -> a
    java.util.Map PREDEFINED_INTERNAL_FORM_STRINGS -> a
    java.util.Map PREDEFINED_SYMBOLS_MAP -> b
    org.matheclipse.core.expression.ISymbolObserver SYMBOL_OBSERVER -> a
    org.matheclipse.core.interfaces.ISymbol E -> a
    org.matheclipse.core.interfaces.ISymbol Pi -> b
    org.matheclipse.core.interfaces.ISymbol IntegerHead -> c
    org.matheclipse.core.interfaces.ISymbol SymbolHead -> d
    org.matheclipse.core.interfaces.ISymbol RealHead -> e
    org.matheclipse.core.interfaces.ISymbol PatternHead -> f
    org.matheclipse.core.interfaces.ISymbol BlankHead -> g
    org.matheclipse.core.interfaces.ISymbol StringHead -> h
    org.matheclipse.core.interfaces.ISymbol MethodHead -> i
    org.matheclipse.core.interfaces.ISymbol False -> j
    org.matheclipse.core.interfaces.ISymbol List -> k
    org.matheclipse.core.interfaces.ISymbol True -> l
    org.matheclipse.core.interfaces.ISymbol Null -> m
    org.matheclipse.core.interfaces.ISymbol Second -> n
    org.matheclipse.core.interfaces.ISymbol Indeterminate -> o
    org.matheclipse.core.interfaces.ISymbol DirectedInfinity -> p
    org.matheclipse.core.interfaces.ISymbol Listable -> q
    org.matheclipse.core.interfaces.ISymbol NumericFunction -> r
    org.matheclipse.core.interfaces.ISymbol Orderless -> s
    org.matheclipse.core.interfaces.ISymbol OneIdentity -> t
    org.matheclipse.core.interfaces.ISymbol Flat -> u
    org.matheclipse.core.interfaces.ISymbol HoldFirst -> v
    org.matheclipse.core.interfaces.ISymbol HoldRest -> w
    org.matheclipse.core.interfaces.ISymbol HoldAll -> x
    org.matheclipse.core.interfaces.ISymbol NHoldFirst -> y
    org.matheclipse.core.interfaces.ISymbol NHoldRest -> z
    org.matheclipse.core.interfaces.ISymbol NHoldAll -> A
    org.matheclipse.core.interfaces.ISymbol Slot -> B
    org.matheclipse.core.interfaces.ISymbol SlotSequence -> C
    org.matheclipse.core.interfaces.ISymbol Options -> bs
    org.matheclipse.core.interfaces.ISymbol ArcCosh -> D
    org.matheclipse.core.interfaces.ISymbol ArcCoth -> E
    org.matheclipse.core.interfaces.ISymbol ArcCsc -> F
    org.matheclipse.core.interfaces.ISymbol ArcCsch -> G
    org.matheclipse.core.interfaces.ISymbol ArcSec -> H
    org.matheclipse.core.interfaces.ISymbol ArcSech -> I
    org.matheclipse.core.interfaces.ISymbol ArcSinh -> J
    org.matheclipse.core.interfaces.ISymbol ArcTanh -> K
    org.matheclipse.core.interfaces.ISymbol Sequence -> L
    org.matheclipse.core.interfaces.ISymbol Append -> bt
    org.matheclipse.core.interfaces.ISymbol AppendTo -> M
    org.matheclipse.core.interfaces.ISymbol Apply -> bu
    org.matheclipse.core.interfaces.ISymbol AtomQ -> bv
    org.matheclipse.core.interfaces.ISymbol Blank -> N
    org.matheclipse.core.interfaces.ISymbol Block -> bw
    org.matheclipse.core.interfaces.ISymbol Break -> bx
    org.matheclipse.core.interfaces.ISymbol Catch -> by
    org.matheclipse.core.interfaces.ISymbol Condition -> O
    org.matheclipse.core.interfaces.ISymbol Delete -> bz
    org.matheclipse.core.interfaces.ISymbol Drop -> bA
    org.matheclipse.core.interfaces.ISymbol Do -> bB
    org.matheclipse.core.interfaces.ISymbol First -> bC
    org.matheclipse.core.interfaces.ISymbol FreeQ -> bD
    org.matheclipse.core.interfaces.ISymbol Head -> bE
    org.matheclipse.core.interfaces.ISymbol If -> bF
    org.matheclipse.core.interfaces.ISymbol LeafCount -> bG
    org.matheclipse.core.interfaces.ISymbol Length -> bH
    org.matheclipse.core.interfaces.ISymbol MemberQ -> bI
    org.matheclipse.core.interfaces.ISymbol Module -> P
    org.matheclipse.core.interfaces.ISymbol N -> bJ
    org.matheclipse.core.interfaces.ISymbol NumberQ -> bK
    org.matheclipse.core.interfaces.ISymbol NumericQ -> bL
    org.matheclipse.core.interfaces.ISymbol Prepend -> bM
    org.matheclipse.core.interfaces.ISymbol PrependTo -> Q
    org.matheclipse.core.interfaces.ISymbol Print -> bN
    org.matheclipse.core.interfaces.ISymbol Reap -> bO
    org.matheclipse.core.interfaces.ISymbol Rest -> bP
    org.matheclipse.core.interfaces.ISymbol Return -> bQ
    org.matheclipse.core.interfaces.ISymbol Sow -> bR
    org.matheclipse.core.interfaces.ISymbol Throw -> bS
    org.matheclipse.core.interfaces.ISymbol While -> bT
    org.matheclipse.core.interfaces.ISymbol Abs -> R
    org.matheclipse.core.interfaces.ISymbol AddTo -> S
    org.matheclipse.core.interfaces.ISymbol And -> T
    org.matheclipse.core.interfaces.ISymbol Apart -> bU
    org.matheclipse.core.interfaces.ISymbol ArcCos -> U
    org.matheclipse.core.interfaces.ISymbol ArcCot -> V
    org.matheclipse.core.interfaces.ISymbol ArcSin -> W
    org.matheclipse.core.interfaces.ISymbol ArcTan -> X
    org.matheclipse.core.interfaces.ISymbol Arg -> bV
    org.matheclipse.core.interfaces.ISymbol Cancel -> bW
    org.matheclipse.core.interfaces.ISymbol Ceiling -> bX
    org.matheclipse.core.interfaces.ISymbol Chop -> bY
    org.matheclipse.core.interfaces.ISymbol Coefficient -> bZ
    org.matheclipse.core.interfaces.ISymbol Collect -> ca
    org.matheclipse.core.interfaces.ISymbol Complex -> Y
    org.matheclipse.core.interfaces.ISymbol CompoundExpression -> cb
    org.matheclipse.core.interfaces.ISymbol Conjugate -> cc
    org.matheclipse.core.interfaces.ISymbol Cos -> Z
    org.matheclipse.core.interfaces.ISymbol Cosh -> aa
    org.matheclipse.core.interfaces.ISymbol Cot -> ab
    org.matheclipse.core.interfaces.ISymbol Coth -> ac
    org.matheclipse.core.interfaces.ISymbol Count -> cd
    org.matheclipse.core.interfaces.ISymbol Csc -> ad
    org.matheclipse.core.interfaces.ISymbol Csch -> ae
    org.matheclipse.core.interfaces.ISymbol D -> af
    org.matheclipse.core.interfaces.ISymbol Decrement -> ag
    org.matheclipse.core.interfaces.ISymbol Denominator -> ce
    org.matheclipse.core.interfaces.ISymbol Derivative -> ah
    org.matheclipse.core.interfaces.ISymbol Det -> cf
    org.matheclipse.core.interfaces.ISymbol Discriminant -> cg
    org.matheclipse.core.interfaces.ISymbol Distribute -> ch
    org.matheclipse.core.interfaces.ISymbol DivideBy -> ai
    org.matheclipse.core.interfaces.ISymbol Equal -> aj
    org.matheclipse.core.interfaces.ISymbol Erf -> ci
    org.matheclipse.core.interfaces.ISymbol EvenQ -> cj
    org.matheclipse.core.interfaces.ISymbol Expand -> ck
    org.matheclipse.core.interfaces.ISymbol ExpandAll -> cl
    org.matheclipse.core.interfaces.ISymbol Exponent -> cm
    org.matheclipse.core.interfaces.ISymbol Factor -> cn
    org.matheclipse.core.interfaces.ISymbol Factorial -> co
    org.matheclipse.core.interfaces.ISymbol FactorSquareFreeList -> cp
    org.matheclipse.core.interfaces.ISymbol Floor -> cq
    org.matheclipse.core.interfaces.ISymbol FractionalPart -> cr
    org.matheclipse.core.interfaces.ISymbol FullSimplify -> cs
    org.matheclipse.core.interfaces.ISymbol Function -> ak
    org.matheclipse.core.interfaces.ISymbol Gamma -> ct
    org.matheclipse.core.interfaces.ISymbol GCD -> cu
    org.matheclipse.core.interfaces.ISymbol Greater -> al
    org.matheclipse.core.interfaces.ISymbol GreaterEqual -> am
    org.matheclipse.core.interfaces.ISymbol Hold -> an
    org.matheclipse.core.interfaces.ISymbol Im -> ao
    org.matheclipse.core.interfaces.ISymbol Increment -> ap
    org.matheclipse.core.interfaces.ISymbol IntegerPart -> aq
    org.matheclipse.core.interfaces.ISymbol Integrate -> ar
    org.matheclipse.core.interfaces.ISymbol InverseErf -> cv
    org.matheclipse.core.interfaces.ISymbol InverseFunction -> cw
    org.matheclipse.core.interfaces.ISymbol Join -> cx
    org.matheclipse.core.interfaces.ISymbol LCM -> cy
    org.matheclipse.core.interfaces.ISymbol Less -> as
    org.matheclipse.core.interfaces.ISymbol LessEqual -> at
    org.matheclipse.core.interfaces.ISymbol Limit -> au
    org.matheclipse.core.interfaces.ISymbol Log -> av
    org.matheclipse.core.interfaces.ISymbol Map -> cz
    org.matheclipse.core.interfaces.ISymbol MatchQ -> cA
    org.matheclipse.core.interfaces.ISymbol Max -> aw
    org.matheclipse.core.interfaces.ISymbol Min -> cB
    org.matheclipse.core.interfaces.ISymbol Mod -> cC
    org.matheclipse.core.interfaces.ISymbol Negative -> cD
    org.matheclipse.core.interfaces.ISymbol Not -> ax
    org.matheclipse.core.interfaces.ISymbol Numerator -> cE
    org.matheclipse.core.interfaces.ISymbol OddQ -> cF
    org.matheclipse.core.interfaces.ISymbol Or -> ay
    org.matheclipse.core.interfaces.ISymbol Order -> cG
    org.matheclipse.core.interfaces.ISymbol OrderedQ -> cH
    org.matheclipse.core.interfaces.ISymbol Part -> az
    org.matheclipse.core.interfaces.ISymbol Plus -> aA
    org.matheclipse.core.interfaces.ISymbol PolynomialQuotient -> cI
    org.matheclipse.core.interfaces.ISymbol PolynomialRemainder -> cJ
    org.matheclipse.core.interfaces.ISymbol Positive -> cK
    org.matheclipse.core.interfaces.ISymbol PossibleZeroQ -> cL
    org.matheclipse.core.interfaces.ISymbol Power -> aB
    org.matheclipse.core.interfaces.ISymbol PreDecrement -> aC
    org.matheclipse.core.interfaces.ISymbol PreIncrement -> aD
    org.matheclipse.core.interfaces.ISymbol Rational -> aE
    org.matheclipse.core.interfaces.ISymbol Re -> aF
    org.matheclipse.core.interfaces.ISymbol ReplaceAll -> cM
    org.matheclipse.core.interfaces.ISymbol ReplacePart -> cN
    org.matheclipse.core.interfaces.ISymbol Rule -> aG
    org.matheclipse.core.interfaces.ISymbol RuleDelayed -> aH
    org.matheclipse.core.interfaces.ISymbol SameQ -> cO
    org.matheclipse.core.interfaces.ISymbol Scan -> cP
    org.matheclipse.core.interfaces.ISymbol Sec -> aI
    org.matheclipse.core.interfaces.ISymbol Sech -> aJ
    org.matheclipse.core.interfaces.ISymbol Set -> aK
    org.matheclipse.core.interfaces.ISymbol SetDelayed -> aL
    org.matheclipse.core.interfaces.ISymbol Sign -> cQ
    org.matheclipse.core.interfaces.ISymbol Sin -> aM
    org.matheclipse.core.interfaces.ISymbol Sinh -> aN
    org.matheclipse.core.interfaces.ISymbol Tan -> aO
    org.matheclipse.core.interfaces.ISymbol Tanh -> aP
    org.matheclipse.core.interfaces.ISymbol Taylor -> cR
    org.matheclipse.core.interfaces.ISymbol Times -> aQ
    org.matheclipse.core.interfaces.ISymbol Together -> cS
    org.matheclipse.core.interfaces.ISymbol TrigExpand -> cT
    org.matheclipse.core.interfaces.ISymbol TrigReduce -> cU
    org.matheclipse.core.interfaces.ISymbol Unequal -> aR
    org.matheclipse.core.interfaces.ISymbol UnsameQ -> cV
    org.matheclipse.core.interfaces.ISymbol UpSet -> aS
    org.matheclipse.core.interfaces.ISymbol UpSetDelayed -> aT
    org.matheclipse.core.interfaces.ISymbol a -> aU
    org.matheclipse.core.interfaces.ISymbol b -> aV
    org.matheclipse.core.interfaces.ISymbol c -> aW
    org.matheclipse.core.interfaces.ISymbol d -> aX
    org.matheclipse.core.interfaces.ISymbol e -> aY
    org.matheclipse.core.interfaces.ISymbol f -> aZ
    org.matheclipse.core.interfaces.ISymbol g -> ba
    org.matheclipse.core.interfaces.ISymbol h -> bb
    org.matheclipse.core.interfaces.ISymbol i -> bc
    org.matheclipse.core.interfaces.ISymbol j -> bd
    org.matheclipse.core.interfaces.ISymbol k -> be
    org.matheclipse.core.interfaces.ISymbol m -> bf
    org.matheclipse.core.interfaces.ISymbol n -> bg
    org.matheclipse.core.interfaces.ISymbol p -> bh
    org.matheclipse.core.interfaces.ISymbol q -> bi
    org.matheclipse.core.interfaces.ISymbol r -> bj
    org.matheclipse.core.interfaces.ISymbol s -> bk
    org.matheclipse.core.interfaces.ISymbol t -> bl
    org.matheclipse.core.interfaces.ISymbol u -> bm
    org.matheclipse.core.interfaces.ISymbol v -> bn
    org.matheclipse.core.interfaces.ISymbol w -> bo
    org.matheclipse.core.interfaces.ISymbol x -> bp
    org.matheclipse.core.interfaces.ISymbol y -> bq
    org.matheclipse.core.interfaces.ISymbol z -> br
    org.matheclipse.core.interfaces.IInteger C0 -> a
    org.matheclipse.core.interfaces.IInteger C1 -> b
    org.matheclipse.core.interfaces.IInteger C2 -> c
    org.matheclipse.core.interfaces.IInteger C3 -> d
    org.matheclipse.core.interfaces.IInteger C4 -> e
    org.matheclipse.core.interfaces.IInteger C5 -> f
    org.matheclipse.core.interfaces.IComplex CI -> a
    org.matheclipse.core.interfaces.IComplex CNI -> b
    org.matheclipse.core.interfaces.IFraction C1D2 -> a
    org.matheclipse.core.interfaces.IFraction CN1D2 -> b
    org.matheclipse.core.interfaces.IFraction C1D3 -> c
    org.matheclipse.core.interfaces.IFraction CN1D3 -> d
    org.matheclipse.core.interfaces.IFraction C1D4 -> e
    org.matheclipse.core.interfaces.IFraction CN1D4 -> f
    org.matheclipse.core.interfaces.INum CD0 -> a
    org.matheclipse.core.interfaces.INum CD1 -> b
    org.matheclipse.core.interfaces.IAST CInfinity -> a
    org.matheclipse.core.interfaces.IAST CNInfinity -> b
    org.matheclipse.core.interfaces.IAST CComplexInfinity -> c
    org.matheclipse.core.interfaces.IAST Slot1 -> d
    org.matheclipse.core.interfaces.IAST Slot2 -> e
    org.matheclipse.core.interfaces.IInteger CN1 -> g
    org.matheclipse.core.interfaces.IInteger CN2 -> h
    org.matheclipse.core.interfaces.IInteger CN3 -> i
    org.matheclipse.core.interfaces.IAST $(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[]) -> a
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,boolean) -> a
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String) -> a
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String,boolean) -> a
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IPatternSequence $ps(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.ISymbol $s(java.lang.String) -> a
    org.matheclipse.core.interfaces.ISymbol $s(java.lang.String,boolean) -> a
    org.matheclipse.core.interfaces.IAST Abs(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST And(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST Apart(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST Apart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST Append(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST Apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST ArcCos(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST ArcCosh(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST ArcCot(org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST ArcCoth(org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST ArcCsc(org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST ArcCsch(org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST ArcSec(org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST ArcSech(org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST ArcSin(org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST ArcSinh(org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST ArcTan(org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST ArcTan(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST ArcTanh(org.matheclipse.core.interfaces.IExpr) -> n
    org.matheclipse.core.interfaces.IAST Arg(org.matheclipse.core.interfaces.IExpr) -> o
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,int,int) -> a
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr) -> p
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr,int,boolean) -> a
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST AtomQ(org.matheclipse.core.interfaces.IExpr) -> q
    org.matheclipse.core.interfaces.IAST BernoulliB(org.matheclipse.core.interfaces.IExpr) -> r
    org.matheclipse.core.interfaces.IAST binary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST Binomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST Block(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.ISymbol bool(boolean) -> a
    org.matheclipse.core.interfaces.IAST Break() -> a
    org.matheclipse.core.interfaces.IAST Cancel(org.matheclipse.core.interfaces.IExpr) -> s
    org.matheclipse.core.interfaces.IAST Catch(org.matheclipse.core.interfaces.IExpr) -> t
    org.matheclipse.core.interfaces.IAST Ceiling(org.matheclipse.core.interfaces.IExpr) -> u
    org.matheclipse.core.interfaces.IAST Coefficient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST Collect(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IComplex complex(double,double) -> a
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IComplexNum complexNum(double) -> a
    org.matheclipse.core.interfaces.IComplexNum complexNum(double,double) -> a
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IAST Chop(org.matheclipse.core.interfaces.IExpr) -> v
    org.matheclipse.core.interfaces.IAST CompoundExpression(org.matheclipse.core.interfaces.IExpr[]) -> a
    org.matheclipse.core.interfaces.IAST Condition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST Conjugate(org.matheclipse.core.interfaces.IExpr) -> w
    org.matheclipse.core.interfaces.IAST Cos(org.matheclipse.core.interfaces.IExpr) -> x
    org.matheclipse.core.interfaces.IAST Cosh(org.matheclipse.core.interfaces.IExpr) -> y
    org.matheclipse.core.interfaces.IAST Cot(org.matheclipse.core.interfaces.IExpr) -> z
    org.matheclipse.core.interfaces.IAST Coth(org.matheclipse.core.interfaces.IExpr) -> A
    org.matheclipse.core.interfaces.IAST Count(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST Csc(org.matheclipse.core.interfaces.IExpr) -> B
    org.matheclipse.core.interfaces.IAST Csch(org.matheclipse.core.interfaces.IExpr) -> C
    org.matheclipse.core.interfaces.IAST D(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST Delete(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST Denominator(org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST Derivative(org.matheclipse.core.interfaces.IExpr) -> E
    org.matheclipse.core.interfaces.IAST Det(org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST Discriminant(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST Distribute(org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST Divide(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST Do(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> n
    org.matheclipse.core.interfaces.IAST Drop(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> o
    org.matheclipse.core.interfaces.IAST Equal(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> p
    org.matheclipse.core.interfaces.IAST Erf(org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evalBlock(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evalExpand(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr evalExpandAll(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr evaln(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
    boolean evalTrue(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST EvenQ(org.matheclipse.core.interfaces.IExpr) -> I
    org.matheclipse.core.interfaces.IAST Exp(org.matheclipse.core.interfaces.IExpr) -> J
    org.matheclipse.core.interfaces.IAST Expand(org.matheclipse.core.interfaces.IExpr) -> K
    org.matheclipse.core.interfaces.IAST Expand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> q
    org.matheclipse.core.interfaces.IAST ExpandAll(org.matheclipse.core.interfaces.IExpr) -> L
    org.matheclipse.core.interfaces.IAST Exponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> r
    org.matheclipse.core.interfaces.IAST Exponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST Factor(org.matheclipse.core.interfaces.IExpr) -> M
    org.matheclipse.core.interfaces.IAST Factorial(org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IAST FactorSquareFreeList(org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST First(org.matheclipse.core.interfaces.IExpr) -> P
    org.matheclipse.core.interfaces.IAST Floor(org.matheclipse.core.interfaces.IExpr) -> Q
    org.matheclipse.core.interfaces.IFraction fraction(org.apache.commons.math3.fraction.BigFraction) -> a
    org.matheclipse.core.interfaces.IFraction fraction(java.math.BigInteger,java.math.BigInteger) -> a
    org.matheclipse.core.interfaces.IFraction fraction(double) -> a
    org.matheclipse.core.interfaces.IFraction fraction(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IFraction fraction(long,long) -> a
    org.matheclipse.core.interfaces.IAST FractionalPart(org.matheclipse.core.interfaces.IExpr) -> R
    org.matheclipse.core.interfaces.IAST FreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> s
    org.matheclipse.core.interfaces.IAST FullSimplify(org.matheclipse.core.interfaces.IExpr) -> S
    org.matheclipse.core.interfaces.IAST Function(org.matheclipse.core.interfaces.IExpr) -> T
    org.matheclipse.core.interfaces.IAST Gamma(org.matheclipse.core.interfaces.IExpr) -> U
    org.matheclipse.core.interfaces.IAST Gamma(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> t
    org.matheclipse.core.interfaces.IAST GCD(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> u
    org.matheclipse.core.interfaces.IAST Greater(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> v
    org.matheclipse.core.interfaces.IAST GreaterEqual(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> w
    org.matheclipse.core.interfaces.IAST Head(org.matheclipse.core.interfaces.IExpr) -> V
    org.matheclipse.core.interfaces.IAST If(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> x
    org.matheclipse.core.interfaces.IAST If(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST Im(org.matheclipse.core.interfaces.IExpr) -> W
    org.matheclipse.core.interfaces.IAST Increment(org.matheclipse.core.interfaces.IExpr) -> X
    org.matheclipse.core.interfaces.ISymbol initFinalSymbol(java.lang.String) -> b
    org.matheclipse.core.interfaces.ISymbol initFinalSymbol(java.lang.String,org.matheclipse.core.interfaces.IEvaluator) -> a
    void initSymbols() -> a
    void initSymbols(java.lang.String,org.matheclipse.core.expression.ISymbolObserver,boolean) -> a
    org.matheclipse.core.interfaces.IInteger integer(java.math.BigInteger) -> a
    org.matheclipse.core.interfaces.IInteger integer(long) -> a
    org.matheclipse.core.interfaces.IInteger integer(java.lang.String,int) -> a
    org.matheclipse.core.interfaces.IAST IntegerPart(org.matheclipse.core.interfaces.IExpr) -> Y
    org.matheclipse.core.interfaces.IAST Integrate(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> y
    org.matheclipse.core.interfaces.IAST InverseErf(org.matheclipse.core.interfaces.IExpr) -> Z
    org.matheclipse.core.interfaces.IAST InverseFunction(org.matheclipse.core.interfaces.IExpr) -> aa
    boolean isNumEqualInteger(double,org.matheclipse.core.interfaces.IInteger) -> a
    boolean isNumIntValue(double) -> a
    boolean isZero(double) -> b
    boolean isZero(double,double) -> a
    org.matheclipse.core.interfaces.IAST Join(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> z
    org.matheclipse.core.interfaces.IAST LCM(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> A
    org.matheclipse.core.interfaces.IAST LeafCount(org.matheclipse.core.interfaces.IExpr) -> ab
    org.matheclipse.core.interfaces.IAST Length(org.matheclipse.core.interfaces.IExpr) -> ac
    org.matheclipse.core.interfaces.IAST Less(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> B
    org.matheclipse.core.interfaces.IAST LessEqual(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> C
    org.matheclipse.core.interfaces.IAST Limit(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST LinearSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> E
    org.matheclipse.core.interfaces.IAST List() -> b
    org.matheclipse.core.interfaces.IAST List(double[]) -> a
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr) -> ad
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr[]) -> b
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST Log(org.matheclipse.core.interfaces.IExpr) -> ae
    org.matheclipse.core.interfaces.IAST Map(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST MatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST Max() -> c
    org.matheclipse.core.interfaces.IAST Max(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> I
    org.matheclipse.core.interfaces.IAST MemberQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> J
    org.matheclipse.core.interfaces.ISymbol method(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    org.matheclipse.core.interfaces.IAST Min(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> K
    org.matheclipse.core.interfaces.IExpr Mod(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST Module(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> L
    org.matheclipse.core.interfaces.IAST N(org.matheclipse.core.interfaces.IExpr) -> af
    org.matheclipse.core.interfaces.IAST Negate(org.matheclipse.core.interfaces.IExpr) -> ag
    org.matheclipse.core.interfaces.IAST Negative(org.matheclipse.core.interfaces.IExpr) -> ah
    org.matheclipse.core.interfaces.IAST Not(org.matheclipse.core.interfaces.IExpr) -> ai
    org.matheclipse.core.interfaces.INum num(double) -> a
    org.matheclipse.core.interfaces.INum num(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.INum num(org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.INum num(java.lang.String) -> a
    org.matheclipse.core.interfaces.IAST NumberQ(org.matheclipse.core.interfaces.IExpr) -> aj
    org.matheclipse.core.interfaces.IAST Numerator(org.matheclipse.core.interfaces.IExpr) -> ak
    org.matheclipse.core.interfaces.IAST NumericQ(org.matheclipse.core.interfaces.IExpr) -> al
    org.matheclipse.core.interfaces.IAST OddQ(org.matheclipse.core.interfaces.IExpr) -> am
    org.matheclipse.core.interfaces.IAST Options(org.matheclipse.core.interfaces.IExpr) -> an
    org.matheclipse.core.interfaces.IAST Or(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> M
    org.matheclipse.core.interfaces.IAST Order(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IAST OrderedQ(org.matheclipse.core.interfaces.IExpr) -> ao
    org.matheclipse.core.interfaces.IAST Part(org.matheclipse.core.interfaces.IExpr[]) -> c
    org.matheclipse.core.interfaces.IAST Plus() -> d
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr) -> ap
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr[]) -> d
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST PolynomialQuotient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST PolynomialRemainder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST Positive(org.matheclipse.core.interfaces.IExpr) -> aq
    org.matheclipse.core.interfaces.IAST PossibleZeroQ(org.matheclipse.core.interfaces.IExpr) -> ar
    org.matheclipse.core.interfaces.IAST Power() -> e
    org.matheclipse.core.interfaces.IAST Power(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> P
    org.matheclipse.core.interfaces.ISymbol predefinedSymbol(java.lang.String) -> c
    org.matheclipse.core.interfaces.IAST Prepend(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Q
    org.matheclipse.core.interfaces.IAST Print(org.matheclipse.core.interfaces.IExpr[]) -> e
    org.matheclipse.core.interfaces.IAST Product(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> R
    org.matheclipse.core.interfaces.IAST quaternary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST quinary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST Quotient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> S
    org.matheclipse.core.interfaces.IAST Rational(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> T
    org.matheclipse.core.interfaces.IAST Re(org.matheclipse.core.interfaces.IExpr) -> as
    org.matheclipse.core.interfaces.IAST Reap(org.matheclipse.core.interfaces.IExpr) -> at
    org.matheclipse.core.interfaces.IAST ReplaceAll(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> U
    org.matheclipse.core.interfaces.IAST ReplacePart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST Rest(org.matheclipse.core.interfaces.IExpr) -> au
    org.matheclipse.core.interfaces.IAST Return(org.matheclipse.core.interfaces.IExpr) -> av
    org.matheclipse.core.interfaces.IAST Reverse(org.matheclipse.core.interfaces.IExpr) -> aw
    org.matheclipse.core.interfaces.IAST Round(org.matheclipse.core.interfaces.IExpr) -> ax
    org.matheclipse.core.interfaces.IAST Rule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> V
    org.matheclipse.core.interfaces.IAST RuleDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> W
    org.matheclipse.core.interfaces.IAST SameQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> X
    org.matheclipse.core.interfaces.IAST Scan(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Y
    org.matheclipse.core.interfaces.IAST Sec(org.matheclipse.core.interfaces.IExpr) -> ay
    org.matheclipse.core.interfaces.IAST Sech(org.matheclipse.core.interfaces.IExpr) -> az
    org.matheclipse.core.interfaces.IAST senary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST Sequence() -> f
    org.matheclipse.core.interfaces.IAST Sequence(org.matheclipse.core.interfaces.IExpr) -> aA
    org.matheclipse.core.interfaces.IAST Set(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Z
    org.matheclipse.core.interfaces.IAST SetDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aa
    org.matheclipse.core.interfaces.IAST Sign(org.matheclipse.core.interfaces.IExpr) -> aB
    org.matheclipse.core.interfaces.IAST Simplify(org.matheclipse.core.interfaces.IExpr) -> aC
    org.matheclipse.core.interfaces.IAST Sin(org.matheclipse.core.interfaces.IExpr) -> aD
    org.matheclipse.core.interfaces.IAST Sinh(org.matheclipse.core.interfaces.IExpr) -> aE
    org.matheclipse.core.interfaces.IAST Slot(org.matheclipse.core.interfaces.IExpr) -> aF
    org.matheclipse.core.interfaces.IAST Sow(org.matheclipse.core.interfaces.IExpr) -> aG
    org.matheclipse.core.interfaces.IAST Sqr(org.matheclipse.core.interfaces.IExpr) -> aH
    org.matheclipse.core.interfaces.IAST Sqrt(org.matheclipse.core.interfaces.IExpr) -> aI
    org.matheclipse.core.interfaces.IStringX stringx(java.lang.String) -> a
    org.matheclipse.core.interfaces.IStringX stringx(java.lang.StringBuffer) -> a
    org.matheclipse.core.interfaces.IExpr subst(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IExpr subst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST Subtract(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ab
    org.matheclipse.core.interfaces.IAST Sum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ac
    org.matheclipse.core.interfaces.IAST Tan(org.matheclipse.core.interfaces.IExpr) -> aJ
    org.matheclipse.core.interfaces.IAST Tanh(org.matheclipse.core.interfaces.IExpr) -> aK
    org.matheclipse.core.interfaces.IAST Taylor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ad
    org.matheclipse.core.interfaces.IAST ternary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST Throw(org.matheclipse.core.interfaces.IExpr) -> aL
    org.matheclipse.core.interfaces.IAST Times() -> g
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr) -> aM
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr[]) -> f
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ae
    org.matheclipse.core.interfaces.IAST Together(org.matheclipse.core.interfaces.IExpr) -> aN
    org.matheclipse.core.interfaces.IAST TrigExpand(org.matheclipse.core.interfaces.IExpr) -> aO
    org.matheclipse.core.interfaces.IAST TrigReduce(org.matheclipse.core.interfaces.IExpr) -> aP
    org.matheclipse.core.interfaces.IAST unary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> af
    org.matheclipse.core.interfaces.IAST Unequal(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ag
    org.matheclipse.core.interfaces.IAST UnsameQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ah
    org.matheclipse.core.interfaces.IAST UpSet(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ai
    org.matheclipse.core.interfaces.IAST While(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aj
    org.matheclipse.core.interfaces.IInteger ZZ(java.math.BigInteger) -> b
    org.matheclipse.core.interfaces.IInteger ZZ(long) -> b
org.matheclipse.core.expression.FractionSym -> kN:
    org.apache.commons.math3.fraction.BigFraction fRational -> a
    int fHashValue -> a
    org.matheclipse.core.expression.FractionSym newInstance(org.apache.commons.math3.fraction.BigFraction) -> a
    org.matheclipse.core.expression.FractionSym valueOf(java.math.BigInteger) -> a
    org.matheclipse.core.expression.FractionSym valueOf(java.math.BigInteger,java.math.BigInteger) -> a
    org.matheclipse.core.expression.FractionSym valueOf(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.expression.FractionSym valueOf(long,long) -> a
    org.matheclipse.core.expression.FractionSym valueOf(double) -> a
    boolean isZero() -> t
    boolean equalsInt(int) -> a
    java.math.BigInteger getBigDenominator() -> a
    java.math.BigInteger getBigNumerator() -> b
    org.apache.commons.math3.fraction.BigFraction getFraction() -> a
    org.matheclipse.core.interfaces.IInteger getDenominator() -> a
    org.matheclipse.core.interfaces.IInteger getNumerator() -> b
    int hierarchy() -> b
    org.matheclipse.core.interfaces.IFraction add(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IFraction multiply(org.matheclipse.core.interfaces.IFraction) -> b
    boolean isNegative() -> i
    boolean isPositive() -> A
    double doubleValue() -> a
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.INumber numericNumber() -> b
    org.matheclipse.core.interfaces.INumber normalize() -> c
    int hashCode() -> hashCode
    org.matheclipse.core.interfaces.ISignedNumber negate() -> c
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> a
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> b
    org.matheclipse.core.interfaces.IFraction pow(int) -> a
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> d
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> c
    java.lang.String internalFormString(boolean,int) -> a
    int toInt() -> e
    long toLong() -> a
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> c
    org.apache.commons.math3.fraction.BigFraction getRational() -> b
    int sign() -> f
    int complexSign() -> c
    org.matheclipse.core.interfaces.IInteger ceil() -> c
    org.matheclipse.core.interfaces.IInteger floor() -> d
    org.matheclipse.core.interfaces.IInteger round() -> e
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> a
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> b
    org.matheclipse.core.interfaces.ISymbol head() -> b
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> a
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> b
    org.matheclipse.core.interfaces.IExpr negate() -> c
    org.matheclipse.core.interfaces.IExpr inverse() -> a
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.INumber opposite() -> a
    org.matheclipse.core.interfaces.IExpr eabs() -> d
org.matheclipse.core.expression.ISymbolObserver -> kO:
org.matheclipse.core.expression.IntegerSym -> kP:
    java.math.BigInteger BI_MINUS_ONE -> b
    java.math.BigInteger fInteger -> a
    int fHashValue -> a
    org.matheclipse.core.expression.IntegerSym newInstance(java.math.BigInteger) -> b
    org.matheclipse.core.expression.IntegerSym valueOf(long) -> a
    org.matheclipse.core.expression.IntegerSym valueOf(java.lang.String,int) -> a
    boolean equalsInt(int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.INumber numericNumber() -> b
    int hierarchy() -> b
    org.matheclipse.core.interfaces.IInteger add(org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IInteger multiply(org.matheclipse.core.interfaces.IInteger) -> b
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.expression.IntegerSym valueOf(java.math.BigInteger) -> a
    org.matheclipse.core.expression.IntegerSym add(org.matheclipse.core.expression.IntegerSym) -> d
    org.matheclipse.core.expression.IntegerSym quotient(org.matheclipse.core.expression.IntegerSym) -> a
    double doubleValue() -> a
    org.matheclipse.core.interfaces.IInteger gcd(org.matheclipse.core.interfaces.IInteger) -> c
    org.matheclipse.core.interfaces.IInteger lcm(org.matheclipse.core.interfaces.IInteger) -> d
    int hashCode() -> hashCode
    boolean isNegative() -> i
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> a
    boolean isPositive() -> A
    boolean isZero() -> t
    boolean isOne() -> r
    boolean isMinusOne() -> s
    org.matheclipse.core.expression.IntegerSym mod(org.matheclipse.core.expression.IntegerSym) -> b
    org.matheclipse.core.expression.IntegerSym multiply(org.matheclipse.core.expression.IntegerSym) -> e
    org.matheclipse.core.interfaces.ISignedNumber negate() -> c
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> a
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> b
    org.matheclipse.core.expression.IntegerSym pow(int) -> a
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> d
    org.matheclipse.core.interfaces.IInteger subtract(org.matheclipse.core.interfaces.IInteger) -> e
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> c
    java.math.BigInteger getBigNumerator() -> a
    org.matheclipse.core.interfaces.IInteger getNumerator() -> b
    org.matheclipse.core.interfaces.IInteger getDenominator() -> a
    org.apache.commons.math3.fraction.BigFraction getFraction() -> a
    org.matheclipse.core.interfaces.IAST factorInteger() -> a
    org.matheclipse.core.interfaces.IInteger eulerPhi() -> f
    org.matheclipse.core.expression.IntegerSym moebiusMu() -> a
    org.matheclipse.core.expression.IntegerSym jacobiSymbol(org.matheclipse.core.expression.IntegerSym) -> c
    org.matheclipse.core.interfaces.IInteger[] primitiveRoots() -> a
    int compareTo(org.matheclipse.core.expression.IntegerSym) -> a
    boolean isEven() -> X
    boolean isOdd() -> Y
    int toInt() -> e
    long toLong() -> a
    int sign() -> f
    org.matheclipse.core.interfaces.IInteger[] nthRootSplit(int) -> a
    int complexSign() -> c
    org.matheclipse.core.interfaces.IInteger ceil() -> c
    org.matheclipse.core.interfaces.IInteger floor() -> d
    org.matheclipse.core.interfaces.IInteger round() -> e
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> a
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> b
    org.matheclipse.core.interfaces.ISymbol head() -> b
    java.lang.String toString() -> toString
    java.lang.String internalFormString(boolean,int) -> a
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> a
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> b
    org.matheclipse.core.interfaces.IExpr negate() -> c
    org.matheclipse.core.interfaces.IExpr inverse() -> a
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.IInteger pow(int) -> a
    org.matheclipse.core.interfaces.INumber opposite() -> a
    org.matheclipse.core.interfaces.IExpr eabs() -> d
org.matheclipse.core.expression.MethodSymbol -> kQ:
    java.lang.reflect.Method fMethod -> a
    org.matheclipse.core.interfaces.IExpr invoke(org.matheclipse.core.interfaces.IAST) -> e
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int hierarchy() -> b
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isTrue() -> u
    boolean isFalse() -> v
    org.matheclipse.core.interfaces.ISymbol head() -> b
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.Num -> kR:
    double fDouble -> a
    org.matheclipse.core.expression.Num newInstance(double) -> b
    int hierarchy() -> b
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> a
    boolean isNumIntValue() -> I
    boolean isNegative() -> i
    boolean isPositive() -> A
    boolean equalsInt(int) -> a
    org.matheclipse.core.interfaces.INum add(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.INum multiply(org.matheclipse.core.interfaces.INum) -> b
    org.matheclipse.core.interfaces.INum pow(org.matheclipse.core.interfaces.INum) -> c
    org.matheclipse.core.expression.Num valueOf(double) -> a
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> a
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> b
    double doubleValue() -> a
    boolean equals(java.lang.Object) -> equals
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> a
    int hashCode() -> hashCode
    int toInt() -> e
    long toLong() -> a
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.ISignedNumber negate() -> c
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> d
    double getRealPart() -> b
    boolean isZero() -> t
    boolean isOne() -> r
    boolean isMinusOne() -> s
    org.matheclipse.core.interfaces.IInteger round() -> e
    int sign() -> f
    int complexSign() -> c
    org.matheclipse.core.interfaces.IInteger ceil() -> c
    org.matheclipse.core.interfaces.IInteger floor() -> d
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> a
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> b
    org.matheclipse.core.interfaces.ISymbol head() -> b
    java.lang.String toString() -> toString
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> a
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> b
    org.matheclipse.core.interfaces.IExpr negate() -> c
    org.matheclipse.core.interfaces.IExpr inverse() -> a
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.INumber opposite() -> a
    org.matheclipse.core.interfaces.IExpr eabs() -> d
org.matheclipse.core.expression.NumberUtil -> kS:
    boolean[] bad255 -> a
    int[] start -> a
    boolean isZero(org.apache.commons.math3.fraction.BigFraction) -> a
    org.apache.commons.math3.fraction.BigFraction inverse(org.apache.commons.math3.fraction.BigFraction) -> a
    boolean isNegative(java.math.BigInteger) -> a
    boolean isZero(java.math.BigInteger) -> b
    boolean isEven(java.math.BigInteger) -> c
    boolean isOdd(java.math.BigInteger) -> d
    long toLong(java.math.BigInteger) -> a
    int toInt(java.math.BigInteger) -> a
    int toInt(double) -> a
    long toLong(double) -> a
    boolean isNegative(org.apache.commons.math3.fraction.BigFraction) -> b
    java.math.BigInteger floor(org.apache.commons.math3.fraction.BigFraction) -> a
    java.math.BigInteger ceiling(org.apache.commons.math3.fraction.BigFraction) -> b
    java.math.BigInteger round(org.apache.commons.math3.fraction.BigFraction,int) -> a
    boolean isPerfectSquare(org.apache.commons.math3.fraction.BigFraction) -> c
    boolean isPerfectSquare(long) -> a
org.matheclipse.core.expression.Pattern -> kT:
    org.matheclipse.core.expression.Pattern NULL_PATTERN -> a
    org.matheclipse.core.interfaces.IExpr fCondition -> a
    int fIndex -> a
    int fHashValue -> b
    org.matheclipse.core.interfaces.ISymbol fSymbol -> a
    boolean fDefault -> a
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr getCondition() -> d
    int getIndex() -> c
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> c
    int hashCode() -> hashCode
    int hierarchy() -> b
    void setIndex(int) -> a
    java.lang.String internalFormString(boolean,int) -> a
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> c
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol head() -> b
    boolean isBlank() -> X
    boolean isConditionMatched(org.matheclipse.core.interfaces.IExpr) -> e
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    boolean isDefault() -> Y
    boolean isPattern() -> x
    boolean isPatternExpr() -> y
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.PatternSequence -> kU:
    org.matheclipse.core.interfaces.IExpr fCondition -> a
    org.matheclipse.core.interfaces.ISymbol fSymbol -> a
    boolean fDefault -> a
    int fIndex -> a
    org.matheclipse.core.expression.PatternSequence valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr getCondition() -> d
    int getIndex() -> c
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> c
    int hashCode() -> hashCode
    int hierarchy() -> b
    java.lang.String internalFormString(boolean,int) -> a
    void setIndex(int) -> a
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> c
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol head() -> b
    boolean isConditionMatchedSequence(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    boolean isPatternExpr() -> y
    boolean isPatternSequence() -> z
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.Primality -> kV:
    java.security.SecureRandom random -> a
    int[] primes -> a
    short[] SHORT_PRIMES -> a
    java.math.BigInteger[] BIprimes -> a
    java.math.BigInteger countPrimes1021(java.math.BigInteger,java.util.Map) -> a
    java.math.BigInteger countPrimes32749(java.math.BigInteger,java.util.Map) -> b
    void pollardRhoFactors(java.math.BigInteger,java.util.Map) -> a
org.matheclipse.core.expression.StringX -> kW:
    java.lang.String fString -> a
    org.matheclipse.core.expression.StringX newInstance(java.lang.String) -> a
    org.matheclipse.core.expression.StringX valueOf(char) -> a
    org.matheclipse.core.expression.StringX valueOf(java.lang.Object) -> a
    org.matheclipse.core.expression.StringX valueOf(java.lang.StringBuffer) -> a
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int hierarchy() -> b
    java.lang.String internalFormString(boolean,int) -> a
    org.matheclipse.core.interfaces.ISymbol head() -> b
    java.lang.String toString() -> toString
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.Symbol -> kX:
    int fAttributes -> a
    org.matheclipse.core.interfaces.IEvaluator fEvaluator -> a
    org.matheclipse.core.patternmatching.DownRulesData fDownRulesData -> a
    org.matheclipse.core.patternmatching.UpRulesData fUpRulesData -> a
    org.matheclipse.core.util.OpenIntToIExprHashMap fDefaultValues -> a
    org.matheclipse.core.expression.Symbol$DummyEvaluator DUMMY_EVALUATOR -> a
    java.lang.String fSymbolName -> a
    int fHashValue -> b
    org.matheclipse.core.interfaces.IExpr[] reassignSymbolValue(com.google.common.base.Function,org.matheclipse.core.interfaces.ISymbol) -> a
    void pushLocalVariable() -> a
    void pushLocalVariable(org.matheclipse.core.interfaces.IExpr) -> a
    void popLocalVariable() -> b
    void clear(org.matheclipse.core.eval.EvalEngine) -> a
    void clearAll(org.matheclipse.core.eval.EvalEngine) -> b
    boolean equals(java.lang.Object) -> equals
    boolean isSymbolName(java.lang.String) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.IExpr evalDownRule$6c3927ef(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evalUpRule$6c3927ef(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction,org.matheclipse.core.interfaces.IExpr) -> b
    int getAttributes() -> c
    org.matheclipse.core.interfaces.IEvaluator getEvaluator() -> a
    boolean hasLocalVariableStack() -> X
    org.matheclipse.core.interfaces.IExpr get() -> d
    void set(org.matheclipse.core.interfaces.IExpr) -> b
    int hashCode() -> hashCode
    int hierarchy() -> b
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    void setAttributes(int) -> a
    void setEvaluator(org.matheclipse.core.interfaces.IEvaluator) -> a
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isAtom() -> V
    boolean isConstant() -> E
    boolean isTrue() -> u
    boolean isValue() -> W
    boolean isFalse() -> v
    boolean isNegative() -> i
    boolean isPositive() -> A
    org.matheclipse.core.interfaces.ISymbol head() -> b
    java.lang.String getSymbolName() -> d
    java.lang.String internalFormString(boolean,int) -> a
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> c
    org.matheclipse.core.interfaces.IExpr getDefaultValue() -> e
    org.matheclipse.core.interfaces.IExpr getDefaultValue(int) -> b
    void setDefaultValue(org.matheclipse.core.interfaces.IExpr) -> c
    void setDefaultValue(int,org.matheclipse.core.interfaces.IExpr) -> a
    java.lang.String definitionToString() -> e
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    org.matheclipse.core.interfaces.IExpr mapConstantDouble(org.matheclipse.core.generic.interfaces.INumericFunction) -> a
    org.matheclipse.core.interfaces.IExpr negate() -> c
    org.matheclipse.core.interfaces.IExpr head() -> b
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.Symbol$DummyEvaluator -> kY:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.form.mathml.AbstractConverter -> kZ:
org.matheclipse.core.form.mathml.AbstractMathMLFormFactory -> la:
    java.util.Hashtable ENTITY_TABLE -> a
org.matheclipse.core.form.mathml.MMLContentFunction -> lb:
org.matheclipse.core.form.mathml.MathMLFormFactory -> lc:
    java.util.Hashtable CONSTANT_SYMBOLS -> b
    java.util.Hashtable operTab -> c
org.matheclipse.core.form.mathml.MathMLFormFactory$Operator -> ld:
    java.lang.String fOperator -> a
    java.lang.String toString() -> toString
org.matheclipse.core.form.output.OutputFormFactory -> le:
    boolean fRelaxedSyntax -> b
    boolean fIgnoreNewLine -> a
    boolean fEmpty -> c
    int fColumnCounter -> a
    org.matheclipse.core.form.output.OutputFormFactory get(boolean) -> a
    void convertDoubleValue(java.lang.Appendable,java.lang.String,int,boolean) -> a
    void convertDoubleComplex(java.lang.Appendable,org.matheclipse.core.interfaces.IComplexNum,int) -> a
    void convertInteger(java.lang.Appendable,org.matheclipse.core.interfaces.IInteger,int) -> a
    void convertFraction(java.lang.Appendable,org.apache.commons.math3.fraction.BigFraction,int) -> a
    void convertComplex(java.lang.Appendable,org.matheclipse.core.interfaces.IComplex,int) -> a
    void convertSymbol(java.lang.Appendable,org.matheclipse.core.interfaces.ISymbol) -> a
    void convert(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr) -> a
    void convertNumber(java.lang.Appendable,org.matheclipse.core.interfaces.INumber,int) -> a
    void convert(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr,int) -> a
    void convertAST(java.lang.Appendable,org.matheclipse.core.interfaces.IAST) -> a
    void newLine(java.lang.Appendable) -> a
    void append(java.lang.Appendable,java.lang.String) -> a
    void append(java.lang.Appendable,char) -> a
org.matheclipse.core.generic.BinaryApply -> lf:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.BinaryBindIth1st -> lg:
    org.matheclipse.core.interfaces.IAST fConstant1 -> a
    org.matheclipse.core.interfaces.IAST fConstant2 -> b
    java.lang.Object apply(int,java.lang.Object) -> a
org.matheclipse.core.generic.BinaryEval -> lh:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.BinaryMap -> li:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.ExprComparator -> lj:
    org.matheclipse.core.generic.ExprComparator CONS -> a
    int compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.generic.Functors -> lk:
    com.google.common.base.Predicate PATTERNQ_PREDICATE -> a
    com.google.common.base.Function scan(org.matheclipse.core.interfaces.IAST,java.util.Collection) -> a
    com.google.common.base.Function append(org.matheclipse.core.interfaces.IAST) -> a
    com.google.common.base.Function evalArg(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.eval.EvalEngine) -> a
    com.google.common.base.Function apply(org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Function collect(java.util.Collection) -> a
    com.google.common.base.Function replaceAll(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Function replace1st(org.matheclipse.core.interfaces.IAST) -> b
    com.google.common.base.Function replace2nd(org.matheclipse.core.interfaces.IAST) -> c
    com.google.common.base.Function rules(java.util.Map) -> a
    com.google.common.base.Function rules(java.lang.String[]) -> a
    com.google.common.base.Function rules(org.matheclipse.core.interfaces.IAST) -> d
    void addRuleToCollection(java.util.Map,java.util.List,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.generic.Functors$1 -> ll:
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$AppendFunctor -> lm:
    org.matheclipse.core.interfaces.IAST fAST -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$ApplyFunctor -> ln:
    org.matheclipse.core.interfaces.IExpr fConstant -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$CollectFunctor -> lo:
    java.util.Collection resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$EvalArgFunctor -> lp:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    int fPosition -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$ReplaceAllFunctor -> lq:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    org.matheclipse.core.interfaces.IExpr fLHS -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$ReplaceArgFunctor -> lr:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    int fPosition -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$RulesFunctor -> ls:
    java.util.Map fEqualRules -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$RulesPatternFunctor -> lt:
    java.util.Map fEqualRules -> a
    java.util.List fMatchers -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.Functors$ScanFunctor -> lu:
    org.matheclipse.core.interfaces.IAST fAST -> a
    java.util.Collection resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT -> lv:
    int TRUE$1c342bc9 -> a
    int FALSE$1c342bc9 -> b
    int UNDEFINED$1c342bc9 -> c
org.matheclipse.core.generic.IsBinaryFalse -> lw:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    int compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.IsLEOrdered -> lx:
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.MultipleArrayFunction -> ly:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fHeadAST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.MultipleConstArrayFunction -> lz:
    org.matheclipse.core.interfaces.IExpr fConstantExpr -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.PositionConverter -> lA:
    int toInt(java.lang.Object) -> a
    java.lang.Object toObject(int) -> a
org.matheclipse.core.generic.Predicates$3 -> lB:
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.generic.Predicates$5 -> lC:
    org.matheclipse.core.interfaces.ISymbol[] val$heads -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.generic.Predicates$InASTPredicate -> lD:
    org.matheclipse.core.interfaces.IAST target -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.generic.Predicates$IsUnaryTrue -> lE:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.generic.UnaryArrayFunction -> lF:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IExpr fValue -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.UnaryNumerical -> lG:
    org.matheclipse.core.interfaces.IExpr fFunction -> a
    org.matheclipse.core.interfaces.ISymbol fVariable -> a
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    double value(double) -> a
    org.apache.commons.math3.analysis.UnivariateFunction derivative() -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.generic.UnaryRangeFunction -> lH:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.combinatoric.CartesianProductIterator -> lI:
    java.util.List comps -> a
    java.util.List compit -> b
    org.matheclipse.core.interfaces.IAST current -> a
    boolean empty -> a
    boolean hasNext() -> hasNext
    org.matheclipse.core.interfaces.IAST next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.generic.combinatoric.CartesianProductList -> lJ:
    java.util.List comps -> a
    org.matheclipse.core.interfaces.IAST fEmptyResultList -> a
    java.util.Iterator iterator() -> iterator
org.matheclipse.core.generic.combinatoric.KPartitionsIterable -> lK:
    int fLength -> b
    int fNumberOfParts -> a
    int[] fPartitionsIndex -> a
    int[] fCopiedResultIndex -> c
    int[] fResultIndex -> b
    int[] nextBeforehand() -> a
    int[] next() -> b
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.generic.combinatoric.KPartitionsList -> lL:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    org.matheclipse.core.generic.combinatoric.KPartitionsIterable fIterable -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.generic.combinatoric.KPermutationsIterable -> lM:
    int n -> a
    int k -> b
    int[] fPermutationsIndex -> a
    int[] y -> b
    boolean first -> a
    int h -> c
    int i -> d
    int m -> e
    int[] fCopiedResultIndex -> c
    int[] fResultIndex -> d
    int[] nextBeforehand() -> b
    int[] next() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.generic.combinatoric.KPermutationsList -> lN:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    org.matheclipse.core.generic.combinatoric.KPermutationsIterable fIterable -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.generic.combinatoric.KSubsetsIterable -> lO:
    int n -> a
    int k -> b
    int[] x -> a
    long bin -> a
    boolean first -> a
    long binomial(long,long) -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.generic.combinatoric.KSubsetsList -> lP:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    java.util.Iterator fIterable -> a
    int fK -> b
    org.matheclipse.core.generic.combinatoric.KSubsetsList createKSubsets(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,int) -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.generic.combinatoric.NumberPartitionsIterable -> lQ:
    int n -> a
    int len -> b
    int[] fPartititionsIndex -> a
    int i -> c
    int k -> d
    int[] fCopiedResultIndex -> b
    int[] fResultIndex -> c
    int[] nextBeforehand() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.generic.interfaces.BiFunction -> lR:
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.interfaces.BiPredicate -> lS:
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.interfaces.IArrayFunction -> lT:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.interfaces.IIterator -> lU:
    boolean setUp() -> a
    void tearDown() -> a
org.matheclipse.core.generic.interfaces.INumericFunction -> lV:
    java.lang.Object apply(double) -> a
org.matheclipse.core.generic.interfaces.IPositionConverter -> lW:
    java.lang.Object toObject(int) -> a
    int toInt(java.lang.Object) -> a
org.matheclipse.core.generic.interfaces.IUnaryIndexFunction -> lX:
    java.lang.Object apply(int,java.lang.Object) -> a
org.matheclipse.core.generic.util.HMArrayList -> lY:
    int firstIndex -> a
    int lastIndex -> b
    int hashValue -> c
    java.lang.Object[] array -> a
    void add(int,java.lang.Object) -> add
    boolean add(java.lang.Object) -> add
    boolean addAll(int,java.util.Collection) -> addAll
    boolean addAll(java.util.Collection) -> addAll
    void clear() -> clear
    java.lang.Object clone() -> clone
    boolean contains(java.lang.Object) -> contains
    boolean equals(java.lang.Object) -> equals
    boolean isSameHead(java.lang.Object,int) -> a
    boolean isSameHeadSizeGE(java.lang.Object,int) -> b
    java.lang.Object get(int) -> get
    void growAtEnd(int) -> c
    void growAtFront(int) -> d
    void growForInsert(int,int) -> a
    int hashCode() -> hashCode
    int indexOf(java.lang.Object) -> indexOf
    boolean isEmpty() -> isEmpty
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.lang.Object remove(int) -> remove
    boolean remove(java.lang.Object) -> remove
    void removeRange(int,int) -> removeRange
    java.lang.Object set(int,java.lang.Object) -> set
    int size() -> size
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules0 -> lZ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules1 -> ma:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules10 -> mb:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules11 -> mc:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules12 -> md:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules13 -> me:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules14 -> mf:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules15 -> mg:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules16 -> mh:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules2 -> mi:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules3 -> mj:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules4 -> mk:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules5 -> ml:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules6 -> mm:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules7 -> mn:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules8 -> mo:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IndefiniteIntegrationRules9 -> mp:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.IntIntegerQ -> org.matheclipse.core.integrate.rubi.IntIntegerQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.integrate.rubi.IntPolynomialQ -> org.matheclipse.core.integrate.rubi.IntPolynomialQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean polynomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.integrate.rubi.UtilityFunctionCtors -> mq:
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_TRIG_SIMPLIFY -> a
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_SMARTLEAFCOUNT -> b
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_SMARTNUMERATOR -> c
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_SMARTDENOMINATOR -> d
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_SIMP -> e
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_REAPLIST -> f
    org.matheclipse.core.interfaces.IAST AlgebraicFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST BinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST BinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST CalculusFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST CalculusQ(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST CommonFactors(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST CommonNumericFactors(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST ComplexFreeQ(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST ConstantFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST ContainsQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST ContentFactor(org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST CosQ(org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST CoshQ(org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST CotQ(org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST CothQ(org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST CscQ(org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST CschQ(org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST DerivativeDivides(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST Dist(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST DivideDegreesOfFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST EasyDQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST EvenQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST ExpQ(org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST ExpandExpression(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST ExpandExpressionAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST ExpandImproperFraction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST ExpandImproperFraction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST ExpandIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST ExpandPolynomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST ExpandTrigExpression(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST ExpandTrigExpressionAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> n
    org.matheclipse.core.interfaces.IAST ExpnExpand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> o
    org.matheclipse.core.interfaces.IAST ExpnExpandAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> p
    org.matheclipse.core.interfaces.IAST FactorOrder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> q
    org.matheclipse.core.interfaces.IAST FalseQ(org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST FindKernel(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> r
    org.matheclipse.core.interfaces.IAST FindTrigFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST FractionOrNegativeQ(org.matheclipse.core.interfaces.IExpr) -> n
    org.matheclipse.core.interfaces.IAST FractionQ(org.matheclipse.core.interfaces.IExpr) -> o
    org.matheclipse.core.interfaces.IAST FractionalPowerFreeQ(org.matheclipse.core.interfaces.IExpr) -> p
    org.matheclipse.core.interfaces.IAST FractionalPowerOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST FractionalPowerOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST FractionalPowerQ(org.matheclipse.core.interfaces.IExpr) -> q
    org.matheclipse.core.interfaces.IAST FunctionOfCosQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST FunctionOfCoshQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST FunctionOfDensePolynomialsQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> s
    org.matheclipse.core.interfaces.IAST FunctionOfExpnQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> t
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialOfLinearAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialOfLinearSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> u
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolicQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST FunctionOfInverseLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> v
    org.matheclipse.core.interfaces.IAST FunctionOfInverseLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST FunctionOfKernelQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST FunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> w
    org.matheclipse.core.interfaces.IAST FunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST FunctionOfLinearSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST FunctionOfLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> x
    org.matheclipse.core.interfaces.IAST FunctionOfLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST FunctionOfPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST FunctionOfProductLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> y
    org.matheclipse.core.interfaces.IAST FunctionOfProductLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST FunctionOfQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST FunctionOfSinQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST FunctionOfSinhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> n
    org.matheclipse.core.interfaces.IAST FunctionOfSquareRootOfQuadratic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> z
    org.matheclipse.core.interfaces.IAST FunctionOfSquareRootOfQuadratic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> o
    org.matheclipse.core.interfaces.IAST FunctionOfTanQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> p
    org.matheclipse.core.interfaces.IAST FunctionOfTanWeight(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> q
    org.matheclipse.core.interfaces.IAST FunctionOfTanhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> r
    org.matheclipse.core.interfaces.IAST FunctionOfTanhWeight(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> s
    org.matheclipse.core.interfaces.IAST FunctionOfTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> A
    org.matheclipse.core.interfaces.IAST FunctionOfTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> t
    org.matheclipse.core.interfaces.IAST FunctionOfTrigQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> u
    org.matheclipse.core.interfaces.IAST GE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> B
    org.matheclipse.core.interfaces.IAST GE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> v
    org.matheclipse.core.interfaces.IAST GT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> C
    org.matheclipse.core.interfaces.IAST GT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> w
    org.matheclipse.core.interfaces.IAST GoodExpansionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> x
    org.matheclipse.core.interfaces.IAST HalfIntegerQ(org.matheclipse.core.interfaces.IExpr) -> r
    org.matheclipse.core.interfaces.IAST HyperbolicQ(org.matheclipse.core.interfaces.IExpr) -> s
    org.matheclipse.core.interfaces.IAST ImaginaryNumericQ(org.matheclipse.core.interfaces.IExpr) -> t
    org.matheclipse.core.interfaces.IAST ImaginaryQ(org.matheclipse.core.interfaces.IExpr) -> u
    org.matheclipse.core.interfaces.IAST ImproperRationalFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> y
    org.matheclipse.core.interfaces.IAST IndependentQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST IntegerPowerQ(org.matheclipse.core.interfaces.IExpr) -> v
    org.matheclipse.core.interfaces.IAST IntegerQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> E
    org.matheclipse.core.interfaces.IAST InverseFunctionFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST InverseFunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST InverseFunctionOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST InverseFunctionQ(org.matheclipse.core.interfaces.IExpr) -> w
    org.matheclipse.core.interfaces.IAST InverseHyperbolicQ(org.matheclipse.core.interfaces.IExpr) -> x
    org.matheclipse.core.interfaces.IAST InverseTrigQ(org.matheclipse.core.interfaces.IExpr) -> y
    org.matheclipse.core.interfaces.IAST LE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> I
    org.matheclipse.core.interfaces.IAST LE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> z
    org.matheclipse.core.interfaces.IAST LT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> J
    org.matheclipse.core.interfaces.IAST LT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> A
    org.matheclipse.core.interfaces.IAST LeadBase(org.matheclipse.core.interfaces.IExpr) -> z
    org.matheclipse.core.interfaces.IAST LeadDegree(org.matheclipse.core.interfaces.IExpr) -> A
    org.matheclipse.core.interfaces.IAST LeadFactor(org.matheclipse.core.interfaces.IExpr) -> B
    org.matheclipse.core.interfaces.IAST LeadTerm(org.matheclipse.core.interfaces.IExpr) -> C
    org.matheclipse.core.interfaces.IAST LinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> K
    org.matheclipse.core.interfaces.IAST LogQ(org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST MakeList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> L
    org.matheclipse.core.interfaces.IAST Map2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> B
    org.matheclipse.core.interfaces.IAST MapAnd(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> M
    org.matheclipse.core.interfaces.IAST MapAnd(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> C
    org.matheclipse.core.interfaces.IAST MapOr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IAST MinimumDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST Mods(org.matheclipse.core.interfaces.IExpr) -> E
    org.matheclipse.core.interfaces.IAST MonomialFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> P
    org.matheclipse.core.interfaces.IAST MonomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Q
    org.matheclipse.core.interfaces.IAST MonomialSumQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> R
    org.matheclipse.core.interfaces.IAST MostMainFactorPosition(org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST NegQ(org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST NegativeCoefficientQ(org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST NegativeOrZeroQ(org.matheclipse.core.interfaces.IExpr) -> I
    org.matheclipse.core.interfaces.IAST NegativeQ(org.matheclipse.core.interfaces.IExpr) -> J
    org.matheclipse.core.interfaces.IAST NonnumericFactors(org.matheclipse.core.interfaces.IExpr) -> K
    org.matheclipse.core.interfaces.IAST NonpolynomialTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> S
    org.matheclipse.core.interfaces.IAST NonpositiveFactors(org.matheclipse.core.interfaces.IExpr) -> L
    org.matheclipse.core.interfaces.IAST NonsumQ(org.matheclipse.core.interfaces.IExpr) -> M
    org.matheclipse.core.interfaces.IAST NonzeroQ(org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IAST NormalForm(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> T
    org.matheclipse.core.interfaces.IAST NotFalseQ(org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST NotIntegrableQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> U
    org.matheclipse.core.interfaces.IAST NumericFactor(org.matheclipse.core.interfaces.IExpr) -> P
    org.matheclipse.core.interfaces.IAST OddHyperbolicPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST OddQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> V
    org.matheclipse.core.interfaces.IAST OddTrigPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> E
    org.matheclipse.core.interfaces.IAST PerfectPowerTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> W
    org.matheclipse.core.interfaces.IAST PolynomialDivide(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST PolynomialFunctionOf(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> X
    org.matheclipse.core.interfaces.IAST PolynomialTermQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Y
    org.matheclipse.core.interfaces.IAST PolynomialTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Z
    org.matheclipse.core.interfaces.IAST PosQ(org.matheclipse.core.interfaces.IExpr) -> Q
    org.matheclipse.core.interfaces.IAST PositiveFactors(org.matheclipse.core.interfaces.IExpr) -> R
    org.matheclipse.core.interfaces.IAST PositiveIntegerPowerQ(org.matheclipse.core.interfaces.IExpr) -> S
    org.matheclipse.core.interfaces.IAST PositiveOrZeroQ(org.matheclipse.core.interfaces.IExpr) -> T
    org.matheclipse.core.interfaces.IAST PositiveQ(org.matheclipse.core.interfaces.IExpr) -> U
    org.matheclipse.core.interfaces.IAST PowerQ(org.matheclipse.core.interfaces.IExpr) -> V
    org.matheclipse.core.interfaces.IAST PowerVariableDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST PowerVariableExpn(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST PowerVariableSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST ProductLogQ(org.matheclipse.core.interfaces.IExpr) -> W
    org.matheclipse.core.interfaces.IAST ProductQ(org.matheclipse.core.interfaces.IExpr) -> X
    org.matheclipse.core.interfaces.IAST PureFunctionOfCosQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> I
    org.matheclipse.core.interfaces.IAST PureFunctionOfCoshQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> J
    org.matheclipse.core.interfaces.IAST PureFunctionOfCotQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> K
    org.matheclipse.core.interfaces.IAST PureFunctionOfCothQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> L
    org.matheclipse.core.interfaces.IAST PureFunctionOfSinQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> M
    org.matheclipse.core.interfaces.IAST PureFunctionOfSinhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IAST PureFunctionOfTanQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST PureFunctionOfTanhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> P
    org.matheclipse.core.interfaces.IAST QuadraticPolynomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aa
    org.matheclipse.core.interfaces.IAST QuadraticQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ab
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsParts(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ac
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ad
    org.matheclipse.core.interfaces.IAST RationalFunctionExponents(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ae
    org.matheclipse.core.interfaces.IAST RationalFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> af
    org.matheclipse.core.interfaces.IAST RationalPowerQ(org.matheclipse.core.interfaces.IExpr) -> Y
    org.matheclipse.core.interfaces.IAST RationalQ(org.matheclipse.core.interfaces.IExpr) -> Z
    org.matheclipse.core.interfaces.IAST RealNumericQ(org.matheclipse.core.interfaces.IExpr) -> aa
    org.matheclipse.core.interfaces.IAST RealQ(org.matheclipse.core.interfaces.IExpr) -> ab
    org.matheclipse.core.interfaces.IAST ReapList(org.matheclipse.core.interfaces.IExpr) -> ac
    org.matheclipse.core.interfaces.IAST RecognizedFormQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ag
    org.matheclipse.core.interfaces.IAST Regularize(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ah
    org.matheclipse.core.interfaces.IAST RegularizeSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Q
    org.matheclipse.core.interfaces.IAST RegularizeTerm(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ai
    org.matheclipse.core.interfaces.IAST RemainingFactors(org.matheclipse.core.interfaces.IExpr) -> ad
    org.matheclipse.core.interfaces.IAST RemainingTerms(org.matheclipse.core.interfaces.IExpr) -> ae
    org.matheclipse.core.interfaces.IAST Rt(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aj
    org.matheclipse.core.interfaces.IAST SecQ(org.matheclipse.core.interfaces.IExpr) -> af
    org.matheclipse.core.interfaces.IAST SechQ(org.matheclipse.core.interfaces.IExpr) -> ag
    org.matheclipse.core.interfaces.IAST Second(org.matheclipse.core.interfaces.IExpr) -> ah
    org.matheclipse.core.interfaces.IAST Simp(org.matheclipse.core.interfaces.IExpr) -> ai
    org.matheclipse.core.interfaces.IAST SimpAux(org.matheclipse.core.interfaces.IExpr) -> aj
    org.matheclipse.core.interfaces.IAST SimpProduct(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ak
    org.matheclipse.core.interfaces.IAST SimpSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> al
    org.matheclipse.core.interfaces.IAST SimplerExpressionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> R
    org.matheclipse.core.interfaces.IAST SimplerRationalFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> am
    org.matheclipse.core.interfaces.IAST SimplifyExpression(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> an
    org.matheclipse.core.interfaces.IAST SinCosQ(org.matheclipse.core.interfaces.IExpr) -> ak
    org.matheclipse.core.interfaces.IAST SinQ(org.matheclipse.core.interfaces.IExpr) -> al
    org.matheclipse.core.interfaces.IAST SinhCoshQ(org.matheclipse.core.interfaces.IExpr) -> am
    org.matheclipse.core.interfaces.IAST SinhQ(org.matheclipse.core.interfaces.IExpr) -> an
    org.matheclipse.core.interfaces.IAST Smallest(org.matheclipse.core.interfaces.IExpr) -> ao
    org.matheclipse.core.interfaces.IAST Smallest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ao
    org.matheclipse.core.interfaces.IAST SmartDenominator(org.matheclipse.core.interfaces.IExpr) -> ap
    org.matheclipse.core.interfaces.IAST SmartLeafCount(org.matheclipse.core.interfaces.IExpr) -> aq
    org.matheclipse.core.interfaces.IAST SmartNumerator(org.matheclipse.core.interfaces.IExpr) -> ar
    org.matheclipse.core.interfaces.IAST SmartTrigExpand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ap
    org.matheclipse.core.interfaces.IAST SplitFactorsOfTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aq
    org.matheclipse.core.interfaces.IAST SplitFreeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ar
    org.matheclipse.core.interfaces.IAST SplitFreeTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> as
    org.matheclipse.core.interfaces.IAST SplitMonomialTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> at
    org.matheclipse.core.interfaces.IAST SqrtNumberQ(org.matheclipse.core.interfaces.IExpr) -> as
    org.matheclipse.core.interfaces.IAST SqrtNumberSumQ(org.matheclipse.core.interfaces.IExpr) -> at
    org.matheclipse.core.interfaces.IAST SqrtQ(org.matheclipse.core.interfaces.IExpr) -> au
    org.matheclipse.core.interfaces.IAST SquareRootOfQuadraticSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST Subst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> S
    org.matheclipse.core.interfaces.IAST SubstFor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> T
    org.matheclipse.core.interfaces.IAST SubstForExpn(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> U
    org.matheclipse.core.interfaces.IAST SubstForFractionalPower(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerAuxQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> V
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> au
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> av
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> W
    org.matheclipse.core.interfaces.IAST SubstForHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST SubstForInverseFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> X
    org.matheclipse.core.interfaces.IAST SubstForInverseFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST SubstForInverseFunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aw
    org.matheclipse.core.interfaces.IAST SubstForInverseFunctionOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ax
    org.matheclipse.core.interfaces.IAST SubstForInverseLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ay
    org.matheclipse.core.interfaces.IAST SubstForPower(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST SubstForTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST SubstQ(org.matheclipse.core.interfaces.IExpr) -> av
    org.matheclipse.core.interfaces.IAST SumFreeQ(org.matheclipse.core.interfaces.IExpr) -> aw
    org.matheclipse.core.interfaces.IAST SumQ(org.matheclipse.core.interfaces.IExpr) -> ax
    org.matheclipse.core.interfaces.IAST TanQ(org.matheclipse.core.interfaces.IExpr) -> ay
    org.matheclipse.core.interfaces.IAST TanhQ(org.matheclipse.core.interfaces.IExpr) -> az
    org.matheclipse.core.interfaces.IAST TrigHyperbolicFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> az
    org.matheclipse.core.interfaces.IAST TrigQ(org.matheclipse.core.interfaces.IExpr) -> aA
    org.matheclipse.core.interfaces.IAST TrigSimplify(org.matheclipse.core.interfaces.IExpr) -> aB
    org.matheclipse.core.interfaces.IAST TrigSimplifyAux(org.matheclipse.core.interfaces.IExpr) -> aC
    org.matheclipse.core.interfaces.IAST TryTrigReduceQ(org.matheclipse.core.interfaces.IExpr) -> aD
    org.matheclipse.core.interfaces.IAST ZeroQ(org.matheclipse.core.interfaces.IExpr) -> aE
org.matheclipse.core.integrate.rubi.UtilityFunctions -> org.matheclipse.core.integrate.rubi.UtilityFunctions:
    org.matheclipse.core.interfaces.ISymbol ListQ -> a
    org.matheclipse.core.interfaces.ISymbol IntIntegerQ -> b
    org.matheclipse.core.interfaces.ISymbol IntPolynomialQ -> c
    org.matheclipse.core.interfaces.IAST Int(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Int
    org.matheclipse.core.interfaces.ISymbol $sDBG(java.lang.String) -> $sDBG
    org.matheclipse.core.interfaces.IAST FunctionOfQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfQ
    org.matheclipse.core.interfaces.IAST IntegrateMonomialSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> IntegrateMonomialSum
    org.matheclipse.core.interfaces.IAST SplitFreeIntegrate(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SplitFreeIntegrate
    org.matheclipse.core.interfaces.IAST TryTanSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TryTanSubst
    org.matheclipse.core.interfaces.IAST TryTanhSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TryTanhSubst
    org.matheclipse.core.interfaces.IAST TryPureTanSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TryPureTanSubst
    org.matheclipse.core.interfaces.IAST TryPureTanhSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TryPureTanhSubst
    org.matheclipse.core.interfaces.IAST LinearSinCosQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LinearSinCosQ
    org.matheclipse.core.interfaces.IAST LinearSinhCoshQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LinearSinhCoshQ
    org.matheclipse.core.interfaces.IExpr isList(org.matheclipse.core.interfaces.IAST) -> isList
    org.matheclipse.core.interfaces.IAST ListQ(org.matheclipse.core.interfaces.IExpr) -> ListQ
    org.matheclipse.core.interfaces.IAST IntIntegerQ(org.matheclipse.core.interfaces.IExpr) -> IntIntegerQ
    org.matheclipse.core.interfaces.IAST IntPolynomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> IntPolynomialQ
    org.matheclipse.core.interfaces.IAST Protect(org.matheclipse.core.interfaces.IExpr) -> Protect
    org.matheclipse.core.interfaces.IAST CosIntegral(org.matheclipse.core.interfaces.IExpr) -> CosIntegral
    org.matheclipse.core.interfaces.IAST EllipticE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> EllipticE
    org.matheclipse.core.interfaces.IAST EllipticF(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> EllipticF
    org.matheclipse.core.interfaces.IAST FresnelC(org.matheclipse.core.interfaces.IExpr) -> FresnelC
    org.matheclipse.core.interfaces.IAST FresnelS(org.matheclipse.core.interfaces.IExpr) -> FresnelS
    org.matheclipse.core.interfaces.IAST SinIntegral(org.matheclipse.core.interfaces.IExpr) -> SinIntegral
    org.matheclipse.core.interfaces.IAST CoshIntegral(org.matheclipse.core.interfaces.IExpr) -> CoshIntegral
    org.matheclipse.core.interfaces.IAST SinhIntegral(org.matheclipse.core.interfaces.IExpr) -> SinhIntegral
    org.matheclipse.core.interfaces.IAST Erfi(org.matheclipse.core.interfaces.IExpr) -> Erfi
    org.matheclipse.core.interfaces.IAST ExpIntegralEi(org.matheclipse.core.interfaces.IExpr) -> ExpIntegralEi
    org.matheclipse.core.interfaces.IAST LogIntegral(org.matheclipse.core.interfaces.IExpr) -> LogIntegral
    org.matheclipse.core.interfaces.IAST PolyLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolyLog
    org.matheclipse.core.interfaces.IAST ProductLog(org.matheclipse.core.interfaces.IExpr) -> ProductLog
    org.matheclipse.core.interfaces.IAST Erfc(org.matheclipse.core.interfaces.IExpr) -> Erfc
    org.matheclipse.core.interfaces.IAST LogGamma(org.matheclipse.core.interfaces.IExpr) -> LogGamma
    org.matheclipse.core.interfaces.IAST Zeta(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Zeta
    org.matheclipse.core.interfaces.IAST PolyGamma(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolyGamma
    org.matheclipse.core.interfaces.IAST ExpIntegralE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpIntegralE
    void init() -> init
org.matheclipse.core.integrate.rubi.UtilityFunctions0 -> mr:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.UtilityFunctions1 -> ms:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.UtilityFunctions2 -> mt:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.UtilityFunctions3 -> mu:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.UtilityFunctions4 -> mv:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi.UtilityFunctions5 -> mw:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi42.IntIntegerQ -> org.matheclipse.core.integrate.rubi42.IntIntegerQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.integrate.rubi42.IntPolynomialQ -> org.matheclipse.core.integrate.rubi42.IntPolynomialQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean polynomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.interfaces.IAST -> mx:
    int getEvalFlags() -> c
    org.matheclipse.core.interfaces.ISymbol topHead() -> a
    boolean isEvalFlagOn(int) -> a
    void setEvalFlags(int) -> a
    void addEvalFlags(int) -> b
    org.matheclipse.core.interfaces.IAST addOneIdentity(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr getOneIdentity(org.matheclipse.core.interfaces.IExpr) -> a
    boolean addAll(java.util.List,int,int) -> a
    boolean addAll(java.util.List) -> a
    boolean isList() -> a
    boolean isPlus() -> k
    boolean isPower() -> l
    boolean isTimes() -> m
    java.util.Iterator iterator() -> iterator
    org.matheclipse.core.interfaces.IExpr arg1() -> c
    org.matheclipse.core.interfaces.IExpr arg2() -> d
    org.matheclipse.core.interfaces.IExpr arg3() -> e
    org.matheclipse.core.interfaces.IExpr last() -> f
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST map(com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IAST[] split(com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IAST[] split(com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IAST clone() -> a
    org.matheclipse.core.interfaces.IAST append(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST cloneSet(int,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST copyHead() -> b
    org.matheclipse.core.interfaces.IAST copyUntil(int) -> a
    int patternHashCode() -> e
    org.matheclipse.core.interfaces.IAST prepend(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.expression.ASTRange args() -> a
    org.matheclipse.core.expression.ASTRange range(int) -> a
    org.matheclipse.core.expression.ASTRange range(int,int) -> a
    org.matheclipse.core.interfaces.IAST getAST(int) -> b
org.matheclipse.core.interfaces.IBigNumber -> my:
    org.matheclipse.core.interfaces.INumber numericNumber() -> b
org.matheclipse.core.interfaces.IComplex -> mz:
    org.matheclipse.core.interfaces.IComplex conjugate() -> a
    org.matheclipse.core.interfaces.IComplex add(org.matheclipse.core.interfaces.IComplex) -> a
    org.apache.commons.math3.fraction.BigFraction getImaginaryPart() -> a
    org.apache.commons.math3.fraction.BigFraction getRealPart() -> b
    org.matheclipse.core.interfaces.IComplex multiply(org.matheclipse.core.interfaces.IComplex) -> b
    org.matheclipse.core.interfaces.IComplex pow(int) -> a
    org.matheclipse.core.interfaces.INumber normalize() -> c
org.matheclipse.core.interfaces.IComplexNum -> mA:
    double dabs() -> c
    double getRealPart() -> b
    double getImaginaryPart() -> a
    org.matheclipse.core.interfaces.IComplexNum conjugate() -> a
    org.matheclipse.core.interfaces.IComplexNum add(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IComplexNum multiply(org.matheclipse.core.interfaces.IComplexNum) -> b
    org.matheclipse.core.interfaces.IComplexNum pow(org.matheclipse.core.interfaces.IComplexNum) -> c
org.matheclipse.core.interfaces.IEvaluator -> mB:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.interfaces.IExpr -> mC:
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> a
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> a
    int accept(org.matheclipse.core.visit.IVisitorInt) -> a
    java.lang.Object asType(java.lang.Class) -> a
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> a
    java.lang.String fullFormString() -> c
    org.matheclipse.core.interfaces.IExpr getAt(int) -> a
    org.matheclipse.core.interfaces.IExpr head() -> b
    int hierarchy() -> b
    java.lang.String internalFormString(boolean,int) -> a
    org.matheclipse.core.interfaces.IExpr inverse() -> a
    boolean isAST() -> Q
    boolean isOrderlessAST() -> R
    boolean isFlatAST() -> S
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> d
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> a
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> b
    boolean isAtom() -> V
    boolean isComplex() -> F
    boolean isComplexNumeric() -> G
    boolean isConstant() -> E
    boolean isDirectedInfinity() -> g
    boolean isInfinity() -> h
    boolean isNegative() -> i
    boolean isNegativeInfinity() -> j
    boolean isCos() -> o
    boolean isFalse() -> v
    boolean isFraction() -> w
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    boolean isFree(com.google.common.base.Predicate,boolean) -> a
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> b
    boolean isMember(com.google.common.base.Predicate,boolean) -> b
    boolean isFunction() -> U
    boolean isInteger() -> H
    boolean isNumIntValue() -> I
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> a
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> b
    boolean isList() -> a
    boolean isSequence() -> b
    boolean isListOfLists() -> c
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> a
    int[] isMatrix() -> a
    boolean isNot() -> L
    boolean isNumber() -> P
    boolean isOne() -> r
    boolean isMinusOne() -> s
    boolean isPlus() -> k
    boolean isPattern() -> x
    boolean isPatternExpr() -> y
    boolean isPatternSequence() -> z
    boolean isPositive() -> A
    boolean isCondition() -> B
    boolean isModule() -> C
    boolean isPower() -> l
    boolean isRational() -> J
    boolean isRuleAST() -> T
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> c
    boolean isSignedNumber() -> K
    boolean isNumeric() -> M
    boolean isNumericFunction() -> N
    boolean isRealFunction() -> O
    boolean isSin() -> n
    boolean isSlot() -> p
    boolean isSlotSequence() -> q
    boolean isSymbol() -> D
    boolean isTimes() -> m
    boolean isTrue() -> u
    boolean isValue() -> W
    int isVector() -> d
    boolean isZero() -> t
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr power(java.lang.Integer) -> a
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> a
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> b
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> c
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> d
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.ISymbol topHead() -> a
org.matheclipse.core.interfaces.IFraction -> mD:
    org.matheclipse.core.interfaces.IFraction add(org.matheclipse.core.interfaces.IFraction) -> a
    org.apache.commons.math3.fraction.BigFraction getRational() -> b
    java.math.BigInteger getBigDenominator() -> a
    java.math.BigInteger getBigNumerator() -> b
    org.matheclipse.core.interfaces.IFraction multiply(org.matheclipse.core.interfaces.IFraction) -> b
    org.matheclipse.core.interfaces.IFraction pow(int) -> a
    org.matheclipse.core.interfaces.INumber normalize() -> c
org.matheclipse.core.interfaces.IInteger -> mE:
    org.matheclipse.core.interfaces.IInteger add(org.matheclipse.core.interfaces.IInteger) -> a
    boolean isEven() -> X
    boolean isOdd() -> Y
    java.math.BigInteger getBigNumerator() -> a
    org.matheclipse.core.interfaces.IInteger multiply(org.matheclipse.core.interfaces.IInteger) -> b
    org.matheclipse.core.interfaces.IInteger subtract(org.matheclipse.core.interfaces.IInteger) -> e
    org.matheclipse.core.interfaces.IInteger pow(int) -> a
    org.matheclipse.core.interfaces.IInteger gcd(org.matheclipse.core.interfaces.IInteger) -> c
    org.matheclipse.core.interfaces.IInteger lcm(org.matheclipse.core.interfaces.IInteger) -> d
    org.matheclipse.core.interfaces.IInteger[] nthRootSplit(int) -> a
org.matheclipse.core.interfaces.INum -> mF:
    double getRealPart() -> b
    org.matheclipse.core.interfaces.INum add(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.INum multiply(org.matheclipse.core.interfaces.INum) -> b
    org.matheclipse.core.interfaces.INum pow(org.matheclipse.core.interfaces.INum) -> c
    boolean isNumIntValue() -> I
    int toInt() -> e
org.matheclipse.core.interfaces.INumber -> mG:
    int complexSign() -> c
    org.matheclipse.core.interfaces.IExpr eabs() -> d
    boolean equalsInt(int) -> a
    org.matheclipse.core.interfaces.INumber opposite() -> a
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> a
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> b
org.matheclipse.core.interfaces.IPattern -> mH:
    org.matheclipse.core.interfaces.IExpr getCondition() -> d
    boolean isConditionMatched(org.matheclipse.core.interfaces.IExpr) -> e
    boolean isBlank() -> X
    boolean isDefault() -> Y
org.matheclipse.core.interfaces.IPatternObject -> mI:
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> c
    int getIndex() -> c
    void setIndex(int) -> a
org.matheclipse.core.interfaces.IPatternSequence -> mJ:
    org.matheclipse.core.interfaces.IExpr getCondition() -> d
    boolean isConditionMatchedSequence(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.interfaces.IRational -> mK:
    org.matheclipse.core.interfaces.IInteger getDenominator() -> a
    org.matheclipse.core.interfaces.IInteger getNumerator() -> b
    org.apache.commons.math3.fraction.BigFraction getFraction() -> a
org.matheclipse.core.interfaces.ISignedNumber -> mL:
    boolean isNegative() -> i
    boolean isPositive() -> A
    boolean isZero() -> t
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> a
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> b
    org.matheclipse.core.interfaces.ISignedNumber negate() -> c
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> a
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> b
    int sign() -> f
    int toInt() -> e
    long toLong() -> a
    org.matheclipse.core.interfaces.IInteger ceil() -> c
    org.matheclipse.core.interfaces.IInteger floor() -> d
    org.matheclipse.core.interfaces.IInteger round() -> e
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> d
    double doubleValue() -> a
org.matheclipse.core.interfaces.IStringX -> mM:
org.matheclipse.core.interfaces.ISymbol -> mN:
    org.matheclipse.core.interfaces.IEvaluator getEvaluator() -> a
    java.lang.String getSymbolName() -> d
    void setEvaluator(org.matheclipse.core.interfaces.IEvaluator) -> a
    boolean isSymbolName(java.lang.String) -> a
    org.matheclipse.core.interfaces.IExpr mapConstantDouble(org.matheclipse.core.generic.interfaces.INumericFunction) -> a
    int getAttributes() -> c
    void setAttributes(int) -> a
    void pushLocalVariable() -> a
    void pushLocalVariable(org.matheclipse.core.interfaces.IExpr) -> a
    void popLocalVariable() -> b
    boolean hasLocalVariableStack() -> X
    org.matheclipse.core.interfaces.IExpr get() -> d
    void set(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evalDownRule$6c3927ef(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evalUpRule$6c3927ef(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr getDefaultValue() -> e
    org.matheclipse.core.interfaces.IExpr getDefaultValue(int) -> b
    void setDefaultValue(org.matheclipse.core.interfaces.IExpr) -> c
    void setDefaultValue(int,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr[] reassignSymbolValue(com.google.common.base.Function,org.matheclipse.core.interfaces.ISymbol) -> a
    void clear(org.matheclipse.core.eval.EvalEngine) -> a
    void clearAll(org.matheclipse.core.eval.EvalEngine) -> b
    java.lang.String definitionToString() -> e
org.matheclipse.core.patternmatching.DownRulesData -> mO:
    java.util.Map fEqualDownRules -> a
    com.google.common.collect.ArrayListMultimap fSimplePatternDownRules -> a
    java.util.List fPatternDownRules -> a
    org.matheclipse.core.interfaces.IExpr evalDownRule$6c3927ef(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule$17baa8e9(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    java.util.Map getEqualDownRules() -> a
    java.util.List definition() -> a
org.matheclipse.core.patternmatching.FlatOrderlessStepVisitor -> mP:
    int[] multiset -> a
    int[] getMultisetArray() -> a
org.matheclipse.core.patternmatching.FlatStepVisitor -> mQ:
    org.matheclipse.core.interfaces.ISymbol fSymbol -> a
    org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher stackMatcher -> a
    org.matheclipse.core.patternmatching.PatternMap fPatternMap -> a
    org.matheclipse.core.interfaces.IExpr[] patternValues -> a
    org.matheclipse.core.interfaces.IAST fLhsPatternAST -> a
    boolean fOneIdentity -> a
    boolean visit(int[][]) -> a
    boolean matchSinglePartition(int[][],org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
org.matheclipse.core.patternmatching.HashedOrderlessMatcher -> mR:
    com.google.common.collect.ArrayListMultimap hashRuleMap -> a
    boolean fDefaultHashCode -> a
    void setUpHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    void setUpHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.patternmatching.HashedPatternRules -> mS:
    int hash1 -> a
    int hash2 -> b
    org.matheclipse.core.patternmatching.DownRulesData fRulesData -> a
    org.matheclipse.core.interfaces.IExpr fLHSPattern1 -> a
    org.matheclipse.core.interfaces.IExpr fLHSPattern2 -> b
    org.matheclipse.core.interfaces.IExpr fCondition -> c
    org.matheclipse.core.interfaces.IExpr fRHS -> d
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.matheclipse.core.patternmatching.IPatternMatcher -> mT:
    org.matheclipse.core.interfaces.IExpr fLhsPatternExpr -> a
    org.matheclipse.core.interfaces.IExpr getLHS() -> a
    org.matheclipse.core.interfaces.IExpr getRHS() -> b
    boolean isRuleWithoutPatterns() -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    java.lang.Object clone() -> clone
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.patternmatching.OrderlessStepVisitor -> mU:
    boolean matchSinglePartition(int[][],org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
org.matheclipse.core.patternmatching.PatternMap -> mV:
    int fPatternCounter -> a
    boolean fRuleWithoutPattern -> a
    org.matheclipse.core.interfaces.ISymbol[] fSymbolsArray -> a
    org.matheclipse.core.interfaces.IExpr[] fPatternValuesArray -> a
    void addPattern(java.util.TreeMap,org.matheclipse.core.interfaces.IPatternObject) -> a
    void determinePatterns(org.matheclipse.core.interfaces.IExpr) -> a
    int determinePatternsRecursive(java.util.TreeMap,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.patternmatching.PatternMap clone() -> a
    org.matheclipse.core.interfaces.IExpr[] copyPattern() -> a
    org.matheclipse.core.interfaces.IExpr getValue(org.matheclipse.core.interfaces.IPatternObject) -> a
    void initPattern() -> a
    void resetPattern(org.matheclipse.core.interfaces.IExpr[]) -> a
    void setValue(org.matheclipse.core.interfaces.IPatternObject,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr substitutePatternSymbols(org.matheclipse.core.interfaces.IExpr) -> a
    java.lang.Object clone() -> clone
org.matheclipse.core.patternmatching.PatternMatcher -> mW:
    org.matheclipse.core.interfaces.IExpr fPatternCondition -> b
    org.matheclipse.core.patternmatching.PatternMap fPatternMap -> a
    boolean checkRHSCondition(org.matheclipse.core.eval.EvalEngine) -> a
    boolean checkCondition() -> b
    boolean equivalent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    boolean isRuleWithoutPatterns() -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    boolean matchExpr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    boolean matchExpr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    boolean matchAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    boolean matchASTSequence(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    org.matheclipse.core.interfaces.IExpr evalAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    boolean matchPattern(org.matheclipse.core.interfaces.IPattern,org.matheclipse.core.interfaces.IExpr) -> a
    boolean matchPatternSequence(org.matheclipse.core.interfaces.IPatternSequence,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object clone() -> clone
    org.matheclipse.core.interfaces.IExpr getCondition() -> c
    org.matheclipse.core.interfaces.IExpr evalLeftHandSide(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.EvalEngine) -> a
    boolean apply(java.lang.Object) -> a
    boolean access$000(org.matheclipse.core.patternmatching.PatternMatcher,org.matheclipse.core.interfaces.IPattern,org.matheclipse.core.interfaces.IExpr) -> a
    boolean access$100(org.matheclipse.core.patternmatching.PatternMatcher,org.matheclipse.core.interfaces.IPatternSequence,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.patternmatching.PatternMatcher$Entry -> mX:
    org.matheclipse.core.interfaces.IExpr fPatternExpr -> a
    org.matheclipse.core.interfaces.IExpr fEvalExpr -> b
org.matheclipse.core.patternmatching.PatternMatcher$OrderlessMatcher -> mY:
    org.matheclipse.core.interfaces.IAST fLHSPatternAST -> a
    org.matheclipse.core.interfaces.IAST fLHSEvalAST -> b
    int[] fUsedIndex -> a
    org.matheclipse.core.patternmatching.PatternMatcher this$0 -> a
    boolean matchOrderlessAST(int,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher -> mZ:
    java.util.ArrayList fStack -> a
    org.matheclipse.core.patternmatching.PatternMatcher this$0 -> a
    void removeFrom(int) -> a
    boolean push(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    boolean matchRest() -> a
org.matheclipse.core.patternmatching.PatternMatcherAndEvaluator -> na:
    org.matheclipse.core.interfaces.IExpr fRightHandSide -> b
    org.matheclipse.core.interfaces.ISymbol fSetSymbol -> a
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    boolean equivalentRHS(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> a
    int hashCode() -> hashCode
    boolean checkRHSCondition(org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getRHS() -> b
org.matheclipse.core.patternmatching.PatternMatcherEquals -> nb:
    org.matheclipse.core.interfaces.IExpr fRightHandSide -> b
    org.matheclipse.core.interfaces.ISymbol fSetSymbol -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getRHS() -> b
    org.matheclipse.core.interfaces.ISymbol getSetSymbol() -> a
    int hashCode() -> hashCode
    boolean isRuleWithoutPatterns() -> a
    void setRHS(org.matheclipse.core.interfaces.IExpr) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.patternmatching.UpRulesData -> nc:
    java.util.Map fEqualUpRules -> a
    com.google.common.collect.ArrayListMultimap fSimplePatternUpRules -> a
    org.matheclipse.core.interfaces.IExpr evalUpRule$6c3927ef(org.matheclipse.core.interfaces.IExpr) -> a
    java.util.Map getEqualUpRules() -> a
    java.util.List definition() -> a
org.matheclipse.core.polynomials.HornerScheme -> nd:
    java.util.TreeMap map -> a
    org.matheclipse.core.interfaces.IExpr getCoefficient(org.matheclipse.core.interfaces.ISignedNumber) -> a
    org.matheclipse.core.interfaces.IAST addToMap(org.matheclipse.core.interfaces.ISignedNumber,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.polynomials.HornerScheme$1 -> ne:
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.IPartialFractionGenerator -> nf:
    void setJAS(org.matheclipse.core.convert.JASConvert) -> a
    org.matheclipse.core.interfaces.IAST getResult() -> a
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> a
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> a
org.matheclipse.core.polynomials.PartialFractionGenerator -> ng:
    org.matheclipse.core.interfaces.IAST result -> a
    org.matheclipse.core.convert.JASConvert jas -> a
    void setJAS(org.matheclipse.core.convert.JASConvert) -> a
    org.matheclipse.core.interfaces.IAST getResult() -> a
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> a
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> a
org.matheclipse.core.polynomials.PartialFractionIntegrateGenerator -> nh:
    org.matheclipse.core.interfaces.IAST result -> a
    org.matheclipse.core.convert.JASConvert jas -> a
    org.matheclipse.core.interfaces.ISymbol x -> a
    void setJAS(org.matheclipse.core.convert.JASConvert) -> a
    org.matheclipse.core.interfaces.IAST getResult() -> a
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> a
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> a
    boolean isQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigRational[]) -> a
org.matheclipse.core.reflection.system.Abs -> org.matheclipse.core.reflection.system.Abs:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Abs$AbsNumericFunction -> ni:
    org.matheclipse.core.interfaces.ISymbol symbol -> a
    java.lang.Object apply(double) -> a
org.matheclipse.core.reflection.system.Abs$AbsTimesFunction -> nj:
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.AddTo -> org.matheclipse.core.reflection.system.AddTo:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.AddTo$AddToFunction -> nk:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.And -> org.matheclipse.core.reflection.system.And:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Apart -> org.matheclipse.core.reflection.system.Apart:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST partialFractionDecompositionRational(org.matheclipse.core.polynomials.IPartialFractionGenerator,org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr[] getFractionalParts(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr[] getFractionalPartsTimes(org.matheclipse.core.interfaces.IAST,boolean) -> a
org.matheclipse.core.reflection.system.ArcCos -> org.matheclipse.core.reflection.system.ArcCos:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCosh -> org.matheclipse.core.reflection.system.ArcCosh:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCot -> org.matheclipse.core.reflection.system.ArcCot:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCoth -> org.matheclipse.core.reflection.system.ArcCoth:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCsc -> org.matheclipse.core.reflection.system.ArcCsc:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCsch -> org.matheclipse.core.reflection.system.ArcCsch:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcSec -> org.matheclipse.core.reflection.system.ArcSec:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcSech -> org.matheclipse.core.reflection.system.ArcSech:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcSin -> org.matheclipse.core.reflection.system.ArcSin:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcSinh -> org.matheclipse.core.reflection.system.ArcSinh:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcTan -> org.matheclipse.core.reflection.system.ArcTan:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcTanh -> org.matheclipse.core.reflection.system.ArcTanh:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Arg -> org.matheclipse.core.reflection.system.Arg:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.BernoulliB -> org.matheclipse.core.reflection.system.BernoulliB:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.apache.commons.math3.fraction.BigFraction bernoulliNumber(java.math.BigInteger) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Binomial -> org.matheclipse.core.reflection.system.Binomial:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    java.math.BigInteger binomial(int,int) -> a
    java.math.BigInteger binomial(java.math.BigInteger,java.math.BigInteger) -> a
org.matheclipse.core.reflection.system.Boole -> org.matheclipse.core.reflection.system.Boole:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.BooleanMinimize -> org.matheclipse.core.reflection.system.BooleanMinimize:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Cancel -> org.matheclipse.core.reflection.system.Cancel:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr cancelPowerTimes(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr[] cancelGCD(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Cancel$PolynomialPredicate -> nl:
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.CartesianProduct -> org.matheclipse.core.reflection.system.CartesianProduct:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.CatalanNumber -> org.matheclipse.core.reflection.system.CatalanNumber:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Ceiling -> org.matheclipse.core.reflection.system.Ceiling:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Ceiling$CeilingPlusFunction -> nm:
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.CharacteristicPolynomial -> org.matheclipse.core.reflection.system.CharacteristicPolynomial:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.ChessboardDistance -> org.matheclipse.core.reflection.system.ChessboardDistance:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Chop -> org.matheclipse.core.reflection.system.Chop:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Coefficient -> org.matheclipse.core.reflection.system.Coefficient:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr coefficientAtom(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IInteger) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr access$000(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr access$100(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IInteger) -> b
    org.matheclipse.core.interfaces.IExpr access$200(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.Coefficient$PlusFunction -> nn:
    org.matheclipse.core.interfaces.IExpr arg2 -> a
    org.matheclipse.core.interfaces.IInteger n -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.CoefficientList -> org.matheclipse.core.reflection.system.CoefficientList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    long univariateCoefficientList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,java.util.List) -> a
    long univariateCoefficientList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,java.util.List,java.util.List) -> a
org.matheclipse.core.reflection.system.Collect -> org.matheclipse.core.reflection.system.Collect:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr collectSingleVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
    void collectToMap(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.IPatternMatcher,java.util.Map,org.matheclipse.core.interfaces.IAST) -> a
    void addOneIdentityPowerFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,java.util.Map) -> a
    void addPowerFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,java.util.Map) -> a
    boolean isPowerMatched(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.IPatternMatcher) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Complement -> org.matheclipse.core.reflection.system.Complement:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Complex -> org.matheclipse.core.reflection.system.Complex:
    org.matheclipse.core.reflection.system.Complex CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ComplexExpand -> org.matheclipse.core.reflection.system.ComplexExpand:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr complexExpand(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr complexExpandNull(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr access$000(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr access$100(org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.ComplexExpand$ComplexExpandVisitor -> no:
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.ComposeList -> org.matheclipse.core.reflection.system.ComposeList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateComposeList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.CompoundExpression -> org.matheclipse.core.reflection.system.CompoundExpression:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Conjugate -> org.matheclipse.core.reflection.system.Conjugate:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.ConjugateTranspose -> org.matheclipse.core.reflection.system.ConjugateTranspose:
    org.matheclipse.core.interfaces.IExpr transform(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.ConstantArray -> org.matheclipse.core.reflection.system.ConstantArray:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArray(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ConstantArray$ArrayIterator -> np:
    int fCurrent -> a
    int fFrom -> b
    int fTo -> c
    boolean setUp() -> a
    void tearDown() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.ContinuedFraction -> org.matheclipse.core.reflection.system.ContinuedFraction:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.CoprimeQ -> org.matheclipse.core.reflection.system.CoprimeQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Cos -> org.matheclipse.core.reflection.system.Cos:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Cosh -> org.matheclipse.core.reflection.system.Cosh:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Cot -> org.matheclipse.core.reflection.system.Cot:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Coth -> org.matheclipse.core.reflection.system.Coth:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Count -> org.matheclipse.core.reflection.system.Count:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Count$CountFunctor -> nq:
    org.matheclipse.core.patternmatching.IPatternMatcher matcher -> a
    int counter -> a
    int getCounter() -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Cross -> org.matheclipse.core.reflection.system.Cross:
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.Csc -> org.matheclipse.core.reflection.system.Csc:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Csch -> org.matheclipse.core.reflection.system.Csch:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Curl -> org.matheclipse.core.reflection.system.Curl:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.D -> org.matheclipse.core.reflection.system.D:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Decrement -> org.matheclipse.core.reflection.system.Decrement:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Function getFunction() -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
    org.matheclipse.core.interfaces.IExpr getResult(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Decrement$DecrementFunction -> nr:
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Default -> org.matheclipse.core.reflection.system.Default:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Denominator -> org.matheclipse.core.reflection.system.Denominator:
    org.matheclipse.core.interfaces.ISymbol[] NUMERATOR_SYMBOLS -> a
    org.matheclipse.core.interfaces.ISymbol[] DENOMINATOR_SYMBOLS -> b
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IAST getDenominatorForm(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Derivative -> org.matheclipse.core.reflection.system.Derivative:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Det -> org.matheclipse.core.reflection.system.Det:
    org.matheclipse.core.expression.ExprFieldElement matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.reflection.system.DiagonalMatrix -> org.matheclipse.core.reflection.system.DiagonalMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.DigitQ -> org.matheclipse.core.reflection.system.DigitQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Dimensions -> org.matheclipse.core.reflection.system.Dimensions:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void getLevel1(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol,java.util.ArrayList) -> a
    void checkLevel(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol,java.util.ArrayList,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Discriminant -> org.matheclipse.core.reflection.system.Discriminant:
    org.matheclipse.core.interfaces.IExpr QUADRATIC -> a
    org.matheclipse.core.interfaces.IExpr CUBIC -> b
    org.matheclipse.core.interfaces.IExpr QUARTIC -> c
    org.matheclipse.core.interfaces.IExpr QUINTIC -> d
    org.matheclipse.core.interfaces.ISymbol[] vars -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Distribute -> org.matheclipse.core.reflection.system.Distribute:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void distributePosition(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.reflection.system.Divergence -> org.matheclipse.core.reflection.system.Divergence:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.DivideBy -> org.matheclipse.core.reflection.system.DivideBy:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
org.matheclipse.core.reflection.system.DivideBy$DivideByFunction -> ns:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Dot -> org.matheclipse.core.reflection.system.Dot:
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Eigenvalues -> org.matheclipse.core.reflection.system.Eigenvalues:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
    org.matheclipse.core.expression.ExprFieldElement matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.reflection.system.Eigenvectors -> org.matheclipse.core.reflection.system.Eigenvectors:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
    org.matheclipse.core.expression.ExprFieldElement matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.reflection.system.Eliminate -> org.matheclipse.core.reflection.system.Eliminate:
    org.matheclipse.core.interfaces.IExpr extractVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IAST eliminateOneVariable(java.util.ArrayList,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Eliminate$VariableCounterVisitor -> nt:
    int fVariableCounter -> a
    int fNodeCounter -> b
    int fMaxVariableDepth -> c
    int fCurrentDepth -> d
    org.matheclipse.core.interfaces.IExpr fVariable -> a
    org.matheclipse.core.interfaces.IAST fExpr -> a
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean visit$6154956d() -> a
    boolean visit$2ed48865() -> b
    boolean visit$f81861f() -> c
    boolean visit$6e7d65cb() -> d
    boolean visit$4d323d8f() -> e
    boolean visit$2402f8ff() -> f
    boolean visit$5ad27180() -> g
    boolean visit$4d02b336() -> h
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.Equal -> org.matheclipse.core.reflection.system.Equal:
    org.matheclipse.core.interfaces.IExpr createComparatorResult(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    int compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Erf -> org.matheclipse.core.reflection.system.Erf:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.EuclidianDistance -> org.matheclipse.core.reflection.system.EuclidianDistance:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.EulerE -> org.matheclipse.core.reflection.system.EulerE:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void set(java.util.ArrayList,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.EulerPhi -> org.matheclipse.core.reflection.system.EulerPhi:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.EvenQ -> org.matheclipse.core.reflection.system.EvenQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Exp -> org.matheclipse.core.reflection.system.Exp:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.Expand -> org.matheclipse.core.reflection.system.Expand:
    org.matheclipse.core.interfaces.IExpr expand(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Expand$Expander -> nu:
    org.matheclipse.core.interfaces.IExpr pattern -> a
    org.matheclipse.core.interfaces.IExpr expand(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr expandPowerNull(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr expandPower(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr expandTimes(org.matheclipse.core.interfaces.IAST) -> c
    org.matheclipse.core.interfaces.IAST expandTimesPlus(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST expandTimesPlus(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST assurePlus(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.Expand$NumberPartititon -> nv:
    org.matheclipse.core.interfaces.IAST expandedResult -> a
    int m -> b
    int n -> a
    int[] parts -> a
    org.matheclipse.core.interfaces.IAST precalculatedPowerASTs -> b
    void partition(int,int,int) -> a
org.matheclipse.core.reflection.system.ExpandAll -> org.matheclipse.core.reflection.system.ExpandAll:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr expandAll(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.Exponent -> org.matheclipse.core.reflection.system.Exponent:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.ExtendedGCD -> org.matheclipse.core.reflection.system.ExtendedGCD:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object[] extendedGCD(java.math.BigInteger,java.math.BigInteger) -> a
org.matheclipse.core.reflection.system.Extract -> org.matheclipse.core.reflection.system.Extract:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Factor -> org.matheclipse.core.reflection.system.Factor:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr factor(org.matheclipse.core.interfaces.IExpr,java.util.List,boolean) -> a
    org.matheclipse.core.interfaces.IExpr factorWithOption(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,java.util.List,boolean) -> a
    org.matheclipse.core.interfaces.IAST factorComplex(org.matheclipse.core.interfaces.IExpr,java.util.List,org.matheclipse.core.interfaces.ISymbol,boolean) -> a
    org.matheclipse.core.interfaces.IAST factorModulus(org.matheclipse.core.interfaces.IExpr,java.util.List,boolean,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST factorModulus(org.matheclipse.core.convert.JASModInteger,edu.jas.arith.ModLongRing,edu.jas.poly.GenPolynomial,boolean) -> a
org.matheclipse.core.reflection.system.FactorInteger -> org.matheclipse.core.reflection.system.FactorInteger:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FactorSquareFree -> org.matheclipse.core.reflection.system.FactorSquareFree:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.FactorSquareFreeList -> org.matheclipse.core.reflection.system.FactorSquareFreeList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.FactorTerms -> org.matheclipse.core.reflection.system.FactorTerms:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Factorial -> org.matheclipse.core.reflection.system.Factorial:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    java.math.BigInteger factorial(java.math.BigInteger) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Factorial2 -> org.matheclipse.core.reflection.system.Factorial2:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Fibonacci -> org.matheclipse.core.reflection.system.Fibonacci:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FindRoot -> org.matheclipse.core.reflection.system.FindRoot:
    org.matheclipse.core.interfaces.ISymbol Newton -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Fit -> org.matheclipse.core.reflection.system.Fit:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Floor -> org.matheclipse.core.reflection.system.Floor:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Floor$FloorPlusFunction -> nw:
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.FractionalPart -> org.matheclipse.core.reflection.system.FractionalPart:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.FrobeniusSolve -> org.matheclipse.core.reflection.system.FrobeniusSolve:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FromCharacterCode -> org.matheclipse.core.reflection.system.FromCharacterCode:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FromContinuedFraction -> org.matheclipse.core.reflection.system.FromContinuedFraction:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FullSimplify -> org.matheclipse.core.reflection.system.FullSimplify:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Function -> org.matheclipse.core.reflection.system.Function:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.GCD -> org.matheclipse.core.reflection.system.GCD:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Gamma -> org.matheclipse.core.reflection.system.Gamma:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.GeometricMean -> org.matheclipse.core.reflection.system.GeometricMean:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Greater -> org.matheclipse.core.reflection.system.Greater:
    org.matheclipse.core.reflection.system.Greater CONST -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr createComparatorResult(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    int prepareCompare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.GreaterEqual -> org.matheclipse.core.reflection.system.GreaterEqual:
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.GroebnerBasis -> org.matheclipse.core.reflection.system.GroebnerBasis:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.HarmonicNumber -> org.matheclipse.core.reflection.system.HarmonicNumber:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.HilbertMatrix -> org.matheclipse.core.reflection.system.HilbertMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.HilbertMatrix$HilbertFunctionDiagonal -> nx:
    java.lang.Object evaluate(int[]) -> a
org.matheclipse.core.reflection.system.Hold -> org.matheclipse.core.reflection.system.Hold:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Horner -> org.matheclipse.core.reflection.system.Horner:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.IdentityMatrix -> org.matheclipse.core.reflection.system.IdentityMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST diagonalMatrix(org.matheclipse.core.interfaces.IExpr[],int) -> a
org.matheclipse.core.reflection.system.Im -> org.matheclipse.core.reflection.system.Im:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr imPowerComplex(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Increment -> org.matheclipse.core.reflection.system.Increment:
    com.google.common.base.Function getFunction() -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
org.matheclipse.core.reflection.system.Increment$IncrementFunction -> ny:
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Inner -> org.matheclipse.core.reflection.system.Inner:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.IntegerPart -> org.matheclipse.core.reflection.system.IntegerPart:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.IntegerPartitions -> org.matheclipse.core.reflection.system.IntegerPartitions:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.IntegerQ -> org.matheclipse.core.reflection.system.IntegerQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Integrate -> org.matheclipse.core.reflection.system.Integrate:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IAST getUtilityFunctionsRuleAST() -> b
org.matheclipse.core.reflection.system.Integrate$1 -> nz:
    org.matheclipse.core.interfaces.ISymbol val$x -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.InterpolatingFunction -> org.matheclipse.core.reflection.system.InterpolatingFunction:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Intersection -> org.matheclipse.core.reflection.system.Intersection:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Inverse -> org.matheclipse.core.reflection.system.Inverse:
    org.apache.commons.math3.linear.FieldMatrix matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.linear.RealMatrix realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.reflection.system.InverseErf -> org.matheclipse.core.reflection.system.InverseErf:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.InverseFunction -> org.matheclipse.core.reflection.system.InverseFunction:
    java.util.Map INVERSE_FUNCTIONS -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST getInverseFunction(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.JacobiMatrix -> org.matheclipse.core.reflection.system.JacobiMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.JacobiSymbol -> org.matheclipse.core.reflection.system.JacobiSymbol:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.Join -> org.matheclipse.core.reflection.system.Join:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.KOrderlessPartitions -> org.matheclipse.core.reflection.system.KOrderlessPartitions:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.KPartitions -> org.matheclipse.core.reflection.system.KPartitions:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.LCM -> org.matheclipse.core.reflection.system.LCM:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.LUDecomposition -> org.matheclipse.core.reflection.system.LUDecomposition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Less -> org.matheclipse.core.reflection.system.Less:
    org.matheclipse.core.reflection.system.Less CONST -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.LessEqual -> org.matheclipse.core.reflection.system.LessEqual:
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.LetterQ -> org.matheclipse.core.reflection.system.LetterQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Level -> org.matheclipse.core.reflection.system.Level:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Limit -> org.matheclipse.core.reflection.system.Limit:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IExpr lHospitalesRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr limit(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,boolean) -> a
    org.matheclipse.core.interfaces.IExpr mapLimit(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.LinearProgramming -> org.matheclipse.core.reflection.system.LinearProgramming:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.LinearSolve -> org.matheclipse.core.reflection.system.LinearSolve:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Log -> org.matheclipse.core.reflection.system.Log:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.LowerCaseQ -> org.matheclipse.core.reflection.system.LowerCaseQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.ManhattanDistance -> org.matheclipse.core.reflection.system.ManhattanDistance:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Map -> org.matheclipse.core.reflection.system.Map:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.MapAll -> org.matheclipse.core.reflection.system.MapAll:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.MapThread -> org.matheclipse.core.reflection.system.MapThread:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.MapThread$UnaryMapThread -> nA:
    org.matheclipse.core.interfaces.IExpr fConstant -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.MatchQ -> org.matheclipse.core.reflection.system.MatchQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.MatrixPower -> org.matheclipse.core.reflection.system.MatrixPower:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.MatrixQ -> org.matheclipse.core.reflection.system.MatrixQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.MatrixRank -> org.matheclipse.core.reflection.system.MatrixRank:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Max -> org.matheclipse.core.reflection.system.Max:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Mean -> org.matheclipse.core.reflection.system.Mean:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalArg1(org.matheclipse.core.interfaces.IExpr) -> c
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Median -> org.matheclipse.core.reflection.system.Median:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalArg1(org.matheclipse.core.interfaces.IExpr) -> c
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Min -> org.matheclipse.core.reflection.system.Min:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Mod -> org.matheclipse.core.reflection.system.Mod:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.MoebiusMu -> org.matheclipse.core.reflection.system.MoebiusMu:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.MonomialList -> org.matheclipse.core.reflection.system.MonomialList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST monomialListModulus$3f73e28d(org.matheclipse.core.interfaces.IExpr,java.util.List,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.Most -> org.matheclipse.core.reflection.system.Most:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Multinomial -> org.matheclipse.core.reflection.system.Multinomial:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.math.BigInteger multinomial(int[],int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NFourierTransform -> org.matheclipse.core.reflection.system.NFourierTransform:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NIntegrate -> org.matheclipse.core.reflection.system.NIntegrate:
    org.matheclipse.core.interfaces.ISymbol LegendreGauss -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NRoots -> org.matheclipse.core.reflection.system.NRoots:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.NSolve -> org.matheclipse.core.reflection.system.NSolve:
    org.matheclipse.core.interfaces.IAST analyzeSublist(java.util.ArrayList,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.NSolve$ExprAnalyzer -> nB:
    int equationType -> a
    org.matheclipse.core.interfaces.IExpr expr -> a
    org.matheclipse.core.interfaces.IExpr numer -> b
    org.matheclipse.core.interfaces.IExpr denom -> c
    int leafCount -> b
    org.matheclipse.core.interfaces.IAST row -> a
    java.util.HashSet symbolSet -> a
    org.matheclipse.core.interfaces.IAST value -> b
    org.matheclipse.core.interfaces.IAST vars -> c
    void analyze() -> a
    void getPlusEquationType(org.matheclipse.core.interfaces.IExpr) -> a
    void getTimesEquationType(org.matheclipse.core.interfaces.IExpr) -> b
    void reset() -> b
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.NSolve$NoSolution -> nC:
    int solType -> a
org.matheclipse.core.reflection.system.Negative -> org.matheclipse.core.reflection.system.Negative:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NextPrime -> org.matheclipse.core.reflection.system.NextPrime:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.NonCommutativeMultiply -> org.matheclipse.core.reflection.system.NonCommutativeMultiply:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NonNegative -> org.matheclipse.core.reflection.system.NonNegative:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Norm -> org.matheclipse.core.reflection.system.Norm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Not -> org.matheclipse.core.reflection.system.Not:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.NullSpace -> org.matheclipse.core.reflection.system.NullSpace:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Numerator -> org.matheclipse.core.reflection.system.Numerator:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.OddQ -> org.matheclipse.core.reflection.system.OddQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Or -> org.matheclipse.core.reflection.system.Or:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Order -> org.matheclipse.core.reflection.system.Order:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.OrderedQ -> org.matheclipse.core.reflection.system.OrderedQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean apply(org.matheclipse.core.interfaces.IAST) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Out -> org.matheclipse.core.reflection.system.Out:
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1IntArg(org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.Outer -> org.matheclipse.core.reflection.system.Outer:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Outer$Generating -> nD:
    org.matheclipse.core.interfaces.IAST fOuterList -> a
    org.matheclipse.core.interfaces.IAST fInnerList -> b
    int fHeadOffset -> a
    org.matheclipse.core.interfaces.IAST outer(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Package -> org.matheclipse.core.reflection.system.Package:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void evalPackage(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST convertSymbolsInList(org.matheclipse.core.interfaces.IAST,java.util.HashMap) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    void loadPackage(org.matheclipse.core.eval.EvalEngine,java.io.Reader) -> a
org.matheclipse.core.reflection.system.PadLeft -> org.matheclipse.core.reflection.system.PadLeft:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr padLeftAtom(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.PadRight -> org.matheclipse.core.reflection.system.PadRight:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr padRightAtom(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.Part -> org.matheclipse.core.reflection.system.Part:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr getPart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr getIndex(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Partition -> org.matheclipse.core.reflection.system.Partition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Pattern -> org.matheclipse.core.reflection.system.Pattern:
    org.matheclipse.core.reflection.system.Pattern CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Permutations -> org.matheclipse.core.reflection.system.Permutations:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Plus -> org.matheclipse.core.reflection.system.Plus:
    org.matheclipse.core.reflection.system.Plus CONST -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> a
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr eInfinity(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.Pochhammer -> org.matheclipse.core.reflection.system.Pochhammer:
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PolynomialExtendedGCD -> org.matheclipse.core.reflection.system.PolynomialExtendedGCD:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PolynomialGCD -> org.matheclipse.core.reflection.system.PolynomialGCD:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr modulusGCD(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.convert.ExprVariables,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PolynomialLCM -> org.matheclipse.core.reflection.system.PolynomialLCM:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PolynomialQ -> org.matheclipse.core.reflection.system.PolynomialQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean polynomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.reflection.system.PolynomialQuotient -> org.matheclipse.core.reflection.system.PolynomialQuotient:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.PolynomialQuotientRemainder -> org.matheclipse.core.reflection.system.PolynomialQuotientRemainder:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr[] quotientRemainder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr[] quotientRemainderModInteger(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.PolynomialRemainder -> org.matheclipse.core.reflection.system.PolynomialRemainder:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Positive -> org.matheclipse.core.reflection.system.Positive:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PossibleZeroQ -> org.matheclipse.core.reflection.system.PossibleZeroQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean possibleZeroQ(org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Power -> org.matheclipse.core.reflection.system.Power:
    org.matheclipse.core.reflection.system.Power CONST -> a
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IInteger[] calculateRoot(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr eComFraArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IFraction) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.PowerExpand -> org.matheclipse.core.reflection.system.PowerExpand:
    java.lang.String[] REPLACE_STRINGS -> a
    com.google.common.base.Function REPLACE_RULES -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PowerMod -> org.matheclipse.core.reflection.system.PowerMod:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.PreDecrement -> org.matheclipse.core.reflection.system.PreDecrement:
    org.matheclipse.core.interfaces.IExpr getResult(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
org.matheclipse.core.reflection.system.PreIncrement -> org.matheclipse.core.reflection.system.PreIncrement:
    com.google.common.base.Function getFunction() -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
org.matheclipse.core.reflection.system.PreIncrement$IncrementFunction -> nE:
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.PrimeQ -> org.matheclipse.core.reflection.system.PrimeQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.PrimitiveRoots -> org.matheclipse.core.reflection.system.PrimitiveRoots:
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Product -> org.matheclipse.core.reflection.system.Product:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Quotient -> org.matheclipse.core.reflection.system.Quotient:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.RandomInteger -> org.matheclipse.core.reflection.system.RandomInteger:
    java.util.Random RANDOM -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.RandomReal -> org.matheclipse.core.reflection.system.RandomReal:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Range -> org.matheclipse.core.reflection.system.Range:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateTable(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Rational -> org.matheclipse.core.reflection.system.Rational:
    org.matheclipse.core.reflection.system.Rational CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Rationalize -> org.matheclipse.core.reflection.system.Rationalize:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Re -> org.matheclipse.core.reflection.system.Re:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr rePowerComplex(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ReplaceAll -> org.matheclipse.core.reflection.system.ReplaceAll:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ReplacePart -> org.matheclipse.core.reflection.system.ReplacePart:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ReplaceRepeated -> org.matheclipse.core.reflection.system.ReplaceRepeated:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Resultant -> org.matheclipse.core.reflection.system.Resultant:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr resultant(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Reverse -> org.matheclipse.core.reflection.system.Reverse:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.RootIntervals -> org.matheclipse.core.reflection.system.RootIntervals:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST croots(org.matheclipse.core.interfaces.IExpr,boolean) -> a
org.matheclipse.core.reflection.system.Roots -> org.matheclipse.core.reflection.system.Roots:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST rootsOfVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,boolean) -> a
org.matheclipse.core.reflection.system.Round -> org.matheclipse.core.reflection.system.Round:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Round$RoundPlusFunction -> nF:
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.RowReduce -> org.matheclipse.core.reflection.system.RowReduce:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Rule -> org.matheclipse.core.reflection.system.Rule:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.RuleDelayed -> org.matheclipse.core.reflection.system.RuleDelayed:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SameQ -> org.matheclipse.core.reflection.system.SameQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Scan -> org.matheclipse.core.reflection.system.Scan:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Sec -> org.matheclipse.core.reflection.system.Sec:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Sech -> org.matheclipse.core.reflection.system.Sech:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Select -> org.matheclipse.core.reflection.system.Select:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Set -> org.matheclipse.core.reflection.system.Set:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object[] createPatternMatcher(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SetDelayed -> org.matheclipse.core.reflection.system.SetDelayed:
    org.matheclipse.core.reflection.system.SetDelayed CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object[] createPatternMatcher(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Sign -> org.matheclipse.core.reflection.system.Sign:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numberSign(org.matheclipse.core.interfaces.INumber) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SignCmp -> org.matheclipse.core.reflection.system.SignCmp:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Simplify -> org.matheclipse.core.reflection.system.Simplify:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Simplify$IsBasicExpressionVisitor -> nG:
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
    boolean visit$f81861f() -> c
    boolean visit$4d323d8f() -> e
    boolean visit$2ed48865() -> b
    boolean visit$6154956d() -> a
    boolean visit$6e7d65cb() -> d
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Simplify$SimplifyVisitor -> nH:
    org.matheclipse.core.reflection.system.Simplify$IsBasicExpressionVisitor isBasicAST -> a
    org.matheclipse.core.interfaces.IExpr tryTransformations(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr tryTransformations(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr tryToReduceNumericFactor(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Sin -> org.matheclipse.core.reflection.system.Sin:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SingularValueDecomposition -> org.matheclipse.core.reflection.system.SingularValueDecomposition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Sinh -> org.matheclipse.core.reflection.system.Sinh:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Solve -> org.matheclipse.core.reflection.system.Solve:
    org.matheclipse.core.interfaces.IAST analyzeSublist(java.util.ArrayList,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Solve$ExprAnalyzer -> nI:
    int fEquationType -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    org.matheclipse.core.interfaces.IExpr fNumer -> b
    org.matheclipse.core.interfaces.IExpr fDenom -> c
    int fLeafCount -> b
    org.matheclipse.core.interfaces.IAST row -> a
    java.util.HashSet symbolSet -> a
    org.matheclipse.core.interfaces.IAST value -> b
    org.matheclipse.core.interfaces.IAST vars -> c
    void analyze() -> a
    void getPlusEquationType(org.matheclipse.core.interfaces.IExpr) -> a
    void getTimesEquationType(org.matheclipse.core.interfaces.IExpr) -> b
    void reset() -> b
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.Solve$NoSolution -> nJ:
    int solType -> a
org.matheclipse.core.reflection.system.Sort -> org.matheclipse.core.reflection.system.Sort:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Sqrt -> org.matheclipse.core.reflection.system.Sqrt:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SquareFreeQ -> org.matheclipse.core.reflection.system.SquareFreeQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.SquaredEuclidianDistance -> org.matheclipse.core.reflection.system.SquaredEuclidianDistance:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.StirlingS2 -> org.matheclipse.core.reflection.system.StirlingS2:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.StringDrop -> org.matheclipse.core.reflection.system.StringDrop:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.StringJoin -> org.matheclipse.core.reflection.system.StringJoin:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.StringLength -> org.matheclipse.core.reflection.system.StringLength:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.StringTake -> org.matheclipse.core.reflection.system.StringTake:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Subsets -> org.matheclipse.core.reflection.system.Subsets:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.SubtractFrom -> org.matheclipse.core.reflection.system.SubtractFrom:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.SubtractFrom$SubtractFromFunction -> nK:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Sum -> org.matheclipse.core.reflection.system.Sum:
    java.util.HashMap MAP_0_N -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr sumPower(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr sumPowerFormula(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.Sum$1 -> nL:
    org.matheclipse.core.interfaces.ISymbol val$var -> a
    org.matheclipse.core.interfaces.ISymbol val$to -> b
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Sum$2 -> nM:
    org.matheclipse.core.interfaces.ISymbol val$var -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.SyntaxLength -> org.matheclipse.core.reflection.system.SyntaxLength:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SyntaxQ -> org.matheclipse.core.reflection.system.SyntaxQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.String) -> a
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Table -> org.matheclipse.core.reflection.system.Table:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateTable(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Take -> org.matheclipse.core.reflection.system.Take:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST take(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.eval.util.ISequence[]) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Tan -> org.matheclipse.core.reflection.system.Tan:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Tanh -> org.matheclipse.core.reflection.system.Tanh:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalD1(org.matheclipse.core.expression.Num) -> a
    org.matheclipse.core.interfaces.IExpr numericEvalDC1(org.matheclipse.core.expression.ComplexNum) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Taylor -> org.matheclipse.core.reflection.system.Taylor:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Thread -> org.matheclipse.core.reflection.system.Thread:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST threadList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int) -> a
org.matheclipse.core.reflection.system.Through -> org.matheclipse.core.reflection.system.Through:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Times -> org.matheclipse.core.reflection.system.Times:
    org.matheclipse.core.reflection.system.Times CONST -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> a
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr eInfinity(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.TimesBy -> org.matheclipse.core.reflection.system.TimesBy:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.TimesBy$TimesByFunction -> nN:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.Timing -> org.matheclipse.core.reflection.system.Timing:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ToCharacterCode -> org.matheclipse.core.reflection.system.ToCharacterCode:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    java.util.List toCharacterCode(java.lang.String,java.lang.String,java.util.List) -> a
org.matheclipse.core.reflection.system.ToString -> org.matheclipse.core.reflection.system.ToString:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.String outputForm(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.ToUnicode -> org.matheclipse.core.reflection.system.ToUnicode:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.String toUnicodeString(java.lang.String,java.lang.String) -> a
org.matheclipse.core.reflection.system.Together -> org.matheclipse.core.reflection.system.Together:
    org.matheclipse.core.reflection.system.Together$TogetherVisitor VISITOR -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr together(org.matheclipse.core.interfaces.IAST) -> c
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Together$TogetherVisitor -> nO:
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr visitPlus(org.matheclipse.core.interfaces.IAST) -> c
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Total -> org.matheclipse.core.reflection.system.Total:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Tr -> org.matheclipse.core.reflection.system.Tr:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Trace -> org.matheclipse.core.reflection.system.Trace:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Transpose -> org.matheclipse.core.reflection.system.Transpose:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr transform(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.TrigExpand -> org.matheclipse.core.reflection.system.TrigExpand:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr expandSinPlus(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr expandCosPlus(org.matheclipse.core.interfaces.IAST,int) -> b
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.TrigReduce -> org.matheclipse.core.reflection.system.TrigReduce:
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher access$000() -> a
org.matheclipse.core.reflection.system.TrigReduce$TrigReduceVisitor -> nP:
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.TrigToExp -> org.matheclipse.core.reflection.system.TrigToExp:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.TrigToExp$TrigToExpVisitor -> nQ:
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.TrueQ -> org.matheclipse.core.reflection.system.TrueQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Tuples -> org.matheclipse.core.reflection.system.Tuples:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void tuples(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void tuplesOfLists(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Unequal -> org.matheclipse.core.reflection.system.Unequal:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Union -> org.matheclipse.core.reflection.system.Union:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.UnitStep -> org.matheclipse.core.reflection.system.UnitStep:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.UnsameQ -> org.matheclipse.core.reflection.system.UnsameQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.UpSet -> org.matheclipse.core.reflection.system.UpSet:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object[] createPatternMatcher$3e35c740(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.UpSetDelayed -> org.matheclipse.core.reflection.system.UpSetDelayed:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.UpperCaseQ -> org.matheclipse.core.reflection.system.UpperCaseQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> a
org.matheclipse.core.reflection.system.VandermondeMatrix -> org.matheclipse.core.reflection.system.VandermondeMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.VandermondeMatrix$1 -> nR:
    org.matheclipse.core.expression.AST val$lst -> a
    java.lang.Object evaluate(int[]) -> a
org.matheclipse.core.reflection.system.Variables -> org.matheclipse.core.reflection.system.Variables:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.VectorQ -> org.matheclipse.core.reflection.system.VectorQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic -> nS:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> a
    long getN() -> a
    void clear() -> a
    org.matheclipse.core.interfaces.IExpr getResult() -> a
    void increment(org.matheclipse.core.interfaces.IExpr) -> a
    boolean test(org.matheclipse.core.interfaces.IAST,int,int,boolean) -> a
org.matheclipse.core.stat.descriptive.SymbolicGeometricMean -> nT:
    org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic product -> a
    void increment(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getResult() -> a
    void clear() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> a
    long getN() -> a
org.matheclipse.core.stat.descriptive.SymbolicStatUtils -> nU:
    org.matheclipse.core.stat.descriptive.SymbolicGeometricMean GEOMETRIC_MEAN -> a
    org.matheclipse.core.interfaces.IExpr geometricMean(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.stat.descriptive.summary.SymbolicProduct -> nV:
    long n -> a
    org.matheclipse.core.interfaces.IExpr value -> a
    void increment(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getResult() -> a
    long getN() -> a
    void clear() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> a
org.matheclipse.core.util.OpenIntToIExprHashMap -> nW:
    int[] keys -> a
    org.matheclipse.core.interfaces.IExpr[] values -> a
    byte[] states -> a
    int size -> a
    int mask -> b
    int count -> c
    org.matheclipse.core.interfaces.IExpr get(int) -> a
    int findInsertionIndex(int[],byte[],int,int) -> a
    int probe(int,int) -> a
    boolean containsKey(int,int) -> a
    org.matheclipse.core.interfaces.IExpr put(int,org.matheclipse.core.interfaces.IExpr) -> a
    int hashOf(int) -> a
org.matheclipse.core.visit.HashValueVisitor -> nX:
    int fMaxDepth -> b
    int currentDepth -> a
    int visit(org.matheclipse.core.interfaces.IAST) -> a
    int visit(org.matheclipse.core.interfaces.IComplex) -> a
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    int visit(org.matheclipse.core.interfaces.IFraction) -> a
    int visit(org.matheclipse.core.interfaces.IInteger) -> a
    int visit(org.matheclipse.core.interfaces.INum) -> a
    int visit(org.matheclipse.core.interfaces.IPattern) -> a
    int visit(org.matheclipse.core.interfaces.IStringX) -> a
    int visit(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.visit.IVisitor -> nY:
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.IVisitorBoolean -> nZ:
    boolean visit$6154956d() -> a
    boolean visit$2ed48865() -> b
    boolean visit$f81861f() -> c
    boolean visit$6e7d65cb() -> d
    boolean visit$4d323d8f() -> e
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean visit$2402f8ff() -> f
    boolean visit$5ad27180() -> g
    boolean visit$4d02b336() -> h
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.IVisitorInt -> oa:
    int visit(org.matheclipse.core.interfaces.IInteger) -> a
    int visit(org.matheclipse.core.interfaces.IFraction) -> a
    int visit(org.matheclipse.core.interfaces.IComplex) -> a
    int visit(org.matheclipse.core.interfaces.INum) -> a
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    int visit(org.matheclipse.core.interfaces.ISymbol) -> a
    int visit(org.matheclipse.core.interfaces.IPattern) -> a
    int visit(org.matheclipse.core.interfaces.IStringX) -> a
    int visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorCollectionBoolean -> ob:
    int fHeadOffset -> a
    java.util.Collection fCollection -> a
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorExpr -> oc:
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPattern) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IStringX) -> a
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> b
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorLevelSpecification -> od:
    com.google.common.base.Function fFunction -> a
    int fFromLevel -> b
    int fToLevel -> c
    int fFromDepth -> d
    int fToDepth -> e
    boolean fIncludeHeads -> a
    int fCurrentLevel -> a
    int fCurrentDepth -> f
    boolean isInRange(int,int) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorReplaceAll -> oe:
    com.google.common.base.Function fFunction -> a
    int fOffset -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPattern) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IStringX) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> b
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorReplacePart -> of:
    org.matheclipse.core.interfaces.IExpr fReplaceExpr -> a
    int[] fPositions -> a
    org.matheclipse.core.interfaces.IExpr visitIndex(org.matheclipse.core.interfaces.IAST,int) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorReplaceSlots -> og:
    org.matheclipse.core.interfaces.IAST astSlots -> a
    org.matheclipse.core.interfaces.IExpr getSlot(org.matheclipse.core.interfaces.IInteger) -> b
    int getSlotSequence(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> b
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.parser.client.Parser -> oh:
    boolean fRelaxedSyntax -> a
    boolean fPackageMode -> b
    org.matheclipse.parser.client.ast.SymbolNode DERIVATIVE -> a
    void getArguments(org.matheclipse.parser.client.ast.FunctionNode) -> a
    org.matheclipse.parser.client.operator.PostfixOperator determinePostfixOperator() -> a
    org.matheclipse.parser.client.operator.InfixOperator determineBinaryOperator() -> a
    org.matheclipse.parser.client.ast.ASTNode parseArguments(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.ASTNode parsePrimary() -> a
    org.matheclipse.parser.client.ast.ASTNode parseLookaheadOperator(int) -> a
    org.matheclipse.parser.client.ast.ASTNode parseOperators(org.matheclipse.parser.client.ast.ASTNode,int) -> a
    org.matheclipse.parser.client.ast.ASTNode parse(java.lang.String) -> a
    org.matheclipse.parser.client.ast.ASTNode getNumber(boolean) -> a
    int getIntegerNumber() -> a
    org.matheclipse.parser.client.ast.SymbolNode getSymbol() -> a
    org.matheclipse.parser.client.ast.FunctionNode getFunctionArguments(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.ASTNode getPart() -> b
org.matheclipse.parser.client.Scanner -> oi:
    java.lang.String fInputString -> a
    char fLastChar -> a
    char fCurrentChar -> b
    int fCurrentPosition -> a
    int fToken -> b
    java.lang.String fOperatorString -> b
    java.util.List fOperList -> a
    int rowCount -> c
    int fCurrentColumnStartPosition -> d
    int numFormat -> e
    org.matheclipse.parser.client.ast.IParserFactory fFactory -> a
    java.util.HashMap CHAR_MAP -> a
    void initialize(java.lang.String) -> a
    void initializeNullScanner() -> b
    void getChar() -> c
    void getNextChar() -> d
    void getNextToken() -> a
    void getComment() -> e
    void throwSyntaxError(java.lang.String) -> b
    void throwSyntaxError(java.lang.String,int) -> a
    java.lang.String getErrorLine() -> b
    java.lang.String getIdentifier() -> a
    java.lang.Object[] getNumberString() -> a
    java.lang.StringBuffer getStringBuffer() -> a
org.matheclipse.parser.client.SyntaxError -> org.matheclipse.parser.client.SyntaxError:
    int fStartOffset -> a
    int fRowIndex -> b
    int fColumnIndex -> c
    java.lang.String fCurrentLine -> a
    java.lang.String fError -> b
    java.lang.String getMessage() -> getMessage
org.matheclipse.parser.client.ast.ASTNode -> org.matheclipse.parser.client.ast.ASTNode:
    java.lang.String fStringValue -> a
    java.lang.String getString() -> a
    java.lang.String toString() -> toString
    boolean isFree(org.matheclipse.parser.client.ast.ASTNode) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FloatNode -> org.matheclipse.parser.client.ast.FloatNode:
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FractionNode -> org.matheclipse.parser.client.ast.FractionNode:
    org.matheclipse.parser.client.ast.IntegerNode fNumerator -> a
    org.matheclipse.parser.client.ast.IntegerNode fDenominator -> b
    org.matheclipse.parser.client.ast.IntegerNode getDenominator() -> a
    org.matheclipse.parser.client.ast.IntegerNode getNumerator() -> b
    java.lang.String toString() -> toString
    double doubleValue() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FunctionNode -> org.matheclipse.parser.client.ast.FunctionNode:
    java.util.ArrayList fNodesList -> a
    boolean add(org.matheclipse.parser.client.ast.ASTNode) -> b
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.parser.client.ast.ASTNode get(int) -> a
    org.matheclipse.parser.client.ast.ASTNode getNode(int) -> b
    int hashCode() -> hashCode
    int indexOf(java.lang.Object) -> indexOf
    boolean isEmpty() -> isEmpty
    boolean isFree(org.matheclipse.parser.client.ast.ASTNode) -> a
    java.util.Iterator iterator() -> iterator
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.util.ListIterator listIterator() -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    org.matheclipse.parser.client.ast.ASTNode set(int,org.matheclipse.parser.client.ast.ASTNode) -> a
    int size() -> size
    java.util.List subList(int,int) -> subList
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    java.lang.String toString() -> toString
    java.lang.Object remove(int) -> remove
    void add(int,java.lang.Object) -> add
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    boolean add(java.lang.Object) -> add
org.matheclipse.parser.client.ast.IParserFactory -> oj:
    java.lang.String getOperatorCharacters() -> a
    org.matheclipse.parser.client.operator.Operator get(java.lang.String) -> a
    java.util.List getOperatorList(java.lang.String) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createAST(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.ASTNode createDouble(java.lang.String) -> a
    org.matheclipse.parser.client.ast.IntegerNode createInteger(java.lang.String,int) -> a
    org.matheclipse.parser.client.ast.IntegerNode createInteger(int) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern2(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> b
    org.matheclipse.parser.client.ast.PatternNode createPattern3(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> c
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> a
    org.matheclipse.parser.client.ast.StringNode createString(java.lang.StringBuffer) -> a
    org.matheclipse.parser.client.ast.SymbolNode createSymbol(java.lang.String) -> a
org.matheclipse.parser.client.ast.IntegerNode -> org.matheclipse.parser.client.ast.IntegerNode:
    org.matheclipse.parser.client.ast.IntegerNode C1 -> a
    int fNumberFormat -> a
    int fIntValue -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.NumberNode -> org.matheclipse.parser.client.ast.NumberNode:
    boolean sign -> a
    void toggleSign() -> a
    java.lang.String getString() -> a
    java.lang.String toString() -> toString
    boolean isSign() -> a
    double doubleValue() -> a
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.Pattern2Node -> org.matheclipse.parser.client.ast.Pattern2Node:
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.Pattern3Node -> org.matheclipse.parser.client.ast.Pattern3Node:
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.PatternNode -> org.matheclipse.parser.client.ast.PatternNode:
    org.matheclipse.parser.client.ast.SymbolNode fSymbol -> a
    boolean fDefault -> a
    org.matheclipse.parser.client.ast.ASTNode fConstraint -> a
    org.matheclipse.parser.client.ast.ASTNode getConstraint() -> a
    org.matheclipse.parser.client.ast.SymbolNode getSymbol() -> a
    boolean isDefault() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.StringNode -> org.matheclipse.parser.client.ast.StringNode:
org.matheclipse.parser.client.ast.SymbolNode -> org.matheclipse.parser.client.ast.SymbolNode:
org.matheclipse.parser.client.eval.ComplexEvalVisitor -> ok:
    java.util.Map SYMBOL_MAP -> a
    java.util.Map SYMBOL_BOOLEAN_MAP -> b
    java.util.Map FUNCTION_MAP -> c
    java.util.Map FUNCTION_BOOLEAN_MAP -> d
    boolean fRelaxedSyntax -> a
org.matheclipse.parser.client.eval.ComplexEvalVisitor$1 -> ol:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.ComplexEvalVisitor$10 -> om:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$11 -> on:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$12 -> oo:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$13 -> op:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$14 -> oq:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$15 -> or:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$16 -> os:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$17 -> ot:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$2 -> ou:
    boolean evaluate(boolean) -> a
org.matheclipse.parser.client.eval.ComplexEvalVisitor$3 -> ov:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.ComplexEvalVisitor$4 -> ow:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$5 -> ox:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$6 -> oy:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$7 -> oz:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$8 -> oA:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$9 -> oB:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$ArcTanFunction -> oC:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$CompoundExpressionFunction -> oD:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$LogFunction -> oE:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$PlusFunction -> oF:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$SetFunction -> oG:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$TimesFunction -> oH:
org.matheclipse.parser.client.eval.ComplexEvaluator -> org.matheclipse.parser.client.eval.ComplexEvaluator:
    java.lang.String toString(org.matheclipse.parser.client.math.Complex) -> a
org.matheclipse.parser.client.eval.ComplexNode -> org.matheclipse.parser.client.eval.ComplexNode:
    org.matheclipse.parser.client.math.Complex value -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.eval.DoubleEvaluator -> org.matheclipse.parser.client.eval.DoubleEvaluator:
    double EPSILON -> a
    java.util.Map SYMBOL_DOUBLE_MAP -> a
    java.util.Map SYMBOL_BOOLEAN_MAP -> b
    java.util.Map FUNCTION_DOUBLE_MAP -> c
    java.util.Map FUNCTION_BOOLEAN_MAP -> d
    org.matheclipse.parser.client.eval.IDoubleCallbackFunction fCallbackFunction -> a
    java.util.Map fVariableMap -> e
    java.util.Map fBooleanVariables -> f
    org.matheclipse.parser.client.ast.ASTNode fNode -> a
    boolean fRelaxedSyntax -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory fASTFactory -> a
    org.matheclipse.parser.client.eval.IDoubleCallbackFunction getCallbackFunction() -> getCallbackFunction
    void setCallbackFunction(org.matheclipse.parser.client.eval.IDoubleCallbackFunction) -> setCallbackFunction
    org.matheclipse.parser.client.ast.ASTNode parse(java.lang.String) -> parse
    org.matheclipse.parser.client.ast.ASTNode parseNode(java.lang.String,boolean) -> parseNode
    double evaluate(java.lang.String) -> evaluate
    double evaluate() -> evaluate
    double evaluateNode(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNode
    double evaluateFunction(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunction
    boolean isSymbol(org.matheclipse.parser.client.ast.SymbolNode,java.lang.String) -> isSymbol
    boolean isSymbol(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.SymbolNode) -> isSymbol
    org.matheclipse.parser.client.ast.ASTNode derivative(org.matheclipse.parser.client.ast.ASTNode,java.lang.String) -> derivative
    org.matheclipse.parser.client.ast.ASTNode derivative(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.SymbolNode) -> derivative
    org.matheclipse.parser.client.ast.ASTNode getDerivativeResult(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.FunctionNode) -> a
    boolean evaluateNodeLogical(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNodeLogical
    boolean evaluateFunctionLogical(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunctionLogical
    org.matheclipse.parser.client.ast.ASTNode optimizeFunction(org.matheclipse.parser.client.ast.FunctionNode) -> optimizeFunction
    void defineVariable(java.lang.String,double) -> defineVariable
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.IDoubleValue) -> defineVariable
    void defineVariable(java.lang.String) -> defineVariable
    org.matheclipse.parser.client.eval.IDoubleValue getVariable(java.lang.String) -> getVariable
    void defineVariable$7b85584e(java.lang.String,org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction) -> defineVariable$7b85584e
    void clearVariables() -> clearVariables
    void getVariables(java.lang.String,java.util.Set) -> getVariables
    void getVariables(java.lang.String,java.util.Set,boolean) -> getVariables
    void getVariables(org.matheclipse.parser.client.ast.ASTNode,java.util.Set) -> getVariables
org.matheclipse.parser.client.eval.DoubleEvaluator$1 -> oI:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$11 -> oJ:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$12 -> oK:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$13 -> oL:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$14 -> oM:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$15 -> oN:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$16 -> oO:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$17 -> oP:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$18 -> oQ:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$19 -> oR:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$2 -> oS:
    boolean evaluate(boolean) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$20 -> oT:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$21 -> oU:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$22 -> oV:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$23 -> oW:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$24 -> oX:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$25 -> oY:
    double evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$3 -> oZ:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$4 -> pa:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$5 -> pb:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$6 -> pc:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$7 -> pd:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$8 -> pe:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$9 -> pf:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$ArcTanFunction -> pg:
    double evaluate(double) -> a
    double evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$CompoundExpressionFunction -> ph:
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$LogFunction -> pi:
    double evaluate(double) -> a
    double evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$MaxFunction -> pj:
    double evaluate(double,double) -> a
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$MinFunction -> pk:
    double evaluate(double,double) -> a
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$PlusFunction -> pl:
    double evaluate(double,double) -> a
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$SetFunction -> pm:
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$TimesFunction -> pn:
    double evaluate(double,double) -> a
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleNode -> org.matheclipse.parser.client.eval.DoubleNode:
    double value -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.eval.DoubleVariable -> po:
    double value -> a
    double getValue() -> a
    void setValue(double) -> a
org.matheclipse.parser.client.eval.IBooleanBoolean1Function -> pp:
    boolean evaluate(boolean) -> a
org.matheclipse.parser.client.eval.IBooleanBoolean2Function -> pq:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.IBooleanDouble2Function -> pr:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.IDouble0Function -> ps:
    double evaluate() -> a
org.matheclipse.parser.client.eval.IDouble1Function -> pt:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.IDouble2Function -> pu:
    double evaluate(double,double) -> a
org.matheclipse.parser.client.eval.IDoubleCallbackFunction -> pv:
    double evaluate$5bc7c9e6(org.matheclipse.parser.client.ast.FunctionNode,double[]) -> a
org.matheclipse.parser.client.eval.IDoubleFunction -> pw:
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.IDoubleValue -> px:
    double getValue() -> a
    void setValue(double) -> a
org.matheclipse.parser.client.eval.api.IASTVisitor -> py:
org.matheclipse.parser.client.eval.api.ObjectEvaluator -> pz:
org.matheclipse.parser.client.math.ArithmeticMathException -> org.matheclipse.parser.client.math.ArithmeticMathException:
org.matheclipse.parser.client.math.Complex -> pA:
    double imaginary -> a
    double real -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isNaN() -> a
org.matheclipse.parser.client.math.MathException -> org.matheclipse.parser.client.math.MathException:
org.matheclipse.parser.client.operator.ASTNodeFactory -> pB:
    java.lang.String[] HEADER_STRINGS -> a
    java.lang.String[] OPERATOR_STRINGS -> b
    org.matheclipse.parser.client.operator.Operator[] OPERATORS -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory MMA_STYLE_FACTORY -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory RELAXED_STYLE_FACTORY -> b
    java.util.HashMap fOperatorMap -> a
    java.util.HashMap fOperatorTokenStartSet -> b
    boolean fIgnoreCase -> a
    java.lang.String getOperatorCharacters() -> a
    org.matheclipse.parser.client.operator.Operator get(java.lang.String) -> a
    java.util.List getOperatorList(java.lang.String) -> a
    org.matheclipse.parser.client.ast.ASTNode createDouble(java.lang.String) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createAST(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.IntegerNode createInteger(java.lang.String,int) -> a
    org.matheclipse.parser.client.ast.IntegerNode createInteger(int) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern2(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> b
    org.matheclipse.parser.client.ast.PatternNode createPattern3(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> c
    org.matheclipse.parser.client.ast.StringNode createString(java.lang.StringBuffer) -> a
    org.matheclipse.parser.client.ast.SymbolNode createSymbol(java.lang.String) -> a
org.matheclipse.parser.client.operator.DivideOperator -> pC:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.InfixOperator -> pD:
    int fGrouping -> a
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.Operator -> pE:
    java.lang.String fFunctionName -> a
    java.lang.String fOperatorString -> b
    int fPrecedence -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String getFunctionName() -> a
    java.lang.String getOperatorString() -> b
    int getPrecedence() -> a
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.matheclipse.parser.client.operator.PostfixOperator -> pF:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.PreMinusOperator -> pG:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.PrePlusOperator -> pH:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.PrefixOperator -> pI:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.SubtractOperator -> pJ:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
