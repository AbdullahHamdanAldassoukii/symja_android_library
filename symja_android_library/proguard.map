cc.redberry.concurrent.OutputPortUnsafe -> a:
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.DummySolutionProvider -> b:
    int[] solution -> a
    int[] currentRemainder -> b
    boolean tick() -> a
    int[] currentRemainders() -> a
    java.lang.Object take() -> a
    boolean equal(java.lang.Object,java.lang.Object) -> a
    void checkArgument(boolean) -> a
    void checkArgument(boolean,java.lang.String,java.lang.Object[]) -> a
    java.lang.Object checkNotNull(java.lang.Object) -> a
    java.lang.Object checkNotNull(java.lang.Object,java.lang.Object) -> a
    int checkElementIndex(int,int) -> a
    int checkPositionIndex(int,int) -> b
    java.lang.String badPositionIndex(int,int,java.lang.String) -> a
    void checkPositionIndexes(int,int,int) -> a
    java.lang.String format(java.lang.String,java.lang.Object[]) -> a
    void checkRemove(boolean) -> b
    java.lang.Object getFirst(java.lang.Iterable,java.lang.Object) -> a
    java.util.HashSet newHashSet(java.lang.Iterable) -> a
    com.google.common.collect.Sets$SetView difference(java.util.Set,java.util.Set) -> a
    int hashCodeImpl(java.util.Set) -> a
    boolean equalsImpl(java.util.Set,java.lang.Object) -> a
    java.util.NavigableSet unmodifiableNavigableSet(java.util.NavigableSet) -> a
    boolean removeAllImpl(java.util.Set,java.util.Iterator) -> a
    boolean removeAllImpl(java.util.Set,java.util.Collection) -> a
    int checkNonNegative(java.lang.String,int) -> a
    long checkNonNegative(java.lang.String,long) -> a
    void checkRoundingUnnecessary(boolean) -> c
    void checkInRange(boolean) -> d
    java.util.List map(java.util.List,edu.jas.structure.UnaryFunctor) -> a
    org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction) -> a
    boolean isBracketing(org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    void verifyInterval(double,double) -> a
    java.lang.Object[] flatten(java.lang.Object[]) -> a
    double erf(double) -> a
    double erfInv(double) -> b
    java.math.BigInteger pow(java.math.BigInteger,long) -> a
    java.math.BigInteger pow(java.math.BigInteger,java.math.BigInteger) -> a
    java.text.NumberFormat getDefaultNumberFormat(java.util.Locale) -> a
    java.lang.StringBuffer formatDouble(double,java.text.NumberFormat,java.lang.StringBuffer,java.text.FieldPosition) -> a
    boolean checkOrder$5183600(double[],int,boolean,boolean) -> a
    void checkOrder(double[]) -> a
    void checkNotNaN(double[]) -> b
    java.lang.Object[] buildArray(org.apache.commons.math3.Field,int) -> a
    java.lang.Object[][] buildArray(org.apache.commons.math3.Field,int,int) -> a
    boolean verifyValues(double[],int,int,boolean) -> a
    int hash(double) -> a
    boolean equals(double,double) -> a
    void checkNotNull(java.lang.Object,org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> a
    void checkNotNull(java.lang.Object) -> a
    org.apfloat.Aprational scale(org.apfloat.Aprational,long) -> a
    java.io.Writer wrapAppendableWriter(java.lang.Appendable) -> a
    java.io.Writer wrapPadWriter(java.io.Writer,boolean) -> a
    void finishPad(java.io.Writer,long) -> a
    void pad(java.lang.Appendable,long) -> a
    org.apfloat.Apfloat toRadixNormalizedPart(org.apfloat.Apfloat,int,long,org.apfloat.RadixConversionHelper$RadixPowerList) -> a
    org.apfloat.Apfloat split(org.apfloat.Apfloat,int,long,long,org.apfloat.RadixConversionHelper$RadixPowerList) -> a
    long getPrecision(long,int,int) -> a
    void scramble(double[],int,int[]) -> a
    void scramble(float[],int,int[]) -> a
    void scramble(int[],int,int[]) -> a
    void scramble(long[],int,int[]) -> a
    org.apache.commons.math3.linear.FieldMatrix list2Matrix(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST matrix2List(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.linear.RealMatrix list2RealMatrix(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST realMatrix2List(org.apache.commons.math3.linear.RealMatrix) -> a
    org.apache.commons.math3.linear.FieldVector list2Vector(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST vector2List(org.apache.commons.math3.linear.FieldVector) -> a
    org.matheclipse.core.interfaces.IAST asList(int[]) -> a
    org.matheclipse.core.interfaces.IExpr power(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    int checkPowerExponent(org.matheclipse.core.interfaces.IAST) -> a
    long checkLongPowerExponent(org.matheclipse.core.interfaces.IAST) -> a
    long checkLongType(org.matheclipse.core.interfaces.IExpr) -> a
    int checkIntType(org.matheclipse.core.interfaces.IAST,int,int) -> a
    int checkIntType(org.matheclipse.core.interfaces.IExpr,int) -> a
    org.matheclipse.core.interfaces.IAST checkRange(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IAST checkRange(org.matheclipse.core.interfaces.IAST,int,int) -> a
    org.matheclipse.core.interfaces.IAST checkSize(org.matheclipse.core.interfaces.IAST,int) -> b
    org.matheclipse.core.interfaces.IAST checkSymbolOrSymbolList(org.matheclipse.core.interfaces.IAST,int) -> c
    org.matheclipse.core.interfaces.ISymbol checkSymbolType(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IAST checkASTUpRuleType(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST checkASTType(org.matheclipse.core.interfaces.IAST,int) -> d
    org.matheclipse.core.interfaces.IAST checkASTType(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST checkEquations(org.matheclipse.core.interfaces.IAST,int) -> e
    org.matheclipse.core.expression.ComplexNum log(org.matheclipse.core.expression.ComplexNum) -> a
    com.google.common.base.Predicate isTrue(org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Predicate isTrue(org.matheclipse.core.eval.EvalEngine,org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Predicate in(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST flatten(org.matheclipse.core.interfaces.IAST) -> a
    boolean flatten(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    boolean flatten(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,int) -> a
    void sort(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST threadList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int,int) -> a
    boolean convertTerm2Coefficients(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[]) -> a
    org.matheclipse.core.interfaces.IAST quarticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST cubicSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST createSet(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IAST quadraticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST biQuadraticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
cc.redberry.core.math.frobenius.FinalSolutionProvider -> c:
    boolean $assertionsDisabled -> a
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.FrobeniusSolver -> d:
    cc.redberry.concurrent.OutputPortUnsafe provider -> a
    int[] take() -> a
    boolean assertEq(int[]) -> a
    java.lang.Object take() -> a
    int hash(double) -> a
cc.redberry.core.math.frobenius.SingleSolutionProvider -> e:
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.SolutionProvider -> f:
    boolean tick() -> a
    int[] currentRemainders() -> a
cc.redberry.core.math.frobenius.SolutionProviderAbstract -> g:
    cc.redberry.core.math.frobenius.SolutionProvider provider -> a
    int position -> a
    int[] coefficients -> a
    int[] currentSolution -> b
    int currentCounter -> b
    int[] currentRemainder -> c
    boolean tick() -> a
    int[] currentRemainders() -> a
cc.redberry.core.math.frobenius.TotalSolutionProvider -> h:
    cc.redberry.core.math.frobenius.SolutionProvider[] providers -> a
    boolean inited -> a
    boolean $assertionsDisabled -> b
    java.lang.Object take() -> a
com.google.common.base.CharMatcher -> com.google.common.base.CharMatcher:
    java.lang.String NINES -> a
    java.lang.String description -> b
    int WHITESPACE_SHIFT -> a
    java.lang.String showCharacter(char) -> a
    com.google.common.base.CharMatcher inRange(char,char) -> a
    com.google.common.base.CharMatcher inRange(char,char,java.lang.String) -> a
    boolean matches(char) -> a
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> a
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
    boolean apply(java.lang.Character) -> a
    java.lang.String toString() -> toString
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$1 -> i:
    boolean matches(char) -> a
    java.lang.String toString() -> toString
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$13 -> j:
    char val$startInclusive -> a
    char val$endInclusive -> b
    boolean matches(char) -> a
com.google.common.base.CharMatcher$15 -> k:
    boolean matches(char) -> a
com.google.common.base.CharMatcher$2 -> l:
    boolean matches(char) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$3 -> m:
    boolean matches(char) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$4 -> n:
    boolean matches(char) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$5 -> o:
    boolean matches(char) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$6 -> p:
    boolean matches(char) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$7 -> q:
    boolean matches(char) -> a
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> a
com.google.common.base.CharMatcher$8 -> r:
    boolean matches(char) -> a
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> a
com.google.common.base.CharMatcher$FastMatcher -> s:
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$Or -> t:
    com.google.common.base.CharMatcher first -> a
    com.google.common.base.CharMatcher second -> b
    boolean matches(char) -> a
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$RangesMatcher -> u:
    char[] rangeStarts -> a
    char[] rangeEnds -> b
    boolean matches(char) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.Converter -> com.google.common.base.Converter:
    boolean handleNullAutomatically -> a
    boolean equals(java.lang.Object) -> equals
com.google.common.base.Function -> com.google.common.base.Function:
    java.lang.Object apply(java.lang.Object) -> apply
    boolean equals(java.lang.Object) -> equals
com.google.common.base.Joiner -> v:
    java.lang.String separator -> a
    com.google.common.base.Joiner useForNull(java.lang.String) -> a
com.google.common.base.Joiner$1 -> w:
    com.google.common.base.Joiner useForNull(java.lang.String) -> a
com.google.common.base.Joiner$MapJoiner -> x:
com.google.common.base.Predicate -> com.google.common.base.Predicate:
    boolean apply(java.lang.Object) -> apply
    boolean equals(java.lang.Object) -> equals
com.google.common.base.Predicates -> y:
    com.google.common.base.Predicate not(com.google.common.base.Predicate) -> a
    com.google.common.base.Predicate in(java.util.Collection) -> a
com.google.common.base.Predicates$InPredicate -> z:
    java.util.Collection target -> a
    boolean apply(java.lang.Object) -> apply
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.base.Predicates$NotPredicate -> A:
    com.google.common.base.Predicate predicate -> a
    boolean apply(java.lang.Object) -> apply
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.google.common.collect.AbstractIndexedListIterator -> B:
    int size -> a
    int position -> b
    java.lang.Object get(int) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    int nextIndex() -> nextIndex
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int previousIndex() -> previousIndex
com.google.common.collect.AbstractIterator -> C:
    int state$1572a20f -> a
    java.lang.Object next -> a
    java.lang.Object computeNext() -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.AbstractIterator$1 -> D:
    int[] $SwitchMap$com$google$common$collect$AbstractIterator$State -> a
com.google.common.collect.AbstractIterator$State -> E:
    int READY$1572a20f -> a
    int NOT_READY$1572a20f -> b
    int DONE$1572a20f -> c
    int FAILED$1572a20f -> d
    int[] $VALUES$12ff0e74 -> a
    int[] values$55dd66eb() -> a
com.google.common.collect.AbstractListMultimap -> F:
    java.util.List createCollection() -> a
    java.util.List get(java.lang.Object) -> a
    boolean put(java.lang.Object,java.lang.Object) -> a
    java.util.Map asMap() -> a
    boolean equals(java.lang.Object) -> equals
    java.util.Collection get(java.lang.Object) -> a
    java.util.Collection createCollection() -> a
com.google.common.collect.AbstractMapBasedMultimap -> G:
    java.util.Map map -> a
    int totalSize -> a
    java.util.Collection createCollection() -> a
    java.util.Collection createCollection(java.lang.Object) -> b
    java.util.Map backingMap() -> b
    int size() -> a
    boolean put(java.lang.Object,java.lang.Object) -> a
    java.util.Collection unmodifiableCollectionSubclass(java.util.Collection) -> a
    void clear() -> a
    java.util.Collection get(java.lang.Object) -> a
    java.util.Collection wrapCollection(java.lang.Object,java.util.Collection) -> a
    java.util.List wrapList(java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> a
    java.util.Set createKeySet() -> a
    java.util.Collection values() -> b
    java.util.Iterator valueIterator() -> a
    java.util.Collection entries() -> c
    java.util.Iterator entryIterator() -> b
    java.util.Map createAsMap() -> c
    java.util.Map access$000(com.google.common.collect.AbstractMapBasedMultimap) -> a
    java.util.Iterator access$100(com.google.common.collect.AbstractMapBasedMultimap,java.util.Collection) -> a
    int access$210(com.google.common.collect.AbstractMapBasedMultimap) -> a
    int access$208(com.google.common.collect.AbstractMapBasedMultimap) -> b
    int access$212(com.google.common.collect.AbstractMapBasedMultimap,int) -> a
    int access$220(com.google.common.collect.AbstractMapBasedMultimap,int) -> b
    java.util.List access$300(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> a
    int access$400(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object) -> a
com.google.common.collect.AbstractMapBasedMultimap$1 -> H:
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.AbstractMapBasedMultimap$2 -> I:
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.AbstractMapBasedMultimap$AsMap -> J:
    java.util.Map submap -> a
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    java.util.Set createEntrySet() -> a
    boolean containsKey(java.lang.Object) -> containsKey
    java.util.Set keySet() -> keySet
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    void clear() -> clear
    java.util.Map$Entry wrapEntry(java.util.Map$Entry) -> a
    java.lang.Object remove(java.lang.Object) -> remove
    java.lang.Object get(java.lang.Object) -> get
com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapEntries -> K:
    com.google.common.collect.AbstractMapBasedMultimap$AsMap this$1 -> a
    java.util.Map map() -> a
    java.util.Iterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapIterator -> L:
    java.util.Iterator delegateIterator -> a
    java.util.Collection collection -> a
    com.google.common.collect.AbstractMapBasedMultimap$AsMap this$1 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
com.google.common.collect.AbstractMapBasedMultimap$Itr -> M:
    java.util.Iterator keyIterator -> a
    java.lang.Object key -> a
    java.util.Collection collection -> a
    java.util.Iterator valueIterator -> b
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapBasedMultimap$KeySet -> N:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
    boolean containsAll(java.util.Collection) -> containsAll
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.google.common.collect.AbstractMapBasedMultimap$KeySet$1 -> O:
    java.util.Map$Entry entry -> a
    java.util.Iterator val$entryIterator -> a
    com.google.common.collect.AbstractMapBasedMultimap$KeySet this$1 -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapBasedMultimap$NavigableAsMap -> P:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.Map$Entry lowerEntry(java.lang.Object) -> lowerEntry
    java.lang.Object lowerKey(java.lang.Object) -> lowerKey
    java.util.Map$Entry floorEntry(java.lang.Object) -> floorEntry
    java.lang.Object floorKey(java.lang.Object) -> floorKey
    java.util.Map$Entry ceilingEntry(java.lang.Object) -> ceilingEntry
    java.lang.Object ceilingKey(java.lang.Object) -> ceilingKey
    java.util.Map$Entry higherEntry(java.lang.Object) -> higherEntry
    java.lang.Object higherKey(java.lang.Object) -> higherKey
    java.util.Map$Entry firstEntry() -> firstEntry
    java.util.Map$Entry lastEntry() -> lastEntry
    java.util.Map$Entry pollFirstEntry() -> pollFirstEntry
    java.util.Map$Entry pollLastEntry() -> pollLastEntry
    java.util.Map$Entry pollAsMapEntry(java.util.Iterator) -> a
    java.util.NavigableMap descendingMap() -> descendingMap
    java.util.NavigableSet createKeySet() -> a
    java.util.NavigableSet navigableKeySet() -> navigableKeySet
    java.util.NavigableSet descendingKeySet() -> descendingKeySet
    java.util.NavigableMap subMap(java.lang.Object,boolean,java.lang.Object,boolean) -> subMap
    java.util.NavigableMap headMap(java.lang.Object,boolean) -> headMap
    java.util.NavigableMap tailMap(java.lang.Object,boolean) -> tailMap
    java.util.SortedSet createKeySet() -> a
    java.util.SortedSet keySet() -> b
    java.util.SortedMap tailMap(java.lang.Object) -> tailMap
    java.util.SortedMap subMap(java.lang.Object,java.lang.Object) -> subMap
    java.util.SortedMap headMap(java.lang.Object) -> headMap
    java.util.SortedMap sortedMap() -> a
    java.util.Set keySet() -> keySet
    java.util.Set createKeySet() -> b
com.google.common.collect.AbstractMapBasedMultimap$NavigableKeySet -> Q:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.lang.Object pollFirst() -> pollFirst
    java.lang.Object pollLast() -> pollLast
    java.util.NavigableSet descendingSet() -> descendingSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedMap sortedMap() -> a
com.google.common.collect.AbstractMapBasedMultimap$RandomAccessWrappedList -> R:
com.google.common.collect.AbstractMapBasedMultimap$SortedAsMap -> S:
    java.util.SortedSet sortedKeySet -> a
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.SortedMap sortedMap() -> a
    java.util.Comparator comparator() -> comparator
    java.lang.Object firstKey() -> firstKey
    java.lang.Object lastKey() -> lastKey
    java.util.SortedMap headMap(java.lang.Object) -> headMap
    java.util.SortedMap subMap(java.lang.Object,java.lang.Object) -> subMap
    java.util.SortedMap tailMap(java.lang.Object) -> tailMap
    java.util.SortedSet keySet() -> b
    java.util.SortedSet createKeySet() -> a
    java.util.Set keySet() -> keySet
    java.util.Set createKeySet() -> b
com.google.common.collect.AbstractMapBasedMultimap$SortedKeySet -> T:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.SortedMap sortedMap() -> a
    java.util.Comparator comparator() -> comparator
    java.lang.Object first() -> first
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.lang.Object last() -> last
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection -> U:
    java.lang.Object key -> a
    java.util.Collection delegate -> a
    com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection ancestor -> a
    java.util.Collection ancestorDelegate -> b
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    void refreshIfEmpty() -> a
    void removeIfEmpty() -> b
    void addToMap() -> c
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    boolean add(java.lang.Object) -> add
    boolean addAll(java.util.Collection) -> addAll
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    void clear() -> clear
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator -> V:
    java.util.Iterator delegateIterator -> a
    java.util.Collection originalDelegate -> a
    com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection this$1 -> a
    void validateIterator() -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapBasedMultimap$WrappedList -> W:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.List getListDelegate() -> a
    boolean addAll(int,java.util.Collection) -> addAll
    java.lang.Object get(int) -> get
    java.lang.Object set(int,java.lang.Object) -> set
    void add(int,java.lang.Object) -> add
    java.lang.Object remove(int) -> remove
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.util.ListIterator listIterator() -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.List subList(int,int) -> subList
com.google.common.collect.AbstractMapBasedMultimap$WrappedList$WrappedListIterator -> X:
    com.google.common.collect.AbstractMapBasedMultimap$WrappedList this$1 -> a
    java.util.ListIterator getDelegateListIterator() -> a
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
    void set(java.lang.Object) -> set
    void add(java.lang.Object) -> add
com.google.common.collect.AbstractMapBasedMultimap$WrappedNavigableSet -> Y:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.lang.Object pollFirst() -> pollFirst
    java.lang.Object pollLast() -> pollLast
    java.util.NavigableSet wrap(java.util.NavigableSet) -> a
    java.util.NavigableSet descendingSet() -> descendingSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.SortedSet getSortedSetDelegate() -> a
com.google.common.collect.AbstractMapBasedMultimap$WrappedSet -> Z:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    boolean removeAll(java.util.Collection) -> removeAll
com.google.common.collect.AbstractMapBasedMultimap$WrappedSortedSet -> aa:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    java.util.SortedSet getSortedSetDelegate() -> a
    java.util.Comparator comparator() -> comparator
    java.lang.Object first() -> first
    java.lang.Object last() -> last
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
com.google.common.collect.AbstractMapEntry -> ab:
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.AbstractMultimap -> ac:
    java.util.Collection entries -> a
    java.util.Set keySet -> a
    java.util.Collection values -> b
    java.util.Map asMap -> a
    boolean isEmpty() -> a
    boolean containsValue(java.lang.Object) -> a
    boolean containsEntry(java.lang.Object,java.lang.Object) -> b
    boolean remove(java.lang.Object,java.lang.Object) -> c
    boolean put(java.lang.Object,java.lang.Object) -> a
    java.util.Collection entries() -> c
    java.util.Iterator entryIterator() -> b
    java.util.Set keySet() -> b
    java.util.Set createKeySet() -> a
    java.util.Collection values() -> b
    java.util.Iterator valueIterator() -> a
    java.util.Map asMap() -> a
    java.util.Map createAsMap() -> c
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.AbstractMultimap$Entries -> ad:
    com.google.common.collect.AbstractMultimap this$0 -> a
    com.google.common.collect.Multimap multimap() -> a
    java.util.Iterator iterator() -> iterator
com.google.common.collect.AbstractMultimap$EntrySet -> ae:
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.google.common.collect.AbstractMultimap$Values -> af:
    com.google.common.collect.AbstractMultimap this$0 -> a
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    void clear() -> clear
com.google.common.collect.AbstractSetMultimap -> ag:
    java.util.Set createCollection() -> c
    java.util.Set get(java.lang.Object) -> a
    java.util.Set entries() -> d
    java.util.Map asMap() -> a
    boolean put(java.lang.Object,java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    java.util.Collection entries() -> c
    java.util.Collection get(java.lang.Object) -> a
    java.util.Collection createCollection() -> a
com.google.common.collect.AbstractSortedKeySortedSetMultimap -> ah:
    java.util.SortedMap asMap() -> a
    java.util.SortedMap backingMap() -> b
    java.util.SortedSet keySet() -> a
    java.util.Map asMap() -> a
    java.util.Set keySet() -> b
    java.util.Map backingMap() -> b
com.google.common.collect.AbstractSortedSetMultimap -> ai:
    java.util.SortedSet createCollection() -> b
    java.util.SortedSet get(java.lang.Object) -> a
    java.util.Map asMap() -> a
    java.util.Collection values() -> b
    java.util.Set get(java.lang.Object) -> a
    java.util.Set createCollection() -> c
    java.util.Collection get(java.lang.Object) -> a
    java.util.Collection createCollection() -> a
com.google.common.collect.ArrayListMultimap -> aj:
    int expectedValuesPerKey -> a
    com.google.common.collect.ArrayListMultimap create() -> a
    java.util.List createCollection() -> a
    boolean equals(java.lang.Object) -> equals
    java.util.Map asMap() -> a
    boolean put(java.lang.Object,java.lang.Object) -> a
    java.util.List get(java.lang.Object) -> a
    java.util.Collection entries() -> c
    java.util.Collection values() -> b
    void clear() -> a
    int size() -> a
    java.util.Collection createCollection() -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    java.util.Set keySet() -> b
    boolean remove(java.lang.Object,java.lang.Object) -> c
    boolean containsEntry(java.lang.Object,java.lang.Object) -> b
    boolean containsValue(java.lang.Object) -> a
    boolean isEmpty() -> a
com.google.common.collect.Collections2 -> ak:
    com.google.common.base.Joiner STANDARD_JOINER -> a
    boolean safeContains(java.util.Collection,java.lang.Object) -> a
    java.util.Collection cast(java.lang.Iterable) -> a
com.google.common.collect.ComparatorOrdering -> al:
    java.util.Comparator comparator -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.ComparisonChain -> am:
    com.google.common.collect.ComparisonChain ACTIVE -> a
    com.google.common.collect.ComparisonChain LESS -> b
    com.google.common.collect.ComparisonChain GREATER -> c
    com.google.common.collect.ComparisonChain start() -> a
    com.google.common.collect.ComparisonChain compare(java.lang.Comparable,java.lang.Comparable) -> a
    int result() -> a
com.google.common.collect.ComparisonChain$1 -> an:
    com.google.common.collect.ComparisonChain compare(java.lang.Comparable,java.lang.Comparable) -> a
    int result() -> a
com.google.common.collect.ComparisonChain$InactiveComparisonChain -> ao:
    int result -> a
    com.google.common.collect.ComparisonChain compare(java.lang.Comparable,java.lang.Comparable) -> a
    int result() -> a
com.google.common.collect.Cut -> ap:
    java.lang.Comparable endpoint -> a
    boolean isLessThan(java.lang.Comparable) -> a
    void describeAsLowerBound(java.lang.StringBuilder) -> a
    void describeAsUpperBound(java.lang.StringBuilder) -> b
    int compareTo(com.google.common.collect.Cut) -> a
    boolean equals(java.lang.Object) -> equals
    com.google.common.collect.Cut belowAll() -> a
    com.google.common.collect.Cut aboveAll() -> b
    int compareTo(java.lang.Object) -> compareTo
com.google.common.collect.Cut$AboveAll -> aq:
    com.google.common.collect.Cut$AboveAll INSTANCE -> a
    boolean isLessThan(java.lang.Comparable) -> a
    void describeAsLowerBound(java.lang.StringBuilder) -> a
    void describeAsUpperBound(java.lang.StringBuilder) -> b
    int compareTo(com.google.common.collect.Cut) -> a
    java.lang.String toString() -> toString
    int compareTo(java.lang.Object) -> compareTo
    com.google.common.collect.Cut$AboveAll access$100() -> a
com.google.common.collect.Cut$AboveValue -> ar:
    boolean isLessThan(java.lang.Comparable) -> a
    void describeAsLowerBound(java.lang.StringBuilder) -> a
    void describeAsUpperBound(java.lang.StringBuilder) -> b
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compareTo(java.lang.Object) -> compareTo
com.google.common.collect.Cut$BelowAll -> as:
    com.google.common.collect.Cut$BelowAll INSTANCE -> a
    boolean isLessThan(java.lang.Comparable) -> a
    void describeAsLowerBound(java.lang.StringBuilder) -> a
    void describeAsUpperBound(java.lang.StringBuilder) -> b
    int compareTo(com.google.common.collect.Cut) -> a
    java.lang.String toString() -> toString
    int compareTo(java.lang.Object) -> compareTo
    com.google.common.collect.Cut$BelowAll access$000() -> a
com.google.common.collect.DescendingImmutableSortedSet -> at:
    com.google.common.collect.ImmutableSortedSet forward -> a
    int size() -> size
    com.google.common.collect.UnmodifiableIterator iterator() -> a
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> a
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> a
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> b
    com.google.common.collect.ImmutableSortedSet descendingSet() -> a
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> b
    com.google.common.collect.ImmutableSortedSet createDescendingSet() -> b
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet descendingSet() -> descendingSet
    java.util.Iterator iterator() -> iterator
com.google.common.collect.EmptyImmutableSortedSet -> au:
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    com.google.common.collect.UnmodifiableIterator iterator() -> a
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> b
    int copyIntoArray(java.lang.Object[],int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.Object first() -> first
    java.lang.Object last() -> last
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> a
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> a
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> b
    com.google.common.collect.ImmutableSortedSet createDescendingSet() -> b
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ForwardingCollection -> av:
    java.util.Collection delegate() -> a
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean removeAll(java.util.Collection) -> removeAll
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean add(java.lang.Object) -> add
    boolean remove(java.lang.Object) -> remove
    boolean containsAll(java.util.Collection) -> containsAll
    boolean addAll(java.util.Collection) -> addAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    java.lang.Object delegate() -> a
com.google.common.collect.ForwardingObject -> aw:
    java.lang.Object delegate() -> a
    java.lang.String toString() -> toString
com.google.common.collect.ForwardingSet -> ax:
    java.util.Set delegate() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.Collection delegate() -> a
    java.lang.Object delegate() -> a
com.google.common.collect.ForwardingSortedSet -> ay:
    java.util.SortedSet delegate() -> a
    java.util.Comparator comparator() -> comparator
    java.lang.Object first() -> first
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.lang.Object last() -> last
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
    java.util.Set delegate() -> a
    java.util.Collection delegate() -> a
    java.lang.Object delegate() -> a
com.google.common.collect.ImmutableCollection -> az:
    com.google.common.collect.UnmodifiableIterator iterator() -> a
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    boolean contains(java.lang.Object) -> contains
    boolean add(java.lang.Object) -> add
    boolean remove(java.lang.Object) -> remove
    boolean addAll(java.util.Collection) -> addAll
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    int copyIntoArray(java.lang.Object[],int) -> a
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableEntry -> aA:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
com.google.common.collect.ImmutableList -> aB:
    com.google.common.collect.ImmutableList EMPTY -> a
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object) -> a
    com.google.common.collect.UnmodifiableIterator iterator() -> a
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> a
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.ImmutableList subList(int,int) -> a
    com.google.common.collect.ImmutableList subListUnchecked(int,int) -> b
    boolean addAll(int,java.util.Collection) -> addAll
    java.lang.Object set(int,java.lang.Object) -> set
    void add(int,java.lang.Object) -> add
    java.lang.Object remove(int) -> remove
    int copyIntoArray(java.lang.Object[],int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.Iterator iterator() -> iterator
    java.util.List subList(int,int) -> subList
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator() -> listIterator
com.google.common.collect.ImmutableList$1 -> aC:
    com.google.common.collect.ImmutableList this$0 -> a
    java.lang.Object get(int) -> a
com.google.common.collect.ImmutableList$SubList -> aD:
    int offset -> a
    int length -> b
    com.google.common.collect.ImmutableList this$0 -> b
    int size() -> size
    java.lang.Object get(int) -> get
    com.google.common.collect.ImmutableList subList(int,int) -> a
    java.util.List subList(int,int) -> subList
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator() -> listIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableSet -> aE:
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    com.google.common.collect.UnmodifiableIterator iterator() -> a
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableSortedSet -> aF:
    java.util.Comparator NATURAL_ORDER -> b
    java.util.Comparator comparator -> a
    com.google.common.collect.ImmutableSortedSet descendingSet -> a
    java.util.Comparator comparator() -> comparator
    com.google.common.collect.UnmodifiableIterator iterator() -> a
    com.google.common.collect.ImmutableSortedSet headSet(java.lang.Object,boolean) -> c
    com.google.common.collect.ImmutableSortedSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> b
    com.google.common.collect.ImmutableSortedSet tailSet(java.lang.Object,boolean) -> d
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> a
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> a
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> b
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.lang.Object first() -> first
    java.lang.Object last() -> last
    java.lang.Object pollFirst() -> pollFirst
    java.lang.Object pollLast() -> pollLast
    com.google.common.collect.ImmutableSortedSet descendingSet() -> a
    com.google.common.collect.ImmutableSortedSet createDescendingSet() -> b
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> b
    java.util.Iterator iterator() -> iterator
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet descendingSet() -> descendingSet
com.google.common.collect.ImmutableSortedSetFauxverideShim -> aG:
com.google.common.collect.Iterators -> aH:
    com.google.common.collect.UnmodifiableListIterator EMPTY_LIST_ITERATOR -> a
    java.util.Iterator EMPTY_MODIFIABLE_ITERATOR -> a
    com.google.common.collect.UnmodifiableIterator emptyIterator() -> a
    java.util.Iterator emptyModifiableIterator() -> a
    com.google.common.collect.UnmodifiableIterator unmodifiableIterator(java.util.Iterator) -> a
    int size(java.util.Iterator) -> a
    boolean removeAll(java.util.Iterator,java.util.Collection) -> a
    boolean elementsEqual(java.util.Iterator,java.util.Iterator) -> a
    boolean addAll(java.util.Collection,java.util.Iterator) -> a
    java.util.Iterator concat(java.util.Iterator,java.util.Iterator) -> a
    com.google.common.collect.UnmodifiableIterator filter(java.util.Iterator,com.google.common.base.Predicate) -> a
    java.util.Iterator transform(java.util.Iterator,com.google.common.base.Function) -> a
    java.lang.Object getNext(java.util.Iterator,java.lang.Object) -> a
    java.lang.Object pollNext(java.util.Iterator) -> a
    void clear(java.util.Iterator) -> a
    com.google.common.collect.UnmodifiableListIterator forArray(java.lang.Object[],int,int,int) -> a
    com.google.common.collect.UnmodifiableIterator singletonIterator(java.lang.Object) -> a
com.google.common.collect.Iterators$1 -> aI:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
com.google.common.collect.Iterators$11 -> aJ:
    java.lang.Object[] val$array -> a
    int val$offset -> a
    java.lang.Object get(int) -> a
com.google.common.collect.Iterators$12 -> aK:
    boolean done -> a
    java.lang.Object val$value -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.Iterators$2 -> aL:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.Iterators$3 -> aM:
    java.util.Iterator val$iterator -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.Iterators$5 -> aN:
    java.util.Iterator current -> a
    java.util.Iterator removeFrom -> b
    java.util.Iterator val$inputs -> c
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.Iterators$7 -> aO:
    java.util.Iterator val$unfiltered -> a
    com.google.common.base.Predicate val$predicate -> a
    java.lang.Object computeNext() -> a
com.google.common.collect.Iterators$8 -> aP:
    com.google.common.base.Function val$function -> a
    java.lang.Object transform(java.lang.Object) -> a
com.google.common.collect.ListMultimap -> aQ:
com.google.common.collect.Maps -> aR:
    java.util.Iterator keyIterator(java.util.Iterator) -> a
    java.util.Iterator valueIterator(java.util.Iterator) -> b
    int capacity(int) -> a
    java.util.Map$Entry immutableEntry(java.lang.Object,java.lang.Object) -> a
    java.lang.Object safeGet(java.util.Map,java.lang.Object) -> a
    boolean safeContainsKey(java.util.Map,java.lang.Object) -> a
    java.lang.Object safeRemove(java.util.Map,java.lang.Object) -> b
com.google.common.collect.Maps$EntryFunction -> aS:
    com.google.common.collect.Maps$EntryFunction KEY -> a
    com.google.common.collect.Maps$EntryFunction VALUE -> b
com.google.common.collect.Maps$EntryFunction$1 -> aT:
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Maps$EntryFunction$2 -> aU:
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Maps$EntrySet -> aV:
    java.util.Map map() -> a
    int size() -> size
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean isEmpty() -> isEmpty
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.Maps$ImprovedAbstractMap -> aW:
    java.util.Set entrySet -> a
    java.util.Set keySet -> b
    java.util.Collection values -> a
    java.util.Set createEntrySet() -> a
    java.util.Set entrySet() -> entrySet
    java.util.Set keySet() -> keySet
    java.util.Set createKeySet() -> b
    java.util.Collection values() -> values
com.google.common.collect.Maps$KeySet -> aX:
    java.util.Map map -> a
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
com.google.common.collect.Maps$Values -> aY:
    java.util.Map map -> a
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    void clear() -> clear
com.google.common.collect.Multimap -> aZ:
    int size() -> a
    boolean containsEntry(java.lang.Object,java.lang.Object) -> b
    boolean remove(java.lang.Object,java.lang.Object) -> c
    void clear() -> a
    java.util.Collection get(java.lang.Object) -> a
    java.util.Map asMap() -> a
com.google.common.collect.Multimaps$Entries -> ba:
    com.google.common.collect.Multimap multimap() -> a
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
com.google.common.collect.Multiset -> bb:
    java.util.Set elementSet() -> a
com.google.common.collect.NaturalOrdering -> bc:
    com.google.common.collect.NaturalOrdering INSTANCE -> a
    com.google.common.collect.Ordering reverse() -> a
    java.lang.String toString() -> toString
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.common.collect.ObjectArrays -> bd:
    java.lang.Object[] EMPTY_ARRAY -> a
    java.lang.Object[] newArray(java.lang.Object[],int) -> a
    java.lang.Object[] arraysCopyOf(java.lang.Object[],int) -> b
    java.lang.Object[] checkElementsNotNull(java.lang.Object[]) -> a
com.google.common.collect.Ordering -> be:
    com.google.common.collect.Ordering natural() -> b
    com.google.common.collect.Ordering from(java.util.Comparator) -> a
    com.google.common.collect.Ordering reverse() -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.common.collect.Range -> com.google.common.collect.Range:
    com.google.common.collect.Cut lowerBound -> a
    com.google.common.collect.Cut upperBound -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String toString(com.google.common.collect.Cut,com.google.common.collect.Cut) -> a
    int compareOrThrow(java.lang.Comparable,java.lang.Comparable) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.collect.Range$1 -> bf:
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Range$2 -> bg:
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Range$3 -> bh:
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.common.collect.RegularImmutableList -> bi:
    int offset -> a
    int size -> b
    java.lang.Object[] array -> a
    int size() -> size
    int copyIntoArray(java.lang.Object[],int) -> a
    java.lang.Object get(int) -> get
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    com.google.common.collect.ImmutableList subListUnchecked(int,int) -> b
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> a
    java.util.ListIterator listIterator(int) -> listIterator
com.google.common.collect.ReverseNaturalOrdering -> bj:
    com.google.common.collect.ReverseNaturalOrdering INSTANCE -> a
    com.google.common.collect.Ordering reverse() -> a
    java.lang.String toString() -> toString
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.common.collect.ReverseOrdering -> bk:
    com.google.common.collect.Ordering forwardOrder -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
    com.google.common.collect.Ordering reverse() -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.google.common.collect.SetMultimap -> bl:
com.google.common.collect.Sets$1 -> bm:
    java.util.Set val$set1 -> a
    java.util.Set val$set2minus1 -> b
    java.util.Set val$set2 -> c
    int size() -> size
    boolean isEmpty() -> isEmpty
    java.util.Iterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
com.google.common.collect.Sets$2 -> bn:
    java.util.Set val$set1 -> a
    com.google.common.base.Predicate val$inSet2 -> a
    java.util.Set val$set2 -> b
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
com.google.common.collect.Sets$3 -> bo:
    java.util.Set val$set1 -> a
    com.google.common.base.Predicate val$notInSet2 -> a
    java.util.Set val$set2 -> b
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
com.google.common.collect.Sets$ImprovedAbstractSet -> bp:
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.Sets$SetView -> bq:
com.google.common.collect.Sets$UnmodifiableNavigableSet -> br:
    java.util.NavigableSet delegate -> a
    com.google.common.collect.Sets$UnmodifiableNavigableSet descendingSet -> a
    java.util.SortedSet delegate() -> a
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.lang.Object pollFirst() -> pollFirst
    java.lang.Object pollLast() -> pollLast
    java.util.NavigableSet descendingSet() -> descendingSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.Set delegate() -> a
    java.util.Collection delegate() -> a
    java.lang.Object delegate() -> a
com.google.common.collect.SingletonImmutableList -> bs:
    java.lang.Object element -> a
    java.lang.Object get(int) -> get
    int indexOf(java.lang.Object) -> indexOf
    com.google.common.collect.UnmodifiableIterator iterator() -> a
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    int size() -> size
    com.google.common.collect.ImmutableList subList(int,int) -> a
    boolean contains(java.lang.Object) -> contains
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean isEmpty() -> isEmpty
    int copyIntoArray(java.lang.Object[],int) -> a
    java.util.List subList(int,int) -> subList
    java.util.Iterator iterator() -> iterator
com.google.common.collect.SortedIterable -> bt:
com.google.common.collect.TransformedIterator -> bu:
    java.util.Iterator backingIterator -> a
    java.lang.Object transform(java.lang.Object) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.TreeMultimap -> bv:
    java.util.Comparator keyComparator -> a
    java.util.Comparator valueComparator -> b
    com.google.common.collect.TreeMultimap create() -> a
    java.util.SortedSet createCollection() -> b
    java.util.Collection createCollection(java.lang.Object) -> b
    java.util.NavigableSet get(java.lang.Object) -> a
    java.util.Collection unmodifiableCollectionSubclass(java.util.Collection) -> a
    java.util.Collection wrapCollection(java.lang.Object,java.util.Collection) -> a
    java.util.SortedSet keySet() -> a
    java.util.SortedMap backingMap() -> b
    java.util.SortedMap asMap() -> a
    java.util.Collection values() -> b
    java.util.Map asMap() -> a
    java.util.SortedSet get(java.lang.Object) -> a
    java.util.Set get(java.lang.Object) -> a
    java.util.Set keySet() -> b
    java.util.Collection get(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    boolean put(java.lang.Object,java.lang.Object) -> a
    java.util.Set entries() -> d
    java.util.Set createCollection() -> c
    java.util.Map createAsMap() -> c
    java.util.Set createKeySet() -> a
    void clear() -> a
    int size() -> a
    java.util.Map backingMap() -> b
    java.util.Collection createCollection() -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean remove(java.lang.Object,java.lang.Object) -> c
    boolean containsEntry(java.lang.Object,java.lang.Object) -> b
    boolean containsValue(java.lang.Object) -> a
    boolean isEmpty() -> a
com.google.common.collect.UnmodifiableIterator -> bw:
    void remove() -> remove
com.google.common.collect.UnmodifiableListIterator -> bx:
    void add(java.lang.Object) -> add
    void set(java.lang.Object) -> set
com.google.common.math.BigIntegerMath -> by:
    java.math.BigInteger SQRT2_PRECOMPUTED_BITS -> a
    boolean isPowerOfTwo(java.math.BigInteger) -> a
    java.math.BigInteger sqrt(java.math.BigInteger,java.math.RoundingMode) -> a
    java.math.BigInteger sqrtFloor(java.math.BigInteger) -> a
    java.math.BigInteger sqrtApproxWithDoubles(java.math.BigInteger) -> b
    java.math.BigInteger factorial(int) -> a
    java.math.BigInteger listProduct(java.util.List,int,int) -> a
    java.math.BigInteger binomial(int,int) -> a
com.google.common.math.BigIntegerMath$1 -> bz:
    int[] $SwitchMap$java$math$RoundingMode -> a
com.google.common.math.DoubleMath -> bA:
    double roundIntermediate(double,java.math.RoundingMode) -> a
    int roundToInt(double,java.math.RoundingMode) -> a
    long roundToLong(double,java.math.RoundingMode) -> a
    java.math.BigInteger roundToBigInteger(double,java.math.RoundingMode) -> a
    boolean isMathematicalInteger(double) -> a
com.google.common.math.DoubleMath$1 -> bB:
    int[] $SwitchMap$java$math$RoundingMode -> a
com.google.common.math.DoubleUtils -> bC:
    long getSignificand(double) -> a
    boolean isFinite(double) -> a
    double bigToDouble(java.math.BigInteger) -> a
com.google.common.math.IntMath -> bD:
    int lessThanBranchFree(int,int) -> a
    int log2(int,java.math.RoundingMode) -> a
    int sqrt(int,java.math.RoundingMode) -> b
    int divide(int,int,java.math.RoundingMode) -> a
com.google.common.math.IntMath$1 -> bE:
    int[] $SwitchMap$java$math$RoundingMode -> a
com.google.common.math.LongMath -> bF:
    long[] factorials -> a
    int[] biggestBinomials -> a
    int[] biggestSimpleBinomials -> b
    int lessThanBranchFree(long,long) -> a
    int log2(long,java.math.RoundingMode) -> a
    long sqrt(long,java.math.RoundingMode) -> a
    long binomial(int,int) -> a
    long multiplyFraction(long,long,long) -> a
com.google.common.math.LongMath$1 -> bG:
    int[] $SwitchMap$java$math$RoundingMode -> a
edu.jas.arith.BigComplex -> bH:
    edu.jas.arith.BigRational re -> a
    edu.jas.arith.BigRational im -> b
    org.apache.log4j.Logger logger -> a
    edu.jas.arith.BigComplex ZERO -> a
    edu.jas.arith.BigComplex ONE -> b
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.arith.BigComplex) -> a
    int signum() -> signum
    edu.jas.arith.BigComplex norm() -> a
    edu.jas.arith.BigComplex multiply(edu.jas.arith.BigComplex) -> b
    edu.jas.arith.BigComplex inverse() -> b
    edu.jas.arith.BigComplex divide(edu.jas.arith.BigComplex) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.BigDecimal -> bI:
    java.math.BigDecimal val -> a
    java.math.MathContext DEFAULT_CONTEXT -> a
    java.math.MathContext context -> b
    edu.jas.arith.BigDecimal ZERO -> a
    edu.jas.arith.BigDecimal ONE -> b
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.arith.BigDecimal) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int signum() -> signum
    edu.jas.arith.BigDecimal divide(edu.jas.arith.BigDecimal) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.BigInteger -> bJ:
    java.math.BigInteger val -> a
    edu.jas.arith.BigInteger ZERO -> a
    edu.jas.arith.BigInteger ONE -> b
    boolean nonNegative -> a
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.arith.BigInteger valueOf(java.math.BigInteger) -> a
    edu.jas.arith.BigInteger fromInteger(long) -> a
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.arith.BigInteger) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.BigInteger abs() -> a
    edu.jas.arith.BigInteger negate() -> b
    int signum() -> signum
    edu.jas.arith.BigInteger subtract(edu.jas.arith.BigInteger) -> e
    edu.jas.arith.BigInteger divide(edu.jas.arith.BigInteger) -> a
    edu.jas.arith.BigInteger remainder(edu.jas.arith.BigInteger) -> b
    edu.jas.arith.BigInteger gcd(edu.jas.arith.BigInteger) -> c
    edu.jas.arith.BigInteger multiply(edu.jas.arith.BigInteger) -> d
    edu.jas.arith.BigRational getRational() -> a
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.BigIntegerIterator -> bK:
    java.math.BigInteger curr -> a
    boolean nonNegative -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.BigInteger next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.BigRational -> bL:
    java.math.BigInteger num -> a
    java.math.BigInteger den -> b
    edu.jas.arith.BigRational ZERO -> a
    edu.jas.arith.BigRational ONE -> b
    boolean nonNegative -> a
    boolean duplicates -> b
    boolean isFinite() -> a
    edu.jas.arith.BigRational getRational() -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.arith.BigRational valueOf(java.math.BigInteger) -> a
    edu.jas.arith.BigRational valueOf(long) -> a
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.BigRational RNRED(java.math.BigInteger,java.math.BigInteger) -> b
    edu.jas.arith.BigRational reduction(java.math.BigInteger,java.math.BigInteger) -> a
    int compareTo(edu.jas.arith.BigRational) -> a
    edu.jas.arith.BigRational subtract(edu.jas.arith.BigRational) -> a
    edu.jas.arith.BigRational inverse() -> b
    edu.jas.arith.BigRational negate() -> c
    edu.jas.arith.BigRational multiply(edu.jas.arith.BigRational) -> b
    edu.jas.arith.BigRational divide(edu.jas.arith.BigRational) -> c
    edu.jas.arith.BigRational random(int,java.util.Random) -> a
    int signum() -> signum
    edu.jas.arith.BigRational sum(edu.jas.arith.BigRational) -> d
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.BigRational$1 -> bM:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.arith.BigRationalIterator -> bN:
    edu.jas.arith.BigRational curr -> a
    edu.jas.arith.BigInteger den -> a
    edu.jas.arith.BigInteger num -> b
    java.util.Iterator denit -> a
    java.util.Iterator numit -> b
    java.util.List denlist -> a
    java.util.List numlist -> b
    java.util.Iterator denlistit -> c
    java.util.Iterator numlistit -> d
    boolean nonNegative -> a
    long level -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.BigRational next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.BigRationalUniqueIterator -> bO:
    java.util.Set unique -> a
    java.util.Iterator ratit -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.BigRational next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModInteger -> bP:
    edu.jas.arith.ModIntegerRing ring -> a
    java.math.BigInteger val -> a
    edu.jas.arith.BigInteger getSymmetricInteger() -> a
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.arith.ModInteger) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int signum() -> signum
    edu.jas.arith.ModInteger subtract(edu.jas.arith.ModInteger) -> a
    edu.jas.arith.ModInteger divide(edu.jas.arith.ModInteger) -> c
    edu.jas.arith.ModInteger inverse() -> a
    edu.jas.arith.ModInteger multiply(edu.jas.arith.ModInteger) -> b
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.arith.ModIntegerIterator -> bQ:
    java.math.BigInteger curr -> a
    edu.jas.arith.ModIntegerRing ring -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.ModInteger next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModIntegerRing -> bR:
    java.math.BigInteger modul -> a
    int isField -> a
    edu.jas.arith.BigInteger getIntegerModul() -> a
    edu.jas.arith.ModInteger getZERO() -> a
    edu.jas.arith.ModInteger getONE() -> b
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.arith.ModInteger fromInteger(java.math.BigInteger) -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.ModLong -> bS:
    edu.jas.arith.ModLongRing ring -> a
    long val -> a
    edu.jas.arith.BigInteger getSymmetricInteger() -> a
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.arith.ModLong) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int signum() -> signum
    edu.jas.arith.ModLong subtract(edu.jas.arith.ModLong) -> a
    edu.jas.arith.ModLong divide(edu.jas.arith.ModLong) -> c
    edu.jas.arith.ModLong inverse() -> a
    edu.jas.arith.ModLong multiply(edu.jas.arith.ModLong) -> b
    long gcd(long,long) -> a
    long[] hegcd(long,long) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.arith.ModLongIterator -> bT:
    long curr -> a
    edu.jas.arith.ModLongRing ring -> a
    boolean hasNext() -> hasNext
    edu.jas.arith.ModLong next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModLongRing -> bU:
    long modul -> a
    int isField -> a
    java.math.BigInteger MAX_LONG -> a
    edu.jas.arith.BigInteger getIntegerModul() -> a
    edu.jas.arith.ModLong getZERO() -> a
    edu.jas.arith.ModLong getONE() -> b
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.arith.ModLong fromInteger(long) -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.arith.Modular -> bV:
    edu.jas.arith.BigInteger getSymmetricInteger() -> a
edu.jas.arith.ModularNotInvertibleException -> bW:
    edu.jas.structure.GcdRingElem f -> a
    edu.jas.structure.GcdRingElem f1 -> b
    edu.jas.structure.GcdRingElem f2 -> c
    java.lang.String toString() -> toString
edu.jas.arith.ModularRingFactory -> bX:
    edu.jas.arith.BigInteger getIntegerModul() -> a
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
edu.jas.arith.PrimeList -> bY:
    java.util.List SMALL_LIST -> a
    java.util.List LOW_LIST -> b
    java.util.List MEDIUM_LIST -> c
    java.util.List LARGE_LIST -> d
    java.util.List MERSENNE_LIST -> e
    java.util.List val -> f
    java.math.BigInteger last -> a
    java.math.BigInteger getLongPrime(int,int) -> a
    java.math.BigInteger getMersennePrime(int) -> b
    java.lang.String toString() -> toString
    int size() -> a
    java.math.BigInteger get(int) -> a
    java.util.Iterator iterator() -> iterator
edu.jas.arith.PrimeList$1 -> bZ:
    int index -> a
    edu.jas.arith.PrimeList this$0 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.PrimeList$2 -> ca:
    int[] $SwitchMap$edu$jas$arith$PrimeList$Range -> a
edu.jas.arith.PrimeList$Range -> cb:
    int small$2289dd20 -> a
    int low$2289dd20 -> b
    int medium$2289dd20 -> c
    int large$2289dd20 -> d
    int mersenne$2289dd20 -> e
    int[] $VALUES$744f6e9b -> a
    int[] values$40345266() -> a
edu.jas.arith.Rational -> cc:
    edu.jas.arith.BigRational getRational() -> a
edu.jas.gb.AbstractPair -> cd:
    edu.jas.poly.ExpVector e -> a
    edu.jas.poly.GenPolynomial pi -> a
    edu.jas.poly.GenPolynomial pj -> b
    int i -> a
    int j -> b
    int s -> c
    void maxIndex(int) -> a
    java.lang.String toString() -> toString
edu.jas.gb.GroebnerBase -> ce:
    java.util.List GB(int,java.util.List) -> a
edu.jas.gb.GroebnerBaseAbstract -> cf:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.gb.Reduction red -> a
    edu.jas.gb.PairList strategy -> a
    java.lang.String toString() -> toString
    java.util.List normalizeZerosOnes(java.util.List) -> a
    int commonZeroTest(java.util.List) -> a
    java.util.List minimalGB(java.util.List) -> b
edu.jas.gb.GroebnerBaseSeq -> cg:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.util.List GB(int,java.util.List) -> a
edu.jas.gb.OrderedPairlist -> ch:
    java.util.List P -> a
    java.util.SortedMap pairlist -> a
    java.util.List red -> b
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.gb.Reduction reduction -> a
    boolean oneInGB -> a
    boolean useCriterion4 -> b
    int putCount -> a
    int remCount -> b
    int moduleVars -> c
    org.apache.log4j.Logger logger -> a
    edu.jas.gb.PairList create(int,edu.jas.poly.GenPolynomialRing) -> a
    java.lang.String toString() -> toString
    int put(edu.jas.poly.GenPolynomial) -> a
    int put(java.util.List) -> a
    edu.jas.gb.Pair removeNext() -> a
    boolean hasNext() -> a
    int putOne() -> a
    boolean criterion3(int,int,edu.jas.poly.ExpVector) -> a
edu.jas.gb.Pair -> ci:
    int n -> c
    boolean toZero -> a
    boolean useCriterion4 -> b
    boolean useCriterion3 -> c
    java.lang.String toString() -> toString
    void setZero() -> a
    boolean equals(java.lang.Object) -> equals
    int compareTo(edu.jas.gb.Pair) -> a
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
edu.jas.gb.PairList -> cj:
    edu.jas.gb.PairList create(int,edu.jas.poly.GenPolynomialRing) -> a
    int put(edu.jas.poly.GenPolynomial) -> a
    int put(java.util.List) -> a
    int putOne() -> a
    edu.jas.gb.Pair removeNext() -> a
    boolean hasNext() -> a
edu.jas.gb.Reduction -> ck:
    edu.jas.poly.GenPolynomial SPolynomial(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    boolean moduleCriterion(int,edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    boolean criterion4(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> a
    boolean isTopReducible(java.util.List,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> a
    java.util.List irreducibleSet(java.util.List) -> a
edu.jas.gb.ReductionAbstract -> cl:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial SPolynomial(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    boolean moduleCriterion(int,edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    boolean criterion4(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> a
    boolean isTopReducible(java.util.List,edu.jas.poly.GenPolynomial) -> a
    java.util.List irreducibleSet(java.util.List) -> a
edu.jas.gb.ReductionSeq -> cm:
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> a
edu.jas.gbufd.GroebnerBasePartial -> cn:
    org.apache.log4j.Logger logger -> a
    edu.jas.gb.GroebnerBaseAbstract bb -> a
    edu.jas.gb.GroebnerBaseAbstract rbb -> b
    java.util.List GB(int,java.util.List) -> a
    java.util.List partialPermutation(java.lang.String[],java.lang.String[]) -> a
    java.util.List getPermutation(java.lang.String[],java.lang.String[]) -> b
    int indexOf(java.lang.String,java.lang.String[]) -> a
    java.lang.String[] remainingVars(java.lang.String[],java.lang.String[]) -> a
    edu.jas.poly.OptimizedPolynomialList partialGB(java.util.List,java.lang.String[]) -> a
edu.jas.gbufd.GroebnerBasePseudoRecSeq -> co:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> a
    edu.jas.gbufd.PseudoReduction redRec -> a
    edu.jas.gbufd.PseudoReduction red -> b
    edu.jas.structure.AbelianGroupFactory cofac$5b76095 -> a
    edu.jas.structure.AbelianGroupFactory baseCofac$5b76095 -> b
    java.util.List GB(int,java.util.List) -> a
    java.util.List minimalGB(java.util.List) -> b
edu.jas.gbufd.PseudoReduction -> cp:
    edu.jas.poly.GenPolynomial normalformRecursive(java.util.List,edu.jas.poly.GenPolynomial) -> b
edu.jas.gbufd.PseudoReductionSeq -> cq:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial normalformRecursive(java.util.List,edu.jas.poly.GenPolynomial) -> b
edu.jas.kern.ComputerThreads -> cr:
    boolean NO_THREADS -> a
    int N_CPUS -> a
    java.util.concurrent.ExecutorService pool -> a
    java.util.concurrent.ExecutorService getPool() -> a
edu.jas.kern.PreemptStatus -> cs:
    boolean allowPreempt -> a
    boolean isAllowed() -> a
edu.jas.kern.PreemptingException -> ct:
edu.jas.kern.PrettyPrint -> cu:
    boolean toDo -> a
    boolean isTrue() -> a
edu.jas.kern.Scripting -> cv:
    int script$36effdbf -> a
    int getLang$69093ba2() -> a
edu.jas.kern.Scripting$Lang -> cw:
    int Python$36effdbf -> a
    int Ruby$36effdbf -> b
    int[] $VALUES$7450ff44 -> a
    int[] values$15230c85() -> a
edu.jas.kern.TimeStatus -> cx:
    boolean allowTime -> a
    long limitTime -> a
    long startTime -> b
    java.util.concurrent.Callable callBack -> a
    void checkTime(java.lang.String) -> a
edu.jas.poly.AlgToPoly -> cy:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.AlgebToCompl -> cz:
    edu.jas.poly.ComplexRing cfac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.AlgebraicNotInvertibleException -> cA:
    edu.jas.poly.GenPolynomial f -> a
    edu.jas.poly.GenPolynomial f1 -> b
    edu.jas.poly.GenPolynomial f2 -> c
    java.lang.String toString() -> toString
edu.jas.poly.AlgebraicNumber -> cB:
    edu.jas.poly.AlgebraicNumberRing ring -> a
    edu.jas.poly.GenPolynomial val -> a
    int isunit -> a
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.poly.AlgebraicNumber) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int signum() -> signum
    edu.jas.poly.AlgebraicNumber inverse() -> a
    edu.jas.poly.AlgebraicNumber multiply(edu.jas.poly.AlgebraicNumber) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.poly.AlgebraicNumberIterator -> cC:
    java.util.Iterator iter -> a
    java.util.List powers -> a
    edu.jas.poly.AlgebraicNumberRing aring -> a
    org.apache.log4j.Logger logger -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.AlgebraicNumberRing -> cD:
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.poly.GenPolynomial modul -> a
    int isField -> a
    edu.jas.poly.AlgebraicNumber getZERO() -> a
    edu.jas.poly.AlgebraicNumber getONE() -> b
    edu.jas.poly.AlgebraicNumber getGenerator() -> c
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    void setField(boolean) -> a
    int getField() -> a
    java.math.BigInteger characteristic() -> a
    edu.jas.poly.AlgebraicNumber fromInteger(long) -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    long totalExtensionDegree() -> a
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.AlgebraicNumberRing$1 -> cE:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.poly.AnyToComplex -> cF:
    edu.jas.poly.ComplexRing cfac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.CoeffToAlg -> cG:
    edu.jas.poly.AlgebraicNumberRing afac -> a
    edu.jas.poly.GenPolynomial zero -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.ComplToAlgeb -> cH:
    edu.jas.poly.AlgebraicNumberRing afac -> a
    edu.jas.poly.AlgebraicNumber I -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.Complex -> cI:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.ComplexRing ring -> a
    edu.jas.structure.RingElem re -> a
    edu.jas.structure.RingElem im -> b
    edu.jas.structure.RingElem getRe() -> a
    edu.jas.structure.RingElem getIm() -> b
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isIMAG() -> a
    boolean isUnit() -> d
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.poly.Complex) -> a
    int signum() -> signum
    edu.jas.poly.Complex sum(edu.jas.poly.Complex) -> a
    edu.jas.poly.Complex subtract(edu.jas.poly.Complex) -> b
    edu.jas.poly.Complex negate() -> b
    edu.jas.poly.Complex norm() -> a
    edu.jas.poly.Complex multiply(edu.jas.poly.Complex) -> c
    edu.jas.poly.Complex inverse() -> c
    edu.jas.poly.Complex divide(edu.jas.poly.Complex) -> d
    edu.jas.poly.Complex[] quotientRemainder(edu.jas.poly.Complex) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.poly.ComplexRing -> cJ:
    edu.jas.structure.AbelianGroupFactory ring$5b76095 -> a
    boolean isFinite() -> a
    edu.jas.poly.Complex getZERO() -> a
    edu.jas.poly.Complex getONE() -> b
    edu.jas.poly.Complex getIMAG() -> c
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.poly.Complex fromInteger(long) -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.DistToRec -> cK:
    edu.jas.poly.GenPolynomialRing fac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.EvalMain -> cL:
    edu.jas.structure.AbelianGroupFactory cfac$5b76095 -> a
    edu.jas.structure.RingElem a -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.EvalMainPol -> cM:
    edu.jas.poly.GenPolynomialRing cfac -> a
    edu.jas.structure.RingElem a -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.ExpVector -> cN:
    int hash -> a
    int storunit$4c0a7abc -> b
    edu.jas.poly.ExpVector create(int) -> a
    edu.jas.poly.ExpVector create(int,int,long) -> a
    edu.jas.poly.ExpVector create(long[]) -> a
    edu.jas.poly.ExpVector create(java.util.Collection) -> a
    edu.jas.poly.ExpVector copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> a
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> a
    java.lang.String varsToString(java.lang.String[]) -> b
    java.lang.String toScript() -> a
    java.lang.String toScript(java.lang.String[]) -> c
    java.lang.String toScriptFactory() -> b
    int indexVar(java.lang.String,java.lang.String[]) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isZERO() -> isZERO
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector EVRAND(int,long,float,java.util.Random) -> a
    int signum() -> signum
    long totalDeg() -> a
    long maxDeg() -> b
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int EVILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int EVILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int EVIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> b
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int EVIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> b
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int EVRILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> c
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int EVRILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> c
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int EVRIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> d
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int EVRIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> d
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int EVIWLC(long[][],edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVector$1 -> cO:
    int[] $SwitchMap$edu$jas$poly$ExpVector$StorUnit -> a
edu.jas.poly.ExpVector$StorUnit -> cP:
    int LONG$4c0a7abc -> a
    int INT$4c0a7abc -> b
    int SHORT$4c0a7abc -> c
    int BYTE$4c0a7abc -> d
    int[] $VALUES$6e403c49 -> a
    int[] values$10d7c10a() -> a
edu.jas.poly.ExpVectorByte -> cQ:
    byte[] val -> a
    edu.jas.poly.ExpVectorByte copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorByte abs() -> b
    edu.jas.poly.ExpVectorByte negate() -> c
    edu.jas.poly.ExpVectorByte sum(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVectorByte subtract(edu.jas.poly.ExpVector) -> b
    int signum() -> signum
    long totalDeg() -> a
    long maxDeg() -> b
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector copy() -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorInteger -> cR:
    int[] val -> a
    edu.jas.poly.ExpVectorInteger copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorInteger abs() -> b
    edu.jas.poly.ExpVectorInteger negate() -> c
    edu.jas.poly.ExpVectorInteger sum(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVectorInteger subtract(edu.jas.poly.ExpVector) -> b
    int signum() -> signum
    long totalDeg() -> a
    long maxDeg() -> b
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector copy() -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorLong -> cS:
    long[] val -> a
    edu.jas.poly.ExpVectorLong copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorLong abs() -> b
    edu.jas.poly.ExpVectorLong negate() -> c
    edu.jas.poly.ExpVectorLong sum(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVectorLong subtract(edu.jas.poly.ExpVector) -> b
    int signum() -> signum
    long totalDeg() -> a
    long maxDeg() -> b
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector copy() -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorPair -> cT:
    edu.jas.poly.ExpVector e1 -> a
    edu.jas.poly.ExpVector e2 -> b
    long totalDeg() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isMultiple(edu.jas.poly.ExpVectorPair) -> a
edu.jas.poly.ExpVectorShort -> cU:
    short[] val -> a
    edu.jas.poly.ExpVectorShort copy() -> a
    long[] getVal() -> a
    long getVal(int) -> a
    long setVal(int,long) -> a
    int length() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorShort abs() -> b
    edu.jas.poly.ExpVectorShort negate() -> c
    edu.jas.poly.ExpVectorShort sum(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVectorShort subtract(edu.jas.poly.ExpVector) -> b
    int signum() -> signum
    long totalDeg() -> a
    long maxDeg() -> b
    int[] dependencyOnVariables() -> a
    boolean multipleOf(edu.jas.poly.ExpVector) -> a
    int compareTo(edu.jas.poly.ExpVector) -> a
    int invLexCompareTo(edu.jas.poly.ExpVector) -> b
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> a
    int invGradCompareTo(edu.jas.poly.ExpVector) -> c
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> b
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> d
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> c
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> e
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> d
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> e
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> d
    edu.jas.poly.ExpVector subst(int,long) -> a
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> c
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> b
    edu.jas.poly.ExpVector negate() -> c
    edu.jas.poly.ExpVector abs() -> b
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.ExpVector contract(int,int) -> a
    edu.jas.poly.ExpVector extendLower(int,int,long) -> c
    edu.jas.poly.ExpVector extend(int,int,long) -> b
    edu.jas.poly.ExpVector copy() -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.FromInteger -> cV:
    edu.jas.structure.AbelianGroupFactory ring$5b76095 -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.FromIntegerPoly -> cW:
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.poly.FromInteger fi -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.GenPolynomial -> cX:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.SortedMap val -> a
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    edu.jas.poly.GenPolynomialRing factory() -> a
    edu.jas.poly.GenPolynomial copy() -> a
    int length() -> a
    java.util.SortedMap getMap() -> a
    void doPutToMap(edu.jas.poly.ExpVector,edu.jas.structure.RingElem) -> a
    void doRemoveFromMap(edu.jas.poly.ExpVector,edu.jas.structure.RingElem) -> b
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> a
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    boolean isConstant() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.poly.GenPolynomial) -> a
    int signum() -> signum
    java.util.Map$Entry leadingMonomial() -> a
    edu.jas.poly.ExpVector leadingExpVector() -> a
    edu.jas.poly.ExpVector trailingExpVector() -> b
    edu.jas.structure.RingElem leadingBaseCoefficient() -> a
    edu.jas.structure.RingElem trailingBaseCoefficient() -> b
    edu.jas.structure.RingElem coefficient(edu.jas.poly.ExpVector) -> a
    long degree(int) -> a
    long degree() -> a
    long totalDegree() -> b
    edu.jas.poly.ExpVector degreeVector() -> c
    edu.jas.structure.RingElem maxNorm() -> c
    edu.jas.structure.RingElem sumNorm() -> d
    edu.jas.poly.GenPolynomial sum(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial sum(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial sum(edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial subtract(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial subtract(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> b
    edu.jas.poly.GenPolynomial subtract(edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenPolynomial subtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial negate() -> b
    edu.jas.poly.GenPolynomial abs() -> c
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem) -> c
    edu.jas.poly.GenPolynomial monic() -> d
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> c
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial divide(edu.jas.structure.RingElem) -> d
    edu.jas.poly.GenPolynomial[] quotientRemainder(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial remainder(edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial[] egcd(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial[] hegcd(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial extend(edu.jas.poly.GenPolynomialRing,int,long) -> a
    edu.jas.poly.GenPolynomial extendLower(edu.jas.poly.GenPolynomialRing,int,long) -> b
    java.util.Map contract(edu.jas.poly.GenPolynomialRing) -> a
    java.util.Iterator coefficientIterator() -> a
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.poly.GenPolynomialIterator -> cY:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.Iterator eviter -> a
    java.util.List powers -> a
    java.util.List coeffiter -> b
    java.util.Iterator itercoeff -> b
    edu.jas.poly.GenPolynomial current -> a
    boolean hasNext() -> hasNext
    edu.jas.poly.GenPolynomial next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.GenPolynomialMonomialIterator -> cZ:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.Iterator iter -> a
    edu.jas.poly.GenPolynomial current -> a
    boolean hasNext() -> hasNext
    edu.jas.poly.GenPolynomial next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.GenPolynomialRing -> da:
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    int nvar -> a
    edu.jas.poly.TermOrder tord -> a
    java.lang.String[] vars -> a
    java.util.Set knownVars -> a
    edu.jas.poly.GenPolynomial ZERO -> a
    edu.jas.poly.GenPolynomial ONE -> b
    edu.jas.poly.ExpVector evzero -> a
    java.util.Random random -> a
    int isField -> b
    org.apache.log4j.Logger logger -> a
    boolean checkPreempt -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String[] getVars() -> a
    java.lang.String[] setVars(java.lang.String[]) -> a
    java.lang.String varsToString() -> b
    edu.jas.structure.RingElem getZEROCoefficient() -> a
    edu.jas.structure.RingElem getONECoefficient() -> b
    edu.jas.poly.GenPolynomial getZERO() -> a
    edu.jas.poly.GenPolynomial getONE() -> b
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.poly.GenPolynomial valueOf(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial fromInteger(long) -> a
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenPolynomial univariate(int) -> a
    edu.jas.poly.GenPolynomial univariate(int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> a
    boolean isFinite() -> a
    java.util.List univariateList() -> a
    java.util.List univariateList(int,long) -> a
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenPolynomialRing contract(int) -> a
    edu.jas.poly.GenPolynomialRing recursive(int) -> b
    edu.jas.poly.PolynomialComparator getComparator() -> a
    java.lang.String[] newVars(java.lang.String,int) -> a
    void addVars(java.lang.String[]) -> a
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.GenPolynomialRing$1 -> db:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.poly.GenPolynomialTokenizer -> dc:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.lang.String[] vars -> a
    int nvars -> a
    edu.jas.poly.TermOrder tord -> a
    java.io.StreamTokenizer tok -> a
    java.io.Reader reader -> a
    edu.jas.structure.AbelianGroupFactory fac$5b76095 -> a
    edu.jas.poly.GenPolynomialRing pfac -> a
    edu.jas.poly.GenSolvablePolynomialRing spfac -> a
    edu.jas.poly.GenPolynomial nextPolynomial() -> a
    long nextExponent() -> a
    edu.jas.poly.GenSolvablePolynomial nextSolvablePolynomial() -> a
    boolean digit(char) -> a
edu.jas.poly.GenSolvablePolynomial -> dd:
    edu.jas.poly.GenSolvablePolynomialRing ring -> a
    org.apache.log4j.Logger logger -> a
    boolean $assertionsDisabled -> a
    edu.jas.poly.GenSolvablePolynomialRing factory() -> a
    edu.jas.poly.GenSolvablePolynomial copy() -> a
    boolean equals(java.lang.Object) -> equals
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.GenSolvablePolynomial) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> b
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenSolvablePolynomial monic() -> b
    edu.jas.poly.GenSolvablePolynomial[] quotientRemainder(edu.jas.poly.GenSolvablePolynomial) -> a
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> c
    edu.jas.poly.GenPolynomial monic() -> d
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem) -> c
    edu.jas.poly.GenPolynomial copy() -> a
    edu.jas.poly.GenPolynomialRing factory() -> a
    edu.jas.structure.ElemFactory factory() -> a
edu.jas.poly.GenSolvablePolynomialRing -> de:
    edu.jas.poly.RelationTable table -> a
    edu.jas.poly.GenSolvablePolynomial ZERO -> a
    edu.jas.poly.GenSolvablePolynomial ONE -> b
    org.apache.log4j.Logger logger -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.GenSolvablePolynomial getZERO() -> a
    edu.jas.poly.GenSolvablePolynomial getONE() -> b
    boolean isCommutative() -> b
    edu.jas.poly.GenSolvablePolynomial fromInteger(long) -> a
    edu.jas.poly.GenSolvablePolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenSolvablePolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenSolvablePolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int,long) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int,int,long) -> a
    java.util.List univariateList() -> a
    java.util.List univariateList(int,long) -> a
    edu.jas.poly.GenSolvablePolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenSolvablePolynomialRing contract(int) -> a
    edu.jas.poly.GenPolynomialRing recursive(int) -> b
    edu.jas.poly.GenPolynomialRing contract(int) -> a
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int) -> a
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenPolynomial fromInteger(long) -> a
    edu.jas.poly.GenPolynomial getONE() -> b
    edu.jas.poly.GenPolynomial getZERO() -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.GenSolvablePolynomialRing$1 -> df:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.poly.ImagPartComplex -> dg:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.InvalidExpressionException -> dh:
edu.jas.poly.ModSymToInt -> di:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.Monomial -> dj:
    edu.jas.poly.ExpVector e -> a
    edu.jas.structure.RingElem c -> a
    java.lang.String toString() -> toString
edu.jas.poly.OptimizedPolynomialList -> dk:
    java.util.List perm -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
edu.jas.poly.OrderedPolynomialList -> dl:
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.List sort(edu.jas.poly.GenPolynomialRing,java.util.List) -> a
edu.jas.poly.OrderedPolynomialList$1 -> dm:
    java.util.Comparator val$evc -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.PolyIterator -> dn:
    java.util.Iterator ms -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.PolyUtil -> do:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    edu.jas.poly.GenPolynomial recursive(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial distribute(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> b
    java.util.List recursive(edu.jas.poly.GenPolynomialRing,java.util.List) -> a
    java.util.List distribute(edu.jas.poly.GenPolynomialRing,java.util.List) -> b
    edu.jas.poly.GenPolynomial integerFromModularCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> c
    java.util.List integerFromModularCoefficients(edu.jas.poly.GenPolynomialRing,java.util.List) -> c
    edu.jas.poly.GenPolynomial integerFromRationalCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> d
    java.lang.Object[] integerFromRationalCoefficientsFactor(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial fromIntegerCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> e
    java.util.List fromIntegerCoefficients(edu.jas.poly.GenPolynomialRing,java.util.List) -> d
    edu.jas.poly.GenPolynomial realPartFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial imaginaryPartFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> g
    edu.jas.poly.GenPolynomial complexFromAny(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> h
    edu.jas.poly.GenPolynomial fromAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> i
    edu.jas.poly.GenPolynomial convertToAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> j
    edu.jas.poly.GenPolynomial complexFromAlgebraic(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> k
    edu.jas.poly.GenPolynomial algebraicFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> l
    edu.jas.poly.GenPolynomial chineseRemainder(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial monic(edu.jas.poly.GenPolynomial) -> a
    java.util.List monic(java.util.List) -> a
    java.util.List leadingExpVector(java.util.List) -> b
    edu.jas.poly.GenPolynomial baseSparsePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial baseDensePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial basePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial[] basePseudoQuotientRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial baseRecursiveDivide(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial recursivePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial recursiveSparsePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial recursiveDensePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> g
    edu.jas.poly.GenPolynomial recursivePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> h
    edu.jas.poly.GenPolynomial coefficientPseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> i
    edu.jas.poly.GenPolynomial coefficientBasePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> c
    edu.jas.poly.GenPolynomial baseDeriviative(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveDeriviative(edu.jas.poly.GenPolynomial) -> c
    edu.jas.arith.BigInteger factorBound(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial evaluateMainRecursive(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenPolynomial evaluateMain(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    java.util.List evaluateMain(edu.jas.poly.GenPolynomialRing,java.util.List,edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem evaluateMain$eff16fa(edu.jas.structure.AbelianGroupFactory,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    java.util.List evaluateMain$444d866c(edu.jas.structure.AbelianGroupFactory,java.util.List,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial evaluateFirstRec(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial substituteMain(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> j
    edu.jas.poly.GenPolynomial substituteUnivariate(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> k
    edu.jas.poly.GenPolynomial seriesOfTaylor(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenPolynomial interpolate(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial interpolate(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial switchVariables(edu.jas.poly.GenPolynomial) -> d
    long coeffMaxDegree(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial map(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.UnaryFunctor) -> a
    edu.jas.poly.GenPolynomial removeUnusedUpperVariables(edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial removeUnusedLowerVariables(edu.jas.poly.GenPolynomial) -> f
edu.jas.poly.PolyUtil$1 -> dp:
    edu.jas.poly.GenPolynomialRing val$fac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolyUtil$2 -> dq:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolyUtil$5 -> dr:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolynomialComparator -> ds:
    edu.jas.poly.TermOrder tord -> a
    boolean reverse -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.PolynomialList -> dt:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.List list -> b
    boolean equals(java.lang.Object) -> equals
    int compareTo(edu.jas.poly.PolynomialList) -> a
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.RatToInt -> du:
    java.math.BigInteger lcm -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RatToIntFactor -> dv:
    java.math.BigInteger lcm -> a
    java.math.BigInteger gcd -> b
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RealPartComplex -> dw:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RecSolvablePolynomial -> dx:
    edu.jas.poly.RecSolvablePolynomialRing ring -> a
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    edu.jas.poly.RecSolvablePolynomial copy() -> a
    boolean equals(java.lang.Object) -> equals
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.RecSolvablePolynomial) -> a
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.RecSolvablePolynomial multiplyLeft(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.RecSolvablePolynomial shift(edu.jas.poly.RecSolvablePolynomial,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> b
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenSolvablePolynomial copy() -> a
    edu.jas.poly.GenSolvablePolynomialRing factory() -> a
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> c
    edu.jas.poly.GenPolynomial copy() -> a
    edu.jas.poly.GenPolynomialRing factory() -> a
    edu.jas.structure.ElemFactory factory() -> a
edu.jas.poly.RecSolvablePolynomialRing -> dy:
    edu.jas.poly.RelationTable coeffTable -> b
    edu.jas.poly.RecSolvablePolynomial ZERO -> a
    edu.jas.poly.RecSolvablePolynomial ONE -> b
    org.apache.log4j.Logger logger -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isCommutative() -> b
    edu.jas.poly.RecSolvablePolynomial fromInteger(long) -> a
    edu.jas.poly.RecSolvablePolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.RecSolvablePolynomial random(int,java.util.Random) -> a
    edu.jas.poly.RecSolvablePolynomial random(int,int,int,float) -> a
    edu.jas.poly.RecSolvablePolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.RecSolvablePolynomial parse(java.lang.String) -> a
    edu.jas.poly.RecSolvablePolynomial parse(java.io.Reader) -> a
    edu.jas.poly.RecSolvablePolynomial univariate(int) -> a
    edu.jas.poly.RecSolvablePolynomial univariate(int,long) -> a
    edu.jas.poly.RecSolvablePolynomial univariate(int,int,long) -> a
    edu.jas.poly.RecSolvablePolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.RecSolvablePolynomialRing contract(int) -> a
    edu.jas.poly.GenSolvablePolynomialRing contract(int) -> a
    edu.jas.poly.GenSolvablePolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int,int,long) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int,long) -> a
    edu.jas.poly.GenSolvablePolynomial univariate(int) -> a
    edu.jas.poly.GenSolvablePolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenSolvablePolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenSolvablePolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenSolvablePolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenSolvablePolynomial fromInteger(long) -> a
    edu.jas.poly.GenSolvablePolynomial getONE() -> b
    edu.jas.poly.GenSolvablePolynomial getZERO() -> a
    edu.jas.poly.GenPolynomialRing contract(int) -> a
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> a
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int,long) -> a
    edu.jas.poly.GenPolynomial univariate(int) -> a
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> a
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> a
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> a
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> a
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> a
    edu.jas.poly.GenPolynomial fromInteger(long) -> a
    edu.jas.poly.GenPolynomial getONE() -> b
    edu.jas.poly.GenPolynomial getZERO() -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.poly.RecSolvablePolynomialRing$1 -> dz:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
edu.jas.poly.RecToDist -> dA:
    edu.jas.poly.GenPolynomialRing fac -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RelationTable -> dB:
    java.util.Map table -> a
    edu.jas.poly.GenSolvablePolynomialRing ring -> a
    boolean coeffTable -> a
    org.apache.log4j.Logger logger -> a
    boolean debug -> b
    boolean equals(java.lang.Object) -> equals
    java.util.Map fromListDeg2(java.util.List) -> a
    boolean equalMaps(java.util.Map,java.util.Map) -> a
    int hashCode() -> hashCode
    boolean isEmpty() -> a
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> a
    java.lang.String toScript() -> a
    void update(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,edu.jas.poly.GenSolvablePolynomial) -> a
    edu.jas.poly.TableRelation lookup(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    java.util.List makeKey(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int size() -> a
    void extend(edu.jas.poly.RelationTable) -> a
    void contract(edu.jas.poly.RelationTable) -> b
    void recursive(edu.jas.poly.RelationTable) -> c
edu.jas.poly.TableRelation -> dC:
    edu.jas.poly.ExpVector e -> a
    edu.jas.poly.ExpVector f -> b
    edu.jas.poly.GenSolvablePolynomial p -> a
    java.lang.String toString() -> toString
edu.jas.poly.TermOrder -> dD:
    int evord -> a
    int evord2 -> b
    int evbeg1 -> c
    int evend1 -> d
    int evbeg2 -> e
    int evend2 -> f
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    long[][] weight -> a
    edu.jas.poly.TermOrder$EVComparator horder -> a
    edu.jas.poly.TermOrder$EVComparator lorder -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    edu.jas.poly.TermOrder extend(int,int) -> a
    edu.jas.poly.TermOrder contract(int,int) -> b
    edu.jas.poly.TermOrder$EVComparator access$000(edu.jas.poly.TermOrder) -> a
    long[][] access$100(edu.jas.poly.TermOrder) -> a
    int access$200(edu.jas.poly.TermOrder) -> a
    int access$300(edu.jas.poly.TermOrder) -> b
    int access$400(edu.jas.poly.TermOrder) -> c
    int access$500(edu.jas.poly.TermOrder) -> d
edu.jas.poly.TermOrder$1 -> dE:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$10 -> dF:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$11 -> dG:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$12 -> dH:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$13 -> dI:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$14 -> dJ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$15 -> dK:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$16 -> dL:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$17 -> dM:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$18 -> dN:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$19 -> dO:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$2 -> dP:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$20 -> dQ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$21 -> dR:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$22 -> dS:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$23 -> dT:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$24 -> dU:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$25 -> dV:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$26 -> dW:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$27 -> dX:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$28 -> dY:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$29 -> dZ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$3 -> ea:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$30 -> eb:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$31 -> ec:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$32 -> ed:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$33 -> ee:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$34 -> ef:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$35 -> eg:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$36 -> eh:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$37 -> ei:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$38 -> ej:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$39 -> ek:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$4 -> el:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$40 -> em:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$41 -> en:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$42 -> eo:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$43 -> ep:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$44 -> eq:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$45 -> er:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$46 -> es:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$47 -> et:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$48 -> eu:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$49 -> ev:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$5 -> ew:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$50 -> ex:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$51 -> ey:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$52 -> ez:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$53 -> eA:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$54 -> eB:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$55 -> eC:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$56 -> eD:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$57 -> eE:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$58 -> eF:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$59 -> eG:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$6 -> eH:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$60 -> eI:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$61 -> eJ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$62 -> eK:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$63 -> eL:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$64 -> eM:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$65 -> eN:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$66 -> eO:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$67 -> eP:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$68 -> eQ:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$69 -> eR:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$7 -> eS:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$70 -> eT:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$8 -> eU:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$9 -> eV:
    edu.jas.poly.TermOrder this$0 -> a
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$EVComparator -> eW:
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrderOptimization -> eX:
    org.apache.log4j.Logger logger -> a
    java.util.List degreeMatrix(edu.jas.poly.GenPolynomial) -> a
    java.util.List expVectorAdd(java.util.List,edu.jas.poly.ExpVector) -> a
    java.util.List optimalPermutation(java.util.List) -> b
    java.util.List inversePermutation(java.util.List) -> a
    java.lang.String[] stringArrayPermutation(java.util.List,java.lang.String[]) -> a
    long[] longArrayPermutation(java.util.List,long[]) -> a
    edu.jas.poly.GenPolynomial permutation(java.util.List,edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    java.util.List permutation(java.util.List,edu.jas.poly.GenPolynomialRing,java.util.List) -> a
    edu.jas.poly.GenPolynomialRing permutation(java.util.List,edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.poly.OptimizedPolynomialList optimizeTermOrder(edu.jas.poly.GenPolynomialRing,java.util.List) -> a
edu.jas.ps.Coefficients -> eY:
    java.util.HashMap coeffCache -> a
    edu.jas.structure.RingElem get(int) -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.Multiply -> eZ:
    edu.jas.structure.RingElem x -> a
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ps.Negate -> fa:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ps.PolynomialTaylorFunction -> fb:
    edu.jas.poly.GenPolynomial pol -> a
    java.lang.String toString() -> toString
    edu.jas.ps.TaylorFunction deriviative() -> a
    edu.jas.structure.RingElem evaluate(edu.jas.structure.RingElem) -> a
edu.jas.ps.Subtract -> fc:
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.ps.Sum -> fd:
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.ps.TaylorFunction -> fe:
    edu.jas.ps.TaylorFunction deriviative() -> a
    edu.jas.structure.RingElem evaluate(edu.jas.structure.RingElem) -> a
edu.jas.ps.UnivPowerSeries -> ff:
    edu.jas.ps.UnivPowerSeriesRing ring -> a
    edu.jas.ps.Coefficients lazyCoeffs -> a
    int truncate -> a
    int order -> b
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    edu.jas.structure.RingElem coefficient(int) -> a
    edu.jas.ps.UnivPowerSeries shift(int) -> a
    edu.jas.ps.UnivPowerSeries map(edu.jas.structure.UnaryFunctor) -> a
    edu.jas.ps.UnivPowerSeries zip(edu.jas.structure.BinaryFunctor,edu.jas.ps.UnivPowerSeries) -> a
    edu.jas.ps.UnivPowerSeries multiply(edu.jas.structure.RingElem) -> a
    edu.jas.ps.UnivPowerSeries negate() -> a
    int order() -> a
    int signum() -> signum
    int compareTo(edu.jas.ps.UnivPowerSeries) -> a
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isUnit() -> d
    edu.jas.ps.UnivPowerSeries multiply(edu.jas.ps.UnivPowerSeries) -> a
    edu.jas.ps.UnivPowerSeries inverse() -> b
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.ps.UnivPowerSeries$10 -> fg:
    edu.jas.ps.UnivPowerSeries this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeries$3 -> fh:
    int val$k -> a
    edu.jas.ps.UnivPowerSeries this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeries$6 -> fi:
    edu.jas.structure.UnaryFunctor val$f -> a
    edu.jas.ps.UnivPowerSeries this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeries$7 -> fj:
    edu.jas.structure.BinaryFunctor val$f -> a
    edu.jas.ps.UnivPowerSeries val$ps -> a
    edu.jas.ps.UnivPowerSeries this$0 -> b
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeries$9 -> fk:
    edu.jas.ps.UnivPowerSeries val$ps -> a
    edu.jas.ps.UnivPowerSeries this$0 -> b
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeriesRing -> fl:
    int truncate -> a
    java.lang.String var -> a
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    edu.jas.ps.UnivPowerSeries ONE -> a
    edu.jas.ps.UnivPowerSeries ZERO -> b
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isFinite() -> a
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    edu.jas.ps.UnivPowerSeries seriesOfTaylor(edu.jas.ps.TaylorFunction,edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.ps.UnivPowerSeriesRing$1 -> fm:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeriesRing$10 -> fn:
    edu.jas.ps.TaylorFunction der -> a
    long k -> a
    long n -> b
    edu.jas.ps.TaylorFunction val$f -> b
    edu.jas.structure.RingElem val$a -> a
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeriesRing$2 -> fo:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.ps.UnivPowerSeriesRing$9 -> fp:
    java.util.Random val$rnd -> a
    float val$d -> a
    int val$k -> a
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    edu.jas.structure.RingElem generate(int) -> b
edu.jas.root.Boundary -> fq:
    edu.jas.root.Rectangle rect -> a
    edu.jas.poly.GenPolynomial A -> a
    edu.jas.poly.GenPolynomial[] polys -> a
    edu.jas.poly.GenPolynomialRing rfac -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
edu.jas.root.ComplexRoots -> fr:
edu.jas.root.ComplexRootsAbstract -> fs:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.Squarefree engine -> a
    edu.jas.poly.Complex rootBound(edu.jas.poly.GenPolynomial) -> a
    long complexRootCount(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> a
    java.util.List complexRoots(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> a
    java.util.List complexRoots(edu.jas.poly.GenPolynomial) -> a
    edu.jas.root.Rectangle complexRootRefinement(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.arith.BigRational) -> a
    edu.jas.poly.Complex[] copyOfComplex(edu.jas.poly.Complex[],int) -> a
edu.jas.root.ComplexRootsSturm -> ft:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    long complexRootCount(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> a
    long windingNumber(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> b
    java.util.List complexRoots(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> a
edu.jas.root.InvalidBoundaryException -> fu:
edu.jas.root.Rectangle -> fv:
    edu.jas.poly.Complex[] corners -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    edu.jas.root.Rectangle exchangeSW(edu.jas.poly.Complex) -> a
    edu.jas.root.Rectangle exchangeNE(edu.jas.poly.Complex) -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
edu.jas.root.RootUtil -> fw:
    org.apache.log4j.Logger logger -> a
    long signVar(java.util.List) -> a
edu.jas.structure.AbelianGroupElem -> fx:
    boolean isZERO() -> isZERO
    int signum() -> signum
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem abs() -> a
edu.jas.structure.AbelianGroupFactory -> fy:
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
edu.jas.structure.BinaryFunctor -> fz:
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.structure.ElemFactory -> fA:
    boolean isFinite() -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element parse(java.lang.String) -> a
    java.lang.String toScript() -> a
edu.jas.structure.Element -> fB:
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.ElemFactory factory() -> a
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
edu.jas.structure.GcdRingElem -> fC:
edu.jas.structure.MonoidElem -> fD:
    boolean isONE() -> isONE
    boolean isUnit() -> d
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem inverse() -> a
edu.jas.structure.MonoidFactory -> fE:
    edu.jas.structure.MonoidElem getONE() -> b
    boolean isCommutative() -> b
edu.jas.structure.NotInvertibleException -> fF:
edu.jas.structure.Power -> fG:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.structure.AbelianGroupFactory fac$5b76095 -> a
    edu.jas.structure.RingElem positivePower(edu.jas.structure.RingElem,long) -> a
    edu.jas.structure.RingElem positivePower(edu.jas.structure.RingElem,java.math.BigInteger) -> a
    edu.jas.structure.RingElem power$51197664(edu.jas.structure.AbelianGroupFactory,edu.jas.structure.RingElem,long) -> a
    edu.jas.structure.RingElem modPower(edu.jas.structure.RingElem,java.math.BigInteger,edu.jas.structure.RingElem) -> a
    long logarithm(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem multiply$1095d1b3(edu.jas.structure.AbelianGroupFactory,java.util.List) -> a
edu.jas.structure.RingElem -> fH:
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
edu.jas.structure.StarRingElem -> fI:
edu.jas.structure.UnaryFunctor -> fJ:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ufd.FactorAbsolute -> fK:
    org.apache.log4j.Logger logger -> b
    java.lang.String toString() -> toString
edu.jas.ufd.FactorAbstract -> fL:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> a
    edu.jas.ufd.SquarefreeAbstract sengine -> a
    java.lang.String toString() -> toString
    boolean isIrreducible(edu.jas.poly.GenPolynomial) -> a
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.List removeOnce(java.util.List,java.util.List) -> a
    java.util.SortedMap baseFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap factors(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> c
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.List) -> a
    java.util.List normalizeFactorization(java.util.List) -> a
edu.jas.ufd.FactorAlgebraic -> fM:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    edu.jas.ufd.FactorAbstract factorCoeff -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
edu.jas.ufd.FactorComplex -> fN:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    edu.jas.ufd.FactorAbstract factorAlgeb -> a
    edu.jas.poly.AlgebraicNumberRing afac -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
edu.jas.ufd.FactorFactory -> fO:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.arith.ModIntegerRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.arith.ModLongRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation$146bcd55() -> a
    edu.jas.ufd.FactorAbstract getImplementation$17dd3501() -> b
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.poly.AlgebraicNumberRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation$7fca19ae(edu.jas.structure.AbelianGroupFactory) -> a
edu.jas.ufd.FactorInteger -> fP:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    edu.jas.ufd.FactorAbstract mfactor -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract mengine -> b
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.BitSet factorDegrees(java.util.List,int) -> a
    long degreeSum(java.util.List) -> a
    java.util.List searchFactorsMonic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,java.util.List,java.util.BitSet) -> a
    java.util.List searchFactorsNonMonic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,java.util.List,java.util.BitSet) -> b
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.List factorsSquarefreeHensel(edu.jas.poly.GenPolynomial) -> c
    boolean testSeparate(java.util.List,edu.jas.arith.BigInteger) -> a
edu.jas.ufd.FactorModular -> fQ:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    java.util.SortedMap baseDistinctDegreeFactors(edu.jas.poly.GenPolynomial) -> d
    java.util.List baseEqualDegreeFactors(edu.jas.poly.GenPolynomial,long) -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
edu.jas.ufd.FactorQuotient -> fR:
    org.apache.log4j.Logger logger -> b
    edu.jas.ufd.FactorAbstract nengine -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> a
edu.jas.ufd.FactorRational -> fS:
    org.apache.log4j.Logger logger -> b
    boolean debug -> a
    edu.jas.ufd.FactorAbstract iengine -> a
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> b
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> a
edu.jas.ufd.Factorization -> fT:
    boolean isIrreducible(edu.jas.poly.GenPolynomial) -> a
edu.jas.ufd.GCDFactory -> fU:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getImplementation(edu.jas.arith.ModLongRing) -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getImplementation$7645a7b4() -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getImplementation$5730d517(edu.jas.structure.AbelianGroupFactory) -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getProxy$5730d517(edu.jas.structure.AbelianGroupFactory) -> b
edu.jas.ufd.GCDProxy -> fV:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract e1 -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract e2 -> b
    java.util.concurrent.ExecutorService pool -> a
    java.lang.String toString() -> toString
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
    boolean access$000(edu.jas.ufd.GCDProxy) -> a
    org.apache.log4j.Logger access$100() -> a
edu.jas.ufd.GCDProxy$1 -> fW:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$10 -> fX:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$11 -> fY:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$12 -> fZ:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$2 -> ga:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$3 -> gb:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$4 -> gc:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$5 -> gd:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$6 -> ge:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$7 -> gf:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$8 -> gg:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$9 -> gh:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GreatestCommonDivisor -> gi:
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
edu.jas.ufd.GreatestCommonDivisorAbstract -> gj:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.lang.String toString() -> toString
    edu.jas.structure.GcdRingElem baseContent(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial basePrimitivePart(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveContent(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursivePrimitivePart(edu.jas.poly.GenPolynomial) -> c
    edu.jas.structure.GcdRingElem baseRecursiveContent(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial baseRecursivePrimitivePart(edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial,edu.jas.structure.GcdRingElem) -> a
    edu.jas.structure.GcdRingElem gcd(edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem) -> a
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial lcm(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> g
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial recursiveResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> h
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial[] baseGcdDiophant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> a
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,java.util.List) -> a
edu.jas.ufd.GreatestCommonDivisorModEval -> gk:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract mufd -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
edu.jas.ufd.GreatestCommonDivisorModular -> gl:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract mufd -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract iufd -> b
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
edu.jas.ufd.GreatestCommonDivisorPrimitive -> gm:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
edu.jas.ufd.GreatestCommonDivisorSimple -> gn:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
edu.jas.ufd.GreatestCommonDivisorSubres -> go:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.structure.GcdRingElem power$24a636e(edu.jas.structure.AbelianGroupFactory,edu.jas.structure.GcdRingElem,long) -> a
    edu.jas.poly.GenPolynomial power$4f9faa70(edu.jas.structure.AbelianGroupFactory,edu.jas.poly.GenPolynomial,long) -> a
edu.jas.ufd.HenselApprox -> gp:
    edu.jas.poly.GenPolynomial A -> a
    edu.jas.poly.GenPolynomial B -> b
    edu.jas.poly.GenPolynomial Am -> c
    edu.jas.poly.GenPolynomial Bm -> d
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
edu.jas.ufd.HenselMultUtil -> gq:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.util.List liftDiophant(java.util.List,edu.jas.poly.GenPolynomial,java.util.List,long,long) -> a
    java.util.List liftHensel(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,java.util.List,java.util.List,long,java.util.List) -> a
edu.jas.ufd.HenselUtil -> gr:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    edu.jas.ufd.HenselApprox liftHenselQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.ufd.HenselApprox liftHenselQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial[] liftExtendedEuclidean(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftExtendedEuclidean(java.util.List,long) -> a
    java.util.List liftDiophant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftDiophant(java.util.List,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftDiophant(java.util.List,long,long) -> a
    boolean isExtendedEuclideanLift(java.util.List,java.util.List) -> a
    boolean isDiophantLift(java.util.List,java.util.List,edu.jas.poly.GenPolynomial) -> a
    java.util.List liftHenselMonic(edu.jas.poly.GenPolynomial,java.util.List,long) -> a
edu.jas.ufd.NoLiftingException -> gs:
edu.jas.ufd.PolyUfdUtil -> gt:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.GenPolynomial integralFromQuotientCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial quotientFromIntegralCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> b
    java.util.List quotientFromIntegralCoefficients(edu.jas.poly.GenPolynomialRing,java.util.Collection) -> a
    edu.jas.poly.GenPolynomial substituteConvertToAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,long) -> a
    edu.jas.poly.GenPolynomial norm(edu.jas.poly.GenPolynomial,long) -> a
    void ensureFieldProperty(edu.jas.poly.AlgebraicNumberRing) -> a
    edu.jas.poly.GenPolynomial substituteKronecker(edu.jas.poly.GenPolynomial,long) -> b
    edu.jas.poly.GenPolynomial backSubstituteKronecker(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,long) -> b
edu.jas.ufd.Quotient -> gu:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.ufd.QuotientRing ring -> a
    edu.jas.poly.GenPolynomial num -> a
    edu.jas.poly.GenPolynomial den -> b
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> d
    boolean isConstant() -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    int compareTo(edu.jas.ufd.Quotient) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.ufd.Quotient sum(edu.jas.ufd.Quotient) -> c
    edu.jas.ufd.Quotient negate() -> a
    int signum() -> signum
    edu.jas.ufd.Quotient divide(edu.jas.ufd.Quotient) -> a
    edu.jas.ufd.Quotient inverse() -> b
    edu.jas.ufd.Quotient multiply(edu.jas.ufd.Quotient) -> b
    edu.jas.ufd.Quotient multiply(edu.jas.poly.GenPolynomial) -> a
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    edu.jas.structure.ElemFactory factory() -> a
    int compareTo(edu.jas.structure.Element) -> a
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
edu.jas.ufd.QuotientRing -> gv:
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.ufd.GreatestCommonDivisor engine -> a
    boolean ufdGCD -> a
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    boolean isFinite() -> a
    edu.jas.ufd.Quotient getZERO() -> a
    edu.jas.ufd.Quotient getONE() -> b
    boolean isCommutative() -> b
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    java.lang.String toString() -> toString
    java.lang.String toScript() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
edu.jas.ufd.Squarefree -> gw:
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
edu.jas.ufd.SquarefreeAbstract -> gx:
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> a
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap normalizeFactorization(java.util.SortedMap) -> a
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> a
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.SquarefreeFactory -> gy:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.SquarefreeAbstract getImplementation(edu.jas.arith.BigRational) -> a
    edu.jas.ufd.SquarefreeAbstract getImplementation(edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.ufd.SquarefreeAbstract getImplementationPoly(edu.jas.poly.GenPolynomialRing) -> b
    edu.jas.ufd.SquarefreeAbstract getImplementation$2123d3d8(edu.jas.structure.AbelianGroupFactory) -> a
edu.jas.ufd.SquarefreeFieldChar0 -> gz:
    org.apache.log4j.Logger logger -> a
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    java.lang.String toString() -> toString
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.SquarefreeFieldCharP -> gA:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    edu.jas.poly.AlgebraicNumberRing aCoFac -> a
    edu.jas.ufd.QuotientRing qCoFac -> a
    java.lang.String toString() -> toString
    edu.jas.poly.GenPolynomial baseSquarefreePart(edu.jas.poly.GenPolynomial) -> d
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> c
edu.jas.ufd.SquarefreeFiniteFieldCharP -> gB:
    org.apache.log4j.Logger logger -> a
    java.util.SortedMap rootCharacteristic(edu.jas.structure.GcdRingElem) -> b
    edu.jas.structure.GcdRingElem coeffRootCharacteristic(edu.jas.structure.GcdRingElem) -> a
    java.util.SortedMap rootCharacteristic(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> c
edu.jas.ufd.SquarefreeInfiniteAlgebraicFieldCharP -> gC:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.SquarefreeAbstract aengine -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.AlgebraicNumber) -> a
    java.util.SortedMap rootCharacteristic(edu.jas.poly.AlgebraicNumber) -> b
    edu.jas.poly.GenPolynomial rootCharacteristic(edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> c
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.SquarefreeInfiniteFieldCharP -> gD:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.SquarefreeAbstract qengine -> a
    java.util.SortedMap squarefreeFactors(edu.jas.ufd.Quotient) -> a
    java.util.SortedMap rootCharacteristic(edu.jas.ufd.Quotient) -> b
    edu.jas.poly.GenPolynomial rootCharacteristic(edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> c
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.SquarefreeRingChar0 -> gE:
    org.apache.log4j.Logger logger -> a
    edu.jas.structure.AbelianGroupFactory coFac$5b76095 -> a
    java.lang.String toString() -> toString
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> b
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> a
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> a
edu.jas.ufd.TrialParts -> gF:
    java.util.List evalPoints -> a
    edu.jas.poly.GenPolynomial univPoly -> a
    java.util.List univFactors -> b
    java.util.List ldcfFactors -> c
    java.util.List ldcfEval -> d
    java.lang.String toString() -> toString
edu.jas.util.CartesianOneProductInfiniteIterator -> gG:
    java.util.Iterator compit -> a
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.CartesianProduct -> gH:
    java.util.List comps -> a
    java.util.Iterator iterator() -> iterator
edu.jas.util.CartesianProductInfinite -> gI:
    java.util.List comps -> a
    java.util.Iterator iterator() -> iterator
edu.jas.util.CartesianProductIterator -> gJ:
    java.util.List comps -> a
    java.util.List compit -> b
    java.util.List current -> c
    boolean empty -> a
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.CartesianTwoProductInfiniteIteratorList -> gK:
    java.util.Iterator compit0 -> a
    java.util.Iterator compit1 -> b
    java.util.List fincomps0 -> a
    java.util.List fincomps1 -> b
    java.util.Iterator fincompit0 -> c
    java.util.Iterator fincompit1 -> d
    java.util.List current -> c
    boolean empty -> a
    long level -> a
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.KsubSet -> gL:
    java.util.List set -> a
    int k -> a
    java.util.Iterator iterator() -> iterator
edu.jas.util.KsubSetIterator -> gM:
    java.util.List set -> a
    int k -> a
    java.util.List rest -> b
    java.lang.Object current -> a
    java.util.Iterator recIter -> a
    java.util.Iterator iter -> b
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.LongIterable -> gN:
    boolean nonNegative -> a
    long upperBound -> a
    java.util.Iterator iterator() -> iterator
edu.jas.util.LongIterator -> gO:
    long current -> a
    boolean empty -> a
    boolean nonNegative -> b
    long upperBound -> b
    boolean hasNext() -> hasNext
    java.lang.Long next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.OneSubSetIterator -> gP:
    java.util.List set -> a
    java.util.Iterator iter -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.ZeroSubSetIterator -> gQ:
    boolean hasNext -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.vector.BasicLinAlg -> gR:
    org.apache.log4j.Logger logger -> a
    java.util.List vectorAdd(java.util.List,java.util.List) -> a
org.apache.commons.math3.Field -> gS:
    java.lang.Object getZero() -> a
    java.lang.Object getOne() -> b
    java.lang.Class getRuntimeClass() -> a
org.apache.commons.math3.FieldElement -> gT:
    java.lang.Object add(java.lang.Object) -> add
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object negate() -> negate
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object reciprocal() -> reciprocal
    org.apache.commons.math3.Field getField() -> getField
org.apache.commons.math3.analysis.BivariateFunction -> gU:
    double value(double,double) -> a
org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction -> gV:
    org.apache.commons.math3.analysis.MultivariateMatrixFunction jacobian() -> a
org.apache.commons.math3.analysis.DifferentiableUnivariateFunction -> gW:
org.apache.commons.math3.analysis.FunctionUtils$13 -> gX:
    org.apache.commons.math3.analysis.BivariateFunction val$f -> a
    double val$fixed -> a
    double value(double) -> a
org.apache.commons.math3.analysis.FunctionUtils$18 -> gY:
    org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction val$f -> a
    double[] value(double[]) -> a
    org.apache.commons.math3.analysis.MultivariateMatrixFunction jacobian() -> a
org.apache.commons.math3.analysis.FunctionUtils$18$1 -> gZ:
    org.apache.commons.math3.analysis.FunctionUtils$18 this$0 -> a
    double[][] value(double[]) -> a
org.apache.commons.math3.analysis.FunctionUtils$19 -> ha:
    org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction val$f -> a
    double[] value(double[]) -> a
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure[] value(org.apache.commons.math3.analysis.differentiation.DerivativeStructure[]) -> a
org.apache.commons.math3.analysis.MultivariateMatrixFunction -> hb:
    double[][] value(double[]) -> a
org.apache.commons.math3.analysis.MultivariateVectorFunction -> hc:
    double[] value(double[]) -> a
org.apache.commons.math3.analysis.ParametricUnivariateFunction -> hd:
    double value(double,double[]) -> a
    double[] gradient(double,double[]) -> a
org.apache.commons.math3.analysis.UnivariateFunction -> he:
    double value(double) -> a
org.apache.commons.math3.analysis.differentiation.DSCompiler -> hf:
    java.util.concurrent.atomic.AtomicReference compilers -> a
    int parameters -> a
    int order -> b
    int[][] sizes -> a
    int[][] derivativesIndirection -> b
    int[] lowerIndirection -> a
    int[][][] multIndirection -> a
    int[][][] compIndirection -> b
    org.apache.commons.math3.analysis.differentiation.DSCompiler getCompiler(int,int) -> a
    int[][] compileSizes(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[][] compileDerivativesIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[] compileLowerIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[][][] compileMultiplicationIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler,int[]) -> a
    int[][][] compileCompositionIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler,int[][],int[][]) -> a
    int getPartialDerivativeIndex(int,int,int[][],int[]) -> a
    int convertIndex(int,int,int[][],int,int,int[][]) -> a
    int getSize() -> a
    void multiply(double[],int,double[],int,double[],int) -> a
    void pow(double[],int,int,double[],int) -> a
    void checkCompatibility(org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
org.apache.commons.math3.analysis.differentiation.DerivativeStructure -> hg:
    org.apache.commons.math3.analysis.differentiation.DSCompiler compiler -> a
    double[] data -> a
    int getFreeParameters() -> a
    int getOrder() -> b
    double getPartialDerivative(int[]) -> a
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure add(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> a
    org.apache.commons.math3.Field getField() -> getField
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    org.apache.commons.math3.analysis.differentiation.DSCompiler access$000(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> a
org.apache.commons.math3.analysis.differentiation.DerivativeStructure$1 -> hh:
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure this$0 -> a
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction -> hi:
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure[] value(org.apache.commons.math3.analysis.differentiation.DerivativeStructure[]) -> a
org.apache.commons.math3.analysis.integration.BaseAbstractUnivariateIntegrator -> hj:
    org.apache.commons.math3.util.Incrementor iterations -> a
    double absoluteAccuracy -> a
    double relativeAccuracy -> b
    int minimalIterationCount -> a
    org.apache.commons.math3.util.Incrementor evaluations -> b
    org.apache.commons.math3.analysis.UnivariateFunction function -> a
    double min -> c
    double max -> d
    double computeObjectiveValue(double) -> a
    double integrate(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.RombergIntegrator -> hk:
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.SimpsonIntegrator -> hl:
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.TrapezoidIntegrator -> hm:
    double s -> e
    double stage(org.apache.commons.math3.analysis.integration.BaseAbstractUnivariateIntegrator,int) -> a
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.UnivariateIntegrator -> hn:
    double integrate(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
org.apache.commons.math3.analysis.integration.gauss.BaseRuleFactory -> ho:
    java.util.Map pointsAndWeights -> a
    java.util.Map pointsAndWeightsDouble -> b
    org.apache.commons.math3.util.Pair getRule(int) -> a
    org.apache.commons.math3.util.Pair getRuleInternal(int) -> b
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.GaussIntegrator -> hp:
    double[] points -> a
    double[] weights -> b
    double integrate(org.apache.commons.math3.analysis.UnivariateFunction) -> a
org.apache.commons.math3.analysis.integration.gauss.GaussIntegratorFactory -> hq:
    org.apache.commons.math3.analysis.integration.gauss.BaseRuleFactory legendre -> a
    org.apache.commons.math3.analysis.integration.gauss.GaussIntegrator legendre(int,double,double) -> a
    org.apache.commons.math3.util.Pair transform(org.apache.commons.math3.util.Pair,double,double) -> a
org.apache.commons.math3.analysis.integration.gauss.HermiteRuleFactory -> hr:
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.LegendreHighPrecisionRuleFactory -> hs:
    java.math.MathContext mContext -> a
    java.math.BigDecimal two -> a
    java.math.BigDecimal minusOne -> b
    java.math.BigDecimal oneHalf -> c
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.LegendreRuleFactory -> ht:
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.interpolation.SplineInterpolator -> hu:
    org.apache.commons.math3.analysis.UnivariateFunction interpolate(double[],double[]) -> a
org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator -> hv:
    org.apache.commons.math3.analysis.UnivariateFunction interpolate(double[],double[]) -> a
org.apache.commons.math3.analysis.polynomials.PolynomialFunction -> hw:
    double[] coefficients -> a
    double value(double) -> a
    double evaluate(double[],double) -> a
    java.lang.String toString() -> toString
    java.lang.String toString(double) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction -> hx:
    double[] knots -> a
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction[] polynomials -> a
    int n -> a
    double value(double) -> a
org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver -> hy:
org.apache.commons.math3.analysis.solvers.AllowedSolution -> hz:
    int ANY_SIDE$37d0779 -> a
    int LEFT_SIDE$37d0779 -> b
    int RIGHT_SIDE$37d0779 -> c
    int BELOW_SIDE$37d0779 -> d
    int ABOVE_SIDE$37d0779 -> e
    int[] $VALUES$1fdc434c -> a
    int[] values$267468cd() -> a
org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver -> hA:
    double functionValueAccuracy -> a
    double absoluteAccuracy -> b
    double relativeAccuracy -> c
    org.apache.commons.math3.util.Incrementor evaluations -> a
    double searchMin -> d
    double searchMax -> e
    double searchStart -> f
    org.apache.commons.math3.analysis.UnivariateFunction function -> a
    double computeObjectiveValue(double) -> a
    void setup(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double) -> a
    double doSolve() -> a
    void verifySequence(double,double,double) -> a
    void verifyBracketing(double,double) -> a
    void incrementEvaluationCount() -> a
org.apache.commons.math3.analysis.solvers.BaseSecantSolver -> hB:
    int allowed$37d0779 -> a
    int method$31c873c3 -> b
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.BaseSecantSolver$1 -> hC:
    int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$BaseSecantSolver$Method -> a
    int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$AllowedSolution -> b
org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method -> hD:
    int REGULA_FALSI$31c873c3 -> a
    int ILLINOIS$31c873c3 -> b
    int PEGASUS$31c873c3 -> c
    int[] $VALUES$69504202 -> a
    int[] values$d90a97d() -> a
org.apache.commons.math3.analysis.solvers.BisectionSolver -> hE:
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.BrentSolver -> hF:
    double doSolve() -> a
    double brent(double,double,double,double) -> a
org.apache.commons.math3.analysis.solvers.IllinoisSolver -> hG:
org.apache.commons.math3.analysis.solvers.MullerSolver -> hH:
    double doSolve() -> a
    double solve(double,double,double,double) -> a
org.apache.commons.math3.analysis.solvers.PegasusSolver -> hI:
org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver -> hJ:
org.apache.commons.math3.analysis.solvers.RiddersSolver -> hK:
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.SecantSolver -> hL:
    double doSolve() -> a
org.apache.commons.math3.complex.Complex -> org.apache.commons.math3.complex.Complex:
    org.apache.commons.math3.complex.Complex I -> a
    org.apache.commons.math3.complex.Complex NaN -> d
    org.apache.commons.math3.complex.Complex INF -> e
    org.apache.commons.math3.complex.Complex ONE -> b
    org.apache.commons.math3.complex.Complex ZERO -> c
    double imaginary -> a
    double real -> b
    boolean isNaN -> a
    boolean isInfinite -> b
    double abs() -> abs
    org.apache.commons.math3.complex.Complex add(org.apache.commons.math3.complex.Complex) -> add
    org.apache.commons.math3.complex.Complex add(double) -> add
    org.apache.commons.math3.complex.Complex conjugate() -> conjugate
    org.apache.commons.math3.complex.Complex divide(org.apache.commons.math3.complex.Complex) -> divide
    org.apache.commons.math3.complex.Complex divide(double) -> divide
    org.apache.commons.math3.complex.Complex reciprocal() -> reciprocal
    boolean equals(java.lang.Object) -> equals
    boolean equals(org.apache.commons.math3.complex.Complex,org.apache.commons.math3.complex.Complex,int) -> equals
    boolean equals(org.apache.commons.math3.complex.Complex,org.apache.commons.math3.complex.Complex) -> equals
    boolean equals(org.apache.commons.math3.complex.Complex,org.apache.commons.math3.complex.Complex,double) -> equals
    boolean equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex,org.apache.commons.math3.complex.Complex,double) -> equalsWithRelativeTolerance
    int hashCode() -> hashCode
    double getImaginary() -> getImaginary
    double getReal() -> getReal
    boolean isNaN() -> isNaN
    boolean isInfinite() -> isInfinite
    org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex) -> multiply
    org.apache.commons.math3.complex.Complex multiply(int) -> multiply
    org.apache.commons.math3.complex.Complex multiply(double) -> multiply
    org.apache.commons.math3.complex.Complex negate() -> negate
    org.apache.commons.math3.complex.Complex subtract(org.apache.commons.math3.complex.Complex) -> subtract
    org.apache.commons.math3.complex.Complex subtract(double) -> subtract
    org.apache.commons.math3.complex.Complex acos() -> acos
    org.apache.commons.math3.complex.Complex asin() -> asin
    org.apache.commons.math3.complex.Complex atan() -> atan
    org.apache.commons.math3.complex.Complex cos() -> cos
    org.apache.commons.math3.complex.Complex cosh() -> cosh
    org.apache.commons.math3.complex.Complex exp() -> exp
    org.apache.commons.math3.complex.Complex log() -> log
    org.apache.commons.math3.complex.Complex pow(org.apache.commons.math3.complex.Complex) -> pow
    org.apache.commons.math3.complex.Complex pow(double) -> pow
    org.apache.commons.math3.complex.Complex sin() -> sin
    org.apache.commons.math3.complex.Complex sinh() -> sinh
    org.apache.commons.math3.complex.Complex sqrt() -> sqrt
    org.apache.commons.math3.complex.Complex sqrt1z() -> sqrt1z
    org.apache.commons.math3.complex.Complex tan() -> tan
    org.apache.commons.math3.complex.Complex tanh() -> tanh
    double getArgument() -> getArgument
    java.util.List nthRoot(int) -> nthRoot
    org.apache.commons.math3.complex.Complex createComplex(double,double) -> a
    org.apache.commons.math3.complex.Complex valueOf(double,double) -> valueOf
    org.apache.commons.math3.complex.Complex valueOf(double) -> valueOf
    org.apache.commons.math3.complex.ComplexField getField() -> getField
    java.lang.String toString() -> toString
    org.apache.commons.math3.Field getField() -> getField
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
org.apache.commons.math3.complex.ComplexField -> hM:
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
org.apache.commons.math3.complex.ComplexField$LazyHolder -> hN:
    org.apache.commons.math3.complex.ComplexField INSTANCE -> a
    org.apache.commons.math3.complex.ComplexField access$000() -> a
org.apache.commons.math3.dfp.Dfp -> hO:
    int[] mant -> a
    byte sign -> a
    int exp -> a
    byte nans -> b
    org.apache.commons.math3.dfp.DfpField field -> a
    org.apache.commons.math3.dfp.Dfp newInstance(org.apache.commons.math3.dfp.Dfp) -> a
    org.apache.commons.math3.dfp.Dfp getZero() -> a
    void shiftLeft() -> a
    void shiftRight() -> b
    int align(int) -> a
    boolean isNaN() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compare(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> a
    int complement(int) -> b
    org.apache.commons.math3.dfp.Dfp add(org.apache.commons.math3.dfp.Dfp) -> b
    org.apache.commons.math3.dfp.Dfp negate() -> b
    int round(int) -> c
    org.apache.commons.math3.dfp.Dfp divide(org.apache.commons.math3.dfp.Dfp) -> c
    java.lang.String toString() -> toString
    java.lang.String dfp2string() -> a
    org.apache.commons.math3.dfp.Dfp dotrap(int,java.lang.String,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> a
    java.lang.Object reciprocal() -> reciprocal
    org.apache.commons.math3.Field getField() -> getField
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
org.apache.commons.math3.dfp.Dfp$1 -> hP:
    int[] $SwitchMap$org$apache$commons$math3$dfp$DfpField$RoundingMode -> a
org.apache.commons.math3.dfp.DfpField -> hQ:
    int radixDigits -> a
    org.apache.commons.math3.dfp.Dfp zero -> a
    org.apache.commons.math3.dfp.Dfp one -> b
    int ieeeFlags -> b
    org.apache.commons.math3.analysis.ParametricUnivariateFunction f -> a
    org.apache.commons.math3.optimization.fitting.CurveFitter this$0 -> a
    void setIEEEFlagsBits(int) -> a
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
    double[] value(double[]) -> a
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure[] value(org.apache.commons.math3.analysis.differentiation.DerivativeStructure[]) -> a
    boolean getValue() -> a
org.apache.commons.math3.dfp.DfpField$RoundingMode -> hR:
    int ROUND_DOWN$7d08181e -> a
    int ROUND_UP$7d08181e -> b
    int ROUND_HALF_UP$7d08181e -> c
    int ROUND_HALF_DOWN$7d08181e -> d
    int ROUND_HALF_EVEN$7d08181e -> e
    int ROUND_HALF_ODD$7d08181e -> f
    int ROUND_CEIL$7d08181e -> g
    int ROUND_FLOOR$7d08181e -> h
    int[] $VALUES$492aff43 -> a
    int[] values$5a699a5c() -> a
org.apache.commons.math3.distribution.AbstractIntegerDistribution -> hS:
    org.apache.commons.math3.random.RandomGenerator random -> a
    int sample() -> a
    double checkedCumulativeProbability(int) -> b
org.apache.commons.math3.distribution.IntegerDistribution -> hT:
    double cumulativeProbability(int) -> a
    double getNumericalMean() -> a
    double getNumericalVariance() -> b
    int getSupportLowerBound() -> b
    int getSupportUpperBound() -> c
org.apache.commons.math3.distribution.UniformIntegerDistribution -> hU:
    int lower -> a
    int upper -> b
    double cumulativeProbability(int) -> a
    double getNumericalMean() -> a
    double getNumericalVariance() -> b
    int getSupportLowerBound() -> b
    int getSupportUpperBound() -> c
    int sample() -> a
org.apache.commons.math3.exception.ConvergenceException -> hV:
org.apache.commons.math3.exception.DimensionMismatchException -> hW:
org.apache.commons.math3.exception.MathArithmeticException -> hX:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathIllegalArgumentException -> hY:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathIllegalNumberException -> hZ:
    java.lang.Integer INTEGER_ZERO -> a
org.apache.commons.math3.exception.MathIllegalStateException -> ia:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathInternalError -> ib:
org.apache.commons.math3.exception.MathUnsupportedOperationException -> ic:
    org.apache.commons.math3.exception.util.ExceptionContext context -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MaxCountExceededException -> id:
    java.lang.Number max -> a
org.apache.commons.math3.exception.MultiDimensionMismatchException -> ie:
org.apache.commons.math3.exception.NoBracketingException -> if:
org.apache.commons.math3.exception.NoDataException -> ig:
org.apache.commons.math3.exception.NonMonotonicSequenceException -> ih:
org.apache.commons.math3.exception.NotANumberException -> ii:
org.apache.commons.math3.exception.NotPositiveException -> ij:
org.apache.commons.math3.exception.NotStrictlyPositiveException -> ik:
org.apache.commons.math3.exception.NullArgumentException -> il:
org.apache.commons.math3.exception.NumberIsTooLargeException -> im:
org.apache.commons.math3.exception.NumberIsTooSmallException -> in:
org.apache.commons.math3.exception.OutOfRangeException -> io:
org.apache.commons.math3.exception.TooManyEvaluationsException -> ip:
org.apache.commons.math3.exception.TooManyIterationsException -> iq:
org.apache.commons.math3.exception.ZeroException -> ir:
org.apache.commons.math3.exception.util.ExceptionContext -> is:
    java.util.List msgPatterns -> a
    java.util.List msgArguments -> b
    void addMessage(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.String getMessage(java.util.Locale) -> a
org.apache.commons.math3.exception.util.Localizable -> it:
    java.lang.String getLocalizedString(java.util.Locale) -> a
org.apache.commons.math3.exception.util.LocalizedFormats -> iu:
    org.apache.commons.math3.exception.util.LocalizedFormats ARGUMENT_OUTSIDE_DOMAIN -> au
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SIZE_EXCEEDS_MAX_VARIABLES -> av
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1 -> aw
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SUMS_TO_ZERO -> ax
    org.apache.commons.math3.exception.util.LocalizedFormats ASSYMETRIC_EIGEN_NOT_SUPPORTED -> ay
    org.apache.commons.math3.exception.util.LocalizedFormats AT_LEAST_ONE_COLUMN -> a
    org.apache.commons.math3.exception.util.LocalizedFormats AT_LEAST_ONE_ROW -> b
    org.apache.commons.math3.exception.util.LocalizedFormats BANDWIDTH -> az
    org.apache.commons.math3.exception.util.LocalizedFormats BESSEL_FUNCTION_BAD_ARGUMENT -> aA
    org.apache.commons.math3.exception.util.LocalizedFormats BESSEL_FUNCTION_FAILED_CONVERGENCE -> aB
    org.apache.commons.math3.exception.util.LocalizedFormats BINOMIAL_INVALID_PARAMETERS_ORDER -> aC
    org.apache.commons.math3.exception.util.LocalizedFormats BINOMIAL_NEGATIVE_PARAMETER -> aD
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> aE
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_0TH_ROOT_OF_UNITY -> aF
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA -> aG
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA -> aH
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N -> c
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS -> aI
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR -> aJ
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_COMPLEX -> aK
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR -> aL
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_OBJECT_TO_FRACTION -> aM
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> aN
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR -> aO
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_RETRIEVE_AT_NEGATIVE_INDEX -> aP
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_SET_AT_NEGATIVE_INDEX -> aQ
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY -> aR
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_TRANSFORM_TO_DOUBLE -> aS
    org.apache.commons.math3.exception.util.LocalizedFormats CARDAN_ANGLES_SINGULARITY -> aT
    org.apache.commons.math3.exception.util.LocalizedFormats CLASS_DOESNT_IMPLEMENT_COMPARABLE -> aU
    org.apache.commons.math3.exception.util.LocalizedFormats CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT -> aV
    org.apache.commons.math3.exception.util.LocalizedFormats COLUMN_INDEX_OUT_OF_RANGE -> aW
    org.apache.commons.math3.exception.util.LocalizedFormats COLUMN_INDEX -> d
    org.apache.commons.math3.exception.util.LocalizedFormats CONSTRAINT -> aX
    org.apache.commons.math3.exception.util.LocalizedFormats CONTINUED_FRACTION_INFINITY_DIVERGENCE -> e
    org.apache.commons.math3.exception.util.LocalizedFormats CONTINUED_FRACTION_NAN_DIVERGENCE -> f
    org.apache.commons.math3.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR -> aY
    org.apache.commons.math3.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_ONE -> aZ
    org.apache.commons.math3.exception.util.LocalizedFormats CONVERGENCE_FAILED -> g
    org.apache.commons.math3.exception.util.LocalizedFormats CROSSING_BOUNDARY_LOOPS -> ba
    org.apache.commons.math3.exception.util.LocalizedFormats CROSSOVER_RATE -> bb
    org.apache.commons.math3.exception.util.LocalizedFormats CUMULATIVE_PROBABILITY_RETURNED_NAN -> bc
    org.apache.commons.math3.exception.util.LocalizedFormats DIFFERENT_ROWS_LENGTHS -> bd
    org.apache.commons.math3.exception.util.LocalizedFormats DIFFERENT_ORIG_AND_PERMUTED_DATA -> be
    org.apache.commons.math3.exception.util.LocalizedFormats DIGEST_NOT_INITIALIZED -> bf
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_2x2 -> h
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_SIMPLE -> i
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH -> bg
    org.apache.commons.math3.exception.util.LocalizedFormats DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN -> j
    org.apache.commons.math3.exception.util.LocalizedFormats DISTRIBUTION_NOT_LOADED -> bh
    org.apache.commons.math3.exception.util.LocalizedFormats DUPLICATED_ABSCISSA_DIVISION_BY_ZERO -> bi
    org.apache.commons.math3.exception.util.LocalizedFormats ELITISM_RATE -> bj
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_CLUSTER_IN_K_MEANS -> bk
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_INTERPOLATION_SAMPLE -> bl
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY -> k
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_SELECTED_COLUMN_INDEX_ARRAY -> bm
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_SELECTED_ROW_INDEX_ARRAY -> bn
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_STRING_FOR_IMAGINARY_CHARACTER -> bo
    org.apache.commons.math3.exception.util.LocalizedFormats ENDPOINTS_NOT_AN_INTERVAL -> l
    org.apache.commons.math3.exception.util.LocalizedFormats EQUAL_VERTICES_IN_SIMPLEX -> bp
    org.apache.commons.math3.exception.util.LocalizedFormats EULER_ANGLES_SINGULARITY -> bq
    org.apache.commons.math3.exception.util.LocalizedFormats EVALUATION -> br
    org.apache.commons.math3.exception.util.LocalizedFormats EXPANSION_FACTOR_SMALLER_THAN_ONE -> bs
    org.apache.commons.math3.exception.util.LocalizedFormats FACTORIAL_NEGATIVE_PARAMETER -> bt
    org.apache.commons.math3.exception.util.LocalizedFormats FAILED_BRACKETING -> bu
    org.apache.commons.math3.exception.util.LocalizedFormats FAILED_FRACTION_CONVERSION -> m
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_COLUMNS_NOT_INITIALIZED_YET -> n
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_ELEMENT_NOT_ZERO -> bv
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_ROWS_NOT_INITIALIZED_YET -> o
    org.apache.commons.math3.exception.util.LocalizedFormats FRACTION_CONVERSION_OVERFLOW -> p
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION_NOT_DIFFERENTIABLE -> bw
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION_NOT_POLYNOMIAL -> bx
    org.apache.commons.math3.exception.util.LocalizedFormats GCD_OVERFLOW_32_BITS -> by
    org.apache.commons.math3.exception.util.LocalizedFormats GCD_OVERFLOW_64_BITS -> bz
    org.apache.commons.math3.exception.util.LocalizedFormats HOLE_BETWEEN_MODELS_TIME_RANGES -> bA
    org.apache.commons.math3.exception.util.LocalizedFormats ILL_CONDITIONED_OPERATOR -> bB
    org.apache.commons.math3.exception.util.LocalizedFormats INCONSISTENT_STATE_AT_2_PI_WRAPPING -> bC
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_LARGER_THAN_MAX -> bD
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_NOT_POSITIVE -> bE
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_OUT_OF_RANGE -> bF
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX -> q
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_FINITE_NUMBER -> bG
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_BOUND -> bH
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_ELEMENT -> bI
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_ARRAY_ELEMENT -> bJ
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_VALUE_CONVERSION -> r
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_CAPACITY_NOT_POSITIVE -> bK
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_COLUMN_AFTER_FINAL_COLUMN -> s
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_ROW_AFTER_FINAL_ROW -> t
    org.apache.commons.math3.exception.util.LocalizedFormats INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE -> bL
    org.apache.commons.math3.exception.util.LocalizedFormats INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES -> bM
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DATA -> bN
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DATA_FOR_T_STATISTIC -> bO
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DIMENSION -> bP
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSION -> u
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE -> bQ
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_ROWS_AND_COLUMNS -> bR
    org.apache.commons.math3.exception.util.LocalizedFormats INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS -> bS
    org.apache.commons.math3.exception.util.LocalizedFormats INTERNAL_ERROR -> v
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BINARY_DIGIT -> bT
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BINARY_CHROMOSOME -> bU
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BRACKETING_PARAMETERS -> bV
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_FIXED_LENGTH_CHROMOSOME -> bW
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_IMPLEMENTATION -> bX
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS -> bY
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_ITERATIONS_LIMITS -> bZ
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_MAX_ITERATIONS -> ca
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_DATA_REGRESSION -> cb
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_REGRESSION_ARRAY -> cc
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_REGRESSION_OBSERVATION -> cd
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_ROUNDING_METHOD -> ce
    org.apache.commons.math3.exception.util.LocalizedFormats ITERATOR_EXHAUSTED -> cf
    org.apache.commons.math3.exception.util.LocalizedFormats ITERATIONS -> w
    org.apache.commons.math3.exception.util.LocalizedFormats LCM_OVERFLOW_32_BITS -> cg
    org.apache.commons.math3.exception.util.LocalizedFormats LCM_OVERFLOW_64_BITS -> ch
    org.apache.commons.math3.exception.util.LocalizedFormats LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE -> ci
    org.apache.commons.math3.exception.util.LocalizedFormats LOESS_EXPECTS_AT_LEAST_ONE_POINT -> cj
    org.apache.commons.math3.exception.util.LocalizedFormats LOWER_BOUND_NOT_BELOW_UPPER_BOUND -> x
    org.apache.commons.math3.exception.util.LocalizedFormats LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT -> ck
    org.apache.commons.math3.exception.util.LocalizedFormats MAP_MODIFIED_WHILE_ITERATING -> cl
    org.apache.commons.math3.exception.util.LocalizedFormats EVALUATIONS -> y
    org.apache.commons.math3.exception.util.LocalizedFormats MAX_COUNT_EXCEEDED -> z
    org.apache.commons.math3.exception.util.LocalizedFormats MAX_ITERATIONS_EXCEEDED -> cm
    org.apache.commons.math3.exception.util.LocalizedFormats MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION -> cn
    org.apache.commons.math3.exception.util.LocalizedFormats MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS -> co
    org.apache.commons.math3.exception.util.LocalizedFormats MUTATION_RATE -> cp
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_ELEMENT_AT_INDEX -> cq
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_VALUE_CONVERSION -> A
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_BRIGHTNESS_EXPONENT -> cr
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_COMPLEX_MODULE -> cs
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_2D_INDEX -> ct
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_INDEX -> cu
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_SUCCESSES -> cv
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SUCCESSES -> cw
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_TRIALS -> cx
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_INTERPOLATION_POINTS -> cy
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_TRIALS -> cz
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_CONVEX -> cA
    org.apache.commons.math3.exception.util.LocalizedFormats ROBUSTNESS_ITERATIONS -> cB
    org.apache.commons.math3.exception.util.LocalizedFormats START_POSITION -> B
    org.apache.commons.math3.exception.util.LocalizedFormats NON_CONVERGENT_CONTINUED_FRACTION -> C
    org.apache.commons.math3.exception.util.LocalizedFormats NON_INVERTIBLE_TRANSFORM -> cC
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_MICROSPHERE_ELEMENTS -> cD
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_POLYNOMIAL_DEGREE -> cE
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_ABSCISSA -> cF
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_ORDINATE -> cG
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_WEIGHT -> cH
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SQUARE_MATRIX -> D
    org.apache.commons.math3.exception.util.LocalizedFormats NORM -> cI
    org.apache.commons.math3.exception.util.LocalizedFormats NORMALIZE_INFINITE -> cJ
    org.apache.commons.math3.exception.util.LocalizedFormats NORMALIZE_NAN -> cK
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ADDITION_COMPATIBLE_MATRICES -> cL
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_DECREASING_NUMBER_OF_POINTS -> cM
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_DECREASING_SEQUENCE -> E
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS -> cN
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION -> F
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_INCREASING_NUMBER_OF_POINTS -> cO
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_INCREASING_SEQUENCE -> G
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_MULTIPLICATION_COMPATIBLE_MATRICES -> cP
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_DEFINITE_MATRIX -> cQ
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_DEFINITE_MATRIX -> cR
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_DEFINITE_OPERATOR -> cS
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SELF_ADJOINT_OPERATOR -> cT
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SQUARE_OPERATOR -> cU
    org.apache.commons.math3.exception.util.LocalizedFormats DEGREES_OF_FREEDOM -> cV
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_DEGREES_OF_FREEDOM -> cW
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_ELEMENT_AT_INDEX -> cX
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_EXPONENT -> cY
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE -> cZ
    org.apache.commons.math3.exception.util.LocalizedFormats BASE -> da
    org.apache.commons.math3.exception.util.LocalizedFormats EXPONENT -> H
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_LENGTH -> db
    org.apache.commons.math3.exception.util.LocalizedFormats LENGTH -> I
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_MEAN -> dc
    org.apache.commons.math3.exception.util.LocalizedFormats MEAN -> dd
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_NUMBER_OF_SAMPLES -> J
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SAMPLES -> de
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_PERMUTATION -> df
    org.apache.commons.math3.exception.util.LocalizedFormats PERMUTATION_SIZE -> dg
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_POISSON_MEAN -> dh
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_POPULATION_SIZE -> di
    org.apache.commons.math3.exception.util.LocalizedFormats POPULATION_SIZE -> dj
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_ROW_DIMENSION -> dk
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SAMPLE_SIZE -> dl
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SCALE -> dm
    org.apache.commons.math3.exception.util.LocalizedFormats SCALE -> dn
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SHAPE -> do
    org.apache.commons.math3.exception.util.LocalizedFormats SHAPE -> dp
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_STANDARD_DEVIATION -> dq
    org.apache.commons.math3.exception.util.LocalizedFormats STANDARD_DEVIATION -> dr
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_UPPER_BOUND -> ds
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_WINDOW_SIZE -> dt
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO -> du
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO_CONSIDER_PADDING -> K
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO_PLUS_ONE -> dv
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS -> dw
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_SEQUENCE -> L
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_KNOT_VALUES -> dx
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS -> dy
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_SEQUENCE -> M
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SUBTRACTION_COMPATIBLE_MATRICES -> dz
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SUPPORTED_IN_DIMENSION_N -> dA
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SYMMETRIC_MATRIX -> dB
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SYMMETRIC_MATRIX -> N
    org.apache.commons.math3.exception.util.LocalizedFormats NO_BIN_SELECTED -> dC
    org.apache.commons.math3.exception.util.LocalizedFormats NO_CONVERGENCE_WITH_ANY_START_POINT -> dD
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DATA -> O
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DEGREES_OF_FREEDOM -> dE
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DENSITY_FOR_THIS_DISTRIBUTION -> dF
    org.apache.commons.math3.exception.util.LocalizedFormats NO_FEASIBLE_SOLUTION -> P
    org.apache.commons.math3.exception.util.LocalizedFormats NO_OPTIMUM_COMPUTED_YET -> dG
    org.apache.commons.math3.exception.util.LocalizedFormats NO_REGRESSORS -> dH
    org.apache.commons.math3.exception.util.LocalizedFormats NO_RESULT_AVAILABLE -> dI
    org.apache.commons.math3.exception.util.LocalizedFormats NO_SUCH_MATRIX_ENTRY -> dJ
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_NOT_ALLOWED -> Q
    org.apache.commons.math3.exception.util.LocalizedFormats NULL_NOT_ALLOWED -> R
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED -> dK
    org.apache.commons.math3.exception.util.LocalizedFormats COVARIANCE_MATRIX -> dL
    org.apache.commons.math3.exception.util.LocalizedFormats DENOMINATOR -> S
    org.apache.commons.math3.exception.util.LocalizedFormats DENOMINATOR_FORMAT -> dM
    org.apache.commons.math3.exception.util.LocalizedFormats FRACTION -> T
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION -> U
    org.apache.commons.math3.exception.util.LocalizedFormats IMAGINARY_FORMAT -> dN
    org.apache.commons.math3.exception.util.LocalizedFormats INPUT_ARRAY -> V
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR -> W
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR_FORMAT -> dO
    org.apache.commons.math3.exception.util.LocalizedFormats OBJECT_TRANSFORMATION -> dP
    org.apache.commons.math3.exception.util.LocalizedFormats REAL_FORMAT -> dQ
    org.apache.commons.math3.exception.util.LocalizedFormats WHOLE_FORMAT -> dR
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_LARGE -> X
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_SMALL -> Y
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_LARGE_BOUND_EXCLUDED -> Z
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_SMALL_BOUND_EXCLUDED -> aa
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE -> dS
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR_OVERFLOW_AFTER_MULTIPLY -> dT
    org.apache.commons.math3.exception.util.LocalizedFormats N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED -> dU
    org.apache.commons.math3.exception.util.LocalizedFormats OBSERVED_COUNTS_ALL_ZERO -> dV
    org.apache.commons.math3.exception.util.LocalizedFormats OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY -> dW
    org.apache.commons.math3.exception.util.LocalizedFormats BOBYQA_BOUND_DIFFERENCE_CONDITION -> dX
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUNDS_QUANTILE_VALUE -> ab
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUNDS_CONFIDENCE_LEVEL -> dY
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUND_SIGNIFICANCE_LEVEL -> dZ
    org.apache.commons.math3.exception.util.LocalizedFormats SIGNIFICANCE_LEVEL -> ea
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_ORDER_ABSCISSA_ARRAY -> eb
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_ROOT_OF_UNITY_INDEX -> ec
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE -> ed
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_SIMPLE -> ac
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_LEFT -> ee
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_RIGHT -> ef
    org.apache.commons.math3.exception.util.LocalizedFormats OUTLINE_BOUNDARY_LOOP_OPEN -> eg
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW -> eh
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_FRACTION -> ei
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_ADDITION -> ej
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_SUBTRACTION -> ek
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_MULTIPLICATION -> el
    org.apache.commons.math3.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD -> em
    org.apache.commons.math3.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD -> en
    org.apache.commons.math3.exception.util.LocalizedFormats PERMUTATION_EXCEEDS_N -> eo
    org.apache.commons.math3.exception.util.LocalizedFormats POLYNOMIAL -> ep
    org.apache.commons.math3.exception.util.LocalizedFormats POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS -> eq
    org.apache.commons.math3.exception.util.LocalizedFormats POPULATION_LIMIT_NOT_POSITIVE -> er
    org.apache.commons.math3.exception.util.LocalizedFormats POWER_NEGATIVE_PARAMETERS -> es
    org.apache.commons.math3.exception.util.LocalizedFormats PROPAGATION_DIRECTION_MISMATCH -> et
    org.apache.commons.math3.exception.util.LocalizedFormats RANDOMKEY_MUTATION_WRONG_CLASS -> eu
    org.apache.commons.math3.exception.util.LocalizedFormats ROOTS_OF_UNITY_NOT_COMPUTED_YET -> ev
    org.apache.commons.math3.exception.util.LocalizedFormats ROTATION_MATRIX_DIMENSIONS -> ew
    org.apache.commons.math3.exception.util.LocalizedFormats ROW_INDEX_OUT_OF_RANGE -> ex
    org.apache.commons.math3.exception.util.LocalizedFormats ROW_INDEX -> ad
    org.apache.commons.math3.exception.util.LocalizedFormats SAME_SIGN_AT_ENDPOINTS -> ae
    org.apache.commons.math3.exception.util.LocalizedFormats SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE -> ey
    org.apache.commons.math3.exception.util.LocalizedFormats SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE -> ez
    org.apache.commons.math3.exception.util.LocalizedFormats SIMPLEX_NEED_ONE_POINT -> eA
    org.apache.commons.math3.exception.util.LocalizedFormats SIMPLE_MESSAGE -> eB
    org.apache.commons.math3.exception.util.LocalizedFormats SINGULAR_MATRIX -> af
    org.apache.commons.math3.exception.util.LocalizedFormats SINGULAR_OPERATOR -> eC
    org.apache.commons.math3.exception.util.LocalizedFormats SUBARRAY_ENDS_AFTER_ARRAY_END -> ag
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_LARGE_CUTOFF_SINGULAR_VALUE -> eD
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_LARGE_TOURNAMENT_ARITY -> eE
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY -> eF
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_MANY_REGRESSORS -> eG
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_COST_RELATIVE_TOLERANCE -> ah
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_INTEGRATION_INTERVAL -> eH
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_ORTHOGONALITY_TOLERANCE -> ai
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE -> aj
    org.apache.commons.math3.exception.util.LocalizedFormats TRUST_REGION_STEP_FAILED -> eI
    org.apache.commons.math3.exception.util.LocalizedFormats TWO_OR_MORE_CATEGORIES_REQUIRED -> eJ
    org.apache.commons.math3.exception.util.LocalizedFormats TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED -> eK
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH -> eL
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM -> eM
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS -> eN
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_ORTHOGONOLIZE_MATRIX -> eO
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN -> ak
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_SOLVE_SINGULAR_PROBLEM -> eP
    org.apache.commons.math3.exception.util.LocalizedFormats UNBOUNDED_SOLUTION -> al
    org.apache.commons.math3.exception.util.LocalizedFormats UNKNOWN_MODE -> eQ
    org.apache.commons.math3.exception.util.LocalizedFormats UNKNOWN_PARAMETER -> eR
    org.apache.commons.math3.exception.util.LocalizedFormats UNMATCHED_ODE_IN_EXPANDED_SET -> eS
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_PARSE_AS_TYPE -> eT
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_PARSE -> eU
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_3D_VECTOR -> eV
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_COMPLEX_NUMBER -> eW
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_REAL_VECTOR -> eX
    org.apache.commons.math3.exception.util.LocalizedFormats UNSUPPORTED_EXPANSION_MODE -> eY
    org.apache.commons.math3.exception.util.LocalizedFormats UNSUPPORTED_OPERATION -> am
    org.apache.commons.math3.exception.util.LocalizedFormats ARITHMETIC_EXCEPTION -> an
    org.apache.commons.math3.exception.util.LocalizedFormats ILLEGAL_STATE -> ao
    org.apache.commons.math3.exception.util.LocalizedFormats USER_EXCEPTION -> eZ
    org.apache.commons.math3.exception.util.LocalizedFormats URL_CONTAINS_NO_DATA -> fa
    org.apache.commons.math3.exception.util.LocalizedFormats VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC -> fb
    org.apache.commons.math3.exception.util.LocalizedFormats VECTOR_LENGTH_MISMATCH -> fc
    org.apache.commons.math3.exception.util.LocalizedFormats VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT -> ap
    org.apache.commons.math3.exception.util.LocalizedFormats WEIGHT_AT_LEAST_ONE_NON_ZERO -> fd
    org.apache.commons.math3.exception.util.LocalizedFormats WRONG_BLOCK_LENGTH -> fe
    org.apache.commons.math3.exception.util.LocalizedFormats WRONG_NUMBER_OF_POINTS -> ff
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_POINTS -> aq
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_DENOMINATOR -> ar
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_DENOMINATOR_IN_FRACTION -> fg
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_FRACTION_TO_DIVIDE_BY -> fh
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM -> as
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_AXIS -> fi
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR -> fj
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NOT_ALLOWED -> at
    java.lang.String sourceFormat -> a
    java.lang.String getLocalizedString(java.util.Locale) -> a
org.apache.commons.math3.fraction.BigFraction -> org.apache.commons.math3.fraction.BigFraction:
    org.apache.commons.math3.fraction.BigFraction TWO -> a
    org.apache.commons.math3.fraction.BigFraction ONE -> b
    org.apache.commons.math3.fraction.BigFraction ZERO -> c
    org.apache.commons.math3.fraction.BigFraction MINUS_ONE -> d
    java.math.BigInteger ONE_HUNDRED -> a
    java.math.BigInteger numerator -> b
    java.math.BigInteger denominator -> c
    org.apache.commons.math3.fraction.BigFraction getReducedFraction(int,int) -> getReducedFraction
    org.apache.commons.math3.fraction.BigFraction abs() -> abs
    org.apache.commons.math3.fraction.BigFraction add(java.math.BigInteger) -> add
    org.apache.commons.math3.fraction.BigFraction add(int) -> add
    org.apache.commons.math3.fraction.BigFraction add(long) -> add
    org.apache.commons.math3.fraction.BigFraction add(org.apache.commons.math3.fraction.BigFraction) -> add
    java.math.BigDecimal bigDecimalValue() -> bigDecimalValue
    java.math.BigDecimal bigDecimalValue(int) -> bigDecimalValue
    java.math.BigDecimal bigDecimalValue(int,int) -> bigDecimalValue
    int compareTo(org.apache.commons.math3.fraction.BigFraction) -> compareTo
    org.apache.commons.math3.fraction.BigFraction divide(java.math.BigInteger) -> divide
    org.apache.commons.math3.fraction.BigFraction divide(int) -> divide
    org.apache.commons.math3.fraction.BigFraction divide(long) -> divide
    org.apache.commons.math3.fraction.BigFraction divide(org.apache.commons.math3.fraction.BigFraction) -> divide
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    float floatValue() -> floatValue
    java.math.BigInteger getDenominator() -> getDenominator
    int getDenominatorAsInt() -> getDenominatorAsInt
    long getDenominatorAsLong() -> getDenominatorAsLong
    java.math.BigInteger getNumerator() -> getNumerator
    int getNumeratorAsInt() -> getNumeratorAsInt
    long getNumeratorAsLong() -> getNumeratorAsLong
    int hashCode() -> hashCode
    int intValue() -> intValue
    long longValue() -> longValue
    org.apache.commons.math3.fraction.BigFraction multiply(java.math.BigInteger) -> multiply
    org.apache.commons.math3.fraction.BigFraction multiply(int) -> multiply
    org.apache.commons.math3.fraction.BigFraction multiply(long) -> multiply
    org.apache.commons.math3.fraction.BigFraction multiply(org.apache.commons.math3.fraction.BigFraction) -> multiply
    org.apache.commons.math3.fraction.BigFraction negate() -> negate
    double percentageValue() -> percentageValue
    org.apache.commons.math3.fraction.BigFraction pow(int) -> pow
    org.apache.commons.math3.fraction.BigFraction pow(long) -> pow
    org.apache.commons.math3.fraction.BigFraction pow(java.math.BigInteger) -> pow
    double pow(double) -> pow
    org.apache.commons.math3.fraction.BigFraction reciprocal() -> reciprocal
    org.apache.commons.math3.fraction.BigFraction reduce() -> reduce
    org.apache.commons.math3.fraction.BigFraction subtract(java.math.BigInteger) -> subtract
    org.apache.commons.math3.fraction.BigFraction subtract(int) -> subtract
    org.apache.commons.math3.fraction.BigFraction subtract(long) -> subtract
    org.apache.commons.math3.fraction.BigFraction subtract(org.apache.commons.math3.fraction.BigFraction) -> subtract
    java.lang.String toString() -> toString
    org.apache.commons.math3.fraction.BigFractionField getField() -> getField
    org.apache.commons.math3.Field getField() -> getField
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    int compareTo(java.lang.Object) -> compareTo
org.apache.commons.math3.fraction.BigFractionField -> iv:
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
org.apache.commons.math3.fraction.BigFractionField$LazyHolder -> iw:
    org.apache.commons.math3.fraction.BigFractionField INSTANCE -> a
    org.apache.commons.math3.fraction.BigFractionField access$000() -> a
org.apache.commons.math3.fraction.FractionConversionException -> ix:
org.apache.commons.math3.linear.AbstractFieldMatrix -> iy:
    org.apache.commons.math3.Field field -> a
    org.apache.commons.math3.Field extractField(org.apache.commons.math3.FieldElement[][]) -> a
    org.apache.commons.math3.Field getField() -> a
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.FieldMatrix scalarMultiply(org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.FieldElement[][] getData() -> a
    org.apache.commons.math3.FieldElement[] getRow(int) -> a
    void setRow(int,org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.FieldElement getEntry(int,int) -> a
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> a
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.linear.FieldVector operate(org.apache.commons.math3.linear.FieldVector) -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void checkRowIndex(int) -> a
    void checkColumnIndex(int) -> b
    void checkMultiplicationCompatible(org.apache.commons.math3.linear.FieldMatrix) -> a
org.apache.commons.math3.linear.AbstractRealMatrix -> iz:
    org.apache.commons.math3.linear.RealMatrixFormat DEFAULT_FORMAT -> a
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> a
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    org.apache.commons.math3.linear.RealVector getRowVector(int) -> a
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> a
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> b
    double[] getRow(int) -> a
    org.apache.commons.math3.linear.RealMatrix transpose() -> a
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
    org.apache.commons.math3.linear.RealVector operate(org.apache.commons.math3.linear.RealVector) -> a
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> a
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
org.apache.commons.math3.linear.AbstractRealMatrix$5 -> iA:
    org.apache.commons.math3.linear.RealMatrix val$out -> a
    void visit(int,int,double) -> a
org.apache.commons.math3.linear.AnyMatrix -> iB:
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
org.apache.commons.math3.linear.Array2DRowFieldMatrix -> iC:
    org.apache.commons.math3.FieldElement[][] data -> a
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.FieldMatrix copy() -> a
    org.apache.commons.math3.FieldElement[][] getData() -> a
    org.apache.commons.math3.FieldElement getEntry(int,int) -> a
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> a
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> b
    int getRowDimension() -> a
    int getColumnDimension() -> b
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.FieldElement[][] copyOut() -> b
org.apache.commons.math3.linear.Array2DRowRealMatrix -> iD:
    double[][] data -> a
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix copy() -> b
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> a
    double[][] copyOut() -> b
org.apache.commons.math3.linear.ArrayFieldVector -> iE:
    org.apache.commons.math3.FieldElement[] data -> a
    org.apache.commons.math3.Field field -> a
    org.apache.commons.math3.FieldElement dotProduct(org.apache.commons.math3.linear.FieldVector) -> a
    org.apache.commons.math3.FieldElement getEntry(int) -> a
    int getDimension() -> a
    org.apache.commons.math3.FieldElement[] toArray() -> a
    void checkVectorDimensions(int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.linear.ArrayRealVector -> iF:
    org.apache.commons.math3.linear.RealVectorFormat DEFAULT_FORMAT -> a
    double[] data -> a
    org.apache.commons.math3.linear.ArrayRealVector copy() -> a
    org.apache.commons.math3.linear.RealVector mapMultiplyToSelf(double) -> a
    double dotProduct(org.apache.commons.math3.linear.RealVector) -> a
    double getEntry(int) -> a
    int getDimension() -> a
    void setEntry(int,double) -> a
    double[] toArray() -> a
    java.lang.String toString() -> toString
    void checkVectorDimensions(org.apache.commons.math3.linear.RealVector) -> a
    void checkVectorDimensions(int) -> a
    boolean isNaN() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.linear.RealVector mapToSelf(org.apache.commons.math3.analysis.UnivariateFunction) -> a
    org.apache.commons.math3.linear.RealVector copy() -> a
    org.apache.commons.math3.linear.RealVector subtract(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.linear.BlockFieldMatrix -> iG:
    org.apache.commons.math3.FieldElement[][] blocks -> a
    int rows -> a
    int columns -> b
    int blockRows -> c
    int blockColumns -> d
    org.apache.commons.math3.FieldElement[][] toBlocksLayout(org.apache.commons.math3.FieldElement[][]) -> a
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.FieldMatrix copy() -> a
    org.apache.commons.math3.linear.FieldMatrix scalarMultiply(org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.FieldElement[][] getData() -> a
    org.apache.commons.math3.FieldElement[] getRow(int) -> a
    void setRow(int,org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.FieldElement getEntry(int,int) -> a
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> a
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> b
    int getRowDimension() -> a
    int getColumnDimension() -> b
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> a
    int blockHeight(int) -> a
    int blockWidth(int) -> b
org.apache.commons.math3.linear.BlockRealMatrix -> iH:
    double[][] blocks -> a
    int rows -> a
    int columns -> b
    int blockRows -> c
    int blockColumns -> d
    double[][] toBlocksLayout(double[][]) -> a
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> a
    org.apache.commons.math3.linear.BlockRealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    org.apache.commons.math3.linear.RealVector getRowVector(int) -> a
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> a
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> b
    double[] getRow(int) -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> a
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> b
    int blockHeight(int) -> a
    int blockWidth(int) -> b
    org.apache.commons.math3.linear.RealMatrix copy() -> b
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix transpose() -> a
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
org.apache.commons.math3.linear.DecompositionSolver -> iI:
    double[][] lu -> a
    int[] pivot -> a
    boolean singular -> a
    boolean isNonSingular() -> a
    org.apache.commons.math3.linear.RealMatrix getInverse() -> a
    org.apache.commons.math3.linear.RealMatrix solve(org.apache.commons.math3.linear.RealMatrix) -> a
org.apache.commons.math3.linear.DiagonalMatrix -> iJ:
    double[] data -> a
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix copy() -> b
    org.apache.commons.math3.linear.DiagonalMatrix multiply(org.apache.commons.math3.linear.DiagonalMatrix) -> a
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
    double[][] getData() -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
org.apache.commons.math3.linear.EigenDecomposition -> iK:
    byte maxIter -> a
    double[] main -> b
    double[] secondary -> c
    org.apache.commons.math3.linear.TriDiagonalTransformer transformer -> a
    double[] realEigenvalues -> a
    double[] imagEigenvalues -> d
    org.apache.commons.math3.linear.ArrayRealVector[] eigenvectors -> a
    org.apache.commons.math3.linear.RealMatrix cachedV -> a
    org.apache.commons.math3.linear.RealMatrix cachedVt -> b
    boolean isSymmetric -> a
    double[] getRealEigenvalues() -> a
    double[] getImagEigenvalues() -> b
    void findEigenVectors(double[][]) -> a
    org.apache.commons.math3.linear.SchurTransformer transformToSchur(org.apache.commons.math3.linear.RealMatrix) -> a
    org.apache.commons.math3.complex.Complex cdiv(double,double,double,double) -> a
    void findEigenVectorsFromSchur(org.apache.commons.math3.linear.SchurTransformer) -> a
org.apache.commons.math3.linear.FieldDecompositionSolver -> iL:
    org.apache.commons.math3.Field field -> a
    org.apache.commons.math3.FieldElement[][] lu -> a
    int[] pivot -> a
    boolean singular -> a
    org.apache.commons.math3.linear.FieldVector solve(org.apache.commons.math3.linear.FieldVector) -> a
    boolean isNonSingular() -> a
    org.apache.commons.math3.linear.FieldMatrix getInverse() -> a
    org.apache.commons.math3.linear.ArrayFieldVector solve(org.apache.commons.math3.linear.ArrayFieldVector) -> a
    org.apache.commons.math3.linear.FieldMatrix solve(org.apache.commons.math3.linear.FieldMatrix) -> a
org.apache.commons.math3.linear.FieldLUDecomposition -> iM:
    org.apache.commons.math3.Field field -> a
    org.apache.commons.math3.FieldElement[][] lu -> a
    int[] pivot -> a
    boolean even -> a
    boolean singular -> b
    org.apache.commons.math3.linear.FieldMatrix cachedL -> a
    org.apache.commons.math3.linear.FieldMatrix cachedU -> b
    int[] getPivot() -> a
    org.apache.commons.math3.linear.FieldDecompositionSolver getSolver() -> a
org.apache.commons.math3.linear.FieldMatrix -> iN:
    org.apache.commons.math3.Field getField() -> a
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> a
    org.apache.commons.math3.linear.FieldMatrix copy() -> a
    org.apache.commons.math3.linear.FieldMatrix scalarMultiply(org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.FieldElement[][] getData() -> a
    org.apache.commons.math3.FieldElement[] getRow(int) -> a
    void setRow(int,org.apache.commons.math3.FieldElement[]) -> a
    org.apache.commons.math3.FieldElement getEntry(int,int) -> a
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> a
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> b
    org.apache.commons.math3.linear.FieldVector operate(org.apache.commons.math3.linear.FieldVector) -> a
org.apache.commons.math3.linear.FieldVector -> iO:
    org.apache.commons.math3.FieldElement dotProduct(org.apache.commons.math3.linear.FieldVector) -> a
    org.apache.commons.math3.FieldElement getEntry(int) -> a
    int getDimension() -> a
    org.apache.commons.math3.FieldElement[] toArray() -> a
org.apache.commons.math3.linear.HessenbergTransformer -> iP:
    double[][] householderVectors -> a
    double[] ort -> a
    org.apache.commons.math3.linear.RealMatrix cachedP -> a
    org.apache.commons.math3.linear.RealMatrix cachedH -> b
    org.apache.commons.math3.linear.RealMatrix getP() -> a
    org.apache.commons.math3.linear.RealMatrix getH() -> b
    void transform() -> a
org.apache.commons.math3.linear.LUDecomposition -> iQ:
    double[][] lu -> a
    int[] pivot -> a
    boolean even -> a
    boolean singular -> b
org.apache.commons.math3.linear.MatrixDimensionMismatchException -> iR:
org.apache.commons.math3.linear.MatrixUtils -> iS:
    org.apache.commons.math3.linear.RealMatrix createRealMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix createRealMatrix(double[][]) -> a
    org.apache.commons.math3.linear.RealMatrix createRealIdentityMatrix(int) -> a
    org.apache.commons.math3.linear.RealMatrix createRealDiagonalMatrix(double[]) -> a
    boolean isSymmetric(org.apache.commons.math3.linear.RealMatrix,double) -> a
    void checkMatrixIndex(org.apache.commons.math3.linear.AnyMatrix,int,int) -> a
    void checkRowIndex(org.apache.commons.math3.linear.AnyMatrix,int) -> a
    void checkColumnIndex(org.apache.commons.math3.linear.AnyMatrix,int) -> b
    void checkSubMatrixIndex(org.apache.commons.math3.linear.AnyMatrix,int,int,int,int) -> a
    void checkMultiplicationCompatible(org.apache.commons.math3.linear.AnyMatrix,org.apache.commons.math3.linear.AnyMatrix) -> a
org.apache.commons.math3.linear.NonSquareMatrixException -> iT:
org.apache.commons.math3.linear.RealLinearOperator -> iU:
org.apache.commons.math3.linear.RealMatrix -> iV:
    org.apache.commons.math3.linear.RealMatrix copy() -> b
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> a
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> a
    double[][] getData() -> a
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> a
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> b
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    org.apache.commons.math3.linear.RealMatrix transpose() -> a
    double[] operate(double[]) -> a
    org.apache.commons.math3.linear.RealVector operate(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.linear.RealMatrixFormat -> iW:
    java.lang.String prefix -> a
    java.lang.String suffix -> b
    java.lang.String rowPrefix -> c
    java.lang.String rowSuffix -> d
    java.lang.String rowSeparator -> e
    java.lang.String columnSeparator -> f
    java.text.NumberFormat format -> a
    org.apache.commons.math3.linear.RealMatrixFormat getInstance(java.util.Locale) -> a
    java.lang.StringBuffer format(org.apache.commons.math3.linear.RealMatrix,java.lang.StringBuffer,java.text.FieldPosition) -> a
org.apache.commons.math3.linear.RealMatrixPreservingVisitor -> iX:
    void visit(int,int,double) -> a
org.apache.commons.math3.linear.RealVector -> iY:
    int getDimension() -> a
    double getEntry(int) -> a
    void setEntry(int,double) -> a
    boolean isNaN() -> a
    void checkVectorDimensions(org.apache.commons.math3.linear.RealVector) -> a
    void checkVectorDimensions(int) -> a
    org.apache.commons.math3.linear.RealVector subtract(org.apache.commons.math3.linear.RealVector) -> a
    org.apache.commons.math3.linear.RealVector copy() -> a
    double dotProduct(org.apache.commons.math3.linear.RealVector) -> a
    org.apache.commons.math3.linear.RealVector mapMultiply(double) -> b
    org.apache.commons.math3.linear.RealVector mapMultiplyToSelf(double) -> a
    double[] toArray() -> a
    java.util.Iterator iterator() -> a
    org.apache.commons.math3.linear.RealVector mapToSelf(org.apache.commons.math3.analysis.UnivariateFunction) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.linear.RealVector$1 -> iZ:
    int i -> a
    org.apache.commons.math3.linear.RealVector$Entry e -> a
    int val$dim -> b
    org.apache.commons.math3.linear.RealVector this$0 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.apache.commons.math3.linear.RealVector$Entry -> ja:
    int index -> a
    org.apache.commons.math3.linear.RealVector this$0 -> a
    double getValue() -> a
org.apache.commons.math3.linear.RealVectorFormat -> jb:
    java.lang.String prefix -> a
    java.lang.String suffix -> b
    java.lang.String separator -> c
    java.text.NumberFormat format -> a
    java.lang.StringBuffer format(org.apache.commons.math3.linear.RealVector,java.lang.StringBuffer,java.text.FieldPosition) -> a
org.apache.commons.math3.linear.SchurTransformer -> jc:
    double[][] matrixP -> a
    double[][] matrixT -> b
    org.apache.commons.math3.linear.RealMatrix cachedP -> a
    org.apache.commons.math3.linear.RealMatrix cachedT -> b
    double epsilon -> a
    org.apache.commons.math3.linear.RealMatrix getT() -> a
    void transform() -> a
org.apache.commons.math3.linear.SchurTransformer$ShiftInfo -> jd:
    double x -> a
    double y -> b
    double w -> c
    double exShift -> d
org.apache.commons.math3.linear.SingularMatrixException -> je:
org.apache.commons.math3.linear.SingularValueDecomposition -> jf:
    double[] singularValues -> a
    int m -> a
    int n -> b
    boolean transposed -> a
    org.apache.commons.math3.linear.RealMatrix cachedU -> a
    org.apache.commons.math3.linear.RealMatrix cachedS -> b
    org.apache.commons.math3.linear.RealMatrix cachedV -> c
org.apache.commons.math3.linear.TriDiagonalTransformer -> jg:
    double[][] householderVectors -> a
    double[] main -> a
    double[] secondary -> b
    org.apache.commons.math3.linear.RealMatrix cachedQ -> a
    org.apache.commons.math3.linear.RealMatrix cachedQt -> b
    org.apache.commons.math3.linear.RealMatrix getQT() -> a
    void transform() -> a
org.apache.commons.math3.optim.BaseMultivariateOptimizer -> jh:
    double[] start -> a
    double[] lowerBound -> b
    double[] upperBound -> c
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.BaseOptimizer -> ji:
    org.apache.commons.math3.util.Incrementor evaluations -> a
    org.apache.commons.math3.util.Incrementor iterations -> b
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object doOptimize() -> a
    void incrementIterationCount() -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.BaseOptimizer$MaxEvalCallback -> jj:
    void trigger(int) -> a
org.apache.commons.math3.optim.BaseOptimizer$MaxIterCallback -> jk:
    void trigger(int) -> a
org.apache.commons.math3.optim.InitialGuess -> jl:
    double[] init -> a
    double[] getInitialGuess() -> a
org.apache.commons.math3.optim.MaxEval -> jm:
    int maxEval -> a
org.apache.commons.math3.optim.MaxIter -> jn:
    int maxIter -> a
org.apache.commons.math3.optim.PointValuePair -> jo:
    double[] getPoint() -> a
org.apache.commons.math3.optim.SimpleBounds -> jp:
    double[] lower -> a
    double[] upper -> b
    double[] getLower() -> a
    double[] getUpper() -> b
org.apache.commons.math3.optim.linear.LinearConstraint -> jq:
    org.apache.commons.math3.linear.RealVector coefficients -> a
    org.apache.commons.math3.optim.linear.Relationship relationship -> a
    double value -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.optim.linear.LinearConstraintSet -> jr:
    java.util.Set linearConstraints -> a
org.apache.commons.math3.optim.linear.LinearObjectiveFunction -> js:
    org.apache.commons.math3.linear.RealVector coefficients -> a
    double constantTerm -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.optim.linear.LinearOptimizer -> jt:
    org.apache.commons.math3.optim.linear.LinearObjectiveFunction function -> a
    java.util.Collection linearConstraints -> a
    boolean nonNegative -> a
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.linear.NoFeasibleSolutionException -> ju:
org.apache.commons.math3.optim.linear.NonNegativeConstraint -> jv:
    boolean isRestricted -> a
org.apache.commons.math3.optim.linear.PivotSelectionRule -> jw:
    org.apache.commons.math3.optim.linear.PivotSelectionRule DANTZIG -> a
    org.apache.commons.math3.optim.linear.PivotSelectionRule BLAND -> b
org.apache.commons.math3.optim.linear.Relationship -> jx:
    org.apache.commons.math3.optim.linear.Relationship EQ -> a
    org.apache.commons.math3.optim.linear.Relationship LEQ -> b
    org.apache.commons.math3.optim.linear.Relationship GEQ -> c
    java.lang.String stringValue -> a
    org.apache.commons.math3.optim.linear.Relationship[] $VALUES -> a
    org.apache.commons.math3.optim.linear.Relationship[] values() -> a
    java.lang.String toString() -> toString
org.apache.commons.math3.optim.linear.Relationship$1 -> jy:
    int[] $SwitchMap$org$apache$commons$math3$optim$linear$Relationship -> a
org.apache.commons.math3.optim.linear.SimplexSolver -> jz:
    double epsilon -> a
    int maxUlps -> a
    double cutOff -> b
    org.apache.commons.math3.optim.linear.PivotSelectionRule pivotSelection -> a
    org.apache.commons.math3.optim.linear.SolutionCallback solutionCallback -> a
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void doIteration(org.apache.commons.math3.optim.linear.SimplexTableau) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object doOptimize() -> a
org.apache.commons.math3.optim.linear.SimplexTableau -> jA:
    org.apache.commons.math3.optim.linear.LinearObjectiveFunction f -> a
    java.util.List constraints -> a
    boolean restrictToNonNegative -> a
    java.util.List columnLabels -> b
    org.apache.commons.math3.linear.Array2DRowRealMatrix tableau -> a
    int numDecisionVariables -> b
    int numSlackVariables -> c
    int numArtificialVariables -> a
    double epsilon -> a
    int maxUlps -> d
    int[] basicVariables -> b
    int[] basicRows -> a
    void initializeColumnLabels() -> b
    org.apache.commons.math3.linear.Array2DRowRealMatrix createTableau(boolean) -> a
    java.util.List normalizeConstraints(java.util.Collection) -> a
    int getNumObjectiveFunctions() -> a
    int getConstraintTypeCounts(org.apache.commons.math3.optim.linear.Relationship) -> a
    double getInvertedCoefficientSum(org.apache.commons.math3.linear.RealVector) -> a
    java.lang.Integer getBasicRow(int) -> a
    void initializeBasicVariables(int) -> a
    void dropPhase1Objective() -> a
    void copyArray(double[],double[]) -> a
    boolean isOptimal() -> a
    org.apache.commons.math3.optim.PointValuePair getSolution() -> a
    void performRowOperations(int,int) -> a
    double getEntry(int,int) -> a
    int getSlackVariableOffset() -> d
    int getArtificialVariableOffset() -> b
    int getRhsOffset() -> c
    int getOriginalNumDecisionVariables() -> e
    double[] getRow(int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.optim.linear.SolutionCallback -> jB:
org.apache.commons.math3.optim.linear.UnboundedSolutionException -> jC:
org.apache.commons.math3.optim.nonlinear.scalar.GoalType -> jD:
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType MAXIMIZE -> a
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType MINIMIZE -> b
org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer -> jE:
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal -> a
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optimization.BaseMultivariateVectorOptimizer -> jF:
    org.apache.commons.math3.optimization.PointVectorValuePair optimize(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,double[],double[],double[]) -> a
org.apache.commons.math3.optimization.ConvergenceChecker -> jG:
    boolean converged$51f99816() -> a
org.apache.commons.math3.optimization.InitialGuess -> jH:
    double[] init -> a
    double[] getInitialGuess() -> a
org.apache.commons.math3.optimization.PointVectorValuePair -> jI:
    double[] getPoint() -> a
    java.lang.Object getValue() -> a
org.apache.commons.math3.optimization.Target -> jJ:
    double[] target -> a
    double[] getTarget() -> a
org.apache.commons.math3.optimization.Weight -> jK:
    org.apache.commons.math3.linear.RealMatrix weightMatrix -> a
org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateVectorOptimizer -> jL:
    org.apache.commons.math3.util.Incrementor evaluations -> a
    org.apache.commons.math3.optimization.ConvergenceChecker checker -> a
    double[] target -> a
    org.apache.commons.math3.linear.RealMatrix weightMatrix -> a
    double[] weight -> b
    double[] start -> c
    org.apache.commons.math3.analysis.MultivariateVectorFunction function -> a
    double[] computeObjectiveValue(double[]) -> a
    org.apache.commons.math3.optimization.PointVectorValuePair optimize(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,double[],double[],double[]) -> a
    org.apache.commons.math3.optimization.PointVectorValuePair optimizeInternal$4b638827(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    double[] getStartPoint() -> a
    org.apache.commons.math3.linear.RealMatrix getWeight() -> a
    double[] getTarget() -> b
    org.apache.commons.math3.optimization.PointVectorValuePair doOptimize() -> a
    void setUp() -> a
org.apache.commons.math3.optimization.fitting.CurveFitter -> jM:
    org.apache.commons.math3.analysis.DifferentiableUnivariateFunction oldOptimizer$11dadcd7 -> a
    cc.redberry.core.math.frobenius.SolutionProvider optimizer$4f2d0069 -> a
    java.util.List observations -> a
    void addObservedPoint(double,double,double) -> a
org.apache.commons.math3.optimization.fitting.CurveFitter$OldTheoreticalValuesFunction -> jN:
    org.apache.commons.math3.analysis.ParametricUnivariateFunction f -> a
    org.apache.commons.math3.optimization.fitting.CurveFitter this$0 -> a
    org.apache.commons.math3.analysis.MultivariateMatrixFunction jacobian() -> a
    double[] value(double[]) -> a
org.apache.commons.math3.optimization.fitting.CurveFitter$OldTheoreticalValuesFunction$1 -> jO:
    org.apache.commons.math3.optimization.fitting.CurveFitter$OldTheoreticalValuesFunction this$1 -> a
    double[][] value(double[]) -> a
org.apache.commons.math3.optimization.fitting.PolynomialFitter -> jP:
    int degree -> a
org.apache.commons.math3.optimization.fitting.WeightedObservedPoint -> jQ:
    double weight -> a
    double x -> b
    double y -> c
org.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer -> jR:
    double[] point -> a
    org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction jF -> a
    int jacobianEvaluations -> a
    org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt -> a
    double computeCost(double[]) -> a
    void setUp() -> a
    double[] computeResiduals(double[]) -> b
    org.apache.commons.math3.optimization.PointVectorValuePair optimize(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,double[],double[],double[]) -> a
org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer -> jS:
    int solvedCols -> b
    double[] diagR -> b
    double[] jacNorm -> c
    double[] beta -> d
    int[] permutation -> a
    int rank -> c
    double lmPar -> a
    double[] lmDir -> e
    double initialStepBoundFactor -> b
    double costRelativeTolerance -> c
    double parRelativeTolerance -> d
    double orthoTolerance -> e
    double qrRankingThreshold -> f
    double[] weightedResidual -> f
    double[][] weightedJacobian -> a
    org.apache.commons.math3.optimization.PointVectorValuePair doOptimize() -> a
org.apache.commons.math3.random.AbstractWell -> jT:
    int index -> a
    int[] v -> a
    int[] iRm1 -> b
    int[] iRm2 -> c
    int[] i1 -> d
    int[] i2 -> e
    int[] i3 -> f
    void setSeed(int[]) -> a
    int next(int) -> a
org.apache.commons.math3.random.BitsStreamGenerator -> jU:
    int next(int) -> a
    double nextDouble() -> a
    int nextInt() -> a
    int nextInt(int) -> b
org.apache.commons.math3.random.RandomDataGenerator -> jV:
org.apache.commons.math3.random.RandomDataImpl -> jW:
org.apache.commons.math3.random.RandomGenerator -> jX:
    int nextInt() -> a
    int nextInt(int) -> b
    double nextDouble() -> a
org.apache.commons.math3.random.Well19937c -> jY:
    int next(int) -> a
org.apache.commons.math3.special.Gamma -> jZ:
    double[] LANCZOS -> a
    double HALF_LOG_2_PI -> a
    double logGamma(double) -> a
    double regularizedGammaP(double,double,double,int) -> a
    double logGamma1p(double) -> b
org.apache.commons.math3.special.Gamma$1 -> ka:
    double val$a -> a
    double getA(int,double) -> a
    double getB$255dfbe(int) -> a
org.apache.commons.math3.stat.StatUtils -> kb:
    org.apache.commons.math3.stat.descriptive.moment.GeometricMean GEOMETRIC_MEAN -> a
    double geometricMean(double[]) -> a
org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic -> kc:
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
    void clear() -> a
    double getResult() -> a
    void increment(double) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic -> kd:
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic -> ke:
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
org.apache.commons.math3.stat.descriptive.UnivariateStatistic -> kf:
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.moment.FirstMoment -> kg:
    long n -> a
    double m1 -> a
    double dev -> b
    double nDev -> c
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
org.apache.commons.math3.stat.descriptive.moment.GeometricMean -> kh:
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic sumOfLogs -> a
    void increment(double) -> a
    double getResult() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
    long getN() -> a
org.apache.commons.math3.stat.descriptive.moment.Mean -> ki:
    org.apache.commons.math3.stat.descriptive.moment.FirstMoment moment -> a
    boolean incMoment -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.moment.SecondMoment -> kj:
    double m2 -> d
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
org.apache.commons.math3.stat.descriptive.moment.Variance -> kk:
    org.apache.commons.math3.stat.descriptive.moment.SecondMoment moment -> a
    boolean incMoment -> a
    boolean isBiasCorrected -> b
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Max -> kl:
    long n -> a
    double value -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Min -> km:
    long n -> a
    double value -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile -> kn:
    org.apache.commons.math3.util.KthSelector kthSelector -> a
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType estimationType -> a
    org.apache.commons.math3.stat.ranking.NaNStrategy nanStrategy -> a
    double quantile -> a
    int[] cachedPivots -> a
    double evaluate(double[],int,int) -> a
    double[] copyOf(double[],int,int) -> a
    double[] replaceAndSlice(double[],int,int,double,double) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$1 -> ko:
    int[] $SwitchMap$org$apache$commons$math3$stat$ranking$NaNStrategy -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType -> kp:
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType LEGACY -> a
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_1 -> b
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_2 -> c
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_3 -> d
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_4 -> e
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_5 -> f
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_6 -> g
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_7 -> h
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_8 -> i
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_9 -> j
    double index(double,int) -> a
    double estimate(double[],int[],double,int,org.apache.commons.math3.util.KthSelector) -> a
    double evaluate(double[],int[],double,org.apache.commons.math3.util.KthSelector) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$1 -> kq:
    double index(double,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$10 -> kr:
    double index(double,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$2 -> ks:
    double index(double,int) -> a
    double estimate(double[],int[],double,int,org.apache.commons.math3.util.KthSelector) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$3 -> kt:
    double index(double,int) -> a
    double estimate(double[],int[],double,int,org.apache.commons.math3.util.KthSelector) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$4 -> ku:
    double index(double,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$5 -> kv:
    double index(double,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$6 -> kw:
    double index(double,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$7 -> kx:
    double index(double,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$8 -> ky:
    double index(double,int) -> a
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$9 -> kz:
    double index(double,int) -> a
org.apache.commons.math3.stat.descriptive.summary.Product -> kA:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.summary.Sum -> kB:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.summary.SumOfLogs -> kC:
    int n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.descriptive.summary.SumOfSquares -> kD:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math3.stat.ranking.NaNStrategy -> kE:
    org.apache.commons.math3.stat.ranking.NaNStrategy MINIMAL -> a
    org.apache.commons.math3.stat.ranking.NaNStrategy MAXIMAL -> b
    org.apache.commons.math3.stat.ranking.NaNStrategy REMOVED -> c
    org.apache.commons.math3.stat.ranking.NaNStrategy FIXED -> e
    org.apache.commons.math3.stat.ranking.NaNStrategy FAILED -> d
    org.apache.commons.math3.stat.ranking.NaNStrategy[] $VALUES -> a
    org.apache.commons.math3.stat.ranking.NaNStrategy[] values() -> a
org.apache.commons.math3.transform.DftNormalization -> kF:
    int STANDARD$1f30b0a8 -> a
    int UNITARY$1f30b0a8 -> b
    int[] $VALUES$289551dd -> a
    int[] values$86c13e2() -> a
org.apache.commons.math3.transform.FastFourierTransformer -> kG:
    double[] W_SUB_N_R -> a
    double[] W_SUB_N_I -> b
    int normalization$1f30b0a8 -> a
    boolean $assertionsDisabled -> a
    void normalizeTransformedData$394e5a16(double[][],int,int) -> a
org.apache.commons.math3.transform.FastFourierTransformer$1 -> kH:
    int[] $SwitchMap$org$apache$commons$math3$transform$DftNormalization -> a
org.apache.commons.math3.transform.TransformUtils -> kI:
    org.apache.commons.math3.complex.Complex[] createComplexArray(double[][]) -> a
org.apache.commons.math3.util.ContinuedFraction -> kJ:
    double getA(int,double) -> a
    double getB$255dfbe(int) -> a
    double evaluate(double,double,int) -> a
org.apache.commons.math3.util.FastMath -> kK:
    double LOG_MAX_VALUE -> a
    double[][] LN_QUICK_COEF -> a
    double[][] LN_HI_PREC_COEF -> b
    double[] SINE_TABLE_A -> a
    double[] SINE_TABLE_B -> b
    double[] COSINE_TABLE_A -> c
    double[] COSINE_TABLE_B -> d
    double[] TANGENT_TABLE_A -> e
    double[] TANGENT_TABLE_B -> f
    long[] RECIP_2PI -> a
    long[] PI_O_4_BITS -> b
    double[] EIGHTHS -> g
    double doubleHighPart(double) -> n
    double sqrt(double) -> a
    double cosh(double) -> b
    double sinh(double) -> c
    double signum(double) -> d
    double exp(double) -> e
    double exp(double,double,double[]) -> a
    double log(double) -> f
    double log(double,double[]) -> a
    double log1p(double) -> g
    double pow(double,double) -> a
    double pow(double,int) -> a
    double sinQ(double,double) -> g
    double cosQ(double,double) -> h
    void reducePayneHanek(double,double[]) -> a
    double sin(double) -> h
    double cos(double) -> i
    double atan(double,double,boolean) -> a
    double atan2(double,double) -> b
    int abs(int) -> a
    long abs(long) -> a
    double abs(double) -> j
    double scalb(double,int) -> b
    double floor(double) -> k
    double ceil(double) -> l
    double rint(double) -> m
    int min(int,int) -> a
    double min(double,double) -> c
    int max(int,int) -> b
    double max(double,double) -> d
    double hypot(double,double) -> e
    double copySign(double,double) -> f
    int getExponent(double) -> a
    int getExponent(float) -> a
org.apache.commons.math3.util.FastMath$CodyWaite -> kL:
    int finalK -> a
    double finalRemA -> a
    double finalRemB -> b
org.apache.commons.math3.util.FastMath$ExpFracTable -> kM:
    double[] EXP_FRAC_TABLE_A -> a
    double[] EXP_FRAC_TABLE_B -> b
    double[] access$200() -> a
    double[] access$300() -> b
org.apache.commons.math3.util.FastMath$ExpIntTable -> kN:
    double[] EXP_INT_TABLE_A -> a
    double[] EXP_INT_TABLE_B -> b
    double[] access$000() -> a
    double[] access$100() -> b
org.apache.commons.math3.util.FastMath$lnMant -> kO:
    double[][] LN_MANT -> a
    double[][] access$400() -> a
org.apache.commons.math3.util.FastMathLiteralArrays -> kP:
    double[] EXP_INT_A -> a
    double[] EXP_INT_B -> b
    double[] EXP_FRAC_A -> c
    double[] EXP_FRAC_B -> d
    double[][] LN_MANT -> a
    double[] loadExpIntA() -> a
    double[] loadExpIntB() -> b
    double[] loadExpFracA() -> c
    double[] loadExpFracB() -> d
    double[][] loadLnMant() -> a
org.apache.commons.math3.util.Incrementor -> kQ:
    int maximalCount -> a
    int count -> b
    org.apache.commons.math3.util.Incrementor$MaxCountExceededCallback maxCountCallback -> a
    void incrementCount() -> a
org.apache.commons.math3.util.Incrementor$1 -> kR:
    void trigger(int) -> a
org.apache.commons.math3.util.Incrementor$MaxCountExceededCallback -> kS:
    void trigger(int) -> a
org.apache.commons.math3.util.KthSelector -> kT:
    org.apache.commons.math3.util.PivotingStrategyInterface pivotingStrategy -> a
    double select(double[],int[],int) -> a
org.apache.commons.math3.util.MathArrays$3 -> kU:
    int[] $SwitchMap$org$apache$commons$math3$util$MathArrays$OrderDirection -> a
    int[] $SwitchMap$org$apache$commons$math3$util$MathArrays$Position -> b
org.apache.commons.math3.util.MathArrays$OrderDirection -> kV:
    int INCREASING$37efe540 -> a
    int DECREASING$37efe540 -> b
    int[] $VALUES$50371d45 -> a
    int[] values$121350fa() -> a
org.apache.commons.math3.util.MathArrays$Position -> kW:
    int HEAD$748fd098 -> a
    int TAIL$748fd098 -> b
    int[] $VALUES$2890f0d3 -> a
    int[] values$75deba52() -> a
org.apache.commons.math3.util.MedianOf3PivotingStrategy -> kX:
    int pivotIndex(double[],int,int) -> a
org.apache.commons.math3.util.Pair -> kY:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.Object getValue() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.apache.commons.math3.util.PivotingStrategyInterface -> kZ:
    int pivotIndex(double[],int,int) -> a
org.apache.commons.math3.util.Precision -> la:
    double EPSILON -> a
    double SAFE_MIN -> b
    long POSITIVE_ZERO_DOUBLE_BITS -> a
    long NEGATIVE_ZERO_DOUBLE_BITS -> b
    int POSITIVE_ZERO_FLOAT_BITS -> a
    int NEGATIVE_ZERO_FLOAT_BITS -> b
    int compareTo(double,double,double) -> a
    boolean equalsIncludingNaN(float,float) -> a
    boolean equals(double,double) -> a
    boolean equalsIncludingNaN(double,double) -> b
    boolean equals(double,double,double) -> a
    boolean equalsWithRelativeTolerance(double,double,double) -> b
    boolean equals(double,double,int) -> a
org.apfloat.Apcomplex -> org.apfloat.Apcomplex:
    org.apfloat.Apint ZERO -> a
    org.apfloat.Apint ONE -> b
    org.apfloat.Apint MINUS_ONE -> c
    org.apfloat.Apcomplex I -> a
    org.apfloat.Apint[] ONES -> a
    org.apfloat.Apfloat real -> a
    org.apfloat.Apfloat imag -> b
    int radix() -> radix
    org.apfloat.Apfloat real() -> real
    org.apfloat.Apfloat imag() -> imag
    org.apfloat.Apcomplex conj() -> conj
    long precision() -> precision
    org.apfloat.Apcomplex precision(long) -> precision
    long scale() -> scale
    long size() -> size
    org.apfloat.Apcomplex negate() -> negate
    org.apfloat.Apcomplex inverse() -> inverse
    org.apfloat.Apcomplex add(org.apfloat.Apcomplex) -> add
    org.apfloat.Apcomplex subtract(org.apfloat.Apcomplex) -> subtract
    org.apfloat.Apcomplex multiply(org.apfloat.Apcomplex) -> multiply
    org.apfloat.Apcomplex divide(org.apfloat.Apcomplex) -> divide
    double doubleValue() -> doubleValue
    float floatValue() -> floatValue
    byte byteValue() -> byteValue
    short shortValue() -> shortValue
    int intValue() -> intValue
    long longValue() -> longValue
    long equalDigits(org.apfloat.Apcomplex) -> equalDigits
    org.apfloat.Apcomplex toRadix(int) -> toRadix
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer) -> writeTo
    void writeTo(java.io.Writer,boolean) -> writeTo
    void formatTo(java.util.Formatter,int,int,int) -> formatTo
org.apfloat.ApcomplexMath -> lb:
    boolean $assertionsDisabled -> a
    org.apfloat.Apfloat abs(org.apfloat.Apcomplex) -> a
    org.apfloat.Apfloat norm(org.apfloat.Apcomplex) -> b
    org.apfloat.Apfloat arg(org.apfloat.Apcomplex) -> c
    org.apfloat.Apcomplex scale(org.apfloat.Apcomplex,long) -> b
    org.apfloat.Apcomplex powAbs(org.apfloat.Apcomplex,long) -> c
    org.apfloat.Apcomplex sqrt(org.apfloat.Apcomplex) -> a
    org.apfloat.Apcomplex inverseRoot(org.apfloat.Apcomplex,long) -> a
    org.apfloat.Apcomplex inverseRootAbs(org.apfloat.Apcomplex,long,long) -> a
    org.apfloat.Apcomplex agm(org.apfloat.Apcomplex,org.apfloat.Apcomplex) -> b
    org.apfloat.Apcomplex log(org.apfloat.Apcomplex) -> b
    org.apfloat.Apcomplex exp(org.apfloat.Apcomplex) -> c
    org.apfloat.Apcomplex pow(org.apfloat.Apcomplex,org.apfloat.Apcomplex) -> a
    org.apfloat.Apcomplex acos(org.apfloat.Apcomplex) -> d
    org.apfloat.Apcomplex acosh(org.apfloat.Apcomplex) -> e
    org.apfloat.Apcomplex asin(org.apfloat.Apcomplex) -> f
    org.apfloat.Apcomplex asinh(org.apfloat.Apcomplex) -> g
    org.apfloat.Apcomplex atan(org.apfloat.Apcomplex) -> h
    org.apfloat.Apcomplex atanh(org.apfloat.Apcomplex) -> i
    org.apfloat.Apcomplex cos(org.apfloat.Apcomplex) -> j
    org.apfloat.Apcomplex cosh(org.apfloat.Apcomplex) -> k
    org.apfloat.Apcomplex sin(org.apfloat.Apcomplex) -> l
    org.apfloat.Apcomplex sinh(org.apfloat.Apcomplex) -> m
    org.apfloat.Apcomplex tan(org.apfloat.Apcomplex) -> n
    org.apfloat.Apcomplex tanh(org.apfloat.Apcomplex) -> o
    org.apfloat.Apcomplex w(org.apfloat.Apcomplex) -> p
    org.apfloat.Apcomplex lastIterationExtendPrecision(int,int,org.apfloat.Apcomplex) -> a
org.apfloat.Apfloat -> org.apfloat.Apfloat:
    org.apfloat.spi.ApfloatImpl impl -> a
    boolean $assertionsDisabled -> a
    int radix() -> radix
    org.apfloat.Apfloat real() -> real
    org.apfloat.Apfloat imag() -> imag
    long precision() -> precision
    org.apfloat.Apfloat precision(long) -> precision
    long scale() -> scale
    long size() -> size
    int signum() -> signum
    boolean isShort() -> isShort
    org.apfloat.Apfloat negate() -> negate
    org.apfloat.Apfloat inverse() -> inverse
    org.apfloat.Apfloat add(org.apfloat.Apfloat) -> add
    org.apfloat.Apfloat subtract(org.apfloat.Apfloat) -> subtract
    org.apfloat.Apfloat addOrSubtract(org.apfloat.Apfloat,boolean) -> a
    org.apfloat.Apfloat multiply(org.apfloat.Apfloat) -> multiply
    org.apfloat.Apfloat divide(org.apfloat.Apfloat) -> divide
    org.apfloat.Apfloat mod(org.apfloat.Apfloat) -> mod
    org.apfloat.Apint floor() -> floor
    org.apfloat.Apint ceil() -> ceil
    org.apfloat.Apint truncate() -> truncate
    org.apfloat.Apfloat frac() -> frac
    double doubleValue() -> doubleValue
    float floatValue() -> floatValue
    byte byteValue() -> byteValue
    short shortValue() -> shortValue
    int intValue() -> intValue
    long longValue() -> longValue
    long equalDigits(org.apfloat.Apfloat) -> equalDigits
    org.apfloat.Apfloat toRadix(int) -> toRadix
    int compareTo(org.apfloat.Apfloat) -> compareTo
    boolean preferCompare(org.apfloat.Apfloat) -> preferCompare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer,boolean) -> writeTo
    void formatTo(java.util.Formatter,int,int,int) -> formatTo
    org.apfloat.spi.ApfloatImpl getImpl(long) -> a
    org.apfloat.Apint roundAway() -> roundAway
    org.apfloat.Apfloat scale(long) -> scale
    org.apfloat.Apfloat abs() -> abs
    int compareToHalf() -> compareToHalf
    org.apfloat.spi.ApfloatImpl getImpl() -> a
    org.apfloat.Apcomplex toRadix(int) -> toRadix
    org.apfloat.Apcomplex inverse() -> inverse
    org.apfloat.Apcomplex negate() -> negate
    org.apfloat.Apcomplex precision(long) -> precision
    int compareTo(java.lang.Object) -> compareTo
org.apfloat.ApfloatConfigurationException -> lc:
org.apfloat.ApfloatContext -> ld:
    org.apfloat.ApfloatContext globalContext -> a
    java.util.Map threadContexts -> a
    java.util.Properties defaultProperties -> a
    java.util.concurrent.ExecutorService defaultExecutorService -> b
    org.apfloat.spi.BuilderFactory builderFactory -> a
    org.apfloat.spi.FilenameGenerator filenameGenerator -> a
    int defaultRadix -> a
    long maxMemoryBlockSize -> a
    int cacheL1Size -> b
    int cacheL2Size -> c
    int cacheBurst -> d
    long memoryThreshold -> b
    long sharedMemoryTreshold -> c
    int blockSize -> e
    int numberOfProcessors -> f
    java.util.Properties properties -> b
    java.lang.Object sharedMemoryLock -> a
    java.util.concurrent.ExecutorService executorService -> a
    java.util.concurrent.ConcurrentHashMap attributes -> a
    org.apfloat.ApfloatContext getContext() -> a
    void setFilenameGenerator(org.apfloat.spi.FilenameGenerator) -> a
    void setNumberOfProcessors(int) -> a
    java.lang.String getProperty(java.lang.String) -> a
    java.util.Properties loadProperties() -> a
    void setProperties(java.util.Properties) -> a
    java.lang.Object clone() -> clone
org.apfloat.ApfloatContext$1 -> le:
    java.util.concurrent.ThreadFactory defaultThreadFactory -> a
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
org.apfloat.ApfloatHelper -> lf:
    boolean $assertionsDisabled -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl implCreateApfloat(java.lang.String,long,int,boolean) -> b
    org.apfloat.spi.ApfloatImpl createApfloat(long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl implCreateApfloat(long,long,int) -> b
    org.apfloat.spi.ApfloatImpl createApfloat(float) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(float,long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(float,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl implCreateApfloat(double,long,int) -> b
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl implCreateApfloat(java.io.PushbackReader,long,int,boolean) -> b
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigInteger) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigInteger,long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigInteger,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigDecimal) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigDecimal,long) -> a
    boolean readMatch(java.io.PushbackReader,int) -> a
    void extractWhitespace(java.io.PushbackReader) -> a
    long[] getMatchingPrecisions(org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    long[] getMatchingPrecisions(org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    void checkPrecision(long) -> a
    void checkPowPrecision(long) -> b
    org.apfloat.Apcomplex checkPowBasic(org.apfloat.Apcomplex,org.apfloat.Apcomplex,long) -> b
    org.apfloat.Apcomplex checkPow(org.apfloat.Apcomplex,org.apfloat.Apcomplex,long) -> a
    org.apfloat.Apfloat checkPow(org.apfloat.Apfloat,org.apfloat.Apfloat,long) -> a
    int getFloatPrecision(int) -> c
    int getDoublePrecision(int) -> a
    int getLongPrecision(int) -> b
    org.apfloat.Apfloat limitPrecision(org.apfloat.Apfloat,long) -> a
    org.apfloat.Apfloat ensurePrecision(org.apfloat.Apfloat,long) -> b
    long extendPrecision(long,long) -> a
    long extendPrecision(long) -> a
    org.apfloat.Apfloat extendPrecision(org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat extendPrecision(org.apfloat.Apfloat,long) -> c
    org.apfloat.Apcomplex setPrecision(org.apfloat.Apcomplex,long) -> a
    org.apfloat.Apcomplex limitPrecision(org.apfloat.Apcomplex,long) -> b
    org.apfloat.Apcomplex ensurePrecision(org.apfloat.Apcomplex,long) -> c
    org.apfloat.Apcomplex extendPrecision(org.apfloat.Apcomplex) -> a
    org.apfloat.Apcomplex extendPrecision(org.apfloat.Apcomplex,long) -> d
    java.math.BigInteger toBigInteger(org.apfloat.Apint) -> a
    int getDefaultRadix() -> a
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> a
org.apfloat.ApfloatHelper$1 -> lg:
    int b -> a
    int bytePosition -> b
    boolean hi -> a
    byte[] val$bytes -> a
    boolean val$startHi -> b
    void write(int) -> write
    void write(char[],int,int) -> write
    void close() -> close
    void flush() -> flush
org.apfloat.ApfloatHelper$2 -> lh:
    int b -> a
    int val$startB -> b
    int read() -> read
    int read(byte[],int,int) -> read
org.apfloat.ApfloatMath -> li:
    java.util.Map SHUTDOWN_MAP -> a
    java.util.concurrent.ConcurrentMap radixPiKeys -> a
    java.util.Map radixPi -> b
    java.util.Map radixPiCalculator -> c
    java.util.Map radixPiT -> d
    java.util.Map radixPiQ -> e
    java.util.Map radixPiP -> f
    java.util.Map radixPiInverseRoot -> g
    java.util.Map radixPiTerms -> h
    java.util.concurrent.ConcurrentMap radixLogKeys -> b
    java.util.Map radixLog -> i
    java.util.Map radixLogPi -> j
    boolean $assertionsDisabled -> a
    org.apfloat.Apfloat pow(org.apfloat.Apfloat,long) -> d
    org.apfloat.Apfloat sqrt(org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat root(org.apfloat.Apfloat,long) -> a
    org.apfloat.Apfloat inverseRoot(org.apfloat.Apfloat,long) -> b
    org.apfloat.Apfloat inverseRoot(org.apfloat.Apfloat,long,long) -> a
    org.apfloat.Apfloat inverseRoot(org.apfloat.Apfloat,long,long,org.apfloat.Apfloat) -> a
    org.apfloat.Apint floor(org.apfloat.Apfloat) -> a
    org.apfloat.Apint ceil(org.apfloat.Apfloat) -> b
    org.apfloat.Apfloat round(org.apfloat.Apfloat,long,java.math.RoundingMode) -> a
    org.apfloat.Apfloat abs(org.apfloat.Apfloat) -> b
    org.apfloat.Apfloat scale(org.apfloat.Apfloat,long) -> c
    org.apfloat.Apfloat fmod(org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat multiplyAdd(org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat multiplySubtract(org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat) -> b
    org.apfloat.Apfloat multiplyAddOrSubtract(org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,boolean) -> a
    org.apfloat.Apfloat agm(org.apfloat.Apfloat,org.apfloat.Apfloat) -> b
    org.apfloat.Apfloat pi(long) -> a
    org.apfloat.Apfloat pi(long,int) -> a
    org.apfloat.Apfloat log(org.apfloat.Apfloat) -> c
    org.apfloat.Apfloat rawLog(org.apfloat.Apfloat,boolean) -> a
    org.apfloat.Apfloat logRadix(long,int) -> b
    org.apfloat.Apfloat logRadix(long,int,boolean) -> a
    org.apfloat.Apfloat exp(org.apfloat.Apfloat) -> d
    org.apfloat.Apfloat pow(org.apfloat.Apfloat,org.apfloat.Apfloat) -> c
    org.apfloat.Apfloat acosh(org.apfloat.Apfloat) -> e
    org.apfloat.Apfloat asinh(org.apfloat.Apfloat) -> f
    org.apfloat.Apfloat atanh(org.apfloat.Apfloat) -> g
    org.apfloat.Apfloat cosh(org.apfloat.Apfloat) -> h
    org.apfloat.Apfloat sinh(org.apfloat.Apfloat) -> i
    org.apfloat.Apfloat tanh(org.apfloat.Apfloat) -> j
    org.apfloat.Apfloat acos(org.apfloat.Apfloat) -> k
    org.apfloat.Apfloat asin(org.apfloat.Apfloat) -> l
    org.apfloat.Apfloat atan(org.apfloat.Apfloat) -> m
    org.apfloat.Apfloat atan2(org.apfloat.Apfloat,org.apfloat.Apfloat) -> d
    org.apfloat.Apfloat cos(org.apfloat.Apfloat) -> n
    org.apfloat.Apfloat sin(org.apfloat.Apfloat) -> o
    org.apfloat.Apfloat tan(org.apfloat.Apfloat) -> p
    org.apfloat.Apfloat w(org.apfloat.Apfloat) -> q
    org.apfloat.Apfloat lastIterationExtendPrecision(int,int,org.apfloat.Apfloat) -> a
org.apfloat.ApfloatMath$ApfloatHolder -> lj:
    org.apfloat.Apfloat apfloat -> a
org.apfloat.ApfloatMath$PiCalculator -> lk:
    org.apfloat.Apfloat A -> a
    org.apfloat.Apfloat B -> b
    org.apfloat.Apfloat J -> c
    org.apfloat.Apfloat ONE -> d
    org.apfloat.Apfloat TWO -> e
    org.apfloat.Apfloat FIVE -> f
    org.apfloat.Apfloat SIX -> g
    int radix -> a
    boolean $assertionsDisabled -> a
    void r(long,long,org.apfloat.ApfloatMath$ApfloatHolder,org.apfloat.ApfloatMath$ApfloatHolder,org.apfloat.ApfloatMath$ApfloatHolder) -> a
org.apfloat.ApfloatRuntimeException -> ll:
org.apfloat.Apint -> lm:
    org.apfloat.Apfloat value -> a
    org.apfloat.Apint numerator() -> a
    org.apfloat.Apint denominator() -> b
    int radix() -> radix
    long scale() -> scale
    long size() -> size
    int signum() -> signum
    boolean isShort() -> isShort
    org.apfloat.Apint negate() -> c
    org.apfloat.Apint add(org.apfloat.Apint) -> a
    org.apfloat.Apint subtract(org.apfloat.Apint) -> b
    org.apfloat.Apint multiply(org.apfloat.Apint) -> c
    org.apfloat.Apint divide(org.apfloat.Apint) -> d
    org.apfloat.Apint mod(org.apfloat.Apint) -> e
    org.apfloat.Apint floor() -> floor
    org.apfloat.Apint ceil() -> ceil
    org.apfloat.Apint truncate() -> truncate
    java.math.BigInteger toBigInteger() -> a
    org.apfloat.Apint toRadix(int) -> a
    int compareTo(org.apfloat.Apint) -> a
    int compareTo(org.apfloat.Aprational) -> a
    int compareTo(org.apfloat.Apfloat) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer,boolean) -> writeTo
    void formatTo(java.util.Formatter,int,int,int) -> formatTo
    org.apfloat.spi.ApfloatImpl getImpl(long) -> a
    org.apfloat.Apint roundAway() -> roundAway
    org.apfloat.Aprational abs() -> a
    org.apfloat.Aprational toRadix(int) -> a
    org.apfloat.Aprational frac() -> b
    org.apfloat.Aprational negate() -> c
    org.apfloat.Apfloat abs() -> abs
    org.apfloat.Apfloat toRadix(int) -> toRadix
    org.apfloat.Apfloat frac() -> frac
    org.apfloat.Apfloat negate() -> negate
    int compareTo(java.lang.Object) -> compareTo
    org.apfloat.Apcomplex toRadix(int) -> toRadix
    org.apfloat.Apcomplex negate() -> negate
org.apfloat.ApintMath -> ln:
    org.apfloat.Apint pow(org.apfloat.Apint,long) -> a
    org.apfloat.Apint abs(org.apfloat.Apint) -> a
    org.apfloat.Apint scale(org.apfloat.Apint,long) -> b
    org.apfloat.Apint[] div(org.apfloat.Apint,org.apfloat.Apint) -> a
    org.apfloat.Apint gcd(org.apfloat.Apint,org.apfloat.Apint) -> a
org.apfloat.Aprational -> lo:
    org.apfloat.Apint numerator -> d
    org.apfloat.Apint denominator -> e
    long scale -> a
    long size -> b
    java.lang.ref.SoftReference inverseDen -> a
    java.lang.ref.SoftReference approx -> b
    org.apfloat.Apint numerator() -> a
    org.apfloat.Apint denominator() -> b
    int radix() -> radix
    long precision() -> precision
    long scale() -> scale
    long size() -> size
    int signum() -> signum
    boolean isShort() -> isShort
    org.apfloat.Aprational negate() -> c
    org.apfloat.Apint floor() -> floor
    org.apfloat.Apint ceil() -> ceil
    org.apfloat.Apint truncate() -> truncate
    org.apfloat.Aprational frac() -> b
    org.apfloat.Aprational toRadix(int) -> a
    int compareTo(org.apfloat.Aprational) -> a
    int compareTo(org.apfloat.Apfloat) -> compareTo
    boolean preferCompare(org.apfloat.Apfloat) -> preferCompare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer) -> writeTo
    void writeTo(java.io.Writer,boolean) -> writeTo
    void formatTo(java.util.Formatter,int,int,int) -> formatTo
    org.apfloat.spi.ApfloatImpl getImpl(long) -> a
    org.apfloat.Apint roundAway() -> roundAway
    org.apfloat.Aprational abs() -> a
    int compareToHalf() -> compareToHalf
    org.apfloat.Aprational reduce() -> d
    org.apfloat.Apfloat ensureApprox(long) -> a
    void setApprox(org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat abs() -> abs
    org.apfloat.Apfloat scale(long) -> scale
    org.apfloat.Apfloat toRadix(int) -> toRadix
    org.apfloat.Apfloat frac() -> frac
    org.apfloat.Apfloat negate() -> negate
    int compareTo(java.lang.Object) -> compareTo
    org.apfloat.Apcomplex toRadix(int) -> toRadix
    org.apfloat.Apcomplex negate() -> negate
org.apfloat.ConcurrentSoftHashMap -> lp:
    java.util.concurrent.ConcurrentHashMap map -> a
    void clear() -> clear
    java.util.Set entrySet() -> entrySet
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object remove(java.lang.Object) -> remove
    int size() -> size
    java.lang.Object unwrap(java.lang.ref.SoftReference) -> a
org.apfloat.ConcurrentWeakHashMap -> lq:
    java.util.concurrent.ConcurrentHashMap map -> a
    java.lang.ref.ReferenceQueue queue -> a
    void clear() -> clear
    java.util.Set entrySet() -> entrySet
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object remove(java.lang.Object) -> remove
    int size() -> size
    org.apfloat.ConcurrentWeakHashMap$Key wrap(java.lang.Object) -> a
    void expungeStaleEntries() -> a
org.apfloat.ConcurrentWeakHashMap$Key -> lr:
    int hashCode -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apfloat.FormattingHelper$AppendableWriter -> ls:
    java.lang.Appendable out -> a
    void write(int) -> write
    void write(char[],int,int) -> write
    void write(java.lang.String,int,int) -> write
    java.io.Writer append(java.lang.CharSequence) -> append
    java.io.Writer append(java.lang.CharSequence,int,int) -> append
    void flush() -> flush
    void close() -> close
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
org.apfloat.FormattingHelper$BufferWriter -> lt:
    java.io.Writer out -> a
org.apfloat.FormattingHelper$CountWriter -> lu:
    long count -> a
    void write(int) -> write
    void write(char[],int,int) -> write
    void write(java.lang.String,int,int) -> write
org.apfloat.FormattingHelper$LocalizeWriter -> lv:
    java.util.Locale locale -> a
    boolean localizeDigits -> a
    boolean isUpperCase -> b
    char zero -> a
    char decimalSeparator -> b
    void write(int) -> write
    void write(char[],int,int) -> write
    void write(java.lang.String,int,int) -> write
org.apfloat.GCDHelper -> lw:
    boolean $assertionsDisabled -> a
    org.apfloat.Apint gcd(org.apfloat.Apint,org.apfloat.Apint) -> a
    org.apfloat.Apint elementaryGcd(org.apfloat.Apint,org.apfloat.Apint) -> b
    org.apfloat.Apint recursiveGcd(org.apfloat.Apint,org.apfloat.Apint) -> c
    org.apfloat.GCDHelper$HalfGcdType halfBinaryGcd(org.apfloat.Apint,org.apfloat.Apint,long) -> a
    org.apfloat.Apint[] binaryDivide(org.apfloat.Apint,org.apfloat.Apint) -> a
    long v(org.apfloat.Apint) -> a
    org.apfloat.Apint powerOfTwo(long) -> a
org.apfloat.GCDHelper$HalfGcdType -> lx:
    long j -> a
    org.apfloat.GCDHelper$Matrix r -> a
org.apfloat.GCDHelper$Matrix -> ly:
    org.apfloat.Apint r11 -> a
    org.apfloat.Apint r12 -> b
    org.apfloat.Apint r21 -> c
    org.apfloat.Apint r22 -> d
    org.apfloat.GCDHelper$Matrix multiply(org.apfloat.GCDHelper$Matrix) -> a
    org.apfloat.Apint multiplyAdd(org.apfloat.Apint,org.apfloat.Apint,org.apfloat.Apint,org.apfloat.Apint) -> a
org.apfloat.InfiniteExpansionException -> lz:
org.apfloat.LambertWHelper -> lA:
    org.apfloat.Apfloat x -> a
    org.apfloat.Apcomplex z -> a
    int radix -> a
    long precision -> a
    long targetPrecision -> b
    long k -> c
    boolean close -> a
    org.apfloat.Apint minusOne -> a
    org.apfloat.Apint one -> b
    org.apfloat.Apint two -> c
    org.apfloat.Apint three -> d
    org.apfloat.Apfloat twoPi -> b
    org.apfloat.Apfloat twoPiK -> c
    org.apfloat.Apfloat e -> d
    org.apfloat.Apfloat minusOnePerE -> e
    org.apfloat.Apcomplex p -> b
    boolean $assertionsDisabled -> b
    org.apfloat.Apfloat w(org.apfloat.Apfloat) -> a
    org.apfloat.Apcomplex w(org.apfloat.Apcomplex) -> a
    org.apfloat.Apfloat real() -> a
    org.apfloat.Apfloat doReal() -> b
    org.apfloat.Apcomplex complex() -> a
    org.apfloat.Apcomplex log(org.apfloat.Apcomplex) -> b
    org.apfloat.Apcomplex logApprox(org.apfloat.Apcomplex) -> c
    org.apfloat.Apcomplex p() -> b
    org.apfloat.Apfloat realSeries(org.apfloat.Apcomplex) -> a
    org.apfloat.Apcomplex complexSeries(org.apfloat.Apcomplex) -> d
    long shiftLeftPrecision(long,int) -> a
    long shiftLeftPrecision(long,int,long) -> a
    org.apfloat.Apfloat twoPi() -> c
org.apfloat.LambertWHelper$ComplexException -> lB:
    java.lang.ArithmeticException getCause() -> a
    java.lang.Throwable getCause() -> getCause
org.apfloat.LossOfPrecisionException -> lC:
org.apfloat.OverflowException -> lD:
org.apfloat.RadixConversionHelper$RadixPowerList -> lE:
    java.util.List list -> a
    org.apfloat.Apfloat pow(long) -> a
    org.apfloat.Apfloat get(int) -> a
org.apfloat.RoundingHelper$1 -> lF:
    int[] $SwitchMap$java$math$RoundingMode -> a
org.apfloat.ShutdownMap -> lG:
    java.util.Set entrySet() -> entrySet
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
org.apfloat.internal.AbstractConvolutionBuilder -> lH:
    double LOG2_3 -> a
    org.apfloat.spi.ConvolutionStrategy createConvolution$75792394(int,long,long) -> a
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.AbstractStepFNTStrategy -> lI:
    org.apfloat.spi.NTTStepStrategy stepStrategy -> a
    boolean $assertionsDisabled -> a
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void transform(org.apfloat.spi.DataStorage,int,int,long,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,int,long,long,int) -> a
org.apfloat.internal.ApfloatInternalException -> lJ:
org.apfloat.internal.BackingStorageException -> lK:
org.apfloat.internal.ConcurrentSoftHashMap -> lL:
    java.util.concurrent.ConcurrentHashMap map -> a
    void clear() -> clear
    java.util.Set entrySet() -> entrySet
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object) -> putIfAbsent
    java.lang.Object remove(java.lang.Object) -> remove
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    java.lang.Object replace(java.lang.Object,java.lang.Object) -> replace
    boolean replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    int size() -> size
    java.lang.ref.SoftReference wrap(java.lang.Object) -> a
    java.lang.Object unwrap(java.lang.ref.SoftReference) -> a
org.apfloat.internal.DiskDataStorage -> lM:
    java.nio.channels.ReadableByteChannel ZERO_CHANNEL -> a
    java.lang.ref.ReferenceQueue referenceQueue -> a
    java.util.Set references -> a
    java.lang.ThreadLocal threadLocal -> a
    boolean cleanUp -> a
    org.apfloat.internal.DiskDataStorage$FileStorage fileStorage -> a
    boolean $assertionsDisabled -> b
    boolean isCached() -> a
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> a
    long implGetSize() -> a
    void implSetSize(long) -> a
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> a
    void setTransposedArray(org.apfloat.spi.ArrayAccess,int,int,int) -> a
    void readToArray(long,org.apfloat.spi.ArrayAccess,int,int) -> a
    void writeFromArray(org.apfloat.spi.ArrayAccess,int,long,int) -> a
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> b
    void transferFrom(java.nio.channels.ReadableByteChannel,long,long) -> a
    void transferTo(java.nio.channels.WritableByteChannel,long,long) -> a
    int getBlockSize() -> a
    int getUnitSize() -> b
    void pad(long,long) -> a
    org.apfloat.internal.DiskDataStorage$FileStorage createFileStorage() -> a
    void referenceFileStorage(org.apfloat.internal.DiskDataStorage$FileStorage) -> b
    void freeFileStorage() -> c
    void forceFreeFileStorage() -> d
    void access$000(org.apfloat.internal.DiskDataStorage$FileStorage) -> a
    void access$100() -> a
    java.nio.ByteBuffer access$200() -> a
org.apfloat.internal.DiskDataStorage$1 -> lN:
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.DiskDataStorage$FileStorage -> lO:
    java.lang.String filename -> a
    java.io.File file -> a
    java.io.RandomAccessFile randomAccessFile -> a
    java.nio.channels.FileChannel fileChannel -> a
    boolean $assertionsDisabled -> a
    void setSize(long) -> a
org.apfloat.internal.DiskDataStorage$FileStorageReference -> lP:
    java.io.File file -> a
    java.io.RandomAccessFile randomAccessFile -> a
    java.nio.channels.FileChannel fileChannel -> a
    void dispose() -> a
org.apfloat.internal.DoubleAdditionBuilder -> lQ:
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.internal.DoubleAdditionStrategy -> lR:
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> b
org.apfloat.internal.DoubleApfloatBuilder -> lS:
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.internal.DoubleApfloatImpl -> lT:
    org.apfloat.spi.DataStorage$Iterator ZERO_ITERATOR -> a
    int sign -> b
    long precision -> a
    long exponent -> b
    org.apfloat.spi.DataStorage dataStorage -> a
    int radix -> c
    int hashCode -> d
    int initialDigits -> e
    long leastZeros -> c
    long size -> d
    boolean $assertionsDisabled -> b
    long readExponent(java.io.PushbackReader) -> a
    long getTrailingZeros(org.apfloat.spi.DataStorage,long) -> a
    long getLeadingZeros(org.apfloat.spi.DataStorage,long) -> b
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> a
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> a
    boolean isShort() -> a
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> b
    org.apfloat.spi.ApfloatImpl absFloor() -> a
    org.apfloat.spi.ApfloatImpl absCeil() -> b
    org.apfloat.spi.ApfloatImpl frac() -> c
    org.apfloat.spi.ApfloatImpl zero() -> e
    int radix() -> a
    long precision() -> a
    long size() -> b
    long getLeastZeros() -> e
    org.apfloat.spi.ApfloatImpl precision(long) -> a
    long scale() -> c
    int signum() -> b
    org.apfloat.spi.ApfloatImpl negate() -> d
    double doubleValue() -> a
    long longValue() -> d
    boolean isOne() -> b
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> a
    int compareTo(org.apfloat.spi.ApfloatImpl) -> a
    org.apfloat.spi.DataStorage$Iterator getZeroPaddedIterator(long,long) -> a
    int compareMantissaTo(org.apfloat.internal.DoubleApfloatImpl) -> a
    long findMismatch(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long) -> a
    double getLeastSignificantWord(long,double) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> a
    void writeZeros(java.io.Writer,long) -> a
    void writeTo(java.io.Writer,boolean) -> a
    long getSize() -> f
    int checkRadix(int) -> a
    double getMostSignificantWord(org.apfloat.spi.DataStorage) -> a
    int getInitialDigits() -> c
    int getInitialDigits(org.apfloat.spi.DataStorage) -> a
    int getDigits(double) -> a
    long getBasePrecision() -> g
    long getBasePrecision(long,int) -> a
    double getWord(long) -> a
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    double access$000(org.apfloat.internal.DoubleApfloatImpl,long,double) -> a
org.apfloat.internal.DoubleApfloatImpl$1 -> lU:
    void setDouble(double) -> a
    void next() -> a
org.apfloat.internal.DoubleApfloatImpl$2 -> lV:
    long index -> a
    long val$end -> b
    org.apfloat.spi.DataStorage$Iterator val$iterator -> a
    long val$start -> c
    org.apfloat.internal.DoubleApfloatImpl this$0 -> a
    double getDouble() -> a
    void next() -> a
    void close() -> b
org.apfloat.internal.DoubleApfloatImpl$3 -> lW:
    double getDouble() -> a
    void next() -> a
org.apfloat.internal.DoubleBaseMath -> lX:
    int radix -> a
    double inverseBase -> a
    boolean $assertionsDisabled -> a
    double baseAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,double,org.apfloat.spi.DataStorage$Iterator,long) -> a
    double baseSubtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,double,org.apfloat.spi.DataStorage$Iterator,long) -> b
    double baseMultiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,double,double,org.apfloat.spi.DataStorage$Iterator,long) -> a
org.apfloat.internal.DoubleBuilderFactory -> org.apfloat.internal.DoubleBuilderFactory:
    org.apfloat.spi.ApfloatBuilder apfloatBuilder -> a
    org.apfloat.spi.DataStorageBuilder dataStorageBuilder -> a
    org.apfloat.spi.AdditionBuilder additionBuilder -> a
    org.apfloat.spi.ConvolutionBuilder convolutionBuilder -> a
    org.apfloat.spi.NTTBuilder nttBuilder -> a
    org.apfloat.spi.MatrixBuilder matrixBuilder -> a
    org.apfloat.spi.CarryCRTBuilder carryCRTBuilder -> a
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> a
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> a
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> a
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> a
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> a
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> a
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> a
    java.lang.Class getElementArrayType() -> a
    int getElementSize() -> a
org.apfloat.internal.DoubleCRTMath -> lY:
    long base -> a
    double inverseBase -> a
    void multiply(double[],double,double[]) -> a
    double compare(double[],double[]) -> a
    double add(double[],double[]) -> b
    void subtract(double[],double[]) -> a
    double divide(double[]) -> a
org.apfloat.internal.DoubleCarryCRTBuilder -> lZ:
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.internal.DoubleCarryCRTStepStrategy -> ma:
    org.apfloat.internal.DoubleModMath MATH_MOD_0 -> a
    org.apfloat.internal.DoubleModMath MATH_MOD_1 -> b
    org.apfloat.internal.DoubleModMath MATH_MOD_2 -> c
    double T0 -> a
    double T1 -> b
    double T2 -> c
    double[] M01 -> a
    double[] M02 -> b
    double[] M12 -> c
    double[] M012 -> d
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage$Iterator arrayIterator(double[]) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> a
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> a
org.apfloat.internal.DoubleCarryCRTStepStrategy$1 -> mb:
    int position -> a
    boolean $assertionsDisabled -> a
    double[] val$data -> a
    boolean hasNext() -> a
    void next() -> a
    double getDouble() -> a
    void setDouble(double) -> a
org.apfloat.internal.DoubleCarryCRTStepStrategy$2 -> mc:
    long position -> a
    long val$size -> b
    org.apfloat.spi.DataStorage$Iterator val$iterator1 -> a
    org.apfloat.spi.DataStorage$Iterator val$iterator2 -> b
    boolean hasNext() -> a
    void next() -> a
    double getDouble() -> a
    void setDouble(double) -> a
    void close() -> b
org.apfloat.internal.DoubleConvolutionBuilder -> md:
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.DoubleDataStorageBuilder -> me:
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.DoubleDiskDataStorage -> mf:
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> b
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    int getUnitSize() -> b
org.apfloat.internal.DoubleDiskDataStorage$BlockIterator -> mg:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    double[] data -> a
    int offset -> c
    int remaining -> d
    boolean $assertionsDisabled -> a
    org.apfloat.internal.DoubleDiskDataStorage this$0 -> a
    void next() -> a
    double getDouble() -> a
    void setDouble(double) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void close() -> b
    void checkAvailable() -> f
org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess -> mh:
    int mode -> c
    long fileOffset -> a
    org.apfloat.internal.DoubleDiskDataStorage this$0 -> a
    void close() -> a
org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess$1 -> mi:
    int readPosition -> a
    double[] val$array -> a
    int write(java.nio.ByteBuffer) -> write
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess$2 -> mj:
    int writePosition -> a
    double[] val$array -> a
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.DoubleDiskDataStorage$TransposedMemoryArrayAccess -> mk:
    int mode -> c
    int startColumn -> d
    int columns -> e
    int rows -> f
    org.apfloat.internal.DoubleDiskDataStorage this$0 -> a
    void close() -> a
org.apfloat.internal.DoubleElementaryModMath -> ml:
    long longModulus -> a
    double modulus -> a
    double inverseModulus -> b
    double modMultiply(double,double) -> a
    double modAdd(double,double) -> b
    double modSubtract(double,double) -> c
    void setModulus(double) -> a
org.apfloat.internal.DoubleFactor3NTTStepStrategy -> mm:
    boolean $assertionsDisabled -> a
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.DoubleFactor3NTTStepStrategy$1 -> mn:
    org.apfloat.spi.DataStorage val$dataStorage0 -> a
    org.apfloat.spi.DataStorage val$dataStorage1 -> b
    org.apfloat.spi.DataStorage val$dataStorage2 -> c
    long val$startColumn -> a
    double val$w -> a
    double val$ww -> b
    double val$w1 -> c
    double val$w2 -> d
    boolean val$isInverse -> a
    org.apfloat.internal.DoubleFactor3NTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.DoubleFactor3NTTStepStrategy$ColumnTransformRunnable -> mo:
    org.apfloat.spi.DataStorage dataStorage0 -> a
    org.apfloat.spi.DataStorage dataStorage1 -> b
    org.apfloat.spi.DataStorage dataStorage2 -> c
    long startColumn -> a
    long columns -> b
    double w -> a
    double ww -> b
    double w1 -> c
    double w2 -> d
    boolean isInverse -> a
    org.apfloat.internal.DoubleFactor3NTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.DoubleKaratsubaConvolutionStrategy -> mp:
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
    org.apfloat.spi.DataStorage add(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    void subtract(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    boolean isZero(org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.DoubleMatrixBuilder -> mq:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
org.apfloat.internal.DoubleMatrixStrategy -> mr:
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
    void moveBlock(double[],int,int,double[],int,int,int) -> a
    void transposeBlock(double[],int,int,int) -> a
    void transposeSquare(double[],int,int,int) -> b
    void permuteToHalfWidth(double[],int,int,int) -> c
    void permuteToDoubleWidth(double[],int,int,int) -> d
org.apfloat.internal.DoubleMediumConvolutionStrategy -> ms:
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.DoubleMediumConvolutionStrategy$1 -> mt:
    double[] buffer -> a
    int position -> a
    int val$bufferSize -> b
    void next() -> a
    double getDouble() -> a
    void setDouble(double) -> a
org.apfloat.internal.DoubleMemoryArrayAccess -> mu:
    double[] data -> a
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> a
    java.lang.Object getData() -> a
    double[] getDoubleData() -> a
    void close() -> a
org.apfloat.internal.DoubleMemoryDataStorage -> mv:
    double[] data -> a
    boolean $assertionsDisabled -> a
    boolean isCached() -> a
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> a
    long implGetSize() -> a
    void implSetSize(long) -> a
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> a
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    double[] access$000(org.apfloat.internal.DoubleMemoryDataStorage) -> a
    long access$100(org.apfloat.internal.DoubleMemoryDataStorage) -> a
org.apfloat.internal.DoubleMemoryDataStorage$ReadOnlyIterator -> mw:
    void setDouble(double) -> a
org.apfloat.internal.DoubleMemoryDataStorage$ReadWriteIterator -> mx:
    double[] data -> a
    int position -> c
    int length -> d
    boolean hasNext() -> a
    void next() -> a
    double getDouble() -> a
    void setDouble(double) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void checkLength() -> c
org.apfloat.internal.DoubleMemoryDataStorage$WriteOnlyIterator -> my:
    double getDouble() -> a
org.apfloat.internal.DoubleModConstants -> mz:
    double[] MODULUS -> a
    double[] PRIMITIVE_ROOT -> b
org.apfloat.internal.DoubleModMath -> mA:
    boolean $assertionsDisabled -> a
    double getForwardNthRoot(double,long) -> a
    double getInverseNthRoot(double,long) -> b
    double modDivide(double,double) -> d
    double modPow(double,double) -> e
org.apfloat.internal.DoubleNTTBuilder -> mB:
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.DoubleNTTConvolutionStepStrategy -> mC:
    boolean $assertionsDisabled -> a
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
org.apfloat.internal.DoubleNTTConvolutionStepStrategy$1 -> mD:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.spi.DataStorage val$source -> b
    org.apfloat.internal.DoubleNTTConvolutionStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.DoubleNTTConvolutionStepStrategy$2 -> mE:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.internal.DoubleNTTConvolutionStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.DoubleNTTConvolutionStepStrategy$MultiplyInPlaceRunnable -> mF:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    org.apfloat.spi.DataStorage source -> b
    long offset -> a
    long length -> b
    org.apfloat.internal.DoubleNTTConvolutionStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.DoubleNTTConvolutionStepStrategy$SquareInPlaceRunnable -> mG:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    long offset -> a
    long length -> b
    org.apfloat.internal.DoubleNTTConvolutionStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.DoubleNTTStepStrategy -> mH:
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.DoubleNTTStepStrategy$1 -> mI:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$columns -> a
    int val$startRow -> b
    int val$startColumn -> c
    double val$w -> a
    double val$scaleFactor -> b
    org.apfloat.internal.DoubleNTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.DoubleNTTStepStrategy$2 -> mJ:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$length -> a
    boolean val$isInverse -> a
    double[] val$wTable -> a
    int[] val$permutationTable -> a
    org.apfloat.internal.DoubleNTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.DoubleNTTStepStrategy$MultiplyRunnable -> mK:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int startRow -> a
    int startColumn -> b
    int rows -> c
    int columns -> d
    double w -> a
    double scaleFactor -> b
    org.apfloat.internal.DoubleNTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.DoubleNTTStepStrategy$TableFNTRunnable -> mL:
    int length -> a
    boolean isInverse -> a
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    double[] wTable -> a
    int[] permutationTable -> a
    org.apfloat.internal.DoubleNTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.DoubleRadixConstants -> mM:
    double[] BASE -> a
    int[] BASE_DIGITS -> a
    double[][] MINIMUM_FOR_DIGITS -> a
    long[] MAX_EXPONENT -> a
org.apfloat.internal.DoubleShortConvolutionStrategy -> mN:
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.DoubleTableFNT -> mO:
    boolean $assertionsDisabled -> a
    void tableFNT(org.apfloat.spi.ArrayAccess,double[],int[]) -> a
    void inverseTableFNT(org.apfloat.spi.ArrayAccess,double[],int[]) -> b
org.apfloat.internal.DoubleTableFNTStrategy -> mP:
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void divideElements(org.apfloat.spi.ArrayAccess,double) -> a
org.apfloat.internal.DoubleWTables -> mQ:
    java.util.concurrent.ConcurrentMap cache -> a
    double[] getWTable(int,int) -> a
    double[] getInverseWTable(int,int) -> b
    double[] getWTable(int,int,boolean) -> a
org.apfloat.internal.Factor3NTTStrategy -> mR:
    org.apfloat.spi.NTTStrategy factor2Strategy -> a
    org.apfloat.spi.Factor3NTTStepStrategy stepStrategy -> a
    boolean $assertionsDisabled -> a
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
org.apfloat.internal.FloatAdditionBuilder -> mS:
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.internal.FloatAdditionStrategy -> mT:
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> b
org.apfloat.internal.FloatApfloatBuilder -> mU:
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.internal.FloatApfloatImpl -> mV:
    org.apfloat.spi.DataStorage$Iterator ZERO_ITERATOR -> a
    int sign -> b
    long precision -> a
    long exponent -> b
    org.apfloat.spi.DataStorage dataStorage -> a
    int radix -> c
    int hashCode -> d
    int initialDigits -> e
    long leastZeros -> c
    long size -> d
    boolean $assertionsDisabled -> b
    long readExponent(java.io.PushbackReader) -> a
    long getTrailingZeros(org.apfloat.spi.DataStorage,long) -> a
    long getLeadingZeros(org.apfloat.spi.DataStorage,long) -> b
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> a
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> a
    boolean isShort() -> a
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> b
    org.apfloat.spi.ApfloatImpl absFloor() -> a
    org.apfloat.spi.ApfloatImpl absCeil() -> b
    org.apfloat.spi.ApfloatImpl frac() -> c
    org.apfloat.spi.ApfloatImpl zero() -> e
    int radix() -> a
    long precision() -> a
    long size() -> b
    long getLeastZeros() -> e
    org.apfloat.spi.ApfloatImpl precision(long) -> a
    long scale() -> c
    int signum() -> b
    org.apfloat.spi.ApfloatImpl negate() -> d
    double doubleValue() -> a
    long longValue() -> d
    boolean isOne() -> b
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> a
    int compareTo(org.apfloat.spi.ApfloatImpl) -> a
    org.apfloat.spi.DataStorage$Iterator getZeroPaddedIterator(long,long) -> a
    int compareMantissaTo(org.apfloat.internal.FloatApfloatImpl) -> a
    long findMismatch(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long) -> a
    float getLeastSignificantWord(long,float) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> a
    void writeZeros(java.io.Writer,long) -> a
    void writeTo(java.io.Writer,boolean) -> a
    long getSize() -> f
    int checkRadix(int) -> a
    float getMostSignificantWord(org.apfloat.spi.DataStorage) -> a
    int getInitialDigits() -> c
    int getInitialDigits(org.apfloat.spi.DataStorage) -> a
    int getDigits(float) -> a
    long getBasePrecision() -> g
    long getBasePrecision(long,int) -> a
    float getWord(long) -> a
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    float access$000(org.apfloat.internal.FloatApfloatImpl,long,float) -> a
org.apfloat.internal.FloatApfloatImpl$1 -> mW:
    void setFloat(float) -> a
    void next() -> a
org.apfloat.internal.FloatApfloatImpl$2 -> mX:
    long index -> a
    long val$end -> b
    org.apfloat.spi.DataStorage$Iterator val$iterator -> a
    long val$start -> c
    org.apfloat.internal.FloatApfloatImpl this$0 -> a
    float getFloat() -> a
    void next() -> a
    void close() -> b
org.apfloat.internal.FloatApfloatImpl$3 -> mY:
    float getFloat() -> a
    void next() -> a
org.apfloat.internal.FloatBaseMath -> mZ:
    int radix -> a
    boolean $assertionsDisabled -> a
    float baseAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,float,org.apfloat.spi.DataStorage$Iterator,long) -> a
    float baseSubtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,float,org.apfloat.spi.DataStorage$Iterator,long) -> b
    float baseMultiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,float,float,org.apfloat.spi.DataStorage$Iterator,long) -> a
org.apfloat.internal.FloatBuilderFactory -> org.apfloat.internal.FloatBuilderFactory:
    org.apfloat.spi.ApfloatBuilder apfloatBuilder -> a
    org.apfloat.spi.DataStorageBuilder dataStorageBuilder -> a
    org.apfloat.spi.AdditionBuilder additionBuilder -> a
    org.apfloat.spi.ConvolutionBuilder convolutionBuilder -> a
    org.apfloat.spi.NTTBuilder nttBuilder -> a
    org.apfloat.spi.MatrixBuilder matrixBuilder -> a
    org.apfloat.spi.CarryCRTBuilder carryCRTBuilder -> a
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> a
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> a
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> a
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> a
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> a
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> a
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> a
    java.lang.Class getElementArrayType() -> a
    int getElementSize() -> a
org.apfloat.internal.FloatCRTMath -> na:
    double base -> a
    void multiply(float[],float,float[]) -> a
    float compare(float[],float[]) -> a
    float add(float[],float[]) -> b
    void subtract(float[],float[]) -> a
    float divide(float[]) -> a
org.apfloat.internal.FloatCarryCRTBuilder -> nb:
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.internal.FloatCarryCRTStepStrategy -> nc:
    org.apfloat.internal.FloatModMath MATH_MOD_0 -> a
    org.apfloat.internal.FloatModMath MATH_MOD_1 -> b
    org.apfloat.internal.FloatModMath MATH_MOD_2 -> c
    float T0 -> a
    float T1 -> b
    float T2 -> c
    float[] M01 -> a
    float[] M02 -> b
    float[] M12 -> c
    float[] M012 -> d
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage$Iterator arrayIterator(float[]) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> a
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> a
org.apfloat.internal.FloatCarryCRTStepStrategy$1 -> nd:
    int position -> a
    boolean $assertionsDisabled -> a
    float[] val$data -> a
    boolean hasNext() -> a
    void next() -> a
    float getFloat() -> a
    void setFloat(float) -> a
org.apfloat.internal.FloatCarryCRTStepStrategy$2 -> ne:
    long position -> a
    long val$size -> b
    org.apfloat.spi.DataStorage$Iterator val$iterator1 -> a
    org.apfloat.spi.DataStorage$Iterator val$iterator2 -> b
    boolean hasNext() -> a
    void next() -> a
    float getFloat() -> a
    void setFloat(float) -> a
    void close() -> b
org.apfloat.internal.FloatConvolutionBuilder -> nf:
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.FloatDataStorageBuilder -> ng:
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.FloatDiskDataStorage -> nh:
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> b
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    int getUnitSize() -> b
org.apfloat.internal.FloatDiskDataStorage$BlockIterator -> ni:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    float[] data -> a
    int offset -> c
    int remaining -> d
    boolean $assertionsDisabled -> a
    org.apfloat.internal.FloatDiskDataStorage this$0 -> a
    void next() -> a
    float getFloat() -> a
    void setFloat(float) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void close() -> b
    void checkAvailable() -> f
org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess -> nj:
    int mode -> c
    long fileOffset -> a
    org.apfloat.internal.FloatDiskDataStorage this$0 -> a
    void close() -> a
org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess$1 -> nk:
    int readPosition -> a
    float[] val$array -> a
    int write(java.nio.ByteBuffer) -> write
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess$2 -> nl:
    int writePosition -> a
    float[] val$array -> a
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.FloatDiskDataStorage$TransposedMemoryArrayAccess -> nm:
    int mode -> c
    int startColumn -> d
    int columns -> e
    int rows -> f
    org.apfloat.internal.FloatDiskDataStorage this$0 -> a
    void close() -> a
org.apfloat.internal.FloatElementaryModMath -> nn:
    float modulus -> a
    double inverseModulus -> a
    float modMultiply(float,float) -> a
    float modAdd(float,float) -> b
    float modSubtract(float,float) -> c
    void setModulus(float) -> a
org.apfloat.internal.FloatFactor3NTTStepStrategy -> no:
    boolean $assertionsDisabled -> a
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.FloatFactor3NTTStepStrategy$1 -> np:
    org.apfloat.spi.DataStorage val$dataStorage0 -> a
    org.apfloat.spi.DataStorage val$dataStorage1 -> b
    org.apfloat.spi.DataStorage val$dataStorage2 -> c
    long val$startColumn -> a
    float val$w -> a
    float val$ww -> b
    float val$w1 -> c
    float val$w2 -> d
    boolean val$isInverse -> a
    org.apfloat.internal.FloatFactor3NTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.FloatFactor3NTTStepStrategy$ColumnTransformRunnable -> nq:
    org.apfloat.spi.DataStorage dataStorage0 -> a
    org.apfloat.spi.DataStorage dataStorage1 -> b
    org.apfloat.spi.DataStorage dataStorage2 -> c
    long startColumn -> a
    long columns -> b
    float w -> a
    float ww -> b
    float w1 -> c
    float w2 -> d
    boolean isInverse -> a
    org.apfloat.internal.FloatFactor3NTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.FloatKaratsubaConvolutionStrategy -> nr:
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
    org.apfloat.spi.DataStorage add(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    void subtract(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    boolean isZero(org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.FloatMatrixBuilder -> ns:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
org.apfloat.internal.FloatMatrixStrategy -> nt:
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
    void moveBlock(float[],int,int,float[],int,int,int) -> a
    void transposeBlock(float[],int,int,int) -> a
    void transposeSquare(float[],int,int,int) -> b
    void permuteToHalfWidth(float[],int,int,int) -> c
    void permuteToDoubleWidth(float[],int,int,int) -> d
org.apfloat.internal.FloatMediumConvolutionStrategy -> nu:
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.FloatMediumConvolutionStrategy$1 -> nv:
    float[] buffer -> a
    int position -> a
    int val$bufferSize -> b
    void next() -> a
    float getFloat() -> a
    void setFloat(float) -> a
org.apfloat.internal.FloatMemoryArrayAccess -> nw:
    float[] data -> a
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> a
    java.lang.Object getData() -> a
    float[] getFloatData() -> a
    void close() -> a
org.apfloat.internal.FloatMemoryDataStorage -> nx:
    float[] data -> a
    boolean $assertionsDisabled -> a
    boolean isCached() -> a
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> a
    long implGetSize() -> a
    void implSetSize(long) -> a
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> a
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    float[] access$000(org.apfloat.internal.FloatMemoryDataStorage) -> a
    long access$100(org.apfloat.internal.FloatMemoryDataStorage) -> a
org.apfloat.internal.FloatMemoryDataStorage$ReadOnlyIterator -> ny:
    void setFloat(float) -> a
org.apfloat.internal.FloatMemoryDataStorage$ReadWriteIterator -> nz:
    float[] data -> a
    int position -> c
    int length -> d
    boolean hasNext() -> a
    void next() -> a
    float getFloat() -> a
    void setFloat(float) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void checkLength() -> c
org.apfloat.internal.FloatMemoryDataStorage$WriteOnlyIterator -> nA:
    float getFloat() -> a
org.apfloat.internal.FloatModConstants -> nB:
    float[] MODULUS -> a
    float[] PRIMITIVE_ROOT -> b
org.apfloat.internal.FloatModMath -> nC:
    boolean $assertionsDisabled -> a
    float getForwardNthRoot(float,long) -> a
    float getInverseNthRoot(float,long) -> b
    float modDivide(float,float) -> d
    float modPow(float,float) -> e
org.apfloat.internal.FloatNTTBuilder -> nD:
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.FloatNTTConvolutionStepStrategy -> nE:
    boolean $assertionsDisabled -> a
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
org.apfloat.internal.FloatNTTConvolutionStepStrategy$1 -> nF:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.spi.DataStorage val$source -> b
    org.apfloat.internal.FloatNTTConvolutionStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.FloatNTTConvolutionStepStrategy$2 -> nG:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.internal.FloatNTTConvolutionStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.FloatNTTConvolutionStepStrategy$MultiplyInPlaceRunnable -> nH:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    org.apfloat.spi.DataStorage source -> b
    long offset -> a
    long length -> b
    org.apfloat.internal.FloatNTTConvolutionStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.FloatNTTConvolutionStepStrategy$SquareInPlaceRunnable -> nI:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    long offset -> a
    long length -> b
    org.apfloat.internal.FloatNTTConvolutionStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.FloatNTTStepStrategy -> nJ:
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.FloatNTTStepStrategy$1 -> nK:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$columns -> a
    int val$startRow -> b
    int val$startColumn -> c
    float val$w -> a
    float val$scaleFactor -> b
    org.apfloat.internal.FloatNTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.FloatNTTStepStrategy$2 -> nL:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$length -> a
    boolean val$isInverse -> a
    float[] val$wTable -> a
    int[] val$permutationTable -> a
    org.apfloat.internal.FloatNTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.FloatNTTStepStrategy$MultiplyRunnable -> nM:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int startRow -> a
    int startColumn -> b
    int rows -> c
    int columns -> d
    float w -> a
    float scaleFactor -> b
    org.apfloat.internal.FloatNTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.FloatNTTStepStrategy$TableFNTRunnable -> nN:
    int length -> a
    boolean isInverse -> a
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    float[] wTable -> a
    int[] permutationTable -> a
    org.apfloat.internal.FloatNTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.FloatRadixConstants -> nO:
    float[] BASE -> a
    int[] BASE_DIGITS -> a
    float[][] MINIMUM_FOR_DIGITS -> a
    long[] MAX_EXPONENT -> a
org.apfloat.internal.FloatShortConvolutionStrategy -> nP:
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.FloatTableFNT -> nQ:
    boolean $assertionsDisabled -> a
    void tableFNT(org.apfloat.spi.ArrayAccess,float[],int[]) -> a
    void inverseTableFNT(org.apfloat.spi.ArrayAccess,float[],int[]) -> b
org.apfloat.internal.FloatTableFNTStrategy -> nR:
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void divideElements(org.apfloat.spi.ArrayAccess,float) -> a
org.apfloat.internal.FloatWTables -> nS:
    java.util.concurrent.ConcurrentMap cache -> a
    float[] getWTable(int,int) -> a
    float[] getInverseWTable(int,int) -> b
    float[] getWTable(int,int,boolean) -> a
org.apfloat.internal.ImplementationMismatchException -> nT:
org.apfloat.internal.IntAdditionBuilder -> nU:
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.internal.IntAdditionStrategy -> nV:
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> b
org.apfloat.internal.IntApfloatBuilder -> nW:
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.internal.IntApfloatImpl -> nX:
    org.apfloat.spi.DataStorage$Iterator ZERO_ITERATOR -> a
    int sign -> b
    long precision -> a
    long exponent -> b
    org.apfloat.spi.DataStorage dataStorage -> a
    int radix -> c
    int hashCode -> d
    int initialDigits -> e
    long leastZeros -> c
    long size -> d
    boolean $assertionsDisabled -> b
    long readExponent(java.io.PushbackReader) -> a
    long getTrailingZeros(org.apfloat.spi.DataStorage,long) -> a
    long getLeadingZeros(org.apfloat.spi.DataStorage,long) -> b
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> a
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> a
    boolean isShort() -> a
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> b
    org.apfloat.spi.ApfloatImpl absFloor() -> a
    org.apfloat.spi.ApfloatImpl absCeil() -> b
    org.apfloat.spi.ApfloatImpl frac() -> c
    org.apfloat.spi.ApfloatImpl zero() -> e
    int radix() -> a
    long precision() -> a
    long size() -> b
    long getLeastZeros() -> e
    org.apfloat.spi.ApfloatImpl precision(long) -> a
    long scale() -> c
    int signum() -> b
    org.apfloat.spi.ApfloatImpl negate() -> d
    double doubleValue() -> a
    long longValue() -> d
    boolean isOne() -> b
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> a
    int compareTo(org.apfloat.spi.ApfloatImpl) -> a
    org.apfloat.spi.DataStorage$Iterator getZeroPaddedIterator(long,long) -> a
    int compareMantissaTo(org.apfloat.internal.IntApfloatImpl) -> a
    long findMismatch(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long) -> a
    int getLeastSignificantWord(long,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> a
    void writeZeros(java.io.Writer,long) -> a
    void writeTo(java.io.Writer,boolean) -> a
    long getSize() -> f
    int checkRadix(int) -> a
    int getMostSignificantWord(org.apfloat.spi.DataStorage) -> a
    int getInitialDigits() -> c
    int getInitialDigits(org.apfloat.spi.DataStorage) -> b
    int getDigits(int) -> b
    long getBasePrecision() -> g
    long getBasePrecision(long,int) -> a
    int getWord(long) -> a
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    int access$000(org.apfloat.internal.IntApfloatImpl,long,int) -> a
org.apfloat.internal.IntApfloatImpl$1 -> nY:
    void setInt(int) -> a
    void next() -> a
org.apfloat.internal.IntApfloatImpl$2 -> nZ:
    long index -> a
    long val$end -> b
    org.apfloat.spi.DataStorage$Iterator val$iterator -> a
    long val$start -> c
    org.apfloat.internal.IntApfloatImpl this$0 -> a
    int getInt() -> a
    void next() -> a
    void close() -> b
org.apfloat.internal.IntApfloatImpl$3 -> oa:
    int getInt() -> a
    void next() -> a
org.apfloat.internal.IntBaseMath -> ob:
    int radix -> a
    boolean $assertionsDisabled -> a
    int baseAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,int,org.apfloat.spi.DataStorage$Iterator,long) -> a
    int baseSubtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,int,org.apfloat.spi.DataStorage$Iterator,long) -> b
    int baseMultiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,int,int,org.apfloat.spi.DataStorage$Iterator,long) -> a
org.apfloat.internal.IntBuilderFactory -> org.apfloat.internal.IntBuilderFactory:
    org.apfloat.spi.ApfloatBuilder apfloatBuilder -> a
    org.apfloat.spi.DataStorageBuilder dataStorageBuilder -> a
    org.apfloat.spi.AdditionBuilder additionBuilder -> a
    org.apfloat.spi.ConvolutionBuilder convolutionBuilder -> a
    org.apfloat.spi.NTTBuilder nttBuilder -> a
    org.apfloat.spi.MatrixBuilder matrixBuilder -> a
    org.apfloat.spi.CarryCRTBuilder carryCRTBuilder -> a
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> a
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> a
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> a
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> a
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> a
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> a
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> a
    java.lang.Class getElementArrayType() -> a
    int getElementSize() -> a
org.apfloat.internal.IntCRTMath -> oc:
    int base -> b
    void multiply(int[],int,int[]) -> a
    int compare(int[],int[]) -> a
    int add(int[],int[]) -> b
    void subtract(int[],int[]) -> a
    int divide(int[]) -> a
org.apfloat.internal.IntCarryCRTBuilder -> od:
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.internal.IntCarryCRTStepStrategy -> oe:
    org.apfloat.internal.IntModMath MATH_MOD_0 -> a
    org.apfloat.internal.IntModMath MATH_MOD_1 -> b
    org.apfloat.internal.IntModMath MATH_MOD_2 -> c
    int T0 -> b
    int T1 -> c
    int T2 -> d
    int[] M01 -> a
    int[] M02 -> b
    int[] M12 -> c
    int[] M012 -> d
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage$Iterator arrayIterator(int[]) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> a
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> a
org.apfloat.internal.IntCarryCRTStepStrategy$1 -> of:
    int position -> a
    boolean $assertionsDisabled -> a
    int[] val$data -> a
    boolean hasNext() -> a
    void next() -> a
    int getInt() -> a
    void setInt(int) -> a
org.apfloat.internal.IntCarryCRTStepStrategy$2 -> og:
    long position -> a
    long val$size -> b
    org.apfloat.spi.DataStorage$Iterator val$iterator1 -> a
    org.apfloat.spi.DataStorage$Iterator val$iterator2 -> b
    boolean hasNext() -> a
    void next() -> a
    int getInt() -> a
    void setInt(int) -> a
    void close() -> b
org.apfloat.internal.IntConvolutionBuilder -> oh:
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.IntDataStorageBuilder -> oi:
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.IntDiskDataStorage -> oj:
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> b
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    int getUnitSize() -> b
org.apfloat.internal.IntDiskDataStorage$BlockIterator -> ok:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int[] data -> a
    int offset -> c
    int remaining -> d
    boolean $assertionsDisabled -> a
    org.apfloat.internal.IntDiskDataStorage this$0 -> a
    void next() -> a
    int getInt() -> a
    void setInt(int) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void close() -> b
    void checkAvailable() -> f
org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess -> ol:
    int mode -> c
    long fileOffset -> a
    org.apfloat.internal.IntDiskDataStorage this$0 -> a
    void close() -> a
org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess$1 -> om:
    int readPosition -> a
    int[] val$array -> a
    int write(java.nio.ByteBuffer) -> write
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess$2 -> on:
    int writePosition -> a
    int[] val$array -> a
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.IntDiskDataStorage$TransposedMemoryArrayAccess -> oo:
    int mode -> c
    int startColumn -> d
    int columns -> e
    int rows -> f
    org.apfloat.internal.IntDiskDataStorage this$0 -> a
    void close() -> a
org.apfloat.internal.IntElementaryModMath -> op:
    int modulus -> a
    double inverseModulus -> a
    int modMultiply(int,int) -> a
    int modAdd(int,int) -> b
    int modSubtract(int,int) -> c
    void setModulus(int) -> a
org.apfloat.internal.IntFactor3NTTStepStrategy -> oq:
    boolean $assertionsDisabled -> a
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.IntFactor3NTTStepStrategy$1 -> or:
    org.apfloat.spi.DataStorage val$dataStorage0 -> a
    org.apfloat.spi.DataStorage val$dataStorage1 -> b
    org.apfloat.spi.DataStorage val$dataStorage2 -> c
    long val$startColumn -> a
    int val$w -> a
    int val$ww -> b
    int val$w1 -> c
    int val$w2 -> d
    boolean val$isInverse -> a
    org.apfloat.internal.IntFactor3NTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.IntFactor3NTTStepStrategy$ColumnTransformRunnable -> os:
    org.apfloat.spi.DataStorage dataStorage0 -> a
    org.apfloat.spi.DataStorage dataStorage1 -> b
    org.apfloat.spi.DataStorage dataStorage2 -> c
    long startColumn -> a
    long columns -> b
    int w -> a
    int ww -> b
    int w1 -> c
    int w2 -> d
    boolean isInverse -> a
    org.apfloat.internal.IntFactor3NTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.IntKaratsubaConvolutionStrategy -> ot:
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
    org.apfloat.spi.DataStorage add(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    void subtract(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    boolean isZero(org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.IntMatrixBuilder -> ou:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
org.apfloat.internal.IntMatrixStrategy -> ov:
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
    void moveBlock(int[],int,int,int[],int,int,int) -> a
    void transposeBlock(int[],int,int,int) -> a
    void transposeSquare(int[],int,int,int) -> b
    void permuteToHalfWidth(int[],int,int,int) -> c
    void permuteToDoubleWidth(int[],int,int,int) -> d
org.apfloat.internal.IntMediumConvolutionStrategy -> ow:
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.IntMediumConvolutionStrategy$1 -> ox:
    int[] buffer -> a
    int position -> a
    int val$bufferSize -> b
    void next() -> a
    int getInt() -> a
    void setInt(int) -> a
org.apfloat.internal.IntMemoryArrayAccess -> oy:
    int[] data -> a
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> a
    java.lang.Object getData() -> a
    int[] getIntData() -> a
    void close() -> a
org.apfloat.internal.IntMemoryDataStorage -> oz:
    int[] data -> a
    boolean $assertionsDisabled -> a
    boolean isCached() -> a
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> a
    long implGetSize() -> a
    void implSetSize(long) -> a
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> a
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    int[] access$000(org.apfloat.internal.IntMemoryDataStorage) -> a
    long access$100(org.apfloat.internal.IntMemoryDataStorage) -> a
org.apfloat.internal.IntMemoryDataStorage$ReadOnlyIterator -> oA:
    void setInt(int) -> a
org.apfloat.internal.IntMemoryDataStorage$ReadWriteIterator -> oB:
    int[] data -> a
    int position -> c
    int length -> d
    boolean hasNext() -> a
    void next() -> a
    int getInt() -> a
    void setInt(int) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void checkLength() -> c
org.apfloat.internal.IntMemoryDataStorage$WriteOnlyIterator -> oC:
    int getInt() -> a
org.apfloat.internal.IntModConstants -> oD:
    int[] MODULUS -> a
    int[] PRIMITIVE_ROOT -> b
org.apfloat.internal.IntModMath -> oE:
    boolean $assertionsDisabled -> a
    int getForwardNthRoot(int,long) -> a
    int getInverseNthRoot(int,long) -> b
    int modDivide(int,int) -> d
    int modPow(int,int) -> e
org.apfloat.internal.IntNTTBuilder -> oF:
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.IntNTTConvolutionStepStrategy -> oG:
    boolean $assertionsDisabled -> a
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
org.apfloat.internal.IntNTTConvolutionStepStrategy$1 -> oH:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.spi.DataStorage val$source -> b
    org.apfloat.internal.IntNTTConvolutionStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.IntNTTConvolutionStepStrategy$2 -> oI:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.internal.IntNTTConvolutionStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.IntNTTConvolutionStepStrategy$MultiplyInPlaceRunnable -> oJ:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    org.apfloat.spi.DataStorage source -> b
    long offset -> a
    long length -> b
    org.apfloat.internal.IntNTTConvolutionStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.IntNTTConvolutionStepStrategy$SquareInPlaceRunnable -> oK:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    long offset -> a
    long length -> b
    org.apfloat.internal.IntNTTConvolutionStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.IntNTTStepStrategy -> oL:
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.IntNTTStepStrategy$1 -> oM:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$columns -> a
    int val$startRow -> b
    int val$startColumn -> c
    int val$w -> d
    int val$scaleFactor -> e
    org.apfloat.internal.IntNTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.IntNTTStepStrategy$2 -> oN:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$length -> a
    boolean val$isInverse -> a
    int[] val$wTable -> a
    int[] val$permutationTable -> b
    org.apfloat.internal.IntNTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.IntNTTStepStrategy$MultiplyRunnable -> oO:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int startRow -> a
    int startColumn -> b
    int rows -> c
    int columns -> d
    int w -> e
    int scaleFactor -> f
    org.apfloat.internal.IntNTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.IntNTTStepStrategy$TableFNTRunnable -> oP:
    int length -> a
    boolean isInverse -> a
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int[] wTable -> a
    int[] permutationTable -> b
    org.apfloat.internal.IntNTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.IntRadixConstants -> oQ:
    int[] BASE -> a
    int[] BASE_DIGITS -> b
    int[][] MINIMUM_FOR_DIGITS -> a
    long[] MAX_EXPONENT -> a
org.apfloat.internal.IntShortConvolutionStrategy -> oR:
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.IntTableFNT -> oS:
    boolean $assertionsDisabled -> a
    void tableFNT(org.apfloat.spi.ArrayAccess,int[],int[]) -> a
    void inverseTableFNT(org.apfloat.spi.ArrayAccess,int[],int[]) -> b
org.apfloat.internal.IntTableFNTStrategy -> oT:
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void divideElements(org.apfloat.spi.ArrayAccess,int) -> a
org.apfloat.internal.IntWTables -> oU:
    java.util.concurrent.ConcurrentMap cache -> a
    int[] getWTable(int,int) -> a
    int[] getInverseWTable(int,int) -> b
    int[] getWTable(int,int,boolean) -> a
org.apfloat.internal.LongAdditionBuilder -> oV:
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.internal.LongAdditionStrategy -> oW:
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> b
org.apfloat.internal.LongApfloatBuilder -> oX:
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.internal.LongApfloatImpl -> oY:
    org.apfloat.spi.DataStorage$Iterator ZERO_ITERATOR -> a
    int sign -> b
    long precision -> a
    long exponent -> b
    org.apfloat.spi.DataStorage dataStorage -> a
    int radix -> c
    int hashCode -> d
    int initialDigits -> e
    long leastZeros -> c
    long size -> d
    boolean $assertionsDisabled -> b
    long readExponent(java.io.PushbackReader) -> a
    long getTrailingZeros(org.apfloat.spi.DataStorage,long) -> a
    long getLeadingZeros(org.apfloat.spi.DataStorage,long) -> b
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> a
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> a
    boolean isShort() -> a
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> b
    org.apfloat.spi.ApfloatImpl absFloor() -> a
    org.apfloat.spi.ApfloatImpl absCeil() -> b
    org.apfloat.spi.ApfloatImpl frac() -> c
    org.apfloat.spi.ApfloatImpl zero() -> e
    int radix() -> a
    long precision() -> a
    long size() -> b
    long getLeastZeros() -> e
    org.apfloat.spi.ApfloatImpl precision(long) -> a
    long scale() -> c
    int signum() -> b
    org.apfloat.spi.ApfloatImpl negate() -> d
    double doubleValue() -> a
    long longValue() -> d
    boolean isOne() -> b
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> a
    int compareTo(org.apfloat.spi.ApfloatImpl) -> a
    org.apfloat.spi.DataStorage$Iterator getZeroPaddedIterator(long,long) -> a
    int compareMantissaTo(org.apfloat.internal.LongApfloatImpl) -> a
    long findMismatch(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long) -> a
    long getLeastSignificantWord(long,long) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> a
    void writeZeros(java.io.Writer,long) -> a
    void writeTo(java.io.Writer,boolean) -> a
    long getSize() -> f
    int checkRadix(int) -> a
    long getMostSignificantWord(org.apfloat.spi.DataStorage) -> a
    int getInitialDigits() -> c
    int getInitialDigits(org.apfloat.spi.DataStorage) -> a
    int getDigits(long) -> a
    long getBasePrecision() -> g
    long getBasePrecision(long,int) -> a
    long getWord(long) -> a
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    long access$000(org.apfloat.internal.LongApfloatImpl,long,long) -> a
org.apfloat.internal.LongApfloatImpl$1 -> oZ:
    void setLong(long) -> a
    void next() -> a
org.apfloat.internal.LongApfloatImpl$2 -> pa:
    long index -> a
    long val$end -> b
    org.apfloat.spi.DataStorage$Iterator val$iterator -> a
    long val$start -> c
    org.apfloat.internal.LongApfloatImpl this$0 -> a
    long getLong() -> a
    void next() -> a
    void close() -> b
org.apfloat.internal.LongApfloatImpl$3 -> pb:
    long getLong() -> a
    void next() -> a
org.apfloat.internal.LongBaseMath -> pc:
    int radix -> a
    double inverseBase -> a
    boolean $assertionsDisabled -> a
    long baseAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long,org.apfloat.spi.DataStorage$Iterator,long) -> a
    long baseSubtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long,org.apfloat.spi.DataStorage$Iterator,long) -> b
    long baseMultiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long,long,org.apfloat.spi.DataStorage$Iterator,long) -> a
org.apfloat.internal.LongBuilderFactory -> org.apfloat.internal.LongBuilderFactory:
    org.apfloat.spi.ApfloatBuilder apfloatBuilder -> a
    org.apfloat.spi.DataStorageBuilder dataStorageBuilder -> a
    org.apfloat.spi.AdditionBuilder additionBuilder -> a
    org.apfloat.spi.ConvolutionBuilder convolutionBuilder -> a
    org.apfloat.spi.NTTBuilder nttBuilder -> a
    org.apfloat.spi.MatrixBuilder matrixBuilder -> a
    org.apfloat.spi.CarryCRTBuilder carryCRTBuilder -> a
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> a
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> a
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> a
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> a
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> a
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> a
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> a
    java.lang.Class getElementArrayType() -> a
    int getElementSize() -> a
org.apfloat.internal.LongCRTMath -> pd:
    long base -> a
    double inverseBase -> a
    void multiply(long[],long,long[]) -> a
    long compare(long[],long[]) -> a
    long add(long[],long[]) -> b
    void subtract(long[],long[]) -> a
    long divide(long[]) -> a
org.apfloat.internal.LongCarryCRTBuilder -> pe:
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.internal.LongCarryCRTStepStrategy -> pf:
    org.apfloat.internal.LongModMath MATH_MOD_0 -> a
    org.apfloat.internal.LongModMath MATH_MOD_1 -> b
    org.apfloat.internal.LongModMath MATH_MOD_2 -> c
    long T0 -> a
    long T1 -> b
    long T2 -> c
    long[] M01 -> a
    long[] M02 -> b
    long[] M12 -> c
    long[] M012 -> d
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage$Iterator arrayIterator(long[]) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> a
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> a
org.apfloat.internal.LongCarryCRTStepStrategy$1 -> pg:
    int position -> a
    boolean $assertionsDisabled -> a
    long[] val$data -> a
    boolean hasNext() -> a
    void next() -> a
    long getLong() -> a
    void setLong(long) -> a
org.apfloat.internal.LongCarryCRTStepStrategy$2 -> ph:
    long position -> a
    long val$size -> b
    org.apfloat.spi.DataStorage$Iterator val$iterator1 -> a
    org.apfloat.spi.DataStorage$Iterator val$iterator2 -> b
    boolean hasNext() -> a
    void next() -> a
    long getLong() -> a
    void setLong(long) -> a
    void close() -> b
org.apfloat.internal.LongConvolutionBuilder -> pi:
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.LongDataStorageBuilder -> pj:
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.LongDiskDataStorage -> pk:
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> b
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    int getUnitSize() -> b
org.apfloat.internal.LongDiskDataStorage$BlockIterator -> pl:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    long[] data -> a
    int offset -> c
    int remaining -> d
    boolean $assertionsDisabled -> a
    org.apfloat.internal.LongDiskDataStorage this$0 -> a
    void next() -> a
    long getLong() -> a
    void setLong(long) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void close() -> b
    void checkAvailable() -> f
org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess -> pm:
    int mode -> c
    long fileOffset -> a
    org.apfloat.internal.LongDiskDataStorage this$0 -> a
    void close() -> a
org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess$1 -> pn:
    int readPosition -> a
    long[] val$array -> a
    int write(java.nio.ByteBuffer) -> write
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess$2 -> po:
    int writePosition -> a
    long[] val$array -> a
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.LongDiskDataStorage$TransposedMemoryArrayAccess -> pp:
    int mode -> c
    int startColumn -> d
    int columns -> e
    int rows -> f
    org.apfloat.internal.LongDiskDataStorage this$0 -> a
    void close() -> a
org.apfloat.internal.LongElementaryModMath -> pq:
    long modulus -> a
    double inverseModulus -> a
    long modMultiply(long,long) -> a
    long modAdd(long,long) -> b
    long modSubtract(long,long) -> c
    void setModulus(long) -> a
org.apfloat.internal.LongFactor3NTTStepStrategy -> pr:
    boolean $assertionsDisabled -> a
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.LongFactor3NTTStepStrategy$1 -> ps:
    org.apfloat.spi.DataStorage val$dataStorage0 -> a
    org.apfloat.spi.DataStorage val$dataStorage1 -> b
    org.apfloat.spi.DataStorage val$dataStorage2 -> c
    long val$startColumn -> a
    long val$w -> b
    long val$ww -> c
    long val$w1 -> d
    long val$w2 -> e
    boolean val$isInverse -> a
    org.apfloat.internal.LongFactor3NTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.LongFactor3NTTStepStrategy$ColumnTransformRunnable -> pt:
    org.apfloat.spi.DataStorage dataStorage0 -> a
    org.apfloat.spi.DataStorage dataStorage1 -> b
    org.apfloat.spi.DataStorage dataStorage2 -> c
    long startColumn -> a
    long columns -> b
    long w -> c
    long ww -> d
    long w1 -> e
    long w2 -> f
    boolean isInverse -> a
    org.apfloat.internal.LongFactor3NTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.LongKaratsubaConvolutionStrategy -> pu:
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
    org.apfloat.spi.DataStorage add(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    void subtract(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    boolean isZero(org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.LongMatrixBuilder -> pv:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
org.apfloat.internal.LongMatrixStrategy -> pw:
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
    void moveBlock(long[],int,int,long[],int,int,int) -> a
    void transposeBlock(long[],int,int,int) -> a
    void transposeSquare(long[],int,int,int) -> b
    void permuteToHalfWidth(long[],int,int,int) -> c
    void permuteToDoubleWidth(long[],int,int,int) -> d
org.apfloat.internal.LongMediumConvolutionStrategy -> px:
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.LongMediumConvolutionStrategy$1 -> py:
    long[] buffer -> a
    int position -> a
    int val$bufferSize -> b
    void next() -> a
    long getLong() -> a
    void setLong(long) -> a
org.apfloat.internal.LongMemoryArrayAccess -> pz:
    long[] data -> a
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> a
    java.lang.Object getData() -> a
    long[] getLongData() -> a
    void close() -> a
org.apfloat.internal.LongMemoryDataStorage -> pA:
    long[] data -> a
    boolean $assertionsDisabled -> a
    boolean isCached() -> a
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> a
    long implGetSize() -> a
    void implSetSize(long) -> a
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> a
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    long[] access$000(org.apfloat.internal.LongMemoryDataStorage) -> a
    long access$100(org.apfloat.internal.LongMemoryDataStorage) -> a
org.apfloat.internal.LongMemoryDataStorage$ReadOnlyIterator -> pB:
    void setLong(long) -> a
org.apfloat.internal.LongMemoryDataStorage$ReadWriteIterator -> pC:
    long[] data -> a
    int position -> c
    int length -> d
    boolean hasNext() -> a
    void next() -> a
    long getLong() -> a
    void setLong(long) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void checkLength() -> c
org.apfloat.internal.LongMemoryDataStorage$WriteOnlyIterator -> pD:
    long getLong() -> a
org.apfloat.internal.LongModConstants -> pE:
    long[] MODULUS -> a
    long[] PRIMITIVE_ROOT -> b
org.apfloat.internal.LongModMath -> pF:
    boolean $assertionsDisabled -> a
    long getForwardNthRoot(long,long) -> d
    long getInverseNthRoot(long,long) -> e
    long modDivide(long,long) -> f
    long modPow(long,long) -> g
org.apfloat.internal.LongNTTBuilder -> pG:
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.LongNTTConvolutionStepStrategy -> pH:
    boolean $assertionsDisabled -> a
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
org.apfloat.internal.LongNTTConvolutionStepStrategy$1 -> pI:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.spi.DataStorage val$source -> b
    org.apfloat.internal.LongNTTConvolutionStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.LongNTTConvolutionStepStrategy$2 -> pJ:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.internal.LongNTTConvolutionStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.LongNTTConvolutionStepStrategy$MultiplyInPlaceRunnable -> pK:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    org.apfloat.spi.DataStorage source -> b
    long offset -> a
    long length -> b
    org.apfloat.internal.LongNTTConvolutionStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.LongNTTConvolutionStepStrategy$SquareInPlaceRunnable -> pL:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    long offset -> a
    long length -> b
    org.apfloat.internal.LongNTTConvolutionStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.LongNTTStepStrategy -> pM:
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.LongNTTStepStrategy$1 -> pN:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$columns -> a
    int val$startRow -> b
    int val$startColumn -> c
    long val$w -> a
    long val$scaleFactor -> b
    org.apfloat.internal.LongNTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.LongNTTStepStrategy$2 -> pO:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$length -> a
    boolean val$isInverse -> a
    long[] val$wTable -> a
    int[] val$permutationTable -> a
    org.apfloat.internal.LongNTTStepStrategy this$0 -> a
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.LongNTTStepStrategy$MultiplyRunnable -> pP:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int startRow -> a
    int startColumn -> b
    int rows -> c
    int columns -> d
    long w -> a
    long scaleFactor -> b
    org.apfloat.internal.LongNTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.LongNTTStepStrategy$TableFNTRunnable -> pQ:
    int length -> a
    boolean isInverse -> a
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    long[] wTable -> a
    int[] permutationTable -> a
    org.apfloat.internal.LongNTTStepStrategy this$0 -> a
    void run() -> run
org.apfloat.internal.LongRadixConstants -> pR:
    long[] BASE -> a
    int[] BASE_DIGITS -> a
    long[][] MINIMUM_FOR_DIGITS -> a
    long[] MAX_EXPONENT -> b
org.apfloat.internal.LongShortConvolutionStrategy -> pS:
    boolean $assertionsDisabled -> b
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.LongTableFNT -> pT:
    boolean $assertionsDisabled -> a
    void tableFNT(org.apfloat.spi.ArrayAccess,long[],int[]) -> a
    void inverseTableFNT(org.apfloat.spi.ArrayAccess,long[],int[]) -> b
org.apfloat.internal.LongTableFNTStrategy -> pU:
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void divideElements(org.apfloat.spi.ArrayAccess,long) -> a
org.apfloat.internal.LongWTables -> pV:
    java.util.concurrent.ConcurrentMap cache -> a
    long[] getWTable(int,int) -> a
    long[] getInverseWTable(int,int) -> b
    long[] getWTable(int,int,boolean) -> a
org.apfloat.internal.MessagePasser -> pW:
    java.util.Map messages -> a
    boolean $assertionsDisabled -> a
    void sendMessage(java.lang.Object,java.lang.Object) -> a
    java.lang.Object receiveMessage(java.lang.Object) -> a
org.apfloat.internal.ParallelRunnable -> pX:
    long length -> a
    long preferredBatchSize -> b
    java.util.concurrent.atomic.AtomicLong started -> a
    java.util.concurrent.atomic.AtomicLong completed -> b
    void run() -> run
    boolean runBatch() -> a
    java.lang.Runnable getRunnable(int,int) -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.ParallelRunner -> pY:
    java.util.Queue tasks -> a
    void runParallel(org.apfloat.internal.ParallelRunnable) -> a
    void wait(java.util.concurrent.Future) -> a
org.apfloat.internal.ParallelThreeNTTConvolutionStrategy -> pZ:
    java.util.Map locks -> a
    java.lang.Object key -> a
    boolean $assertionsDisabled -> a
    void lock(long) -> a
    void unlock() -> a
org.apfloat.internal.ParallelThreeNTTConvolutionStrategy$LockFuture -> qa:
    java.util.concurrent.Callable VOID_CALLABLE -> a
    java.util.concurrent.locks.Lock lock -> a
    boolean isDone() -> isDone
org.apfloat.internal.ParallelThreeNTTConvolutionStrategy$LockFuture$1 -> qb:
    java.lang.Object call() -> call
org.apfloat.internal.Parallelizable -> qc:
org.apfloat.internal.RadixMismatchException -> qd:
org.apfloat.internal.Scramble -> qe:
    boolean $assertionsDisabled -> a
    int permute(int,int) -> a
    int[] createScrambleTable(int) -> a
org.apfloat.internal.SixStepFNTStrategy -> qf:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    boolean $assertionsDisabled -> a
    void transform(org.apfloat.spi.DataStorage,int,int,long,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,int,long,long,int) -> a
    void transposeInitial$3fbfc74b(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeMiddle$3fbfc74b(org.apfloat.spi.ArrayAccess,int,int) -> b
    void transformFirst(org.apfloat.spi.ArrayAccess,int,int,boolean,int) -> a
    void transformSecond(org.apfloat.spi.ArrayAccess,int,int,boolean,int) -> b
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,long,long,boolean,int) -> a
org.apfloat.internal.StepCarryCRTStrategy -> qg:
    int radix -> a
    org.apfloat.spi.DataStorage carryCRT(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.StepCarryCRTStrategy$1 -> qh:
    org.apfloat.spi.DataStorage val$resultMod0 -> a
    org.apfloat.spi.DataStorage val$resultMod1 -> b
    org.apfloat.spi.DataStorage val$resultMod2 -> c
    org.apfloat.spi.DataStorage val$dataStorage -> d
    long val$size -> a
    long val$resultSize -> b
    org.apfloat.internal.MessagePasser val$messagePasser -> a
    org.apfloat.spi.CarryCRTStepStrategy val$stepStrategy -> a
    org.apfloat.internal.StepCarryCRTStrategy this$0 -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.StepCarryCRTStrategy$CarryCRTRunnable -> qi:
    org.apfloat.spi.DataStorage resultMod0 -> a
    org.apfloat.spi.DataStorage resultMod1 -> b
    org.apfloat.spi.DataStorage resultMod2 -> c
    org.apfloat.spi.DataStorage dataStorage -> d
    long size -> a
    long resultSize -> b
    long offset -> c
    long length -> d
    org.apfloat.internal.MessagePasser messagePasser -> a
    org.apfloat.spi.CarryCRTStepStrategy stepStrategy -> a
    boolean $assertionsDisabled -> a
    void run() -> run
org.apfloat.internal.ThreeNTTConvolutionStrategy -> qj:
    org.apfloat.spi.NTTStrategy nttStrategy -> a
    org.apfloat.spi.CarryCRTStrategy carryCRTStrategy -> a
    org.apfloat.spi.NTTConvolutionStepStrategy stepStrategy -> a
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
    org.apfloat.spi.DataStorage convoluteOne(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,int,boolean) -> a
    org.apfloat.spi.DataStorage autoConvolute(org.apfloat.spi.DataStorage,long) -> a
    org.apfloat.spi.DataStorage autoConvoluteOne(org.apfloat.spi.DataStorage,long,int,boolean) -> a
    void lock(long) -> a
    void unlock() -> a
    org.apfloat.spi.DataStorage createCachedDataStorage(long) -> a
    org.apfloat.spi.DataStorage createDataStorage(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.TransformLengthExceededException -> qk:
org.apfloat.internal.TwoPassFNTStrategy -> ql:
    boolean $assertionsDisabled -> a
    void transform(org.apfloat.spi.DataStorage,int,int,long,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,int,long,long,int) -> a
    org.apfloat.spi.ArrayAccess getColumns(org.apfloat.spi.DataStorage,int,int,int) -> a
    org.apfloat.spi.ArrayAccess getRows(org.apfloat.spi.DataStorage,int,int,int) -> b
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformColumns(org.apfloat.spi.ArrayAccess,int,int,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,int) -> b
    int getMaxMemoryBlockSize(long) -> a
org.apfloat.spi.AdditionBuilder -> qm:
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.spi.AdditionStrategy -> qn:
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> b
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> a
org.apfloat.spi.ApfloatBuilder -> qo:
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.spi.ApfloatImpl -> qp:
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> a
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> a
    boolean isShort() -> a
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> b
    org.apfloat.spi.ApfloatImpl absFloor() -> a
    org.apfloat.spi.ApfloatImpl absCeil() -> b
    org.apfloat.spi.ApfloatImpl frac() -> c
    int radix() -> a
    long precision() -> a
    long size() -> b
    org.apfloat.spi.ApfloatImpl precision(long) -> a
    long scale() -> c
    int signum() -> b
    org.apfloat.spi.ApfloatImpl negate() -> d
    double doubleValue() -> a
    long longValue() -> d
    boolean isOne() -> b
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> a
    int compareTo(org.apfloat.spi.ApfloatImpl) -> a
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> a
    void writeTo(java.io.Writer,boolean) -> a
org.apfloat.spi.ArrayAccess -> qq:
    int offset -> a
    int length -> b
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> a
    java.lang.Object getData() -> a
    int[] getIntData() -> a
    long[] getLongData() -> a
    float[] getFloatData() -> a
    double[] getDoubleData() -> a
    void close() -> a
org.apfloat.spi.BuilderFactory -> qr:
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> a
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> a
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> a
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> a
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> a
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> a
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> a
    java.lang.Class getElementArrayType() -> a
    int getElementSize() -> a
org.apfloat.spi.CarryCRTBuilder -> qs:
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.spi.CarryCRTStepStrategy -> qt:
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> a
org.apfloat.spi.CarryCRTStrategy -> qu:
    org.apfloat.spi.DataStorage carryCRT(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.spi.ConvolutionBuilder -> qv:
    org.apfloat.spi.ConvolutionStrategy createConvolution$75792394(int,long,long) -> a
org.apfloat.spi.ConvolutionStrategy -> qw:
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.spi.DataStorage -> qx:
    long offset -> a
    long length -> b
    org.apfloat.spi.DataStorage originalDataStorage -> a
    boolean isReadOnly -> a
    boolean isSubsequenced -> b
    org.apfloat.spi.DataStorage subsequence(long,long) -> b
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> a
    void copyFrom(org.apfloat.spi.DataStorage) -> a
    void copyFrom(org.apfloat.spi.DataStorage,long) -> b
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> a
    long getSize() -> b
    long implGetSize() -> a
    void setSize(long) -> b
    void implSetSize(long) -> a
    boolean isReadOnly() -> b
    void setReadOnly() -> b
    org.apfloat.spi.ArrayAccess getArray(int,long,int) -> b
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> a
    org.apfloat.spi.ArrayAccess getTransposedArray(int,int,int,int) -> c
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> a
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> a
    boolean isSubsequenced() -> c
    boolean isCached() -> a
org.apfloat.spi.DataStorage$AbstractIterator -> qy:
    int mode -> a
    int increment -> b
    long position -> a
    long length -> b
    boolean hasNext() -> a
    void next() -> a
    int getInt() -> a
    long getLong() -> a
    float getFloat() -> a
    double getDouble() -> a
    void setInt(int) -> a
    void setLong(long) -> a
    void setFloat(float) -> a
    void setDouble(double) -> a
    void checkGet() -> d
    void checkSet() -> e
    void checkLength() -> c
org.apfloat.spi.DataStorage$Iterator -> qz:
    boolean hasNext() -> a
    void next() -> a
    int getInt() -> a
    long getLong() -> a
    float getFloat() -> a
    double getDouble() -> a
    void setInt(int) -> a
    void setLong(long) -> a
    void setFloat(float) -> a
    void setDouble(double) -> a
    java.lang.Object get(java.lang.Class) -> a
    void set(java.lang.Class,java.lang.Object) -> a
    void close() -> b
org.apfloat.spi.DataStorageBuilder -> qA:
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    org.apfloat.spi.DataStorage createCachedDataStorage(long) -> b
    org.apfloat.spi.DataStorage createDataStorage(org.apfloat.spi.DataStorage) -> a
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.spi.Factor3NTTStepStrategy -> qB:
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.spi.FilenameGenerator -> qC:
    java.lang.String path -> a
    long value -> a
    java.lang.String suffix -> b
    java.lang.String generateFilename() -> a
    java.lang.String getInitialValue() -> b
org.apfloat.spi.MatrixBuilder -> qD:
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
org.apfloat.spi.MatrixStrategy -> qE:
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
org.apfloat.spi.NTTBuilder -> qF:
    org.apfloat.spi.NTTStrategy createNTT(long) -> a
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.spi.NTTConvolutionStepStrategy -> qG:
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
org.apfloat.spi.NTTStepStrategy -> qH:
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.spi.NTTStrategy -> qI:
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
org.apfloat.spi.RadixConstants -> qJ:
    int[][] RADIX_FACTORS -> a
    int[] FLOAT_PRECISION -> a
    int[] DOUBLE_PRECISION -> b
    int[] LONG_PRECISION -> c
    int[] LONG_DIGITS -> d
org.apfloat.spi.Util -> qK:
    boolean $assertionsDisabled -> a
    int round2down(int) -> a
    long round2down(long) -> a
    long round2up(long) -> b
    long round23down(long) -> c
    long round23up(long) -> d
    int sqrt4down(int) -> b
    long sqrt4down(long) -> e
    int sqrt4up(int) -> c
    int log2down(long) -> a
    int log2up(long) -> b
    long ifFinite(long,long) -> a
org.matheclipse.combinatoric.AbstractListStepVisitor -> qL:
    java.util.List list -> a
    java.lang.Object[] array -> a
    void toIntArray(java.util.List,int,int) -> a
    boolean visit(int[][]) -> a
    int[] getMultisetArray() -> a
org.matheclipse.combinatoric.IStepVisitor -> qM:
    boolean visit(int[][]) -> a
    int[] getMultisetArray() -> a
org.matheclipse.combinatoric.MultisetCombinationIterator -> qN:
    int[] result -> a
    int[] multiset -> b
    int n -> a
    int k -> b
    int[] next() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.combinatoric.MultisetPartitionsIterator -> qO:
    int n -> a
    int[] multiset -> a
    int[][] result -> a
    org.matheclipse.combinatoric.RosenNumberPartitionIterator rosen -> a
    org.matheclipse.combinatoric.IStepVisitor handler -> a
    boolean execute() -> a
    void recursiveMultisetCombination(int[],int[],int) -> a
org.matheclipse.combinatoric.NumberPartitionsIterator -> qP:
    int[][] result -> a
    org.matheclipse.combinatoric.RosenNumberPartitionIterator rosen -> a
    org.matheclipse.combinatoric.IStepVisitor handler -> a
org.matheclipse.combinatoric.RosenIterator -> qQ:
    int n -> a
    int k -> b
    int[] a -> a
    long count -> a
    long count(int,int) -> a
    boolean hasNext() -> hasNext
    int[] next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.combinatoric.RosenNumberPartitionIterator -> qR:
    int[] next() -> a
    java.lang.Object next() -> next
org.matheclipse.combinatoric.StopException -> qS:
org.matheclipse.commons.math.analysis.solvers.AbstractDifferentiableUnivariateSolver -> qT:
    org.apache.commons.math3.analysis.UnivariateFunction functionDerivative -> b
    double computeDerivativeObjectiveValue(double) -> b
    void setup(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
org.matheclipse.commons.math.analysis.solvers.DifferentiableUnivariateFunction -> qU:
    org.apache.commons.math3.analysis.UnivariateFunction derivative() -> a
org.matheclipse.commons.math.analysis.solvers.NewtonSolver -> qV:
    double doSolve() -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm -> qW:
    org.apache.commons.math3.linear.FieldMatrix rowReducedMatrix -> a
    org.apache.commons.math3.linear.FieldMatrix nullSpaceCache -> b
    int matrixRankCache -> a
    org.apache.commons.math3.FieldElement zero -> a
    org.apache.commons.math3.FieldElement one -> b
    int numRows -> b
    int numCols -> c
    boolean isZero(org.apache.commons.math3.FieldElement) -> a
    boolean isOne(org.apache.commons.math3.FieldElement) -> b
    org.apache.commons.math3.FieldElement getCoordinate(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex) -> a
    void swapRow(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex) -> a
    void multiplyAdd(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix getNullSpace(org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.linear.FieldMatrix rowReduce() -> a
    int getMatrixRank() -> a
    void scaleRow(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.apache.commons.math3.FieldElement) -> a
org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex -> qX:
    int row -> a
    int col -> b
    java.lang.String toString() -> toString
org.matheclipse.core.basic.Config -> org.matheclipse.core.basic.Config:
    boolean SWING_PLOT_FRAME -> SWING_PLOT_FRAME
    long TIME_CONSTRAINED_MILLISECONDS -> TIME_CONSTRAINED_MILLISECONDS
    long FOREVER -> FOREVER
    long TIME_CONSTRAINED_SLEEP_MILLISECONDS -> TIME_CONSTRAINED_SLEEP_MILLISECONDS
    boolean DEBUG -> DEBUG
    boolean SHOW_STACKTRACE -> SHOW_STACKTRACE
    boolean SHOW_CONSOLE -> SHOW_CONSOLE
    boolean SHOW_PATTERN_EVAL_STEPS -> SHOW_PATTERN_EVAL_STEPS
    java.util.Set SHOW_PATTERN_SYMBOL_STEPS -> SHOW_PATTERN_SYMBOL_STEPS
    boolean PARSER_USE_LOWERCASE_SYMBOLS -> PARSER_USE_LOWERCASE_SYMBOLS
    boolean RUBI_CONVERT_SYMBOLS -> RUBI_CONVERT_SYMBOLS
    boolean SERVER_MODE -> SERVER_MODE
    double DOUBLE_EPSILON -> DOUBLE_EPSILON
    double DOUBLE_TOLERANCE -> DOUBLE_TOLERANCE
    double DEFAULT_ROOTS_CHOP_DELTA -> DEFAULT_ROOTS_CHOP_DELTA
    int BIGINTEGER_MAX_SIZE -> BIGINTEGER_MAX_SIZE
    int FASTTABLE_MAX_SIZE -> FASTTABLE_MAX_SIZE
    int STRING_MAX_SIZE -> STRING_MAX_SIZE
    int AST_MAX_POOL_SIZE -> AST_MAX_POOL_SIZE
    int INTEGER_MAX_POOL_SIZE -> INTEGER_MAX_POOL_SIZE
    int FRACTION_MAX_POOL_SIZE -> FRACTION_MAX_POOL_SIZE
    int COMPLEX_MAX_POOL_SIZE -> COMPLEX_MAX_POOL_SIZE
    int DOUBLE_MAX_POOL_SIZE -> DOUBLE_MAX_POOL_SIZE
    int DOUBLECOMPLEX_MAX_POOL_SIZE -> DOUBLECOMPLEX_MAX_POOL_SIZE
    int PATTERN_MAX_POOL_SIZE -> PATTERN_MAX_POOL_SIZE
    int STRING_MAX_POOL_SIZE -> STRING_MAX_POOL_SIZE
    int MAX_DOUBLE_VECTOR_SIZE -> MAX_DOUBLE_VECTOR_SIZE
    int MAX_DOUBLE_MATRIX_SIZE -> MAX_DOUBLE_MATRIX_SIZE
org.matheclipse.core.boole.QuineMcCluskyFormula -> qY:
    java.util.List termList -> a
    java.util.List originalTermList -> b
    org.matheclipse.core.interfaces.IAST variables -> a
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr toExpr() -> a
    void reduceToPrimeImplicants() -> a
    void reducePrimeImplicantsToSubset() -> b
    int extractEssentialImplicant(boolean[][]) -> a
    void extractImplicant(boolean[][],int) -> a
    int extractLargestImplicant(boolean[][]) -> b
org.matheclipse.core.boole.QuineMcCluskyTerm -> qZ:
    byte[] varVals -> a
    java.lang.String toString() -> toString
    org.matheclipse.core.boole.QuineMcCluskyTerm combine(org.matheclipse.core.boole.QuineMcCluskyTerm) -> a
    int countValues(byte) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void addBytes(java.util.ArrayList,java.util.ArrayList) -> a
org.matheclipse.core.builtin.constant.Catalan -> org.matheclipse.core.builtin.constant.Catalan:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.ComplexInfinity -> org.matheclipse.core.builtin.constant.ComplexInfinity:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.constant.Degree -> org.matheclipse.core.builtin.constant.Degree:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.constant.E -> org.matheclipse.core.builtin.constant.E:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr apfloatEval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.EulerGamma -> org.matheclipse.core.builtin.constant.EulerGamma:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.Glaisher -> org.matheclipse.core.builtin.constant.Glaisher:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.GoldenRatio -> org.matheclipse.core.builtin.constant.GoldenRatio:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.I -> org.matheclipse.core.builtin.constant.I:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
org.matheclipse.core.builtin.constant.Infinity -> org.matheclipse.core.builtin.constant.Infinity:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.constant.Khinchin -> org.matheclipse.core.builtin.constant.Khinchin:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.constant.Pi -> org.matheclipse.core.builtin.constant.Pi:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr apfloatEval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> a
    double evalReal() -> a
org.matheclipse.core.builtin.function.And -> org.matheclipse.core.builtin.function.And:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Append -> org.matheclipse.core.builtin.function.Append:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.AppendTo -> org.matheclipse.core.builtin.function.AppendTo:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.AppendTo$AppendToFunction -> ra:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Apply -> org.matheclipse.core.builtin.function.Apply:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Array -> org.matheclipse.core.builtin.function.Array:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArray(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Array$ArrayIterator -> rb:
    int fCurrent -> a
    int fFrom -> b
    int fTo -> c
    boolean setUp() -> a
    void tearDown() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.builtin.function.AtomQ -> org.matheclipse.core.builtin.function.AtomQ:
    org.matheclipse.core.builtin.function.AtomQ CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Attributes -> org.matheclipse.core.builtin.function.Attributes:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Blank -> org.matheclipse.core.builtin.function.Blank:
    org.matheclipse.core.builtin.function.Blank CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Block -> org.matheclipse.core.builtin.function.Block:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Break -> org.matheclipse.core.builtin.function.Break:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Cases -> org.matheclipse.core.builtin.function.Cases:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Cases$CasesPatternMatcherFunctor -> rc:
    org.matheclipse.core.patternmatching.PatternMatcher matcher -> a
    org.matheclipse.core.interfaces.IAST resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Cases$CasesRulesFunctor -> rd:
    com.google.common.base.Function function -> a
    org.matheclipse.core.interfaces.IAST resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Catch -> org.matheclipse.core.builtin.function.Catch:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Chop -> org.matheclipse.core.builtin.function.Chop:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Clear -> org.matheclipse.core.builtin.function.Clear:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.ClearAll -> org.matheclipse.core.builtin.function.ClearAll:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Complex -> org.matheclipse.core.builtin.function.Complex:
    org.matheclipse.core.builtin.function.Complex CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.CompoundExpression -> org.matheclipse.core.builtin.function.CompoundExpression:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Condition -> org.matheclipse.core.builtin.function.Condition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean checkCondition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Continue -> org.matheclipse.core.builtin.function.Continue:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Defer -> org.matheclipse.core.builtin.function.Defer:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Definition -> org.matheclipse.core.builtin.function.Definition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Delete -> org.matheclipse.core.builtin.function.Delete:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.DeleteCases -> org.matheclipse.core.builtin.function.DeleteCases:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Depth -> org.matheclipse.core.builtin.function.Depth:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    int depth(org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.builtin.function.DirectedInfinity -> org.matheclipse.core.builtin.function.DirectedInfinity:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr timesInf(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Do -> org.matheclipse.core.builtin.function.Do:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Do$DoIterator -> re:
    java.util.List fIterList -> a
    int fIndex -> a
    org.matheclipse.core.interfaces.IExpr doIt(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.builtin.function.Drop -> org.matheclipse.core.builtin.function.Drop:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.EvenQ -> org.matheclipse.core.builtin.function.EvenQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.First -> org.matheclipse.core.builtin.function.First:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.FixedPoint -> org.matheclipse.core.builtin.function.FixedPoint:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Flatten -> org.matheclipse.core.builtin.function.Flatten:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Fold -> org.matheclipse.core.builtin.function.Fold:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateNestList(org.matheclipse.core.interfaces.IAST) -> c
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.FoldList -> org.matheclipse.core.builtin.function.FoldList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateNestList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IAST foldLeft(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int,int,org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.For -> org.matheclipse.core.builtin.function.For:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.FreeQ -> org.matheclipse.core.builtin.function.FreeQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.FullForm -> org.matheclipse.core.builtin.function.FullForm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Function -> org.matheclipse.core.builtin.function.Function:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Head -> org.matheclipse.core.builtin.function.Head:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Hold -> org.matheclipse.core.builtin.function.Hold:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Identity -> org.matheclipse.core.builtin.function.Identity:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.If -> org.matheclipse.core.builtin.function.If:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Implies -> org.matheclipse.core.builtin.function.Implies:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Insert -> org.matheclipse.core.builtin.function.Insert:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.IntegerQ -> org.matheclipse.core.builtin.function.IntegerQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.JavaForm -> org.matheclipse.core.builtin.function.JavaForm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Last -> org.matheclipse.core.builtin.function.Last:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.LeafCount -> org.matheclipse.core.builtin.function.LeafCount:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.LeafCount$LeafCountVisitor -> org.matheclipse.core.builtin.function.LeafCount$LeafCountVisitor:
    int fHeadOffset -> a
    long visit$2ed48855() -> a
    long visit$f81862f() -> b
    long visit$4d323d9f() -> c
    long visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Length -> org.matheclipse.core.builtin.function.Length:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.ListQ -> org.matheclipse.core.builtin.function.ListQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.MathMLForm -> org.matheclipse.core.builtin.function.MathMLForm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.MemberQ -> org.matheclipse.core.builtin.function.MemberQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Module -> org.matheclipse.core.builtin.function.Module:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean checkModuleCondition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.IExpr evalModule(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> a
    void rememberVariables(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.EvalEngine,java.lang.String,java.util.Map) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.N -> org.matheclipse.core.builtin.function.N:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Nand -> org.matheclipse.core.builtin.function.Nand:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Nest -> org.matheclipse.core.builtin.function.Nest:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.NestList -> org.matheclipse.core.builtin.function.NestList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.NestWhile -> org.matheclipse.core.builtin.function.NestWhile:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.NestWhileList -> org.matheclipse.core.builtin.function.NestWhileList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Nor -> org.matheclipse.core.builtin.function.Nor:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.NumberQ -> org.matheclipse.core.builtin.function.NumberQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.NumericQ -> org.matheclipse.core.builtin.function.NumericQ:
    org.matheclipse.core.builtin.function.NumericQ CONST -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.ISignedNumber getSignedNumberNumericQ(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.INumber getNumberNumericQ(org.matheclipse.core.interfaces.IExpr) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.OddQ -> org.matheclipse.core.builtin.function.OddQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Or -> org.matheclipse.core.builtin.function.Or:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Package -> org.matheclipse.core.builtin.function.Package:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void evalPackage(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST convertSymbolsInList(org.matheclipse.core.interfaces.IAST,java.util.HashMap) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    void loadPackage(org.matheclipse.core.eval.EvalEngine,java.io.Reader) -> a
org.matheclipse.core.builtin.function.Pattern -> org.matheclipse.core.builtin.function.Pattern:
    org.matheclipse.core.builtin.function.Pattern CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Position -> org.matheclipse.core.builtin.function.Position:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST position(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.LevelSpec,com.google.common.base.Predicate,org.matheclipse.core.generic.interfaces.IPositionConverter,int) -> a
    org.matheclipse.core.interfaces.IAST position(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.util.LevelSpec) -> a
org.matheclipse.core.builtin.function.Prepend -> org.matheclipse.core.builtin.function.Prepend:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.PrependTo -> org.matheclipse.core.builtin.function.PrependTo:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.PrependTo$PrependToFunction -> rf:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Print -> org.matheclipse.core.builtin.function.Print:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Quiet -> org.matheclipse.core.builtin.function.Quiet:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Rational -> org.matheclipse.core.builtin.function.Rational:
    org.matheclipse.core.builtin.function.Rational CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Reap -> org.matheclipse.core.builtin.function.Reap:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Rest -> org.matheclipse.core.builtin.function.Rest:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Return -> org.matheclipse.core.builtin.function.Return:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Riffle -> org.matheclipse.core.builtin.function.Riffle:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.RotateLeft -> org.matheclipse.core.builtin.function.RotateLeft:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.RotateRight -> org.matheclipse.core.builtin.function.RotateRight:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.Rule -> org.matheclipse.core.builtin.function.Rule:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.RuleDelayed -> org.matheclipse.core.builtin.function.RuleDelayed:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Set -> org.matheclipse.core.builtin.function.Set:
    org.matheclipse.core.builtin.function.Set CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object[] createPatternMatcher(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> b
    java.lang.Object[] putDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.SetAttributes -> org.matheclipse.core.builtin.function.SetAttributes:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.builtin.function.SetDelayed -> org.matheclipse.core.builtin.function.SetDelayed:
    org.matheclipse.core.builtin.function.SetDelayed CONST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object[] putDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Sow -> org.matheclipse.core.builtin.function.Sow:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Switch -> org.matheclipse.core.builtin.function.Switch:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.TeXForm -> org.matheclipse.core.builtin.function.TeXForm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Throw -> org.matheclipse.core.builtin.function.Throw:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.TimeConstrained -> org.matheclipse.core.builtin.function.TimeConstrained:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Trace -> org.matheclipse.core.builtin.function.Trace:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Unevaluated -> org.matheclipse.core.builtin.function.Unevaluated:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.Unique -> org.matheclipse.core.builtin.function.Unique:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.UpSet -> org.matheclipse.core.builtin.function.UpSet:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object[] createPatternMatcher$3e35c740(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.UpSetDelayed -> org.matheclipse.core.builtin.function.UpSetDelayed:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.ValueQ -> org.matheclipse.core.builtin.function.ValueQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Which -> org.matheclipse.core.builtin.function.Which:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.While -> org.matheclipse.core.builtin.function.While:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.convert.AST2Expr -> rg:
    java.lang.String[] UPPERCASE_SYMBOL_STRINGS -> a
    java.lang.String[] SYMBOL_STRINGS -> b
    java.lang.String[] FUNCTION_STRINGS -> c
    java.util.Map RUBI_STATISTICS_MAP -> b
    java.util.Map PREDEFINED_SYMBOLS_MAP -> a
    java.lang.String[] ALIASES_STRINGS -> d
    org.matheclipse.core.interfaces.IExpr[] ALIASES_SYMBOLS -> a
    java.util.Map PREDEFINED_ALIASES_MAP -> c
    java.lang.String TIMES_STRING -> a
    java.lang.String TRUE_STRING -> b
    org.matheclipse.core.convert.AST2Expr CONST -> a
    org.matheclipse.core.convert.AST2Expr CONST_LC -> b
    int fPrecision -> a
    boolean fLowercaseEnabled -> a
    org.matheclipse.core.interfaces.IExpr convert(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.IExpr convert(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.core.interfaces.IExpr rewriteLessGreaterAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.convert.ConversionException -> rh:
org.matheclipse.core.convert.Expr2Object -> ri:
    int MAX_POLYNOMIAL -> a
    double[] toDoubleVector(org.matheclipse.core.interfaces.IAST) -> a
    double[] toPolynomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    java.util.Map toPolynomialMap(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    void addCoefficient(java.util.Map,double,int) -> a
org.matheclipse.core.convert.JASConvert -> rj:
    edu.jas.structure.AbelianGroupFactory fRingFactory$5b76095 -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    edu.jas.poly.GenPolynomialRing fBigIntegerPolyFactory -> b
    java.util.List fVariables -> a
    edu.jas.poly.GenPolynomial expr2JAS(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    edu.jas.poly.GenPolynomial numericExpr2JAS(org.matheclipse.core.interfaces.IExpr) -> a
    edu.jas.poly.GenPolynomial expr2Poly(org.matheclipse.core.interfaces.IExpr,boolean) -> b
    edu.jas.poly.GenPolynomial fraction2Poly(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object[] factorTerms(edu.jas.poly.GenPolynomial) -> a
    org.matheclipse.core.interfaces.IExpr integerPoly2Expr(edu.jas.poly.GenPolynomial) -> a
    org.matheclipse.core.interfaces.IAST poly2Expr(edu.jas.poly.GenPolynomial,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST rationalPoly2Expr(edu.jas.poly.GenPolynomial) -> a
    org.matheclipse.core.interfaces.IComplex jas2Complex(edu.jas.poly.Complex) -> a
org.matheclipse.core.convert.JASConvert$RatToRatFactor -> rk:
    java.math.BigInteger lcm -> a
    java.math.BigInteger gcd -> b
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
org.matheclipse.core.convert.JASIExpr -> rl:
    edu.jas.structure.AbelianGroupFactory fRingFactory$5b76095 -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    java.util.List fVariables -> a
    boolean fNumericFunction -> a
    edu.jas.poly.GenPolynomial expr2IExprJAS(org.matheclipse.core.interfaces.IExpr) -> a
    edu.jas.poly.GenPolynomial expr2IExprJAS(org.matheclipse.core.polynomials.Polynomial) -> a
    edu.jas.poly.GenPolynomial expr2IExprPoly(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr exprPoly2Expr(edu.jas.poly.GenPolynomial,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.convert.JASModInteger -> rm:
    edu.jas.arith.ModLongRing fRingFactory -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    java.util.List fVariables -> a
    edu.jas.poly.GenPolynomial expr2JAS(org.matheclipse.core.interfaces.IExpr) -> a
    edu.jas.poly.GenPolynomial expr2Poly(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IExpr modLongPoly2Expr(edu.jas.poly.GenPolynomial) -> a
    edu.jas.arith.ModLongRing option2ModLongRing(org.matheclipse.core.interfaces.ISignedNumber) -> a
org.matheclipse.core.convert.Object2Expr -> rn:
    org.matheclipse.core.convert.Object2Expr CONST -> a
    org.matheclipse.core.interfaces.IExpr convert(java.lang.Object) -> a
    org.matheclipse.core.interfaces.IExpr convertComplex(org.apache.commons.math3.complex.Complex[]) -> a
org.matheclipse.core.convert.VariablesSet -> org.matheclipse.core.convert.VariablesSet:
    java.util.Set fVariablesSet -> a
    boolean add(org.matheclipse.core.interfaces.ISymbol) -> a
    void addVarList(org.matheclipse.core.interfaces.IExpr) -> a
    java.util.List appendToList(java.util.List) -> a
    org.matheclipse.core.interfaces.IAST getVarList() -> a
    boolean isSize(int) -> a
    int size() -> a
org.matheclipse.core.convert.VariablesSet$1 -> org.matheclipse.core.convert.VariablesSet$1:
    org.matheclipse.core.convert.VariablesSet$IsMemberVisitor visitor -> a
    org.matheclipse.core.convert.VariablesSet val$exprVar -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.convert.VariablesSet$IsMemberVisitor -> org.matheclipse.core.convert.VariablesSet$IsMemberVisitor:
    org.matheclipse.core.convert.VariablesSet this$0 -> a
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.convert.VariablesSet$VariablesVisitor -> org.matheclipse.core.convert.VariablesSet$VariablesVisitor:
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.eval.CoreCallbackFunction -> ro:
    org.matheclipse.core.eval.CoreCallbackFunction CONST -> a
    double evaluate$5bc7c9e6(org.matheclipse.parser.client.ast.FunctionNode,double[]) -> a
org.matheclipse.core.eval.EvalComplex -> org.matheclipse.core.eval.EvalComplex:
org.matheclipse.core.eval.EvalDouble -> org.matheclipse.core.eval.EvalDouble:
    double eval(double[],int,org.matheclipse.core.interfaces.IExpr) -> eval
    double evalAST(double[],int,org.matheclipse.core.interfaces.IAST) -> evalAST
    double evalSymbol(org.matheclipse.core.interfaces.ISymbol) -> evalSymbol
org.matheclipse.core.eval.EvalEngine -> org.matheclipse.core.eval.EvalEngine:
    java.util.Map fUserVariableMap -> a
    java.util.IdentityHashMap fLocalVariableStackMap -> a
    boolean fStopRequested -> a
    int fRecursionCounter -> a
    boolean fNumericMode -> b
    int fNumericPrecision -> b
    boolean fEvalLHSMode -> c
    java.lang.String fSessionID -> a
    boolean fTraceMode -> d
    org.matheclipse.core.eval.TraceStack fTraceStack -> a
    java.io.PrintStream fOutPrintStream -> a
    int fRecursionLimit -> c
    int fIterationLimit -> d
    int fAnonymousCounter -> e
    boolean fPackageMode -> e
    int fModuleCounter -> f
    boolean fRelaxedSyntax -> f
    org.matheclipse.core.interfaces.IAST reapList -> a
    java.util.Set fModifiedVariablesList -> a
    org.matheclipse.core.eval.LastCalculationsHistory fOutList -> a
    org.matheclipse.core.interfaces.IExpr fAnswer -> a
    boolean fOutListDisabled -> g
    boolean fQuietMode -> h
    java.lang.ThreadLocal instance -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr evalBlock(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> evalBlock
    org.matheclipse.core.interfaces.IExpr evalQuiet(org.matheclipse.core.interfaces.IExpr) -> evalQuiet
    org.matheclipse.core.interfaces.IExpr evalQuietNull(org.matheclipse.core.interfaces.IExpr) -> evalQuietNull
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.IExpr) -> evalNull
    int getNextAnonymousCounter() -> getNextAnonymousCounter
    java.lang.String getNextCounter() -> getNextCounter
    java.util.Stack localStack(org.matheclipse.core.interfaces.ISymbol) -> localStack
    java.util.Stack localStackCreate(org.matheclipse.core.interfaces.ISymbol) -> localStackCreate
    void set(org.matheclipse.core.eval.EvalEngine) -> set
    org.matheclipse.core.interfaces.IAST threadASTListArgs(org.matheclipse.core.interfaces.IAST) -> threadASTListArgs
    org.matheclipse.core.eval.EvalEngine get() -> get
    void remove() -> remove
    boolean addModifiedVariable(org.matheclipse.core.interfaces.ISymbol) -> addModifiedVariable
    void addOut(org.matheclipse.core.interfaces.IExpr) -> addOut
    void addRules(org.matheclipse.core.interfaces.IAST) -> addRules
    void beginTrace(com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> beginTrace
    org.matheclipse.core.interfaces.IAST endTrace() -> endTrace
    org.matheclipse.core.interfaces.IAST evalArgs(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr evalAST(org.matheclipse.core.interfaces.IAST) -> evalAST
    org.matheclipse.core.interfaces.IExpr evalRules(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST) -> evalRules
    org.matheclipse.core.interfaces.IExpr evalASTAttributes(org.matheclipse.core.interfaces.IAST) -> evalASTAttributes
    org.matheclipse.core.interfaces.IExpr evalAttributes(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST) -> evalAttributes
    org.matheclipse.core.interfaces.IExpr evalASTBuiltinFunction(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evalLoop(org.matheclipse.core.interfaces.IExpr) -> evalLoop
    org.matheclipse.core.interfaces.IExpr evalSetAttributes(org.matheclipse.core.interfaces.IAST) -> evalSetAttributes
    org.matheclipse.core.interfaces.IExpr evalSetAttributesRecursive(org.matheclipse.core.interfaces.IAST,boolean) -> a
    org.matheclipse.core.interfaces.IAST evalSetAttributeArg(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evalSetOrderless(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IAST evalFlatOrderlessAttributesRecursive(org.matheclipse.core.interfaces.IAST) -> evalFlatOrderlessAttributesRecursive
    org.matheclipse.core.interfaces.IAST evalTrace(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> evalTrace
    boolean evalTrue(org.matheclipse.core.interfaces.IExpr) -> evalTrue
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(java.lang.String) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateNull(org.matheclipse.core.interfaces.IExpr) -> evaluateNull
    org.matheclipse.core.interfaces.IExpr evalWithoutNumericReset(org.matheclipse.core.interfaces.IExpr) -> evalWithoutNumericReset
    org.matheclipse.core.interfaces.IAST flattenSequences(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr getAnswer() -> getAnswer
    int getIterationLimit() -> getIterationLimit
    java.util.Map getLocalVariableStackMap() -> getLocalVariableStackMap
    java.util.Set getModifiedVariables() -> getModifiedVariables
    org.matheclipse.core.eval.LastCalculationsHistory getOutList() -> getOutList
    java.io.PrintStream getOutPrintStream() -> getOutPrintStream
    org.matheclipse.core.interfaces.IAST getReapList() -> getReapList
    int getRecursionLimit() -> getRecursionLimit
    java.lang.String getSessionID() -> getSessionID
    org.matheclipse.core.interfaces.ISymbol getUserVariable(java.lang.String) -> getUserVariable
    org.matheclipse.core.interfaces.ISymbol putUserVariable(java.lang.String,org.matheclipse.core.interfaces.ISymbol) -> putUserVariable
    void removeUserVariables(java.util.Map) -> removeUserVariables
    int incModuleCounter() -> incModuleCounter
    void init() -> init
    boolean isEvalLHSMode() -> isEvalLHSMode
    boolean isNumericMode() -> isNumericMode
    boolean isOutListDisabled() -> isOutListDisabled
    boolean isPackageMode() -> isPackageMode
    boolean isQuietMode() -> isQuietMode
    boolean isRelaxedSyntax() -> isRelaxedSyntax
    boolean isStopRequested() -> isStopRequested
    boolean isTraceMode() -> isTraceMode
    org.matheclipse.core.interfaces.IExpr parse(java.lang.String) -> parse
    org.matheclipse.parser.client.ast.ASTNode parseNode(java.lang.String) -> parseNode
    void reset() -> reset
    void setIterationLimit(int) -> setIterationLimit
    void setNumericMode(boolean) -> setNumericMode
    void setNumericMode(boolean,int) -> setNumericMode
    int getNumericPrecision() -> getNumericPrecision
    boolean isApfloat() -> isApfloat
    boolean isApfloat(int) -> isApfloat
    void setNumericPrecision(int) -> setNumericPrecision
    void setOutListDisabled(boolean,int) -> setOutListDisabled
    void setOutPrintStream(java.io.PrintStream) -> setOutPrintStream
    void setPackageMode(boolean) -> setPackageMode
    void setQuietMode(boolean) -> setQuietMode
    void setReapList(org.matheclipse.core.interfaces.IAST) -> setReapList
    void setRecursionLimit(int) -> setRecursionLimit
    void setRelaxedSyntax(boolean) -> setRelaxedSyntax
    void setSessionID(java.lang.String) -> setSessionID
    void setStopRequested(boolean) -> setStopRequested
    void setTraceMode(boolean) -> setTraceMode
    int sizeOut() -> sizeOut
    void stopRequest() -> stopRequest
    java.lang.String toString() -> toString
    void printMessage(java.lang.String) -> printMessage
org.matheclipse.core.eval.EvalEngine$1 -> rp:
    int fID -> a
    java.lang.Object initialValue() -> initialValue
org.matheclipse.core.eval.EvalUtilities -> org.matheclipse.core.eval.EvalUtilities:
    org.matheclipse.core.interfaces.IExpr evaluate(java.lang.String) -> evaluate
    org.matheclipse.core.interfaces.IExpr eval(java.lang.String,org.matheclipse.core.eval.EvalEngine) -> eval
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr) -> evaluate
    java.lang.String toJavaForm(java.lang.String) -> toJavaForm
    org.matheclipse.core.interfaces.IAST evalTrace(java.lang.String,com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> evalTrace
    org.matheclipse.core.interfaces.IAST evalTrace(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> evalTrace
    void toMathML(java.lang.String,java.io.Writer) -> toMathML
org.matheclipse.core.eval.LastCalculationsHistory -> rq:
    org.matheclipse.core.interfaces.IExpr[] fOutHistory -> a
    int fMaximumCapacity -> a
    int fIndex -> b
    int fAllEntriesCounter -> c
    org.matheclipse.core.interfaces.IExpr get(int) -> a
org.matheclipse.core.eval.MathMLUtilities -> org.matheclipse.core.eval.MathMLUtilities:
    org.matheclipse.core.eval.EvalEngine fEvalEngine -> a
    org.matheclipse.core.form.mathml.MathMLFormFactory fMathMLFactory -> a
    boolean fMSIE -> a
    boolean fMathMLHeader -> b
    void toMathML(java.lang.String,java.io.Writer) -> toMathML
    void toMathML(org.matheclipse.core.interfaces.IExpr,java.io.Writer) -> toMathML
    void toJava(java.lang.String,java.io.Writer,boolean) -> toJava
    void startRequest() -> startRequest
    void stopRequest() -> stopRequest
org.matheclipse.core.eval.MathUtils -> org.matheclipse.core.eval.MathUtils:
    java.lang.Double[][] rom -> a
    double romberg(int,int) -> a
    double arcLength(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> arcLength
    double integrate(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> integrate
    double integrate(java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> integrate
    double getFunctionVal(java.lang.String,double) -> getFunctionVal
    double getFunctionVal(java.lang.String,java.lang.String,java.lang.String) -> getFunctionVal
    java.lang.String getFunctionVal(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[]) -> getFunctionVal
    boolean isValid(java.lang.String,java.lang.String[]) -> isValid
    boolean[] isValid(java.lang.String[],java.lang.String[]) -> isValid
    java.lang.String getDerivative(java.lang.String,java.lang.String[],java.lang.String) -> getDerivative
    java.lang.String getPowerSeries(java.lang.String,java.lang.String,java.lang.String,int) -> getPowerSeries
    java.lang.String tangentLine(java.lang.String,java.lang.String,java.lang.String) -> tangentLine
    double surfaceArea(java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> surfaceArea
    java.lang.String evaluate(java.lang.String,java.lang.String) -> evaluate
    java.lang.String evaluate(java.lang.String,org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr parse(java.lang.String,org.matheclipse.core.interfaces.IAST) -> parse
org.matheclipse.core.eval.Namespace -> rr:
    java.util.ArrayList fNamespacesString -> a
    java.util.Map fPackageNamespaceMap -> a
    void setEvaluator(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.eval.PlusOp -> rs:
    java.util.Map plusMap -> a
    boolean evaled -> a
    org.matheclipse.core.interfaces.IExpr numberValue -> a
    boolean addMerge(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr infinityPlus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr negativeInfinityPlus(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.Range -> rt:
    org.matheclipse.core.interfaces.IAST fList -> a
    int fStart -> a
    int fEnd -> b
    org.matheclipse.core.interfaces.IExpr foldLeft(org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IExpr) -> a
    java.util.Iterator iterator() -> iterator
    java.util.Collection rotateLeft(java.util.Collection,int) -> a
    java.util.Collection rotateRight(java.util.Collection,int) -> b
    int size() -> a
    org.matheclipse.core.interfaces.IAST sort(org.matheclipse.core.generic.ExprComparator) -> a
    java.util.List toList(java.util.List) -> a
org.matheclipse.core.eval.Range$RangeIterator -> ru:
    int fCurrrent -> a
    org.matheclipse.core.eval.Range fRange -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.eval.SymjaInterpreter -> rv:
    java.lang.String codeString -> a
    java.io.PrintStream outStream -> a
    java.lang.String interpreter(java.lang.String) -> a
    java.lang.String interpreter(org.matheclipse.core.interfaces.IAST) -> a
    void printException(java.lang.Appendable,java.lang.Throwable) -> a
org.matheclipse.core.eval.SystemNamespace -> rw:
    org.matheclipse.core.eval.Namespace DEFAULT -> a
org.matheclipse.core.eval.TeXUtilities -> org.matheclipse.core.eval.TeXUtilities:
    org.matheclipse.core.eval.EvalEngine fEvalEngine -> a
    org.matheclipse.core.form.tex.TeXFormFactory fTeXFactory -> a
    org.matheclipse.parser.client.Parser fParser -> a
    void toTeX(java.lang.String,java.io.Writer) -> toTeX
    void toTeX(org.matheclipse.core.interfaces.IExpr,java.io.Writer) -> toTeX
    void stopRequest() -> stopRequest
org.matheclipse.core.eval.TraceStack -> rx:
    java.util.Stack fStack -> a
    com.google.common.base.Predicate fMatcher -> a
    org.matheclipse.core.interfaces.IAST fList -> b
    org.matheclipse.core.interfaces.IAST fTraceList -> a
    void pushList() -> a
    void popList() -> b
    void add(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.eval.exception.BooleanFunctionConversionException -> ry:
org.matheclipse.core.eval.exception.BreakException -> org.matheclipse.core.eval.exception.BreakException:
org.matheclipse.core.eval.exception.ConditionException -> org.matheclipse.core.eval.exception.ConditionException:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.ContinueException -> org.matheclipse.core.eval.exception.ContinueException:
org.matheclipse.core.eval.exception.DimensionException -> org.matheclipse.core.eval.exception.DimensionException:
org.matheclipse.core.eval.exception.DivisionByZero -> org.matheclipse.core.eval.exception.DivisionByZero:
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.FlowControlException -> org.matheclipse.core.eval.exception.FlowControlException:
org.matheclipse.core.eval.exception.IndeterminateException -> org.matheclipse.core.eval.exception.IndeterminateException:
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.IterationLimitExceeded -> org.matheclipse.core.eval.exception.IterationLimitExceeded:
    int fLimit -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    java.lang.String getMessage() -> getMessage
    void throwIt(int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.eval.exception.JASConversionException -> rz:
org.matheclipse.core.eval.exception.NoEvalException -> org.matheclipse.core.eval.exception.NoEvalException:
org.matheclipse.core.eval.exception.NonNegativeIntegerExpected -> org.matheclipse.core.eval.exception.NonNegativeIntegerExpected:
    int fCurrent -> a
    org.matheclipse.core.interfaces.IAST fExpr -> a
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.RecursionLimitExceeded -> org.matheclipse.core.eval.exception.RecursionLimitExceeded:
    int fLimit -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    java.lang.String getMessage() -> getMessage
    void throwIt(int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.eval.exception.ReturnException -> org.matheclipse.core.eval.exception.ReturnException:
    org.matheclipse.core.interfaces.IExpr value -> a
org.matheclipse.core.eval.exception.RuleCreationError -> org.matheclipse.core.eval.exception.RuleCreationError:
    org.matheclipse.core.interfaces.IExpr fLHS -> a
    org.matheclipse.core.interfaces.IExpr fRHS -> b
    org.matheclipse.core.interfaces.IExpr fCondition -> c
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.ThrowException -> org.matheclipse.core.eval.exception.ThrowException:
    org.matheclipse.core.interfaces.IExpr value -> a
org.matheclipse.core.eval.exception.TimeExceeded -> org.matheclipse.core.eval.exception.TimeExceeded:
org.matheclipse.core.eval.exception.UnsupportedParameterException -> org.matheclipse.core.eval.exception.UnsupportedParameterException:
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.WrappedException -> org.matheclipse.core.eval.exception.WrappedException:
    java.lang.Throwable fThrowable -> a
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.WrongArgumentType -> org.matheclipse.core.eval.exception.WrongArgumentType:
    int fPosition -> a
    org.matheclipse.core.interfaces.IExpr fArg -> a
    org.matheclipse.core.interfaces.IAST fExpr -> a
    java.lang.String fMessage -> a
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.WrongNumberOfArguments -> org.matheclipse.core.eval.exception.WrongNumberOfArguments:
    int fAllowed -> a
    int fCurrent -> b
    org.matheclipse.core.interfaces.IAST fExpr -> a
    int fTextNumber -> c
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.interfaces.AbstractArg1 -> org.matheclipse.core.eval.interfaces.AbstractArg1:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    org.matheclipse.core.interfaces.IExpr e1IntArg(org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.eval.interfaces.AbstractArg12 -> org.matheclipse.core.eval.interfaces.AbstractArg12:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.interfaces.AbstractArg2 -> org.matheclipse.core.eval.interfaces.AbstractArg2:
    org.matheclipse.core.interfaces.IExpr binaryOperator(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr e2ApfloatArg(org.matheclipse.core.expression.ApfloatNum,org.matheclipse.core.expression.ApfloatNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2ApcomplexArg(org.matheclipse.core.expression.ApcomplexNum,org.matheclipse.core.expression.ApcomplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr eComFraArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.interfaces.AbstractArgMultiple -> org.matheclipse.core.eval.interfaces.AbstractArgMultiple:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> a
    org.matheclipse.core.interfaces.IAST evaluateHashs(org.matheclipse.core.interfaces.IAST) -> a
    void defineHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr binaryOperator(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.eval.interfaces.AbstractCoreFunctionEvaluator -> org.matheclipse.core.eval.interfaces.AbstractCoreFunctionEvaluator:
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.interfaces.AbstractFunctionEvaluator -> org.matheclipse.core.eval.interfaces.AbstractFunctionEvaluator:
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean isNegativeExpression(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getNormalizedNegativeExpression(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr[] getPeriodicParts(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getPureImaginaryPart(org.matheclipse.core.interfaces.IExpr) -> c
org.matheclipse.core.eval.interfaces.AbstractMatrix1Expr -> org.matheclipse.core.eval.interfaces.AbstractMatrix1Expr:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.expression.ExprFieldElement matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.eval.interfaces.AbstractMatrix1Matrix -> org.matheclipse.core.eval.interfaces.AbstractMatrix1Matrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.apache.commons.math3.linear.FieldMatrix matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.linear.RealMatrix realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.eval.interfaces.AbstractNonOrderlessArgMultiple -> org.matheclipse.core.eval.interfaces.AbstractNonOrderlessArgMultiple:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.eval.interfaces.AbstractSymbolEvaluator -> org.matheclipse.core.eval.interfaces.AbstractSymbolEvaluator:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr apfloatEval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.eval.interfaces.AbstractTrigArg1 -> org.matheclipse.core.eval.interfaces.AbstractTrigArg1:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
org.matheclipse.core.eval.interfaces.ICoreFunctionEvaluator -> org.matheclipse.core.eval.interfaces.ICoreFunctionEvaluator:
org.matheclipse.core.eval.interfaces.IFunctionEvaluator -> org.matheclipse.core.eval.interfaces.IFunctionEvaluator:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.eval.interfaces.INumeric -> rA:
    double evalReal(double[],int,int) -> a
org.matheclipse.core.eval.interfaces.ISignedNumberConstant -> rB:
    double evalReal() -> a
org.matheclipse.core.eval.interfaces.ISymbolEvaluator -> org.matheclipse.core.eval.interfaces.ISymbolEvaluator:
    org.matheclipse.core.interfaces.IExpr evaluate$7a5d7f22() -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr apfloatEval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> a
org.matheclipse.core.eval.util.AbstractSequence -> rC:
    int fStartOffset -> a
    int fEndOffset -> b
    int fStep -> c
    int getStep() -> a
org.matheclipse.core.eval.util.IIndexFunction -> rD:
    java.lang.Object evaluate(int[]) -> a
org.matheclipse.core.eval.util.ISequence -> rE:
    int getEnd() -> b
    int getStart() -> c
    int getStep() -> a
    void setListSize(int) -> a
org.matheclipse.core.eval.util.IndexFunctionDiagonal -> rF:
    org.matheclipse.core.interfaces.IExpr[] fValues -> a
    java.lang.Object evaluate(int[]) -> a
org.matheclipse.core.eval.util.IndexTableGenerator -> rG:
    int[] fIndexArray -> a
    org.matheclipse.core.interfaces.IAST fPrototypeList -> a
    org.matheclipse.core.eval.util.IIndexFunction fFunction -> a
    int fIndex -> a
    int[] fCurrentIndex -> b
    org.matheclipse.core.interfaces.IExpr table() -> a
org.matheclipse.core.eval.util.Iterator -> rH:
    org.matheclipse.core.interfaces.IExpr count -> d
    boolean fNumericMode -> a
    org.matheclipse.core.eval.EvalEngine evalEngine -> a
    org.matheclipse.core.interfaces.IExpr start -> e
    org.matheclipse.core.interfaces.IExpr maxCounterOrList -> f
    int maxCounterOrListIndex -> a
    org.matheclipse.core.interfaces.IExpr step -> g
    org.matheclipse.core.interfaces.IExpr originalStart -> a
    org.matheclipse.core.interfaces.IExpr originalMaxCount -> b
    org.matheclipse.core.interfaces.IExpr originalStep -> c
    org.matheclipse.core.interfaces.ISymbol variable -> a
    boolean hasNext() -> hasNext
    boolean isValidVariable() -> b
    boolean isNumericFunction() -> c
    void remove() -> remove
    boolean setUp() -> a
    void tearDown() -> a
    java.lang.Object next() -> next
org.matheclipse.core.eval.util.LevelSpec -> rI:
    int fFromLevel -> a
    int fToLevel -> b
    int fFromDepth -> c
    int fToDepth -> d
    int fCurrentLevel -> e
    int fCurrentDepth -> f
    int getCurrentLevel() -> a
    void setFromLevelAsCurrent() -> a
    void incCurrentLevel() -> b
    void decCurrentLevel() -> c
    boolean isInRange() -> a
    int getCurrentDepth() -> b
    void setCurrentDepth(int) -> a
org.matheclipse.core.eval.util.LevelSpecification -> rJ:
org.matheclipse.core.eval.util.ListSizeSequence -> rK:
    int fHeadOffset -> c
    int fListSize -> d
    void setListSize(int) -> a
    int getStart() -> c
    int getEnd() -> b
org.matheclipse.core.eval.util.Options -> rL:
    org.matheclipse.core.interfaces.IAST fDefaultOptionsList -> a
    org.matheclipse.core.interfaces.IAST fCurrentOptionsList -> b
    boolean isOption(java.lang.String) -> a
    org.matheclipse.core.interfaces.IExpr getOption(java.lang.String) -> a
org.matheclipse.core.eval.util.Sequence -> rM:
org.matheclipse.core.eval.util.TableGenerator -> rN:
    java.util.List fIterList -> a
    org.matheclipse.core.interfaces.IExpr fDefaultValue -> a
    org.matheclipse.core.interfaces.IAST fPrototypeList -> a
    org.matheclipse.core.generic.interfaces.IArrayFunction fFunction -> a
    int fIndex -> a
    org.matheclipse.core.interfaces.IExpr[] fCurrentIndex -> a
    org.matheclipse.core.interfaces.IExpr table() -> a
org.matheclipse.core.eval.util.WrongSequenceException -> rO:
org.matheclipse.core.expression.AST -> org.matheclipse.core.expression.AST:
    java.util.EnumMap fProperties -> a
    int fEvalFlags -> c
    int fPatternMatchingHashValue -> d
    java.lang.Object getProperty(org.matheclipse.core.interfaces.IAST$PROPERTY) -> getProperty
    java.lang.Object putProperty(org.matheclipse.core.interfaces.IAST$PROPERTY,java.lang.Object) -> putProperty
    org.matheclipse.core.interfaces.IAST clone() -> clone
    org.matheclipse.core.interfaces.IAST setAtClone(int,org.matheclipse.core.interfaces.IExpr) -> setAtClone
    int findFirstEquals(org.matheclipse.core.interfaces.IExpr) -> findFirstEquals
    org.matheclipse.core.interfaces.ISymbol topHead() -> topHead
    int hierarchy() -> hierarchy
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> isLTOrdered
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> isLEOrdered
    boolean isGTOrdered(org.matheclipse.core.interfaces.IExpr) -> isGTOrdered
    boolean isGEOrdered(org.matheclipse.core.interfaces.IExpr) -> isGEOrdered
    int getEvalFlags() -> getEvalFlags
    void setEvalFlags(int) -> setEvalFlags
    void addEvalFlags(int) -> addEvalFlags
    org.matheclipse.core.interfaces.IAST addOneIdentity(org.matheclipse.core.interfaces.IAST) -> addOneIdentity
    org.matheclipse.core.interfaces.IExpr getOneIdentity(org.matheclipse.core.interfaces.IExpr) -> getOneIdentity
    boolean isEvalFlagOn(int) -> isEvalFlagOn
    boolean isEvalFlagOff(int) -> isEvalFlagOff
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    boolean isList() -> isList
    boolean isSequence() -> isSequence
    boolean isListOfLists() -> isListOfLists
    boolean isComplexInfinity() -> isComplexInfinity
    boolean isDirectedInfinity() -> isDirectedInfinity
    boolean isE() -> isE
    boolean isIndeterminate() -> isIndeterminate
    boolean isInfinity() -> isInfinity
    boolean isNegative() -> isNegative
    boolean isNegativeInfinity() -> isNegativeInfinity
    boolean isPlus() -> isPlus
    boolean isPower() -> isPower
    boolean isTimes() -> isTimes
    boolean isSin() -> isSin
    boolean isCos() -> isCos
    boolean isTan() -> isTan
    boolean isArcSin() -> isArcSin
    boolean isAnd() -> isAnd
    boolean isArcCos() -> isArcCos
    boolean isArcTan() -> isArcTan
    boolean isSinh() -> isSinh
    boolean isSlot() -> isSlot
    boolean isSlotSequence() -> isSlotSequence
    boolean isCosh() -> isCosh
    boolean isTanh() -> isTanh
    boolean isArcSinh() -> isArcSinh
    boolean isArcCosh() -> isArcCosh
    boolean isArcTanh() -> isArcTanh
    boolean isLog() -> isLog
    boolean isOr() -> isOr
    boolean isOne() -> isOne
    boolean isMinusOne() -> isMinusOne
    boolean isZero() -> isZero
    boolean isTrue() -> isTrue
    boolean isFalse() -> isFalse
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> isSame
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    int[] isMatrix() -> isMatrix
    int isVector() -> isVector
    boolean isFraction() -> isFraction
    boolean isPattern() -> isPattern
    boolean isPatternDefault() -> isPatternDefault
    boolean isPatternExpr() -> isPatternExpr
    boolean isPatternSequence() -> isPatternSequence
    boolean isPi() -> isPi
    boolean isPolynomial(org.matheclipse.core.interfaces.ISymbol) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.IAST) -> isPolynomial
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.ISymbol,long) -> isPolynomialOfMaxDegree
    boolean isPositive() -> isPositive
    boolean isCondition() -> isCondition
    boolean isModule() -> isModule
    boolean isSymbol() -> isSymbol
    boolean isConstant() -> isConstant
    boolean isComplex() -> isComplex
    boolean isComplexNumeric() -> isComplexNumeric
    boolean isInteger() -> isInteger
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumIntValue() -> isNumIntValue
    boolean isRational() -> isRational
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isSignedNumber() -> isSignedNumber
    boolean isNot() -> isNot
    boolean isNumeric() -> isNumeric
    boolean isNumericMode() -> isNumericMode
    boolean isNumericFunction() -> isNumericFunction
    boolean isRealFunction() -> isRealFunction
    boolean isNumber() -> isNumber
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr) -> apply
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr,int) -> apply
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr,int,int) -> apply
    org.matheclipse.core.interfaces.IExpr apply(java.util.List) -> apply
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr[]) -> apply
    org.matheclipse.core.interfaces.IAST map(com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST mapAt(org.matheclipse.core.interfaces.IAST,int) -> mapAt
    org.matheclipse.core.interfaces.IAST mapAt(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int) -> mapAt
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.interfaces.BiFunction) -> map
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> replacePart
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> replaceSlots
    org.matheclipse.core.interfaces.IAST[] filter(com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST[] filter(com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate,int) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    boolean isAST() -> isAST
    boolean isOrderlessAST() -> isOrderlessAST
    boolean isFlatAST() -> isFlatAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,org.matheclipse.core.interfaces.IExpr[]) -> isAST
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> isASTSizeGE
    boolean isAST(java.lang.String) -> isAST
    boolean isAST(java.lang.String,int) -> isAST
    boolean isRuleAST() -> isRuleAST
    boolean isFreeAt(int,org.matheclipse.core.interfaces.IExpr) -> isFreeAt
    boolean isFree(org.matheclipse.core.interfaces.IExpr) -> isFree
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> isFree
    boolean isFree(com.google.common.base.Predicate,boolean) -> isFree
    boolean isFreeAST(org.matheclipse.core.interfaces.IExpr) -> isFreeAST
    boolean isFreeAST(com.google.common.base.Predicate) -> isFreeAST
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> isMember
    boolean isMember(com.google.common.base.Predicate,boolean) -> isMember
    boolean isFunction() -> isFunction
    int compareToTimes(org.matheclipse.core.expression.AST) -> a
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    int compareToAST(org.matheclipse.core.expression.AST) -> b
    boolean equals(java.lang.Object) -> equals
    boolean equalsAt(int,org.matheclipse.core.interfaces.IExpr) -> equalsAt
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    int patternHashCode() -> patternHashCode
    boolean isAtom() -> isAtom
    org.matheclipse.core.interfaces.IAST copyHead() -> copyHead
    org.matheclipse.core.interfaces.IAST copyUntil(int) -> copyUntil
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    org.matheclipse.core.interfaces.IExpr variables2Slots(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,com.google.common.base.Function) -> a
    java.lang.String fullFormString() -> fullFormString
    java.lang.String internalFormString(boolean,int) -> internalFormString
    void internalFormOrderless(org.matheclipse.core.interfaces.IAST,java.lang.StringBuffer,java.lang.String,boolean,int) -> a
    java.lang.String toString() -> toString
    java.lang.String toFullFormString() -> c
    boolean addAll(java.util.List) -> addAll
    boolean addAll(java.util.List,int,int) -> addAll
    org.matheclipse.core.interfaces.IAST addAtClone(int,org.matheclipse.core.interfaces.IExpr) -> addAtClone
    org.matheclipse.core.expression.ASTRange args() -> args
    org.matheclipse.core.expression.ASTRange range() -> range
    org.matheclipse.core.expression.ASTRange range(int) -> range
    org.matheclipse.core.expression.ASTRange range(int,int) -> range
    org.matheclipse.core.expression.AST newInstance(int,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.ISymbol,int[]) -> a
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.ISymbol,double[]) -> a
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.ISymbol,org.apache.commons.math3.complex.Complex[]) -> a
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.IExpr negative() -> negative
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IExpr power(long) -> power
    org.matheclipse.core.interfaces.IExpr power(org.matheclipse.core.interfaces.IExpr) -> power
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IExpr getAt(int) -> getAt
    java.lang.Object asType(java.lang.Class) -> asType
    org.matheclipse.core.interfaces.IInteger getInt(int) -> getInt
    org.matheclipse.core.interfaces.INumber getNumber(int) -> getNumber
    org.matheclipse.core.interfaces.IAST getAST(int) -> getAST
    org.matheclipse.core.interfaces.IExpr getPart(int[]) -> getPart
    org.matheclipse.core.interfaces.IExpr getPart(java.util.List) -> getPart
    org.matheclipse.core.interfaces.IAST getList(int) -> getList
    long leafCount() -> leafCount
    java.util.List leaves() -> leaves
    boolean isZERO() -> isZERO
    int signum() -> signum
    edu.jas.structure.ElemFactory factory() -> a
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    org.matheclipse.core.interfaces.IExpr divide(org.matheclipse.core.interfaces.IExpr) -> divide
    boolean isONE() -> isONE
    boolean isUnit() -> d
    boolean isValue() -> isValue
    boolean isVariable() -> isVariable
    org.matheclipse.core.interfaces.IAST removeAtClone(int) -> removeAtClone
    org.matheclipse.core.interfaces.IExpr head() -> head
    java.util.Iterator iterator() -> iterator
    java.util.Iterator iterator0() -> iterator0
    org.matheclipse.core.interfaces.IExpr arg1() -> arg1
    org.matheclipse.core.interfaces.IExpr arg2() -> arg2
    org.matheclipse.core.interfaces.IExpr arg3() -> arg3
    org.matheclipse.core.interfaces.IExpr arg4() -> arg4
    org.matheclipse.core.interfaces.IExpr arg5() -> arg5
    org.matheclipse.core.interfaces.IExpr last() -> last
    org.matheclipse.core.interfaces.IAST appendClone(org.matheclipse.core.interfaces.IExpr) -> appendClone
    org.matheclipse.core.interfaces.IAST prependClone(org.matheclipse.core.interfaces.IExpr) -> prependClone
    java.lang.Object clone() -> clone
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
org.matheclipse.core.expression.AST$ASTIterator -> rP:
    org.matheclipse.core.expression.HMArrayList _table -> a
    int _currentIndex -> a
    int _start -> b
    int _end -> c
    int _nextIndex -> d
    boolean hasNext() -> hasNext
    int nextIndex() -> nextIndex
    boolean hasPrevious() -> hasPrevious
    int previousIndex() -> previousIndex
    void remove() -> remove
    void add(java.lang.Object) -> add
    void set(java.lang.Object) -> set
    java.lang.Object previous() -> previous
    java.lang.Object next() -> next
    org.matheclipse.core.expression.HMArrayList access$002(org.matheclipse.core.expression.AST$ASTIterator,org.matheclipse.core.expression.HMArrayList) -> a
    int access$102(org.matheclipse.core.expression.AST$ASTIterator,int) -> a
    int access$202(org.matheclipse.core.expression.AST$ASTIterator,int) -> b
    int access$302(org.matheclipse.core.expression.AST$ASTIterator,int) -> c
    int access$402(org.matheclipse.core.expression.AST$ASTIterator,int) -> d
org.matheclipse.core.expression.ASTRange -> rQ:
    java.util.List toList() -> a
org.matheclipse.core.expression.ApcomplexNum -> org.matheclipse.core.expression.ApcomplexNum:
    org.apfloat.Apcomplex fApcomplex -> a
    org.matheclipse.core.expression.ApcomplexNum valueOf(org.apfloat.Apcomplex) -> a
    org.matheclipse.core.expression.ApcomplexNum valueOf(org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    org.matheclipse.core.expression.ApcomplexNum valueOf(double,long) -> a
    org.matheclipse.core.expression.ApcomplexNum valueOf(double,double,long) -> a
    org.matheclipse.core.expression.ApcomplexNum valueOf(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,int) -> a
    double getImaginaryPart() -> getImaginaryPart
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    double getRealPart() -> getRealPart
    boolean isZero() -> isZero
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IComplexNum add(org.matheclipse.core.interfaces.IComplexNum) -> add
    org.matheclipse.core.expression.ApcomplexNum add(org.matheclipse.core.expression.ApcomplexNum) -> a
    org.matheclipse.core.interfaces.IComplexNum multiply(org.matheclipse.core.interfaces.IComplexNum) -> multiply
    org.matheclipse.core.interfaces.IComplexNum pow(org.matheclipse.core.interfaces.IComplexNum) -> pow
    org.matheclipse.core.interfaces.IComplexNum conjugate() -> conjugate
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    double dabs() -> dabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    double getImaginary() -> a
    double getReal() -> b
    int hashCode() -> hashCode
    org.matheclipse.core.expression.ApcomplexNum multiply(org.matheclipse.core.expression.ApcomplexNum) -> b
    org.matheclipse.core.expression.ApcomplexNum negate() -> a
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    java.lang.String toString() -> toString
    int complexSign() -> complexSign
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.ApfloatNum -> org.matheclipse.core.expression.ApfloatNum:
    org.apfloat.Apfloat fApfloat -> a
    org.matheclipse.core.expression.ApfloatNum valueOf(double,long) -> a
    org.matheclipse.core.expression.ApfloatNum valueOf(org.apfloat.Apfloat) -> a
    org.matheclipse.core.expression.ApfloatNum valueOf(java.math.BigInteger,long) -> a
    org.matheclipse.core.expression.ApfloatNum valueOf(java.math.BigInteger,java.math.BigInteger,long) -> a
    org.matheclipse.core.expression.ApfloatNum valueOf(java.lang.String,int) -> a
    int hierarchy() -> hierarchy
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumIntValue() -> isNumIntValue
    boolean isNegative() -> isNegative
    boolean isPositive() -> isPositive
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INum add(org.matheclipse.core.interfaces.INum) -> add
    org.matheclipse.core.interfaces.INum multiply(org.matheclipse.core.interfaces.INum) -> multiply
    org.matheclipse.core.interfaces.INum pow(org.matheclipse.core.interfaces.INum) -> pow
    int compareAbsValueToOne() -> compareAbsValueToOne
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    int hashCode() -> hashCode
    int intValue() -> intValue
    int toInt() -> toInt
    long toLong() -> toLong
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.expression.ApfloatNum negate() -> a
    org.matheclipse.core.expression.ApfloatNum opposite() -> c
    org.matheclipse.core.expression.ApfloatNum inverse() -> b
    double getRealPart() -> getRealPart
    boolean isE() -> isE
    boolean isMinusOne() -> isMinusOne
    boolean isOne() -> isOne
    boolean isPi() -> isPi
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isZero() -> isZero
    org.matheclipse.core.interfaces.IInteger round() -> round
    int sign() -> sign
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.String toString() -> toString
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.ComplexNum -> org.matheclipse.core.expression.ComplexNum:
    org.matheclipse.core.expression.ComplexNum I -> a
    org.matheclipse.core.expression.ComplexNum NaN -> b
    org.apache.commons.math3.complex.Complex fComplex -> a
    org.matheclipse.core.expression.ComplexNum newInstance(org.apache.commons.math3.complex.Complex) -> b
    org.matheclipse.core.expression.ComplexNum valueOf(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.expression.ComplexNum valueOf(double) -> a
    org.matheclipse.core.expression.ComplexNum valueOf(double,double) -> a
    double getImaginaryPart() -> getImaginaryPart
    double getRealPart() -> getRealPart
    boolean isZero() -> isZero
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IComplexNum add(org.matheclipse.core.interfaces.IComplexNum) -> add
    org.matheclipse.core.expression.ComplexNum add(org.matheclipse.core.expression.ComplexNum) -> a
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    org.matheclipse.core.interfaces.IComplexNum multiply(org.matheclipse.core.interfaces.IComplexNum) -> multiply
    org.matheclipse.core.interfaces.IComplexNum pow(org.matheclipse.core.interfaces.IComplexNum) -> pow
    org.matheclipse.core.interfaces.IComplexNum conjugate() -> conjugate
    org.matheclipse.core.expression.ComplexNum divide(org.matheclipse.core.expression.ComplexNum) -> b
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    double dabs() -> dabs
    double dabs(org.apache.commons.math3.complex.Complex) -> a
    int compareAbsValueToOne() -> compareAbsValueToOne
    int hashCode() -> hashCode
    org.matheclipse.core.expression.ComplexNum multiply(org.matheclipse.core.expression.ComplexNum) -> c
    org.matheclipse.core.expression.ComplexNum negate() -> a
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.expression.ComplexNum subtract(org.matheclipse.core.expression.ComplexNum) -> d
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    java.lang.String toString() -> toString
    int complexSign() -> complexSign
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.ComplexSym -> org.matheclipse.core.expression.ComplexSym:
    org.apache.commons.math3.fraction.BigFraction _real -> a
    org.apache.commons.math3.fraction.BigFraction _imaginary -> b
    int fHashValue -> a
    org.matheclipse.core.expression.ComplexSym valueOf(java.math.BigInteger,java.math.BigInteger) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(org.apache.commons.math3.fraction.BigFraction,org.apache.commons.math3.fraction.BigFraction) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(long,long,long,long) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IComplex conjugate() -> conjugate
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    org.matheclipse.core.expression.ComplexSym add(org.matheclipse.core.expression.ComplexSym) -> a
    org.matheclipse.core.interfaces.IComplex add(org.matheclipse.core.interfaces.IComplex) -> add
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INumber numericNumber() -> numericNumber
    org.apache.commons.math3.fraction.BigFraction getImaginaryPart() -> getImaginaryPart
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.apache.commons.math3.fraction.BigFraction getRealPart() -> getRealPart
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    boolean isZero() -> isZero
    org.matheclipse.core.interfaces.IComplex multiply(org.matheclipse.core.interfaces.IComplex) -> multiply
    org.matheclipse.core.interfaces.IComplex pow(int) -> pow
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.expression.ComplexSym negate() -> a
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.INumber normalize() -> normalize
    int complexSign() -> complexSign
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
org.matheclipse.core.expression.ExprField -> rR:
    org.matheclipse.core.expression.ExprField CONST -> a
    org.matheclipse.core.expression.ExprFieldElement ONE -> a
    org.matheclipse.core.expression.ExprFieldElement ZERO -> b
    org.matheclipse.core.expression.ExprFieldElement getOne() -> a
    java.lang.Class getRuntimeClass() -> a
    java.lang.Object getOne() -> b
    java.lang.Object getZero() -> a
org.matheclipse.core.expression.ExprFieldElement -> rS:
    org.matheclipse.core.interfaces.IExpr val -> a
    org.matheclipse.core.expression.ExprFieldElement add(org.matheclipse.core.expression.ExprFieldElement) -> a
    boolean equals(java.lang.Object) -> equals
    org.apache.commons.math3.Field getField() -> getField
    int hashCode() -> hashCode
    org.matheclipse.core.expression.ExprFieldElement multiply(org.matheclipse.core.expression.ExprFieldElement) -> b
    org.matheclipse.core.expression.ExprFieldElement subtract(org.matheclipse.core.expression.ExprFieldElement) -> c
    java.lang.String toString() -> toString
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.expression.ExprImpl -> org.matheclipse.core.expression.ExprImpl:
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.visit.VisitorReplaceAll) -> a
    org.matheclipse.core.interfaces.IExpr abs() -> b
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr[]) -> apply
    org.matheclipse.core.interfaces.IExpr apply(java.util.List) -> apply
    java.lang.Object asType(java.lang.Class) -> asType
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.IExpr divide(org.matheclipse.core.interfaces.IExpr) -> divide
    org.matheclipse.core.interfaces.IExpr[] egcd(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    edu.jas.structure.ElemFactory factory() -> a
    java.lang.String fullFormString() -> fullFormString
    org.matheclipse.core.interfaces.IExpr gcd(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getAt(int) -> getAt
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    boolean isAnd() -> isAnd
    boolean isArcCos() -> isArcCos
    boolean isArcCosh() -> isArcCosh
    boolean isArcSin() -> isArcSin
    boolean isArcSinh() -> isArcSinh
    boolean isArcTan() -> isArcTan
    boolean isArcTanh() -> isArcTanh
    boolean isAST() -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,org.matheclipse.core.interfaces.IExpr[]) -> isAST
    boolean isAST(java.lang.String) -> isAST
    boolean isAST(java.lang.String,int) -> isAST
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> isASTSizeGE
    boolean isAtom() -> isAtom
    boolean isComplex() -> isComplex
    boolean isComplexInfinity() -> isComplexInfinity
    boolean isComplexNumeric() -> isComplexNumeric
    boolean isCondition() -> isCondition
    boolean isConstant() -> isConstant
    boolean isCos() -> isCos
    boolean isCosh() -> isCosh
    boolean isDirectedInfinity() -> isDirectedInfinity
    boolean isE() -> isE
    boolean isFalse() -> isFalse
    boolean isFlatAST() -> isFlatAST
    boolean isFraction() -> isFraction
    boolean isFree(org.matheclipse.core.interfaces.IExpr) -> isFree
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> isFree
    boolean isFree(com.google.common.base.Predicate,boolean) -> isFree
    boolean isFreeAST(org.matheclipse.core.interfaces.IExpr) -> isFreeAST
    boolean isFreeAST(com.google.common.base.Predicate) -> isFreeAST
    boolean isFunction() -> isFunction
    boolean isGEOrdered(org.matheclipse.core.interfaces.IExpr) -> isGEOrdered
    boolean isGTOrdered(org.matheclipse.core.interfaces.IExpr) -> isGTOrdered
    boolean isIndeterminate() -> isIndeterminate
    boolean isInfinity() -> isInfinity
    boolean isInteger() -> isInteger
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> isLEOrdered
    boolean isList() -> isList
    boolean isListOfLists() -> isListOfLists
    boolean isLog() -> isLog
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> isLTOrdered
    int[] isMatrix() -> isMatrix
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> isMember
    boolean isMember(com.google.common.base.Predicate,boolean) -> isMember
    boolean isMinusOne() -> isMinusOne
    boolean isModule() -> isModule
    boolean isNegative() -> isNegative
    boolean isNegativeInfinity() -> isNegativeInfinity
    boolean isNot() -> isNot
    boolean isNumber() -> isNumber
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumeric() -> isNumeric
    boolean isNumericFunction() -> isNumericFunction
    boolean isNumericMode() -> isNumericMode
    boolean isNumIntValue() -> isNumIntValue
    boolean isOne() -> isOne
    boolean isONE() -> isONE
    boolean isOr() -> isOr
    boolean isOrderlessAST() -> isOrderlessAST
    boolean isPattern() -> isPattern
    boolean isPatternDefault() -> isPatternDefault
    boolean isPatternExpr() -> isPatternExpr
    boolean isPatternSequence() -> isPatternSequence
    boolean isPi() -> isPi
    boolean isPlus() -> isPlus
    boolean isPolynomial(org.matheclipse.core.interfaces.ISymbol) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.IAST) -> isPolynomial
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.ISymbol,long) -> isPolynomialOfMaxDegree
    boolean isPositive() -> isPositive
    boolean isPower() -> isPower
    boolean isRational() -> isRational
    boolean isRealFunction() -> isRealFunction
    boolean isRuleAST() -> isRuleAST
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> isSame
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    boolean isSequence() -> isSequence
    boolean isSignedNumber() -> isSignedNumber
    boolean isSin() -> isSin
    boolean isSinh() -> isSinh
    boolean isSlot() -> isSlot
    boolean isSlotSequence() -> isSlotSequence
    boolean isSymbol() -> isSymbol
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isTan() -> isTan
    boolean isTanh() -> isTanh
    boolean isTimes() -> isTimes
    boolean isTrue() -> isTrue
    boolean isUnit() -> d
    boolean isValue() -> isValue
    boolean isVariable() -> isVariable
    int isVector() -> isVector
    boolean isZero() -> isZero
    boolean isZERO() -> isZERO
    long leafCount() -> leafCount
    java.util.List leaves() -> leaves
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr negative() -> negative
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr power(org.matheclipse.core.interfaces.IExpr) -> power
    org.matheclipse.core.interfaces.IExpr power(long) -> power
    org.matheclipse.core.interfaces.IExpr remainder(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> replacePart
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> replaceSlots
    int signum() -> signum
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.ISymbol topHead() -> topHead
    java.lang.String toScript() -> a
    java.lang.String toScriptFactory() -> b
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> a
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> b
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> c
org.matheclipse.core.expression.ExprRingFactory -> rT:
    boolean isField() -> c
    java.math.BigInteger characteristic() -> a
    boolean isFinite() -> a
    java.lang.String toScript() -> a
    boolean isCommutative() -> b
    edu.jas.structure.AbelianGroupElem getZERO() -> c
    edu.jas.structure.Element parse(java.lang.String) -> a
    edu.jas.structure.Element random(int,java.util.Random) -> a
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> a
    edu.jas.structure.Element fromInteger(long) -> a
    edu.jas.structure.MonoidElem getONE() -> b
org.matheclipse.core.expression.F -> org.matheclipse.core.expression.F:
    boolean isSystemStarted -> isSystemStarted
    boolean isSystemInitialized -> isSystemInitialized
    java.util.Map PREDEFINED_INTERNAL_FORM_STRINGS -> PREDEFINED_INTERNAL_FORM_STRINGS
    java.util.Map PREDEFINED_PATTERN_MAP -> PREDEFINED_PATTERN_MAP
    java.util.Map PREDEFINED_SYMBOLS_MAP -> PREDEFINED_SYMBOLS_MAP
    org.matheclipse.core.expression.ISymbolObserver SYMBOL_OBSERVER -> SYMBOL_OBSERVER
    org.matheclipse.core.interfaces.ISymbol Catalan -> Catalan
    org.matheclipse.core.interfaces.ISymbol ComplexInfinity -> ComplexInfinity
    org.matheclipse.core.interfaces.ISymbol Degree -> Degree
    org.matheclipse.core.interfaces.ISymbol E -> E
    org.matheclipse.core.interfaces.ISymbol EulerGamma -> EulerGamma
    org.matheclipse.core.interfaces.ISymbol Glaisher -> Glaisher
    org.matheclipse.core.interfaces.ISymbol GoldenRatio -> GoldenRatio
    org.matheclipse.core.interfaces.ISymbol I -> I
    org.matheclipse.core.interfaces.ISymbol Infinity -> Infinity
    org.matheclipse.core.interfaces.ISymbol Khinchin -> Khinchin
    org.matheclipse.core.interfaces.ISymbol Pi -> Pi
    org.matheclipse.core.interfaces.ISymbol IntegerHead -> IntegerHead
    org.matheclipse.core.interfaces.ISymbol SymbolHead -> SymbolHead
    org.matheclipse.core.interfaces.ISymbol RealHead -> RealHead
    org.matheclipse.core.interfaces.ISymbol PatternHead -> PatternHead
    org.matheclipse.core.interfaces.ISymbol BlankHead -> BlankHead
    org.matheclipse.core.interfaces.ISymbol StringHead -> StringHead
    org.matheclipse.core.interfaces.ISymbol MethodHead -> MethodHead
    org.matheclipse.core.interfaces.ISymbol False -> False
    org.matheclipse.core.interfaces.ISymbol List -> List
    org.matheclipse.core.interfaces.ISymbol True -> True
    org.matheclipse.core.interfaces.ISymbol Null -> Null
    org.matheclipse.core.interfaces.ISymbol Second -> Second
    org.matheclipse.core.interfaces.ISymbol Indeterminate -> Indeterminate
    org.matheclipse.core.interfaces.ISymbol Listable -> Listable
    org.matheclipse.core.interfaces.ISymbol Constant -> Constant
    org.matheclipse.core.interfaces.ISymbol NumericFunction -> NumericFunction
    org.matheclipse.core.interfaces.ISymbol Orderless -> Orderless
    org.matheclipse.core.interfaces.ISymbol OneIdentity -> OneIdentity
    org.matheclipse.core.interfaces.ISymbol Flat -> Flat
    org.matheclipse.core.interfaces.ISymbol HoldFirst -> HoldFirst
    org.matheclipse.core.interfaces.ISymbol HoldRest -> HoldRest
    org.matheclipse.core.interfaces.ISymbol HoldAll -> HoldAll
    org.matheclipse.core.interfaces.ISymbol NHoldFirst -> NHoldFirst
    org.matheclipse.core.interfaces.ISymbol NHoldRest -> NHoldRest
    org.matheclipse.core.interfaces.ISymbol NHoldAll -> NHoldAll
    org.matheclipse.core.interfaces.ISymbol Line -> Line
    org.matheclipse.core.interfaces.ISymbol BoxRatios -> BoxRatios
    org.matheclipse.core.interfaces.ISymbol MeshRange -> MeshRange
    org.matheclipse.core.interfaces.ISymbol PlotRange -> PlotRange
    org.matheclipse.core.interfaces.ISymbol AxesStyle -> AxesStyle
    org.matheclipse.core.interfaces.ISymbol Automatic -> Automatic
    org.matheclipse.core.interfaces.ISymbol AxesOrigin -> AxesOrigin
    org.matheclipse.core.interfaces.ISymbol Axes -> Axes
    org.matheclipse.core.interfaces.ISymbol Background -> Background
    org.matheclipse.core.interfaces.ISymbol White -> White
    org.matheclipse.core.interfaces.ISymbol Slot -> Slot
    org.matheclipse.core.interfaces.ISymbol SlotSequence -> SlotSequence
    org.matheclipse.core.interfaces.ISymbol Options -> Options
    org.matheclipse.core.interfaces.ISymbol Graphics -> Graphics
    org.matheclipse.core.interfaces.ISymbol Graphics3D -> Graphics3D
    org.matheclipse.core.interfaces.ISymbol Show -> Show
    org.matheclipse.core.interfaces.ISymbol SurfaceGraphics -> SurfaceGraphics
    org.matheclipse.core.interfaces.ISymbol ArcCosh -> ArcCosh
    org.matheclipse.core.interfaces.ISymbol ArcCoth -> ArcCoth
    org.matheclipse.core.interfaces.ISymbol ArcCsc -> ArcCsc
    org.matheclipse.core.interfaces.ISymbol ArcCsch -> ArcCsch
    org.matheclipse.core.interfaces.ISymbol ArcSec -> ArcSec
    org.matheclipse.core.interfaces.ISymbol ArcSech -> ArcSech
    org.matheclipse.core.interfaces.ISymbol ArcSinh -> ArcSinh
    org.matheclipse.core.interfaces.ISymbol ArcTanh -> ArcTanh
    org.matheclipse.core.interfaces.ISymbol Plot -> Plot
    org.matheclipse.core.interfaces.ISymbol Plot3D -> Plot3D
    org.matheclipse.core.interfaces.ISymbol RootOf -> RootOf
    org.matheclipse.core.interfaces.ISymbol Sequence -> Sequence
    org.matheclipse.core.interfaces.ISymbol And -> And
    org.matheclipse.core.interfaces.ISymbol Append -> Append
    org.matheclipse.core.interfaces.ISymbol AppendTo -> AppendTo
    org.matheclipse.core.interfaces.ISymbol Apply -> Apply
    org.matheclipse.core.interfaces.ISymbol Attributes -> Attributes
    org.matheclipse.core.interfaces.ISymbol Array -> Array
    org.matheclipse.core.interfaces.ISymbol AtomQ -> AtomQ
    org.matheclipse.core.interfaces.ISymbol Blank -> Blank
    org.matheclipse.core.interfaces.ISymbol Block -> Block
    org.matheclipse.core.interfaces.ISymbol Break -> Break
    org.matheclipse.core.interfaces.ISymbol Cases -> Cases
    org.matheclipse.core.interfaces.ISymbol Catch -> Catch
    org.matheclipse.core.interfaces.ISymbol Chop -> Chop
    org.matheclipse.core.interfaces.ISymbol Clear -> Clear
    org.matheclipse.core.interfaces.ISymbol ClearAll -> ClearAll
    org.matheclipse.core.interfaces.ISymbol Complex -> Complex
    org.matheclipse.core.interfaces.ISymbol CompoundExpression -> CompoundExpression
    org.matheclipse.core.interfaces.ISymbol Condition -> Condition
    org.matheclipse.core.interfaces.ISymbol Continue -> Continue
    org.matheclipse.core.interfaces.ISymbol Defer -> Defer
    org.matheclipse.core.interfaces.ISymbol Definition -> Definition
    org.matheclipse.core.interfaces.ISymbol Delete -> Delete
    org.matheclipse.core.interfaces.ISymbol DeleteCases -> DeleteCases
    org.matheclipse.core.interfaces.ISymbol Depth -> Depth
    org.matheclipse.core.interfaces.ISymbol DirectedInfinity -> DirectedInfinity
    org.matheclipse.core.interfaces.ISymbol Drop -> Drop
    org.matheclipse.core.interfaces.ISymbol Do -> Do
    org.matheclipse.core.interfaces.ISymbol EvenQ -> EvenQ
    org.matheclipse.core.interfaces.ISymbol First -> First
    org.matheclipse.core.interfaces.ISymbol FixedPoint -> FixedPoint
    org.matheclipse.core.interfaces.ISymbol Flatten -> Flatten
    org.matheclipse.core.interfaces.ISymbol Fold -> Fold
    org.matheclipse.core.interfaces.ISymbol FoldList -> FoldList
    org.matheclipse.core.interfaces.ISymbol For -> For
    org.matheclipse.core.interfaces.ISymbol FreeQ -> FreeQ
    org.matheclipse.core.interfaces.ISymbol FullForm -> FullForm
    org.matheclipse.core.interfaces.ISymbol Function -> A
    org.matheclipse.core.interfaces.ISymbol Head -> Head
    org.matheclipse.core.interfaces.ISymbol Hold -> Hold
    org.matheclipse.core.interfaces.ISymbol Identity -> Identity
    org.matheclipse.core.interfaces.ISymbol If -> If
    org.matheclipse.core.interfaces.ISymbol Implies -> Implies
    org.matheclipse.core.interfaces.ISymbol Insert -> Insert
    org.matheclipse.core.interfaces.ISymbol IntegerQ -> IntegerQ
    org.matheclipse.core.interfaces.ISymbol JavaForm -> JavaForm
    org.matheclipse.core.interfaces.ISymbol Last -> Last
    org.matheclipse.core.interfaces.ISymbol LeafCount -> LeafCount
    org.matheclipse.core.interfaces.ISymbol Length -> Length
    org.matheclipse.core.interfaces.ISymbol ListQ -> ListQ
    org.matheclipse.core.interfaces.ISymbol MathMLForm -> MathMLForm
    org.matheclipse.core.interfaces.ISymbol MemberQ -> MemberQ
    org.matheclipse.core.interfaces.ISymbol Module -> Module
    org.matheclipse.core.interfaces.ISymbol N -> N
    org.matheclipse.core.interfaces.ISymbol Nand -> Nand
    org.matheclipse.core.interfaces.ISymbol Nest -> Nest
    org.matheclipse.core.interfaces.ISymbol NestList -> NestList
    org.matheclipse.core.interfaces.ISymbol NestWhile -> NestWhile
    org.matheclipse.core.interfaces.ISymbol NestWhileList -> NestWhileList
    org.matheclipse.core.interfaces.ISymbol Nor -> Nor
    org.matheclipse.core.interfaces.ISymbol NumberQ -> NumberQ
    org.matheclipse.core.interfaces.ISymbol NumericQ -> NumericQ
    org.matheclipse.core.interfaces.ISymbol OddQ -> OddQ
    org.matheclipse.core.interfaces.ISymbol Or -> Or
    org.matheclipse.core.interfaces.ISymbol Package -> Package
    org.matheclipse.core.interfaces.ISymbol Pattern -> Pattern
    org.matheclipse.core.interfaces.ISymbol Position -> Position
    org.matheclipse.core.interfaces.ISymbol Prepend -> Prepend
    org.matheclipse.core.interfaces.ISymbol PrependTo -> PrependTo
    org.matheclipse.core.interfaces.ISymbol Print -> Print
    org.matheclipse.core.interfaces.ISymbol Quiet -> Quiet
    org.matheclipse.core.interfaces.ISymbol Rational -> Rational
    org.matheclipse.core.interfaces.ISymbol Reap -> Reap
    org.matheclipse.core.interfaces.ISymbol Rest -> Rest
    org.matheclipse.core.interfaces.ISymbol Return -> Return
    org.matheclipse.core.interfaces.ISymbol Riffle -> Riffle
    org.matheclipse.core.interfaces.ISymbol RotateLeft -> RotateLeft
    org.matheclipse.core.interfaces.ISymbol RotateRight -> RotateRight
    org.matheclipse.core.interfaces.ISymbol Rule -> Rule
    org.matheclipse.core.interfaces.ISymbol RuleDelayed -> RuleDelayed
    org.matheclipse.core.interfaces.ISymbol Set -> Set
    org.matheclipse.core.interfaces.ISymbol SetAttributes -> SetAttributes
    org.matheclipse.core.interfaces.ISymbol SetDelayed -> SetDelayed
    org.matheclipse.core.interfaces.ISymbol Sow -> Sow
    org.matheclipse.core.interfaces.ISymbol Switch -> Switch
    org.matheclipse.core.interfaces.ISymbol TeXForm -> TeXForm
    org.matheclipse.core.interfaces.ISymbol TimeConstrained -> TimeConstrained
    org.matheclipse.core.interfaces.ISymbol Throw -> Throw
    org.matheclipse.core.interfaces.ISymbol Trace -> Trace
    org.matheclipse.core.interfaces.ISymbol Unevaluated -> Unevaluated
    org.matheclipse.core.interfaces.ISymbol Unique -> Unique
    org.matheclipse.core.interfaces.ISymbol UpSet -> UpSet
    org.matheclipse.core.interfaces.ISymbol UpSetDelayed -> UpSetDelayed
    org.matheclipse.core.interfaces.ISymbol ValueQ -> ValueQ
    org.matheclipse.core.interfaces.ISymbol Which -> Which
    org.matheclipse.core.interfaces.ISymbol While -> While
    org.matheclipse.core.interfaces.ISymbol Abs -> Abs
    org.matheclipse.core.interfaces.ISymbol AddTo -> AddTo
    org.matheclipse.core.interfaces.ISymbol Apart -> Apart
    org.matheclipse.core.interfaces.ISymbol ArcCos -> ArcCos
    org.matheclipse.core.interfaces.ISymbol ArcCot -> ArcCot
    org.matheclipse.core.interfaces.ISymbol ArcSin -> ArcSin
    org.matheclipse.core.interfaces.ISymbol ArcTan -> ArcTan
    org.matheclipse.core.interfaces.ISymbol Arg -> Arg
    org.matheclipse.core.interfaces.ISymbol Binomial -> Binomial
    org.matheclipse.core.interfaces.ISymbol Boole -> Boole
    org.matheclipse.core.interfaces.ISymbol BooleanMinimize -> BooleanMinimize
    org.matheclipse.core.interfaces.ISymbol Cancel -> Cancel
    org.matheclipse.core.interfaces.ISymbol CartesianProduct -> CartesianProduct
    org.matheclipse.core.interfaces.ISymbol CatalanNumber -> CatalanNumber
    org.matheclipse.core.interfaces.ISymbol Ceiling -> Ceiling
    org.matheclipse.core.interfaces.ISymbol CharacteristicPolynomial -> CharacteristicPolynomial
    org.matheclipse.core.interfaces.ISymbol ChessboardDistance -> ChessboardDistance
    org.matheclipse.core.interfaces.ISymbol Coefficient -> Coefficient
    org.matheclipse.core.interfaces.ISymbol CoefficientList -> CoefficientList
    org.matheclipse.core.interfaces.ISymbol Collect -> Collect
    org.matheclipse.core.interfaces.ISymbol Complement -> Complement
    org.matheclipse.core.interfaces.ISymbol ComposeList -> ComposeList
    org.matheclipse.core.interfaces.ISymbol Conjugate -> Conjugate
    org.matheclipse.core.interfaces.ISymbol ConjugateTranspose -> ConjugateTranspose
    org.matheclipse.core.interfaces.ISymbol ConstantArray -> ConstantArray
    org.matheclipse.core.interfaces.ISymbol ContinuedFraction -> ContinuedFraction
    org.matheclipse.core.interfaces.ISymbol CoprimeQ -> CoprimeQ
    org.matheclipse.core.interfaces.ISymbol Cos -> Cos
    org.matheclipse.core.interfaces.ISymbol Cosh -> Cosh
    org.matheclipse.core.interfaces.ISymbol Cot -> Cot
    org.matheclipse.core.interfaces.ISymbol Coth -> Coth
    org.matheclipse.core.interfaces.ISymbol Count -> Count
    org.matheclipse.core.interfaces.ISymbol Cross -> Cross
    org.matheclipse.core.interfaces.ISymbol Csc -> Csc
    org.matheclipse.core.interfaces.ISymbol Csch -> Csch
    org.matheclipse.core.interfaces.ISymbol Curl -> Curl
    org.matheclipse.core.interfaces.ISymbol D -> D
    org.matheclipse.core.interfaces.ISymbol Decrement -> Decrement
    org.matheclipse.core.interfaces.ISymbol Default -> Default
    org.matheclipse.core.interfaces.ISymbol Denominator -> Denominator
    org.matheclipse.core.interfaces.ISymbol Derivative -> Derivative
    org.matheclipse.core.interfaces.ISymbol Det -> Det
    org.matheclipse.core.interfaces.ISymbol DiagonalMatrix -> DiagonalMatrix
    org.matheclipse.core.interfaces.ISymbol DigitQ -> DigitQ
    org.matheclipse.core.interfaces.ISymbol Dimensions -> Dimensions
    org.matheclipse.core.interfaces.ISymbol Discriminant -> Discriminant
    org.matheclipse.core.interfaces.ISymbol Distribute -> Distribute
    org.matheclipse.core.interfaces.ISymbol Divergence -> Divergence
    org.matheclipse.core.interfaces.ISymbol DivideBy -> DivideBy
    org.matheclipse.core.interfaces.ISymbol Divisible -> Divisible
    org.matheclipse.core.interfaces.ISymbol Dot -> Dot
    org.matheclipse.core.interfaces.ISymbol Eigenvalues -> Eigenvalues
    org.matheclipse.core.interfaces.ISymbol Eigenvectors -> Eigenvectors
    org.matheclipse.core.interfaces.ISymbol Equal -> Equal
    org.matheclipse.core.interfaces.ISymbol Equivalent -> Equivalent
    org.matheclipse.core.interfaces.ISymbol Erf -> Erf
    org.matheclipse.core.interfaces.ISymbol Erfc -> Erfc
    org.matheclipse.core.interfaces.ISymbol Erfi -> Erfi
    org.matheclipse.core.interfaces.ISymbol EuclidianDistance -> EuclidianDistance
    org.matheclipse.core.interfaces.ISymbol EulerPhi -> EulerPhi
    org.matheclipse.core.interfaces.ISymbol Exp -> Exp
    org.matheclipse.core.interfaces.ISymbol Expand -> Expand
    org.matheclipse.core.interfaces.ISymbol ExpandAll -> ExpandAll
    org.matheclipse.core.interfaces.ISymbol Exponent -> Exponent
    org.matheclipse.core.interfaces.ISymbol ExtendedGCD -> ExtendedGCD
    org.matheclipse.core.interfaces.ISymbol Extract -> Extract
    org.matheclipse.core.interfaces.ISymbol Factor -> Factor
    org.matheclipse.core.interfaces.ISymbol Factorial -> Factorial
    org.matheclipse.core.interfaces.ISymbol Factorial2 -> Factorial2
    org.matheclipse.core.interfaces.ISymbol FactorInteger -> FactorInteger
    org.matheclipse.core.interfaces.ISymbol FactorSquareFree -> FactorSquareFree
    org.matheclipse.core.interfaces.ISymbol FactorSquareFreeList -> FactorSquareFreeList
    org.matheclipse.core.interfaces.ISymbol FactorTerms -> FactorTerms
    org.matheclipse.core.interfaces.ISymbol Fibonacci -> Fibonacci
    org.matheclipse.core.interfaces.ISymbol FindRoot -> FindRoot
    org.matheclipse.core.interfaces.ISymbol Fit -> Fit
    org.matheclipse.core.interfaces.ISymbol Floor -> Floor
    org.matheclipse.core.interfaces.ISymbol FractionalPart -> FractionalPart
    org.matheclipse.core.interfaces.ISymbol FrobeniusSolve -> FrobeniusSolve
    org.matheclipse.core.interfaces.ISymbol FromCharacterCode -> FromCharacterCode
    org.matheclipse.core.interfaces.ISymbol FromContinuedFraction -> FromContinuedFraction
    org.matheclipse.core.interfaces.ISymbol FullSimplify -> FullSimplify
    org.matheclipse.core.interfaces.ISymbol Gamma -> Gamma
    org.matheclipse.core.interfaces.ISymbol GCD -> GCD
    org.matheclipse.core.interfaces.ISymbol GeometricMean -> GeometricMean
    org.matheclipse.core.interfaces.ISymbol Greater -> Greater
    org.matheclipse.core.interfaces.ISymbol GreaterEqual -> GreaterEqual
    org.matheclipse.core.interfaces.ISymbol GroebnerBasis -> GroebnerBasis
    org.matheclipse.core.interfaces.ISymbol HarmonicNumber -> HarmonicNumber
    org.matheclipse.core.interfaces.ISymbol HilbertMatrix -> HilbertMatrix
    org.matheclipse.core.interfaces.ISymbol Horner -> Horner
    org.matheclipse.core.interfaces.ISymbol HurwitzZeta -> HurwitzZeta
    org.matheclipse.core.interfaces.ISymbol IdentityMatrix -> IdentityMatrix
    org.matheclipse.core.interfaces.ISymbol Im -> Im
    org.matheclipse.core.interfaces.ISymbol Increment -> Increment
    org.matheclipse.core.interfaces.ISymbol Inner -> Inner
    org.matheclipse.core.interfaces.ISymbol IntegerPart -> IntegerPart
    org.matheclipse.core.interfaces.ISymbol IntegerPartitions -> IntegerPartitions
    org.matheclipse.core.interfaces.ISymbol Integrate -> Integrate
    org.matheclipse.core.interfaces.ISymbol Intersection -> Intersection
    org.matheclipse.core.interfaces.ISymbol Inverse -> Inverse
    org.matheclipse.core.interfaces.ISymbol InverseErf -> InverseErf
    org.matheclipse.core.interfaces.ISymbol InverseFunction -> InverseFunction
    org.matheclipse.core.interfaces.ISymbol JacobiMatrix -> JacobiMatrix
    org.matheclipse.core.interfaces.ISymbol JacobiSymbol -> JacobiSymbol
    org.matheclipse.core.interfaces.ISymbol Join -> Join
    org.matheclipse.core.interfaces.ISymbol KOrderlessPartitions -> KOrderlessPartitions
    org.matheclipse.core.interfaces.ISymbol KPartitions -> KPartitions
    org.matheclipse.core.interfaces.ISymbol LCM -> LCM
    org.matheclipse.core.interfaces.ISymbol Less -> Less
    org.matheclipse.core.interfaces.ISymbol LessEqual -> LessEqual
    org.matheclipse.core.interfaces.ISymbol LetterQ -> LetterQ
    org.matheclipse.core.interfaces.ISymbol Level -> Level
    org.matheclipse.core.interfaces.ISymbol Limit -> Limit
    org.matheclipse.core.interfaces.ISymbol LinearProgramming -> LinearProgramming
    org.matheclipse.core.interfaces.ISymbol LinearSolve -> LinearSolve
    org.matheclipse.core.interfaces.ISymbol Log -> Log
    org.matheclipse.core.interfaces.ISymbol LowerCaseQ -> LowerCaseQ
    org.matheclipse.core.interfaces.ISymbol LUDecomposition -> LUDecomposition
    org.matheclipse.core.interfaces.ISymbol ManhattanDistance -> ManhattanDistance
    org.matheclipse.core.interfaces.ISymbol Map -> Map
    org.matheclipse.core.interfaces.ISymbol MapAll -> MapAll
    org.matheclipse.core.interfaces.ISymbol MapThread -> MapThread
    org.matheclipse.core.interfaces.ISymbol MatchQ -> MatchQ
    org.matheclipse.core.interfaces.ISymbol MatrixPower -> MatrixPower
    org.matheclipse.core.interfaces.ISymbol MatrixQ -> MatrixQ
    org.matheclipse.core.interfaces.ISymbol Max -> Max
    org.matheclipse.core.interfaces.ISymbol Mean -> Mean
    org.matheclipse.core.interfaces.ISymbol Median -> Median
    org.matheclipse.core.interfaces.ISymbol Min -> Min
    org.matheclipse.core.interfaces.ISymbol Mod -> Mod
    org.matheclipse.core.interfaces.ISymbol MoebiusMu -> MoebiusMu
    org.matheclipse.core.interfaces.ISymbol Most -> Most
    org.matheclipse.core.interfaces.ISymbol Multinomial -> Multinomial
    org.matheclipse.core.interfaces.ISymbol Negative -> Negative
    org.matheclipse.core.interfaces.ISymbol NextPrime -> NextPrime
    org.matheclipse.core.interfaces.ISymbol NFourierTransform -> NFourierTransform
    org.matheclipse.core.interfaces.ISymbol NIntegrate -> NIntegrate
    org.matheclipse.core.interfaces.ISymbol NonCommutativeMultiply -> NonCommutativeMultiply
    org.matheclipse.core.interfaces.ISymbol NonNegative -> NonNegative
    org.matheclipse.core.interfaces.ISymbol Norm -> Norm
    org.matheclipse.core.interfaces.ISymbol Not -> Not
    org.matheclipse.core.interfaces.ISymbol NRoots -> NRoots
    org.matheclipse.core.interfaces.ISymbol NSolve -> NSolve
    org.matheclipse.core.interfaces.ISymbol Numerator -> Numerator
    org.matheclipse.core.interfaces.ISymbol Order -> Order
    org.matheclipse.core.interfaces.ISymbol OrderedQ -> OrderedQ
    org.matheclipse.core.interfaces.ISymbol Out -> Out
    org.matheclipse.core.interfaces.ISymbol Outer -> Outer
    org.matheclipse.core.interfaces.ISymbol PadLeft -> PadLeft
    org.matheclipse.core.interfaces.ISymbol PadRight -> PadRight
    org.matheclipse.core.interfaces.ISymbol Part -> Part
    org.matheclipse.core.interfaces.ISymbol Partition -> Partition
    org.matheclipse.core.interfaces.ISymbol Permutations -> Permutations
    org.matheclipse.core.interfaces.ISymbol Piecewise -> Piecewise
    org.matheclipse.core.interfaces.ISymbol Plus -> Plus
    org.matheclipse.core.interfaces.ISymbol PolynomialExtendedGCD -> PolynomialExtendedGCD
    org.matheclipse.core.interfaces.ISymbol PolynomialGCD -> PolynomialGCD
    org.matheclipse.core.interfaces.ISymbol PolynomialLCM -> PolynomialLCM
    org.matheclipse.core.interfaces.ISymbol PolynomialQ -> PolynomialQ
    org.matheclipse.core.interfaces.ISymbol PolynomialQuotient -> PolynomialQuotient
    org.matheclipse.core.interfaces.ISymbol PolynomialQuotientRemainder -> PolynomialQuotientRemainder
    org.matheclipse.core.interfaces.ISymbol PolynomialRemainder -> PolynomialRemainder
    org.matheclipse.core.interfaces.ISymbol Positive -> Positive
    org.matheclipse.core.interfaces.ISymbol PossibleZeroQ -> PossibleZeroQ
    org.matheclipse.core.interfaces.ISymbol Power -> Power
    org.matheclipse.core.interfaces.ISymbol PowerExpand -> PowerExpand
    org.matheclipse.core.interfaces.ISymbol PowerMod -> PowerMod
    org.matheclipse.core.interfaces.ISymbol PreDecrement -> PreDecrement
    org.matheclipse.core.interfaces.ISymbol PreIncrement -> PreIncrement
    org.matheclipse.core.interfaces.ISymbol PrimeQ -> PrimeQ
    org.matheclipse.core.interfaces.ISymbol PrimitiveRoots -> PrimitiveRoots
    org.matheclipse.core.interfaces.ISymbol Product -> Product
    org.matheclipse.core.interfaces.ISymbol ProductLog -> ProductLog
    org.matheclipse.core.interfaces.ISymbol Quotient -> Quotient
    org.matheclipse.core.interfaces.ISymbol RandomInteger -> RandomInteger
    org.matheclipse.core.interfaces.ISymbol RandomReal -> RandomReal
    org.matheclipse.core.interfaces.ISymbol Range -> Range
    org.matheclipse.core.interfaces.ISymbol Rationalize -> Rationalize
    org.matheclipse.core.interfaces.ISymbol Re -> Re
    org.matheclipse.core.interfaces.ISymbol ReplaceAll -> ReplaceAll
    org.matheclipse.core.interfaces.ISymbol ReplacePart -> ReplacePart
    org.matheclipse.core.interfaces.ISymbol ReplaceRepeated -> ReplaceRepeated
    org.matheclipse.core.interfaces.ISymbol Resultant -> Resultant
    org.matheclipse.core.interfaces.ISymbol Reverse -> Reverse
    org.matheclipse.core.interfaces.ISymbol RootIntervals -> RootIntervals
    org.matheclipse.core.interfaces.ISymbol Roots -> Roots
    org.matheclipse.core.interfaces.ISymbol Round -> Round
    org.matheclipse.core.interfaces.ISymbol SameQ -> SameQ
    org.matheclipse.core.interfaces.ISymbol Scan -> Scan
    org.matheclipse.core.interfaces.ISymbol Sec -> Sec
    org.matheclipse.core.interfaces.ISymbol Sech -> Sech
    org.matheclipse.core.interfaces.ISymbol Select -> Select
    org.matheclipse.core.interfaces.ISymbol Sign -> Sign
    org.matheclipse.core.interfaces.ISymbol SignCmp -> SignCmp
    org.matheclipse.core.interfaces.ISymbol Simplify -> Simplify
    org.matheclipse.core.interfaces.ISymbol Sin -> Sin
    org.matheclipse.core.interfaces.ISymbol Sinc -> Sinc
    org.matheclipse.core.interfaces.ISymbol SingularValueDecomposition -> SingularValueDecomposition
    org.matheclipse.core.interfaces.ISymbol Sinh -> Sinh
    org.matheclipse.core.interfaces.ISymbol Solve -> Solve
    org.matheclipse.core.interfaces.ISymbol Sort -> Sort
    org.matheclipse.core.interfaces.ISymbol Sqrt -> Sqrt
    org.matheclipse.core.interfaces.ISymbol SquaredEuclidianDistance -> SquaredEuclidianDistance
    org.matheclipse.core.interfaces.ISymbol SquareFreeQ -> SquareFreeQ
    org.matheclipse.core.interfaces.ISymbol StirlingS2 -> StirlingS2
    org.matheclipse.core.interfaces.ISymbol StringDrop -> StringDrop
    org.matheclipse.core.interfaces.ISymbol StringJoin -> StringJoin
    org.matheclipse.core.interfaces.ISymbol StringLength -> StringLength
    org.matheclipse.core.interfaces.ISymbol StringTake -> StringTake
    org.matheclipse.core.interfaces.ISymbol Subfactorial -> Subfactorial
    org.matheclipse.core.interfaces.ISymbol Subscript -> Subscript
    org.matheclipse.core.interfaces.ISymbol Subsuperscript -> Subsuperscript
    org.matheclipse.core.interfaces.ISymbol Subsets -> Subsets
    org.matheclipse.core.interfaces.ISymbol SubtractFrom -> SubtractFrom
    org.matheclipse.core.interfaces.ISymbol Superscript -> Superscript
    org.matheclipse.core.interfaces.ISymbol Sum -> Sum
    org.matheclipse.core.interfaces.ISymbol Surd -> Surd
    org.matheclipse.core.interfaces.ISymbol SyntaxLength -> SyntaxLength
    org.matheclipse.core.interfaces.ISymbol SyntaxQ -> SyntaxQ
    org.matheclipse.core.interfaces.ISymbol Table -> Table
    org.matheclipse.core.interfaces.ISymbol Take -> Take
    org.matheclipse.core.interfaces.ISymbol Tan -> Tan
    org.matheclipse.core.interfaces.ISymbol Tanh -> Tanh
    org.matheclipse.core.interfaces.ISymbol Taylor -> Taylor
    org.matheclipse.core.interfaces.ISymbol Thread -> Thread
    org.matheclipse.core.interfaces.ISymbol Through -> Through
    org.matheclipse.core.interfaces.ISymbol Times -> Times
    org.matheclipse.core.interfaces.ISymbol TimesBy -> TimesBy
    org.matheclipse.core.interfaces.ISymbol Timing -> Timing
    org.matheclipse.core.interfaces.ISymbol ToCharacterCode -> ToCharacterCode
    org.matheclipse.core.interfaces.ISymbol Together -> Together
    org.matheclipse.core.interfaces.ISymbol ToString -> ToString
    org.matheclipse.core.interfaces.ISymbol Total -> Total
    org.matheclipse.core.interfaces.ISymbol ToUnicode -> ToUnicode
    org.matheclipse.core.interfaces.ISymbol Tr -> Tr
    org.matheclipse.core.interfaces.ISymbol Transpose -> Transpose
    org.matheclipse.core.interfaces.ISymbol TrigExpand -> TrigExpand
    org.matheclipse.core.interfaces.ISymbol TrigReduce -> TrigReduce
    org.matheclipse.core.interfaces.ISymbol TrigToExp -> TrigToExp
    org.matheclipse.core.interfaces.ISymbol TrueQ -> TrueQ
    org.matheclipse.core.interfaces.ISymbol Unequal -> Unequal
    org.matheclipse.core.interfaces.ISymbol Union -> Union
    org.matheclipse.core.interfaces.ISymbol UnitStep -> UnitStep
    org.matheclipse.core.interfaces.ISymbol UnsameQ -> UnsameQ
    org.matheclipse.core.interfaces.ISymbol UpperCaseQ -> UpperCaseQ
    org.matheclipse.core.interfaces.ISymbol VandermondeMatrix -> VandermondeMatrix
    org.matheclipse.core.interfaces.ISymbol Variables -> Variables
    org.matheclipse.core.interfaces.ISymbol VectorQ -> VectorQ
    org.matheclipse.core.interfaces.ISymbol Xor -> Xor
    org.matheclipse.core.interfaces.ISymbol a -> a
    org.matheclipse.core.interfaces.ISymbol b -> b
    org.matheclipse.core.interfaces.ISymbol c -> c
    org.matheclipse.core.interfaces.ISymbol d -> d
    org.matheclipse.core.interfaces.ISymbol e -> e
    org.matheclipse.core.interfaces.ISymbol f -> f
    org.matheclipse.core.interfaces.ISymbol g -> g
    org.matheclipse.core.interfaces.ISymbol h -> h
    org.matheclipse.core.interfaces.ISymbol i -> i
    org.matheclipse.core.interfaces.ISymbol j -> j
    org.matheclipse.core.interfaces.ISymbol k -> k
    org.matheclipse.core.interfaces.ISymbol l -> l
    org.matheclipse.core.interfaces.ISymbol m -> m
    org.matheclipse.core.interfaces.ISymbol n -> n
    org.matheclipse.core.interfaces.ISymbol o -> o
    org.matheclipse.core.interfaces.ISymbol p -> p
    org.matheclipse.core.interfaces.ISymbol q -> q
    org.matheclipse.core.interfaces.ISymbol r -> r
    org.matheclipse.core.interfaces.ISymbol s -> s
    org.matheclipse.core.interfaces.ISymbol t -> t
    org.matheclipse.core.interfaces.ISymbol u -> u
    org.matheclipse.core.interfaces.ISymbol v -> v
    org.matheclipse.core.interfaces.ISymbol w -> w
    org.matheclipse.core.interfaces.ISymbol x -> x
    org.matheclipse.core.interfaces.ISymbol y -> y
    org.matheclipse.core.interfaces.ISymbol z -> z
    org.matheclipse.core.interfaces.IPattern a_ -> a_
    org.matheclipse.core.interfaces.IPattern b_ -> b_
    org.matheclipse.core.interfaces.IPattern c_ -> c_
    org.matheclipse.core.interfaces.IPattern d_ -> d_
    org.matheclipse.core.interfaces.IPattern e_ -> e_
    org.matheclipse.core.interfaces.IPattern f_ -> f_
    org.matheclipse.core.interfaces.IPattern g_ -> g_
    org.matheclipse.core.interfaces.IPattern h_ -> h_
    org.matheclipse.core.interfaces.IPattern i_ -> i_
    org.matheclipse.core.interfaces.IPattern j_ -> j_
    org.matheclipse.core.interfaces.IPattern k_ -> k_
    org.matheclipse.core.interfaces.IPattern l_ -> l_
    org.matheclipse.core.interfaces.IPattern m_ -> m_
    org.matheclipse.core.interfaces.IPattern n_ -> n_
    org.matheclipse.core.interfaces.IPattern o_ -> o_
    org.matheclipse.core.interfaces.IPattern p_ -> p_
    org.matheclipse.core.interfaces.IPattern q_ -> q_
    org.matheclipse.core.interfaces.IPattern r_ -> r_
    org.matheclipse.core.interfaces.IPattern s_ -> s_
    org.matheclipse.core.interfaces.IPattern t_ -> t_
    org.matheclipse.core.interfaces.IPattern u_ -> u_
    org.matheclipse.core.interfaces.IPattern v_ -> v_
    org.matheclipse.core.interfaces.IPattern w_ -> w_
    org.matheclipse.core.interfaces.IPattern x_ -> x_
    org.matheclipse.core.interfaces.IPattern y_ -> y_
    org.matheclipse.core.interfaces.IPattern z_ -> z_
    org.matheclipse.core.interfaces.IPattern a_Symbol -> a_Symbol
    org.matheclipse.core.interfaces.IPattern b_Symbol -> b_Symbol
    org.matheclipse.core.interfaces.IPattern c_Symbol -> c_Symbol
    org.matheclipse.core.interfaces.IPattern d_Symbol -> d_Symbol
    org.matheclipse.core.interfaces.IPattern e_Symbol -> e_Symbol
    org.matheclipse.core.interfaces.IPattern f_Symbol -> f_Symbol
    org.matheclipse.core.interfaces.IPattern g_Symbol -> g_Symbol
    org.matheclipse.core.interfaces.IPattern h_Symbol -> h_Symbol
    org.matheclipse.core.interfaces.IPattern i_Symbol -> i_Symbol
    org.matheclipse.core.interfaces.IPattern j_Symbol -> j_Symbol
    org.matheclipse.core.interfaces.IPattern k_Symbol -> k_Symbol
    org.matheclipse.core.interfaces.IPattern l_Symbol -> l_Symbol
    org.matheclipse.core.interfaces.IPattern m_Symbol -> m_Symbol
    org.matheclipse.core.interfaces.IPattern n_Symbol -> n_Symbol
    org.matheclipse.core.interfaces.IPattern o_Symbol -> o_Symbol
    org.matheclipse.core.interfaces.IPattern p_Symbol -> p_Symbol
    org.matheclipse.core.interfaces.IPattern q_Symbol -> q_Symbol
    org.matheclipse.core.interfaces.IPattern r_Symbol -> r_Symbol
    org.matheclipse.core.interfaces.IPattern s_Symbol -> s_Symbol
    org.matheclipse.core.interfaces.IPattern t_Symbol -> t_Symbol
    org.matheclipse.core.interfaces.IPattern u_Symbol -> u_Symbol
    org.matheclipse.core.interfaces.IPattern v_Symbol -> v_Symbol
    org.matheclipse.core.interfaces.IPattern w_Symbol -> w_Symbol
    org.matheclipse.core.interfaces.IPattern x_Symbol -> x_Symbol
    org.matheclipse.core.interfaces.IPattern y_Symbol -> y_Symbol
    org.matheclipse.core.interfaces.IPattern z_Symbol -> z_Symbol
    org.matheclipse.core.interfaces.IPattern a_DEFAULT -> a_DEFAULT
    org.matheclipse.core.interfaces.IPattern b_DEFAULT -> b_DEFAULT
    org.matheclipse.core.interfaces.IPattern c_DEFAULT -> c_DEFAULT
    org.matheclipse.core.interfaces.IPattern d_DEFAULT -> d_DEFAULT
    org.matheclipse.core.interfaces.IPattern e_DEFAULT -> e_DEFAULT
    org.matheclipse.core.interfaces.IPattern f_DEFAULT -> f_DEFAULT
    org.matheclipse.core.interfaces.IPattern g_DEFAULT -> g_DEFAULT
    org.matheclipse.core.interfaces.IPattern h_DEFAULT -> h_DEFAULT
    org.matheclipse.core.interfaces.IPattern i_DEFAULT -> i_DEFAULT
    org.matheclipse.core.interfaces.IPattern j_DEFAULT -> j_DEFAULT
    org.matheclipse.core.interfaces.IPattern k_DEFAULT -> k_DEFAULT
    org.matheclipse.core.interfaces.IPattern l_DEFAULT -> l_DEFAULT
    org.matheclipse.core.interfaces.IPattern m_DEFAULT -> m_DEFAULT
    org.matheclipse.core.interfaces.IPattern n_DEFAULT -> n_DEFAULT
    org.matheclipse.core.interfaces.IPattern o_DEFAULT -> o_DEFAULT
    org.matheclipse.core.interfaces.IPattern p_DEFAULT -> p_DEFAULT
    org.matheclipse.core.interfaces.IPattern q_DEFAULT -> q_DEFAULT
    org.matheclipse.core.interfaces.IPattern r_DEFAULT -> r_DEFAULT
    org.matheclipse.core.interfaces.IPattern s_DEFAULT -> s_DEFAULT
    org.matheclipse.core.interfaces.IPattern t_DEFAULT -> t_DEFAULT
    org.matheclipse.core.interfaces.IPattern u_DEFAULT -> u_DEFAULT
    org.matheclipse.core.interfaces.IPattern v_DEFAULT -> v_DEFAULT
    org.matheclipse.core.interfaces.IPattern w_DEFAULT -> w_DEFAULT
    org.matheclipse.core.interfaces.IPattern x_DEFAULT -> x_DEFAULT
    org.matheclipse.core.interfaces.IPattern y_DEFAULT -> y_DEFAULT
    org.matheclipse.core.interfaces.IPattern z_DEFAULT -> z_DEFAULT
    org.matheclipse.core.expression.IntegerSym C0 -> C0
    org.matheclipse.core.expression.IntegerSym C1 -> C1
    org.matheclipse.core.expression.IntegerSym C2 -> C2
    org.matheclipse.core.expression.IntegerSym C3 -> C3
    org.matheclipse.core.expression.IntegerSym C4 -> C4
    org.matheclipse.core.expression.IntegerSym C5 -> C5
    org.matheclipse.core.expression.IntegerSym C6 -> C6
    org.matheclipse.core.expression.IntegerSym C7 -> C7
    org.matheclipse.core.expression.IntegerSym C8 -> C8
    org.matheclipse.core.expression.IntegerSym C9 -> C9
    org.matheclipse.core.expression.IntegerSym C10 -> C10
    org.matheclipse.core.interfaces.IComplex CI -> CI
    org.matheclipse.core.interfaces.IComplex CNI -> CNI
    org.matheclipse.core.interfaces.IFraction C1D2 -> C1D2
    org.matheclipse.core.interfaces.IFraction CN1D2 -> CN1D2
    org.matheclipse.core.interfaces.IFraction C1D3 -> C1D3
    org.matheclipse.core.interfaces.IFraction CN1D3 -> CN1D3
    org.matheclipse.core.interfaces.IFraction C1D4 -> C1D4
    org.matheclipse.core.interfaces.IFraction CN1D4 -> CN1D4
    org.matheclipse.core.interfaces.INum CD0 -> CD0
    org.matheclipse.core.interfaces.INum CD1 -> CD1
    org.matheclipse.core.interfaces.IAST CInfinity -> CInfinity
    org.matheclipse.core.interfaces.IAST CNInfinity -> CNInfinity
    org.matheclipse.core.interfaces.IAST CComplexInfinity -> CComplexInfinity
    org.matheclipse.core.interfaces.IAST CSqrt2 -> CSqrt2
    org.matheclipse.core.interfaces.IAST CSqrt3 -> CSqrt3
    org.matheclipse.core.interfaces.IAST CSqrt5 -> CSqrt5
    org.matheclipse.core.interfaces.IAST CSqrt6 -> CSqrt6
    org.matheclipse.core.interfaces.IAST CSqrt7 -> CSqrt7
    org.matheclipse.core.interfaces.IAST CSqrt10 -> CSqrt10
    org.matheclipse.core.interfaces.IAST C1DSqrt2 -> C1DSqrt2
    org.matheclipse.core.interfaces.IAST C1DSqrt3 -> C1DSqrt3
    org.matheclipse.core.interfaces.IAST C1DSqrt5 -> C1DSqrt5
    org.matheclipse.core.interfaces.IAST C1DSqrt6 -> C1DSqrt6
    org.matheclipse.core.interfaces.IAST C1DSqrt7 -> C1DSqrt7
    org.matheclipse.core.interfaces.IAST C1DSqrt10 -> C1DSqrt10
    org.matheclipse.core.interfaces.IAST Slot1 -> Slot1
    org.matheclipse.core.interfaces.IAST Slot2 -> Slot2
    org.matheclipse.core.expression.IntegerSym CN1 -> CN1
    org.matheclipse.core.expression.IntegerSym CN2 -> CN2
    org.matheclipse.core.expression.IntegerSym CN3 -> CN3
    org.matheclipse.core.expression.IntegerSym CN4 -> CN4
    org.matheclipse.core.expression.IntegerSym CN5 -> CN5
    org.matheclipse.core.expression.IntegerSym CN6 -> CN6
    org.matheclipse.core.expression.IntegerSym CN7 -> CN7
    org.matheclipse.core.expression.IntegerSym CN8 -> CN8
    org.matheclipse.core.expression.IntegerSym CN9 -> CN9
    org.matheclipse.core.expression.IntegerSym CN10 -> CN10
    org.matheclipse.core.interfaces.IAST $(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[]) -> $
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol) -> $p
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,boolean) -> $p
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> $p
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> $p
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String) -> $p
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String,boolean) -> $p
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String,org.matheclipse.core.interfaces.IExpr) -> $p
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String,org.matheclipse.core.interfaces.IExpr,boolean) -> $p
    org.matheclipse.core.interfaces.IPatternSequence $ps(org.matheclipse.core.interfaces.ISymbol) -> $ps
    org.matheclipse.core.interfaces.IPatternSequence $ps(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> $ps
    org.matheclipse.core.interfaces.IPatternSequence $ps(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> $ps
    org.matheclipse.core.interfaces.IPatternSequence $ps(java.lang.String) -> $ps
    org.matheclipse.core.interfaces.ISymbol $s(java.lang.String) -> $s
    org.matheclipse.core.interfaces.ISymbol $s(java.lang.String,boolean) -> $s
    org.matheclipse.core.interfaces.IAST Abs(org.matheclipse.core.interfaces.IExpr) -> Abs
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> and
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> and
    org.matheclipse.core.interfaces.IExpr and(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IExpr and(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IAST And() -> And
    org.matheclipse.core.interfaces.IAST And(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> And
    org.matheclipse.core.interfaces.IAST Apart(org.matheclipse.core.interfaces.IExpr) -> Apart
    org.matheclipse.core.interfaces.IAST Apart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Apart
    org.matheclipse.core.interfaces.IAST Append(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Append
    org.matheclipse.core.interfaces.IAST Apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Apply
    org.matheclipse.core.interfaces.IAST ArcCos(org.matheclipse.core.interfaces.IExpr) -> ArcCos
    org.matheclipse.core.interfaces.IAST ArcCosh(org.matheclipse.core.interfaces.IExpr) -> ArcCosh
    org.matheclipse.core.interfaces.IAST ArcCot(org.matheclipse.core.interfaces.IExpr) -> ArcCot
    org.matheclipse.core.interfaces.IAST ArcCoth(org.matheclipse.core.interfaces.IExpr) -> ArcCoth
    org.matheclipse.core.interfaces.IAST ArcCsc(org.matheclipse.core.interfaces.IExpr) -> ArcCsc
    org.matheclipse.core.interfaces.IAST ArcCsch(org.matheclipse.core.interfaces.IExpr) -> ArcCsch
    org.matheclipse.core.interfaces.IAST ArcSec(org.matheclipse.core.interfaces.IExpr) -> ArcSec
    org.matheclipse.core.interfaces.IAST ArcSech(org.matheclipse.core.interfaces.IExpr) -> ArcSech
    org.matheclipse.core.interfaces.IAST ArcSin(org.matheclipse.core.interfaces.IExpr) -> ArcSin
    org.matheclipse.core.interfaces.IAST ArcSinh(org.matheclipse.core.interfaces.IExpr) -> ArcSinh
    org.matheclipse.core.interfaces.IAST ArcTan(org.matheclipse.core.interfaces.IExpr) -> ArcTan
    org.matheclipse.core.interfaces.IAST ArcTan(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ArcTan
    org.matheclipse.core.interfaces.IAST ArcTanh(org.matheclipse.core.interfaces.IExpr) -> ArcTanh
    org.matheclipse.core.interfaces.IAST Arg(org.matheclipse.core.interfaces.IExpr) -> Arg
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,int,int) -> ast
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr) -> ast
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr,int,boolean) -> ast
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.IExpr) -> ast
    org.matheclipse.core.interfaces.IAST AtomQ(org.matheclipse.core.interfaces.IExpr) -> AtomQ
    org.matheclipse.core.interfaces.IAST BernoulliB(org.matheclipse.core.interfaces.IExpr) -> BernoulliB
    org.matheclipse.core.interfaces.IAST binary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> binary
    org.matheclipse.core.interfaces.IAST Binomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Binomial
    org.matheclipse.core.interfaces.IAST Block(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Block
    org.matheclipse.core.interfaces.ISymbol bool(boolean) -> bool
    org.matheclipse.core.interfaces.IAST Break() -> Break
    org.matheclipse.core.interfaces.IAST Cancel(org.matheclipse.core.interfaces.IExpr) -> Cancel
    org.matheclipse.core.interfaces.IExpr cast(java.lang.Object) -> cast
    org.matheclipse.core.interfaces.IAST Catch(org.matheclipse.core.interfaces.IExpr) -> Catch
    org.matheclipse.core.interfaces.IComplex CC(org.matheclipse.core.interfaces.IFraction) -> CC
    org.matheclipse.core.interfaces.IComplex CC(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> CC
    org.matheclipse.core.interfaces.IComplex CC(long,long,long,long) -> CC
    org.matheclipse.core.interfaces.IAST Ceiling(org.matheclipse.core.interfaces.IExpr) -> Ceiling
    org.matheclipse.core.interfaces.IAST Clear(org.matheclipse.core.interfaces.IExpr[]) -> Clear
    org.matheclipse.core.interfaces.IAST CNInfinity() -> CNInfinity
    org.matheclipse.core.interfaces.IAST Coefficient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Coefficient
    org.matheclipse.core.interfaces.IAST CoefficientList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> CoefficientList
    org.matheclipse.core.interfaces.IAST Collect(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Collect
    int compareTo(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compareTo
    int compareTo(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> compareTo
    int compareTo(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> compareTo
    int compareTo(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> compareTo
    int compareTo(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.IComplex complex(double,double) -> complex
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IFraction) -> complex
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> complex
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> complex
    org.matheclipse.core.interfaces.IComplex complex(long,long,long,long) -> complex
    org.matheclipse.core.interfaces.IComplexNum complexNum(double) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(double,double) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.apache.commons.math3.complex.Complex) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.apfloat.Apfloat,org.apfloat.Apfloat) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.apfloat.Apfloat) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.apfloat.Apcomplex) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IComplex) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IFraction) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IInteger) -> complexNum
    org.matheclipse.core.interfaces.IAST Chop(org.matheclipse.core.interfaces.IExpr) -> Chop
    org.matheclipse.core.interfaces.IAST Complex(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Complex
    org.matheclipse.core.interfaces.IAST CompoundExpression(org.matheclipse.core.interfaces.IExpr[]) -> CompoundExpression
    org.matheclipse.core.interfaces.IAST Condition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Condition
    org.matheclipse.core.interfaces.IAST Conjugate(org.matheclipse.core.interfaces.IExpr) -> Conjugate
    org.matheclipse.core.interfaces.IAST Continue() -> Continue
    org.matheclipse.core.interfaces.IAST CoprimeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> CoprimeQ
    org.matheclipse.core.interfaces.IAST Cos(org.matheclipse.core.interfaces.IExpr) -> Cos
    org.matheclipse.core.interfaces.IAST Cosh(org.matheclipse.core.interfaces.IExpr) -> Cosh
    org.matheclipse.core.interfaces.IAST Cot(org.matheclipse.core.interfaces.IExpr) -> Cot
    org.matheclipse.core.interfaces.IAST Coth(org.matheclipse.core.interfaces.IExpr) -> Coth
    org.matheclipse.core.interfaces.IAST Count(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Count
    org.matheclipse.core.interfaces.IAST Cross(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Cross
    org.matheclipse.core.interfaces.IAST Csc(org.matheclipse.core.interfaces.IExpr) -> Csc
    org.matheclipse.core.interfaces.IAST Csch(org.matheclipse.core.interfaces.IExpr) -> Csch
    org.matheclipse.core.interfaces.IAST D() -> D
    org.matheclipse.core.interfaces.IAST D(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST Decrement(org.matheclipse.core.interfaces.IExpr) -> Decrement
    org.matheclipse.core.interfaces.IAST Defer(org.matheclipse.core.interfaces.IExpr) -> Defer
    org.matheclipse.core.interfaces.IAST Delete(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Delete
    org.matheclipse.core.interfaces.IAST DeleteCases(org.matheclipse.core.interfaces.IExpr[]) -> DeleteCases
    org.matheclipse.core.interfaces.IAST Denominator(org.matheclipse.core.interfaces.IExpr) -> Denominator
    org.matheclipse.core.interfaces.IAST Depth(org.matheclipse.core.interfaces.IExpr) -> Depth
    org.matheclipse.core.interfaces.IAST Derivative(org.matheclipse.core.interfaces.IExpr) -> Derivative
    org.matheclipse.core.interfaces.IAST Det(org.matheclipse.core.interfaces.IExpr) -> Det
    org.matheclipse.core.interfaces.IAST DirectedInfinity(org.matheclipse.core.interfaces.IExpr) -> DirectedInfinity
    org.matheclipse.core.interfaces.IAST Discriminant(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Discriminant
    org.matheclipse.core.interfaces.IAST Distribute(org.matheclipse.core.interfaces.IExpr) -> Distribute
    org.matheclipse.core.interfaces.IAST Distribute(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Distribute
    org.matheclipse.core.interfaces.IAST Distribute(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Distribute
    org.matheclipse.core.interfaces.IExpr div(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> div
    org.matheclipse.core.interfaces.IExpr div(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> div
    org.matheclipse.core.interfaces.IExpr div(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> div
    org.matheclipse.core.interfaces.IExpr div(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> div
    org.matheclipse.core.interfaces.IAST Divide(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Divide
    org.matheclipse.core.interfaces.IAST Divisible(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Divisible
    org.matheclipse.core.interfaces.IAST Do(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Do
    org.matheclipse.core.interfaces.IAST Dot(org.matheclipse.core.interfaces.IExpr[]) -> Dot
    org.matheclipse.core.interfaces.IAST Dot(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Dot
    org.matheclipse.core.interfaces.IAST Drop(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Drop
    org.matheclipse.core.interfaces.IAST Equal(org.matheclipse.core.interfaces.IExpr[]) -> Equal
    org.matheclipse.core.interfaces.IAST Equal(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Equal
    boolean equals(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> equals
    boolean equals(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> equals
    boolean equals(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> equals
    boolean equals(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> equals
    boolean equals(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> equals
    org.matheclipse.core.interfaces.IAST Erf(org.matheclipse.core.interfaces.IExpr) -> Erf
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr evalQuiet(org.matheclipse.core.interfaces.IExpr) -> evalQuiet
    org.matheclipse.core.interfaces.IExpr evalQuietNull(org.matheclipse.core.interfaces.IExpr) -> evalQuietNull
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr evalBlock(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> evalBlock
    org.matheclipse.core.interfaces.IExpr evalExpand(org.matheclipse.core.interfaces.IExpr) -> evalExpand
    org.matheclipse.core.interfaces.IExpr expand(org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> expand
    org.matheclipse.core.interfaces.IExpr evalExpandAll(org.matheclipse.core.interfaces.IExpr) -> evalExpandAll
    org.matheclipse.core.interfaces.IExpr expandAll(org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> expandAll
    org.matheclipse.core.interfaces.IExpr evaln(org.matheclipse.core.interfaces.IExpr) -> evaln
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> evalNull
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> evalNull
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> evalNull
    boolean evalTrue(org.matheclipse.core.interfaces.IExpr) -> evalTrue
    org.matheclipse.core.interfaces.IAST EvenQ(org.matheclipse.core.interfaces.IExpr) -> EvenQ
    org.matheclipse.core.interfaces.IAST Exp(org.matheclipse.core.interfaces.IExpr) -> Exp
    org.matheclipse.core.interfaces.IAST Expand(org.matheclipse.core.interfaces.IExpr) -> Expand
    org.matheclipse.core.interfaces.IAST Expand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Expand
    org.matheclipse.core.interfaces.IAST ExpandAll(org.matheclipse.core.interfaces.IExpr) -> ExpandAll
    org.matheclipse.core.interfaces.IAST Exponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Exponent
    org.matheclipse.core.interfaces.IAST Exponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Exponent
    org.matheclipse.core.interfaces.IAST Extract(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Extract
    org.matheclipse.core.interfaces.IAST Factor(org.matheclipse.core.interfaces.IExpr) -> Factor
    org.matheclipse.core.interfaces.IAST Factorial(org.matheclipse.core.interfaces.IExpr) -> Factorial
    org.matheclipse.core.interfaces.IAST FactorInteger(org.matheclipse.core.interfaces.IExpr) -> FactorInteger
    org.matheclipse.core.interfaces.IAST FactorSquareFree(org.matheclipse.core.interfaces.IExpr) -> FactorSquareFree
    org.matheclipse.core.interfaces.IAST FactorSquareFreeList(org.matheclipse.core.interfaces.IExpr) -> FactorSquareFreeList
    org.matheclipse.core.interfaces.IAST Fibonacci(org.matheclipse.core.interfaces.IExpr) -> Fibonacci
    org.matheclipse.core.interfaces.IAST First(org.matheclipse.core.interfaces.IExpr) -> First
    org.matheclipse.core.interfaces.IAST Flatten(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Flatten
    org.matheclipse.core.interfaces.IAST Floor(org.matheclipse.core.interfaces.IExpr) -> Floor
    org.matheclipse.core.interfaces.IFraction fraction(org.apache.commons.math3.fraction.BigFraction) -> fraction
    org.matheclipse.core.interfaces.IFraction fraction(java.math.BigInteger,java.math.BigInteger) -> fraction
    org.matheclipse.core.interfaces.IFraction fraction(double) -> fraction
    org.matheclipse.core.interfaces.IFraction fraction(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> fraction
    org.matheclipse.core.interfaces.IFraction fraction(long,long) -> fraction
    org.matheclipse.core.interfaces.IAST FractionalPart(org.matheclipse.core.interfaces.IExpr) -> FractionalPart
    org.matheclipse.core.interfaces.IAST FreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FreeQ
    org.matheclipse.core.interfaces.IAST FullForm(org.matheclipse.core.interfaces.IExpr) -> FullForm
    org.matheclipse.core.interfaces.IAST FullSimplify(org.matheclipse.core.interfaces.IExpr) -> FullSimplify
    org.matheclipse.core.interfaces.IAST Function(org.matheclipse.core.interfaces.IExpr) -> Function
    org.matheclipse.core.interfaces.IAST Gamma(org.matheclipse.core.interfaces.IExpr) -> Gamma
    org.matheclipse.core.interfaces.IAST Gamma(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Gamma
    org.matheclipse.core.interfaces.IAST GCD(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GCD
    org.matheclipse.core.eval.Namespace getNamespace() -> getNamespace
    org.matheclipse.core.interfaces.IAST Graphics() -> Graphics
    org.matheclipse.core.interfaces.IAST Greater(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Greater
    org.matheclipse.core.interfaces.IAST GreaterEqual(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GreaterEqual
    org.matheclipse.core.interfaces.IAST HarmonicNumber(org.matheclipse.core.interfaces.IExpr) -> HarmonicNumber
    org.matheclipse.core.interfaces.IAST HarmonicNumber(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> HarmonicNumber
    org.matheclipse.core.interfaces.IAST Head(org.matheclipse.core.interfaces.IExpr) -> Head
    org.matheclipse.core.interfaces.IAST Hold(org.matheclipse.core.interfaces.IExpr) -> Hold
    org.matheclipse.core.interfaces.IAST HurwitzZeta(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> HurwitzZeta
    org.matheclipse.core.interfaces.IAST Identity(org.matheclipse.core.interfaces.IExpr) -> Identity
    org.matheclipse.core.interfaces.IAST If(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> If
    org.matheclipse.core.interfaces.IAST If(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> If
    org.matheclipse.core.interfaces.IAST Im(org.matheclipse.core.interfaces.IExpr) -> Im
    org.matheclipse.core.interfaces.IAST Increment(org.matheclipse.core.interfaces.IExpr) -> Increment
    org.matheclipse.core.interfaces.ISymbol initFinalSymbol(java.lang.String) -> initFinalSymbol
    org.matheclipse.core.interfaces.ISymbol initFinalSymbol(java.lang.String,org.matheclipse.core.interfaces.IEvaluator) -> a
    org.matheclipse.core.interfaces.IPattern initPredefinedPattern(org.matheclipse.core.interfaces.ISymbol) -> initPredefinedPattern
    void initSymbols() -> initSymbols
    void initSymbols(java.lang.String,org.matheclipse.core.expression.ISymbolObserver,boolean) -> initSymbols
    void initSymbols(java.io.Reader,org.matheclipse.core.expression.ISymbolObserver) -> initSymbols
    org.matheclipse.core.interfaces.IInteger integer(java.math.BigInteger) -> integer
    org.matheclipse.core.interfaces.IInteger integer(long) -> integer
    org.matheclipse.core.interfaces.IInteger integer(java.lang.String,int) -> integer
    org.matheclipse.core.interfaces.IAST Insert(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Insert
    org.matheclipse.core.interfaces.IAST IntegerPart(org.matheclipse.core.interfaces.IExpr) -> IntegerPart
    org.matheclipse.core.interfaces.IAST IntegerQ(org.matheclipse.core.interfaces.IExpr) -> IntegerQ
    org.matheclipse.core.interfaces.IAST Integrate(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Integrate
    org.matheclipse.core.interfaces.IAST Inverse(org.matheclipse.core.interfaces.IExpr) -> Inverse
    org.matheclipse.core.interfaces.IAST InverseErf(org.matheclipse.core.interfaces.IExpr) -> InverseErf
    org.matheclipse.core.interfaces.IAST InverseFunction(org.matheclipse.core.interfaces.IExpr) -> InverseFunction
    boolean isNumEqualInteger(double,org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumIntValue(double,int) -> isNumIntValue
    boolean isNumIntValue(double) -> isNumIntValue
    boolean isNumIntValue(double,double) -> isNumIntValue
    boolean isZero(double) -> isZero
    boolean isZero(double,double) -> isZero
    org.matheclipse.core.interfaces.IAST Join(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Join
    org.matheclipse.core.interfaces.IAST Last(org.matheclipse.core.interfaces.IExpr) -> Last
    org.matheclipse.core.interfaces.IAST LCM(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LCM
    org.matheclipse.core.interfaces.IAST LeafCount(org.matheclipse.core.interfaces.IExpr) -> LeafCount
    org.matheclipse.core.interfaces.IAST Length(org.matheclipse.core.interfaces.IExpr) -> Length
    org.matheclipse.core.interfaces.IAST Less(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Less
    org.matheclipse.core.interfaces.IAST LessEqual(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LessEqual
    org.matheclipse.core.interfaces.IAST Limit(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Limit
    org.matheclipse.core.interfaces.IAST Line() -> Line
    org.matheclipse.core.interfaces.IAST LinearSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LinearSolve
    org.matheclipse.core.interfaces.IAST List() -> List
    org.matheclipse.core.interfaces.IAST List(double[]) -> List
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr) -> List
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr[]) -> List
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> List
    org.matheclipse.core.interfaces.IAST List(long[]) -> List
    org.matheclipse.core.interfaces.IAST ListQ(org.matheclipse.core.interfaces.IExpr) -> ListQ
    org.matheclipse.core.interfaces.ISymbol local(java.lang.String) -> local
    org.matheclipse.core.interfaces.ISymbol local(java.lang.String,org.matheclipse.core.interfaces.IExpr) -> local
    org.matheclipse.core.interfaces.IAST Log(org.matheclipse.core.interfaces.IExpr) -> Log
    org.matheclipse.core.interfaces.IAST Log(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Log
    org.matheclipse.core.interfaces.IAST Map(org.matheclipse.core.interfaces.IExpr) -> Map
    org.matheclipse.core.interfaces.IAST Map(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Map
    org.matheclipse.core.interfaces.IAST MapAll(org.matheclipse.core.interfaces.IExpr) -> MapAll
    org.matheclipse.core.interfaces.IAST MatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MatchQ
    org.matheclipse.core.interfaces.IAST MatrixPower(org.matheclipse.core.interfaces.IExpr) -> MatrixPower
    org.matheclipse.core.interfaces.IAST Max() -> Max
    org.matheclipse.core.interfaces.IAST Max(org.matheclipse.core.interfaces.IExpr) -> Max
    org.matheclipse.core.interfaces.IAST Max(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Max
    org.matheclipse.core.interfaces.IAST MemberQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MemberQ
    org.matheclipse.core.interfaces.ISymbol method(java.lang.String,java.lang.String,java.lang.String) -> method
    org.matheclipse.core.interfaces.ISymbol method(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> method
    org.matheclipse.core.interfaces.IAST Min() -> Min
    org.matheclipse.core.interfaces.IAST Min(org.matheclipse.core.interfaces.IExpr) -> Min
    org.matheclipse.core.interfaces.IAST Min(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Min
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> minus
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> minus
    org.matheclipse.core.interfaces.IExpr minus(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr minus(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> mod
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> mod
    org.matheclipse.core.interfaces.IExpr mod(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr mod(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr Mod(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Mod
    org.matheclipse.core.interfaces.IAST Module(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Module
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> multiply
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> multiply
    org.matheclipse.core.interfaces.IExpr multiply(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IExpr multiply(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IAST N(org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IExpr Negate(org.matheclipse.core.interfaces.IExpr) -> Negate
    org.matheclipse.core.interfaces.IAST Negative(org.matheclipse.core.interfaces.IExpr) -> Negative
    org.matheclipse.core.interfaces.IAST newInstance(int,org.matheclipse.core.interfaces.IExpr) -> newInstance
    org.matheclipse.core.interfaces.IAST Not(org.matheclipse.core.interfaces.IExpr) -> Not
    org.matheclipse.core.interfaces.INum num(double) -> num
    org.matheclipse.core.interfaces.INum num(org.matheclipse.core.interfaces.IFraction) -> num
    org.matheclipse.core.interfaces.INum num(org.matheclipse.core.interfaces.IInteger) -> num
    org.matheclipse.core.interfaces.INum num(java.lang.String) -> num
    org.matheclipse.core.interfaces.INum num(org.apfloat.Apfloat) -> num
    org.matheclipse.core.interfaces.IAST NumberQ(org.matheclipse.core.interfaces.IExpr) -> NumberQ
    org.matheclipse.core.interfaces.IAST Numerator(org.matheclipse.core.interfaces.IExpr) -> Numerator
    org.matheclipse.core.interfaces.IAST NumericQ(org.matheclipse.core.interfaces.IExpr) -> NumericQ
    org.matheclipse.core.interfaces.IAST OddQ(org.matheclipse.core.interfaces.IExpr) -> OddQ
    org.matheclipse.core.interfaces.IAST Options(org.matheclipse.core.interfaces.IExpr) -> Options
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> or
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> or
    org.matheclipse.core.interfaces.IExpr or(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IExpr or(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IAST Or() -> Or
    org.matheclipse.core.interfaces.IAST Or(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Or
    org.matheclipse.core.interfaces.IAST Order(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Order
    org.matheclipse.core.interfaces.IAST OrderedQ(org.matheclipse.core.interfaces.IExpr) -> OrderedQ
    org.matheclipse.core.interfaces.IAST Part() -> Part
    org.matheclipse.core.interfaces.IAST Part(org.matheclipse.core.interfaces.IExpr[]) -> Part
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> plus
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> plus
    org.matheclipse.core.interfaces.IExpr plus(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr plus(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IAST Plus() -> Plus
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr) -> Plus
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr[]) -> Plus
    org.matheclipse.core.interfaces.IAST Plus(long,org.matheclipse.core.interfaces.IExpr[]) -> Plus
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Plus
    org.matheclipse.core.interfaces.IAST PolynomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialQ
    org.matheclipse.core.interfaces.IAST PolynomialQuotient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialQuotient
    org.matheclipse.core.interfaces.IAST PolynomialRemainder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialRemainder
    org.matheclipse.core.interfaces.IAST PolynomialQuotientRemainder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialQuotientRemainder
    org.matheclipse.core.interfaces.IAST Position(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Position
    org.matheclipse.core.interfaces.IAST Positive(org.matheclipse.core.interfaces.IExpr) -> Positive
    org.matheclipse.core.interfaces.IAST PossibleZeroQ(org.matheclipse.core.interfaces.IExpr) -> PossibleZeroQ
    org.matheclipse.core.interfaces.IAST Power() -> Power
    org.matheclipse.core.interfaces.IAST Power(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Power
    org.matheclipse.core.interfaces.IExpr Power(org.matheclipse.core.interfaces.IExpr,long) -> Power
    org.matheclipse.core.interfaces.IAST PowerExpand(org.matheclipse.core.interfaces.IExpr) -> PowerExpand
    org.matheclipse.core.interfaces.ISymbol predefinedSymbol(java.lang.String) -> predefinedSymbol
    org.matheclipse.core.interfaces.IAST Prepend(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Prepend
    org.matheclipse.core.interfaces.IAST PrimeQ(org.matheclipse.core.interfaces.IExpr) -> PrimeQ
    org.matheclipse.core.interfaces.IAST Print(org.matheclipse.core.interfaces.IExpr[]) -> Print
    org.matheclipse.core.interfaces.IAST Product(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Product
    org.matheclipse.core.interfaces.IAST ProductLog(org.matheclipse.core.interfaces.IExpr) -> ProductLog
    org.matheclipse.core.interfaces.IFraction QQ(org.apache.commons.math3.fraction.BigFraction) -> QQ
    org.matheclipse.core.interfaces.IFraction QQ(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> QQ
    org.matheclipse.core.interfaces.IFraction QQ(long,long) -> QQ
    org.matheclipse.core.interfaces.IAST quaternary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> quaternary
    org.matheclipse.core.interfaces.IAST quinary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> quinary
    org.matheclipse.core.interfaces.IAST Quiet(org.matheclipse.core.interfaces.IExpr) -> Quiet
    org.matheclipse.core.interfaces.IAST Quotient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Quotient
    org.matheclipse.core.interfaces.IAST Rational(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Rational
    org.matheclipse.core.interfaces.IAST Re(org.matheclipse.core.interfaces.IExpr) -> Re
    org.matheclipse.core.interfaces.IAST Reap(org.matheclipse.core.interfaces.IExpr) -> Reap
    org.matheclipse.core.interfaces.IAST ReplaceAll(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ReplaceAll
    org.matheclipse.core.interfaces.IAST ReplacePart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ReplacePart
    org.matheclipse.core.interfaces.IAST ReplacePart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ReplacePart
    org.matheclipse.core.interfaces.IAST Rest(org.matheclipse.core.interfaces.IExpr) -> Rest
    org.matheclipse.core.interfaces.IAST Resultant(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Resultant
    org.matheclipse.core.interfaces.IAST Return(org.matheclipse.core.interfaces.IExpr) -> Return
    org.matheclipse.core.interfaces.IAST Reverse(org.matheclipse.core.interfaces.IExpr) -> Reverse
    org.matheclipse.core.interfaces.IAST Roots(org.matheclipse.core.interfaces.IExpr) -> Roots
    org.matheclipse.core.interfaces.IAST Round(org.matheclipse.core.interfaces.IExpr) -> Round
    org.matheclipse.core.interfaces.IAST Rule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Rule
    org.matheclipse.core.interfaces.IAST RuleDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RuleDelayed
    org.matheclipse.core.interfaces.IAST SameQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SameQ
    org.matheclipse.core.interfaces.IAST Scan(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Scan
    org.matheclipse.core.interfaces.IAST Sec(org.matheclipse.core.interfaces.IExpr) -> Sec
    org.matheclipse.core.interfaces.IAST Sech(org.matheclipse.core.interfaces.IExpr) -> Sech
    org.matheclipse.core.interfaces.IAST senary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> senary
    org.matheclipse.core.interfaces.IAST Select(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Select
    org.matheclipse.core.interfaces.IAST Sequence() -> Sequence
    org.matheclipse.core.interfaces.IAST Sequence(org.matheclipse.core.interfaces.IExpr) -> Sequence
    org.matheclipse.core.interfaces.IAST Sequence(org.matheclipse.core.interfaces.IExpr[]) -> Sequence
    org.matheclipse.core.interfaces.IAST SetAttributes(org.matheclipse.core.interfaces.IExpr) -> SetAttributes
    org.matheclipse.core.interfaces.IAST SetAttributes(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SetAttributes
    org.matheclipse.core.interfaces.IAST Set(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Set
    org.matheclipse.core.interfaces.IAST ISet(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ISet
    org.matheclipse.core.interfaces.IAST SetDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SetDelayed
    org.matheclipse.core.interfaces.IAST ISetDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ISetDelayed
    org.matheclipse.core.interfaces.IAST Show(org.matheclipse.core.interfaces.IExpr) -> Show
    org.matheclipse.core.interfaces.IAST Sign(org.matheclipse.core.interfaces.IExpr) -> Sign
    org.matheclipse.core.interfaces.IAST SignCmp(org.matheclipse.core.interfaces.IExpr) -> SignCmp
    org.matheclipse.core.interfaces.IAST Simplify(org.matheclipse.core.interfaces.IExpr) -> Simplify
    org.matheclipse.core.interfaces.IAST Sin(org.matheclipse.core.interfaces.IExpr) -> Sin
    org.matheclipse.core.interfaces.IAST Sinc(org.matheclipse.core.interfaces.IExpr) -> Sinc
    org.matheclipse.core.interfaces.IAST Sinh(org.matheclipse.core.interfaces.IExpr) -> Sinh
    org.matheclipse.core.interfaces.IAST Slot(org.matheclipse.core.interfaces.IExpr) -> Slot
    org.matheclipse.core.interfaces.IAST Slot(int) -> Slot
    org.matheclipse.core.interfaces.IAST Solve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Solve
    org.matheclipse.core.interfaces.IAST Sort(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Sort
    org.matheclipse.core.interfaces.IAST Sow(org.matheclipse.core.interfaces.IExpr) -> Sow
    org.matheclipse.core.interfaces.IAST Sqr(org.matheclipse.core.interfaces.IExpr) -> Sqr
    org.matheclipse.core.interfaces.IAST Sqrt(org.matheclipse.core.interfaces.IExpr) -> Sqrt
    org.matheclipse.core.interfaces.IAST StringJoin(org.matheclipse.core.interfaces.IExpr) -> StringJoin
    org.matheclipse.core.interfaces.IStringX stringx(java.lang.String) -> stringx
    org.matheclipse.core.interfaces.IStringX stringx(java.lang.StringBuffer) -> stringx
    org.matheclipse.core.interfaces.IExpr subst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> subst
    org.matheclipse.core.interfaces.IExpr subst(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> subst
    org.matheclipse.core.interfaces.IExpr subst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> subst
    org.matheclipse.core.interfaces.IAST Subfactorial(org.matheclipse.core.interfaces.IExpr) -> Subfactorial
    org.matheclipse.core.interfaces.IAST Subtract(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Subtract
    org.matheclipse.core.interfaces.IAST Sum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Sum
    org.matheclipse.core.interfaces.IAST SurfaceGraphics() -> SurfaceGraphics
    org.matheclipse.core.interfaces.IAST Take(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Take
    org.matheclipse.core.interfaces.IAST Tan(org.matheclipse.core.interfaces.IExpr) -> Tan
    org.matheclipse.core.interfaces.IAST Tanh(org.matheclipse.core.interfaces.IExpr) -> Tanh
    org.matheclipse.core.interfaces.IAST Taylor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Taylor
    org.matheclipse.core.interfaces.IAST ternary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ternary
    org.matheclipse.core.interfaces.IAST Throw(org.matheclipse.core.interfaces.IExpr) -> Throw
    org.matheclipse.core.interfaces.IAST TimeConstrained(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TimeConstrained
    org.matheclipse.core.interfaces.IAST TimeConstrained(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TimeConstrained
    org.matheclipse.core.interfaces.IAST Times() -> Times
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr) -> Times
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr[]) -> Times
    org.matheclipse.core.interfaces.IAST Times(long,org.matheclipse.core.interfaces.IExpr[]) -> Times
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Times
    org.matheclipse.core.interfaces.IAST Together(org.matheclipse.core.interfaces.IExpr) -> Together
    org.matheclipse.core.interfaces.IAST Tr(org.matheclipse.core.interfaces.IExpr) -> Tr
    org.matheclipse.core.interfaces.IAST Trace(org.matheclipse.core.interfaces.IExpr) -> Trace
    org.matheclipse.core.interfaces.IAST Transpose(org.matheclipse.core.interfaces.IExpr) -> Transpose
    org.matheclipse.core.interfaces.IAST TrigExpand(org.matheclipse.core.interfaces.IExpr) -> TrigExpand
    org.matheclipse.core.interfaces.IAST TrigReduce(org.matheclipse.core.interfaces.IExpr) -> TrigReduce
    org.matheclipse.core.interfaces.IAST TrigToExp(org.matheclipse.core.interfaces.IExpr) -> TrigToExp
    org.matheclipse.core.interfaces.IAST unary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> unary
    org.matheclipse.core.interfaces.IAST Unequal(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Unequal
    org.matheclipse.core.interfaces.IAST Unevaluated(org.matheclipse.core.interfaces.IExpr) -> Unevaluated
    org.matheclipse.core.interfaces.IAST Unique(org.matheclipse.core.interfaces.IExpr) -> Unique
    org.matheclipse.core.interfaces.IAST UnsameQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UnsameQ
    org.matheclipse.core.interfaces.IAST UpSet(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UpSet
    org.matheclipse.core.interfaces.IAST UpSetDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UpSetDelayed
    org.matheclipse.core.interfaces.IAST While(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> While
    org.matheclipse.core.interfaces.IInteger ZZ(java.math.BigInteger) -> ZZ
    org.matheclipse.core.interfaces.IInteger ZZ(long) -> ZZ
    org.matheclipse.core.interfaces.INumber chopNumber(org.matheclipse.core.interfaces.INumber,double) -> chopNumber
    org.matheclipse.core.interfaces.IExpr chopExpr(org.matheclipse.core.interfaces.IExpr,double) -> chopExpr
org.matheclipse.core.expression.FractionSym -> org.matheclipse.core.expression.FractionSym:
    org.apache.commons.math3.fraction.BigFraction fRational -> a
    int fHashValue -> a
    org.matheclipse.core.expression.FractionSym newInstance(org.apache.commons.math3.fraction.BigFraction) -> a
    org.matheclipse.core.expression.FractionSym valueOf(java.math.BigInteger) -> a
    org.matheclipse.core.expression.FractionSym valueOf(org.apache.commons.math3.fraction.BigFraction) -> b
    org.matheclipse.core.expression.FractionSym valueOf(java.math.BigInteger,java.math.BigInteger) -> a
    org.matheclipse.core.expression.FractionSym valueOf(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.expression.FractionSym valueOf(long,long) -> a
    org.matheclipse.core.expression.FractionSym valueOf(double) -> a
    boolean isZero() -> isZero
    boolean equalsInt(int) -> equalsInt
    java.math.BigInteger getBigDenominator() -> getBigDenominator
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.apache.commons.math3.fraction.BigFraction getFraction() -> getFraction
    org.matheclipse.core.interfaces.IInteger getDenominator() -> getDenominator
    org.matheclipse.core.interfaces.IInteger getNumerator() -> getNumerator
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IFraction add(org.matheclipse.core.interfaces.IFraction) -> add
    org.matheclipse.core.interfaces.IFraction multiply(org.matheclipse.core.interfaces.IFraction) -> multiply
    boolean isNegative() -> isNegative
    boolean isPositive() -> isPositive
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    org.matheclipse.core.expression.FractionSym eabs() -> a
    int compareAbsValueToOne() -> compareAbsValueToOne
    java.math.BigInteger[] divideAndRemainder() -> divideAndRemainder
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INumber numericNumber() -> numericNumber
    org.matheclipse.core.interfaces.INumber normalize() -> normalize
    int hashCode() -> hashCode
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    org.matheclipse.core.interfaces.IFraction pow(int) -> pow
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    java.lang.String internalFormString(boolean,int) -> internalFormString
    int toInt() -> toInt
    long toLong() -> toLong
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    org.matheclipse.core.interfaces.IExpr gcd(org.matheclipse.core.interfaces.IExpr) -> a
    org.apache.commons.math3.fraction.BigFraction getRational() -> getRational
    int sign() -> sign
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
    org.matheclipse.core.interfaces.IInteger round() -> round
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISymbol head() -> a
    org.matheclipse.core.interfaces.IFraction abs() -> abs
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr abs() -> b
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.IRational abs() -> abs
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.HMArrayList -> rU:
    int firstIndex -> a
    int lastIndex -> b
    int hashValue -> c
    java.lang.Object[] array -> a
    void add(int,java.lang.Object) -> add
    boolean add(java.lang.Object) -> add
    boolean addAll(int,java.util.Collection) -> addAll
    boolean addAll(java.util.Collection) -> addAll
    void clear() -> clear
    java.lang.Object clone() -> clone
    boolean contains(java.lang.Object) -> contains
    boolean equals(java.lang.Object) -> equals
    boolean isSameHead(java.lang.Object,int) -> a
    boolean isSameHeadSizeGE(java.lang.Object,int) -> b
    java.lang.Object get(int) -> get
    void growAtEnd(int) -> a
    void growAtFront(int) -> b
    void growForInsert(int,int) -> a
    int hashCode() -> hashCode
    int indexOf(java.lang.Object) -> indexOf
    boolean isEmpty() -> isEmpty
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.lang.Object remove(int) -> remove
    boolean remove(java.lang.Object) -> remove
    void removeRange(int,int) -> removeRange
    java.lang.Object set(int,java.lang.Object) -> set
    int size() -> size
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
org.matheclipse.core.expression.ISymbolObserver -> rV:
org.matheclipse.core.expression.IntegerSym -> org.matheclipse.core.expression.IntegerSym:
    java.math.BigInteger BI_MINUS_ONE -> b
    java.math.BigInteger fInteger -> a
    int fHashValue -> a
    org.matheclipse.core.expression.IntegerSym newInstance(java.math.BigInteger) -> a
    org.matheclipse.core.expression.IntegerSym valueOf(long) -> a
    org.matheclipse.core.expression.IntegerSym valueOf(java.lang.String,int) -> a
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INumber numericNumber() -> numericNumber
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IInteger add(org.matheclipse.core.interfaces.IInteger) -> add
    org.matheclipse.core.interfaces.IInteger multiply(org.matheclipse.core.interfaces.IInteger) -> multiply
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.expression.IntegerSym valueOf(java.math.BigInteger) -> b
    org.matheclipse.core.interfaces.IExpr[] egcd(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.expression.IntegerSym eabs() -> b
    int compareAbsValueToOne() -> compareAbsValueToOne
    org.matheclipse.core.expression.IntegerSym add(org.matheclipse.core.expression.IntegerSym) -> d
    org.matheclipse.core.expression.IntegerSym quotient(org.matheclipse.core.expression.IntegerSym) -> a
    double doubleValue() -> doubleValue
    org.matheclipse.core.interfaces.IInteger gcd(org.matheclipse.core.interfaces.IInteger) -> gcd
    org.matheclipse.core.interfaces.IExpr gcd(org.matheclipse.core.interfaces.IExpr) -> a
    java.math.BigInteger lcm(java.math.BigInteger,java.math.BigInteger) -> a
    org.matheclipse.core.interfaces.IInteger lcm(org.matheclipse.core.interfaces.IInteger) -> lcm
    int hashCode() -> hashCode
    boolean isNegative() -> isNegative
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumIntValue() -> isNumIntValue
    boolean isPositive() -> isPositive
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isZero() -> isZero
    boolean isOne() -> isOne
    boolean isMinusOne() -> isMinusOne
    int intValue() -> intValue
    long longValue() -> longValue
    org.matheclipse.core.expression.IntegerSym mod(org.matheclipse.core.expression.IntegerSym) -> b
    org.matheclipse.core.expression.IntegerSym multiply(org.matheclipse.core.expression.IntegerSym) -> e
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    org.matheclipse.core.expression.IntegerSym pow(int) -> a
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    org.matheclipse.core.interfaces.IInteger subtract(org.matheclipse.core.interfaces.IInteger) -> subtract
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.matheclipse.core.interfaces.IInteger getNumerator() -> getNumerator
    org.matheclipse.core.interfaces.IInteger getDenominator() -> getDenominator
    org.apache.commons.math3.fraction.BigFraction getFraction() -> getFraction
    org.matheclipse.core.interfaces.IAST factorize(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST factorInteger() -> a
    org.matheclipse.core.interfaces.IInteger eulerPhi() -> a
    org.matheclipse.core.expression.IntegerSym moebiusMu() -> a
    org.matheclipse.core.expression.IntegerSym jacobiSymbol(org.matheclipse.core.expression.IntegerSym) -> c
    org.matheclipse.core.interfaces.IInteger[] primitiveRoots() -> a
    int compareTo(org.matheclipse.core.expression.IntegerSym) -> a
    org.matheclipse.core.expression.IntegerSym[] divideAndRemainder(org.matheclipse.core.expression.IntegerSym) -> a
    org.matheclipse.core.interfaces.IExpr remainder(org.matheclipse.core.interfaces.IExpr) -> b
    boolean isEven() -> isEven
    boolean isOdd() -> isOdd
    int toInt() -> toInt
    long toLong() -> toLong
    int sign() -> sign
    org.matheclipse.core.interfaces.IInteger nthRoot(int) -> nthRoot
    org.matheclipse.core.interfaces.IInteger[] nthRootSplit(int) -> nthRootSplit
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
    org.matheclipse.core.interfaces.IInteger round() -> round
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.String toString() -> toString
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.IRational abs() -> abs
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr abs() -> b
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> a
    edu.jas.structure.AbelianGroupElem abs() -> a
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> a
    org.matheclipse.core.interfaces.IInteger pow(int) -> pow
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.MethodSymbol -> org.matheclipse.core.expression.MethodSymbol:
    java.lang.reflect.Method fMethod -> a
    org.matheclipse.core.interfaces.IExpr invoke(org.matheclipse.core.interfaces.IAST) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isTrue() -> isTrue
    boolean isFalse() -> isFalse
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.Num -> org.matheclipse.core.expression.Num:
    double fDouble -> a
    org.matheclipse.core.expression.Num newInstance(double) -> b
    int hierarchy() -> hierarchy
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumIntValue() -> isNumIntValue
    boolean isNegative() -> isNegative
    boolean isPositive() -> isPositive
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INum add(org.matheclipse.core.interfaces.INum) -> add
    org.matheclipse.core.interfaces.INum multiply(org.matheclipse.core.interfaces.INum) -> multiply
    org.matheclipse.core.interfaces.INum pow(org.matheclipse.core.interfaces.INum) -> pow
    org.matheclipse.core.expression.Num valueOf(double) -> a
    int compareAbsValueToOne() -> compareAbsValueToOne
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    int hashCode() -> hashCode
    int intValue() -> intValue
    int toInt() -> toInt
    long toLong() -> toLong
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    double getRealPart() -> getRealPart
    boolean isE() -> isE
    boolean isOne() -> isOne
    boolean isMinusOne() -> isMinusOne
    boolean isPi() -> isPi
    boolean isZero() -> isZero
    org.matheclipse.core.interfaces.IInteger round() -> round
    int sign() -> sign
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.String toString() -> toString
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
    edu.jas.structure.MonoidElem inverse() -> a
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.NumberUtil -> rW:
    java.math.BigInteger MINUS_ONE -> a
    boolean[] bad255 -> a
    int[] start -> a
    boolean isZero(org.apache.commons.math3.fraction.BigFraction) -> a
    org.apache.commons.math3.fraction.BigFraction inverse(org.apache.commons.math3.fraction.BigFraction) -> a
    boolean isOne(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isMinusOne(org.matheclipse.core.interfaces.IExpr) -> b
    boolean isNegative(java.math.BigInteger) -> a
    boolean isZero(java.math.BigInteger) -> b
    boolean isEven(java.math.BigInteger) -> c
    boolean isOdd(java.math.BigInteger) -> d
    long toLong(java.math.BigInteger) -> a
    int toInt(java.math.BigInteger) -> a
    int toInt(double) -> a
    long toLong(double) -> a
    boolean isNegative(org.apache.commons.math3.fraction.BigFraction) -> b
    java.math.BigInteger floor(org.apache.commons.math3.fraction.BigFraction) -> a
    java.math.BigInteger ceiling(org.apache.commons.math3.fraction.BigFraction) -> b
    java.math.BigInteger round(org.apache.commons.math3.fraction.BigFraction,int) -> a
    boolean isPerfectSquare(org.apache.commons.math3.fraction.BigFraction) -> c
    boolean isPerfectSquare(long) -> a
org.matheclipse.core.expression.Pattern -> org.matheclipse.core.expression.Pattern:
    org.matheclipse.core.expression.Pattern NULL_PATTERN -> a
    org.matheclipse.core.interfaces.IExpr fCondition -> a
    int fHashValue -> a
    org.matheclipse.core.interfaces.ISymbol fSymbol -> a
    boolean fDefault -> a
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    int getIndex(org.matheclipse.core.patternmatching.PatternMap) -> a
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> b
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    java.lang.String internalFormString(boolean,int) -> internalFormString
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> a
    boolean isBlank() -> isBlank
    boolean isConditionMatched(org.matheclipse.core.interfaces.IExpr) -> isConditionMatched
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean isPatternDefault() -> isPatternDefault
    boolean isPattern() -> isPattern
    boolean isPatternExpr() -> isPatternExpr
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.PatternSequence -> org.matheclipse.core.expression.PatternSequence:
    org.matheclipse.core.interfaces.IExpr fCondition -> a
    org.matheclipse.core.interfaces.ISymbol fSymbol -> a
    boolean fDefault -> a
    org.matheclipse.core.expression.PatternSequence valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    org.matheclipse.core.expression.PatternSequence valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.expression.PatternSequence valueOf(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    int getIndex(org.matheclipse.core.patternmatching.PatternMap) -> a
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> b
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    java.lang.String internalFormString(boolean,int) -> internalFormString
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> a
    boolean isBlank() -> isBlank
    boolean isConditionMatchedSequence(org.matheclipse.core.interfaces.IAST) -> isConditionMatchedSequence
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean isDefault() -> isDefault
    boolean isPatternExpr() -> isPatternExpr
    boolean isPatternSequence() -> isPatternSequence
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.Primality -> rX:
    java.security.SecureRandom random -> a
    int[] primes -> a
    short[] SHORT_PRIMES -> a
    java.math.BigInteger[] BIprimes -> a
    java.math.BigInteger countPrimes1021(java.math.BigInteger,java.util.Map) -> a
    java.math.BigInteger countPrimes32749(java.math.BigInteger,java.util.Map) -> b
    void pollardRhoFactors(java.math.BigInteger,java.util.Map) -> a
org.matheclipse.core.expression.StringX -> org.matheclipse.core.expression.StringX:
    java.lang.String fString -> a
    org.matheclipse.core.expression.StringX newInstance(java.lang.String) -> a
    org.matheclipse.core.expression.StringX valueOf(char) -> a
    org.matheclipse.core.expression.StringX valueOf(java.lang.Object) -> a
    org.matheclipse.core.expression.StringX valueOf(java.lang.StringBuffer) -> a
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.String toString() -> toString
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.Symbol -> org.matheclipse.core.expression.Symbol:
    int fAttributes -> a
    org.matheclipse.core.interfaces.IEvaluator fEvaluator -> a
    org.matheclipse.core.patternmatching.DownRulesData fDownRulesData -> a
    org.matheclipse.core.patternmatching.UpRulesData fUpRulesData -> a
    org.matheclipse.core.util.OpenIntToIExprHashMap fDefaultValues -> a
    org.matheclipse.core.expression.Symbol$DummyEvaluator DUMMY_EVALUATOR -> a
    java.lang.String fSymbolName -> a
    int fHashValue -> b
    org.matheclipse.core.interfaces.IExpr[] reassignSymbolValue(com.google.common.base.Function,org.matheclipse.core.interfaces.ISymbol) -> reassignSymbolValue
    boolean hasAssignedSymbolValue() -> hasAssignedSymbolValue
    org.matheclipse.core.interfaces.IExpr getAssignedValue() -> getAssignedValue
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr[]) -> apply
    void pushLocalVariable() -> pushLocalVariable
    void pushLocalVariable(org.matheclipse.core.interfaces.IExpr) -> pushLocalVariable
    void popLocalVariable() -> popLocalVariable
    void clear(org.matheclipse.core.eval.EvalEngine) -> clear
    void clearAll(org.matheclipse.core.eval.EvalEngine) -> clearAll
    boolean equals(java.lang.Object) -> equals
    boolean isSymbolName(java.lang.String) -> isSymbolName
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.IExpr evalDownRule$6c3927ef(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction,org.matheclipse.core.interfaces.IExpr) -> evalDownRule$6c3927ef
    org.matheclipse.core.interfaces.IExpr evalUpRule$6c3927ef(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction,org.matheclipse.core.interfaces.IExpr) -> evalUpRule$6c3927ef
    int getAttributes() -> getAttributes
    org.matheclipse.core.interfaces.IEvaluator getEvaluator() -> getEvaluator
    boolean hasLocalVariableStack() -> hasLocalVariableStack
    org.matheclipse.core.interfaces.IExpr get() -> get
    void set(org.matheclipse.core.interfaces.IExpr) -> set
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    boolean isString(java.lang.String) -> isString
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int,boolean) -> putDownRule
    org.matheclipse.core.patternmatching.PatternMatcher putDownRule(org.matheclipse.core.patternmatching.PatternMatcherAndInvoker) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> putUpRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> putUpRule
    void setAttributes(int) -> setAttributes
    void setEvaluator(org.matheclipse.core.interfaces.IEvaluator) -> setEvaluator
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isAtom() -> isAtom
    boolean isConstant() -> isConstant
    boolean isE() -> isE
    boolean isTrue() -> isTrue
    boolean isValue() -> isValue
    boolean isVariable() -> isVariable
    boolean isFalse() -> isFalse
    boolean isIndeterminate() -> isIndeterminate
    boolean isNegative() -> isNegative
    boolean isPi() -> isPi
    boolean isPolynomial(org.matheclipse.core.interfaces.ISymbol) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.IAST) -> isPolynomial
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.ISymbol,long) -> isPolynomialOfMaxDegree
    boolean isPositive() -> isPositive
    org.matheclipse.core.interfaces.ISymbol head() -> a
    java.lang.String getSymbolName() -> getSymbolName
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    java.lang.String internalFormString(boolean,int) -> internalFormString
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    java.util.List definition() -> definition
    org.matheclipse.core.interfaces.IExpr getDefaultValue() -> getDefaultValue
    org.matheclipse.core.interfaces.IExpr getDefaultValue(int) -> getDefaultValue
    void setDefaultValue(org.matheclipse.core.interfaces.IExpr) -> setDefaultValue
    void setDefaultValue(int,org.matheclipse.core.interfaces.IExpr) -> setDefaultValue
    java.lang.String definitionToString() -> definitionToString
    void readSymbol(java.io.ObjectInputStream) -> readSymbol
    void writeSymbol(java.io.ObjectOutputStream) -> writeSymbol
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.IExpr mapConstantDouble(org.matheclipse.core.generic.interfaces.INumericFunction) -> mapConstantDouble
    org.matheclipse.core.interfaces.IExpr negate() -> a
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> b
    int compareTo(edu.jas.structure.Element) -> a
org.matheclipse.core.expression.Symbol$DummyEvaluator -> rY:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.form.mathml.AbstractConverter -> org.matheclipse.core.form.mathml.AbstractConverter:
    org.matheclipse.core.form.mathml.AbstractMathMLFormFactory fFactory -> a
    void setFactory(org.matheclipse.core.form.mathml.AbstractMathMLFormFactory) -> a
org.matheclipse.core.form.mathml.AbstractMathMLFormFactory -> rZ:
    java.util.Hashtable ENTITY_TABLE -> a
    java.lang.String fTagPrefix -> a
    void tag(java.lang.StringBuffer,java.lang.String,java.lang.String) -> a
    void tagStart(java.lang.StringBuffer,java.lang.String) -> a
    void tagEnd(java.lang.StringBuffer,java.lang.String) -> b
    org.matheclipse.core.form.mathml.IConverter reflection(java.lang.String) -> a
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> a
    void convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> a
org.matheclipse.core.form.mathml.AbstractOperator -> org.matheclipse.core.form.mathml.AbstractOperator:
    int fPrecedence -> a
    java.lang.String fFirstTag -> a
    java.lang.String fOperator -> b
    void precedenceOpen(java.lang.StringBuffer,int) -> a
    void precedenceClose(java.lang.StringBuffer,int) -> b
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.IConverter -> sa:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.MMLContentFunction -> org.matheclipse.core.form.mathml.MMLContentFunction:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.MMLFunction -> org.matheclipse.core.form.mathml.MMLFunction:
    java.lang.String fFunctionName -> a
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.MMLPostfix -> org.matheclipse.core.form.mathml.MMLPostfix:
    java.lang.String fOperator -> a
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.MathMLFormFactory -> sb:
    java.util.Hashtable CONSTANT_SYMBOLS -> b
    java.util.Hashtable operTab -> c
    int plusPrec -> a
    void convertFraction(java.lang.StringBuffer,org.apache.commons.math3.fraction.BigFraction,int) -> a
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> a
    void convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> a
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.form.mathml.IConverter reflection(java.lang.String) -> a
org.matheclipse.core.form.mathml.MathMLFormFactory$Operator -> sc:
    java.lang.String fOperator -> a
    org.matheclipse.core.form.mathml.MathMLFormFactory this$0 -> a
    java.lang.String toString() -> toString
org.matheclipse.core.form.mathml.reflection.Abs -> org.matheclipse.core.form.mathml.reflection.Abs:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.And -> org.matheclipse.core.form.mathml.reflection.And:
org.matheclipse.core.form.mathml.reflection.Binomial -> org.matheclipse.core.form.mathml.reflection.Binomial:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Ceiling -> org.matheclipse.core.form.mathml.reflection.Ceiling:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.CompoundExpression -> org.matheclipse.core.form.mathml.reflection.CompoundExpression:
org.matheclipse.core.form.mathml.reflection.D -> org.matheclipse.core.form.mathml.reflection.D:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Equal -> org.matheclipse.core.form.mathml.reflection.Equal:
org.matheclipse.core.form.mathml.reflection.Factorial -> org.matheclipse.core.form.mathml.reflection.Factorial:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Factorial2 -> org.matheclipse.core.form.mathml.reflection.Factorial2:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Floor -> org.matheclipse.core.form.mathml.reflection.Floor:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Greater -> org.matheclipse.core.form.mathml.reflection.Greater:
org.matheclipse.core.form.mathml.reflection.GreaterEqual -> org.matheclipse.core.form.mathml.reflection.GreaterEqual:
org.matheclipse.core.form.mathml.reflection.Integrate -> org.matheclipse.core.form.mathml.reflection.Integrate:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
    boolean iteratorStep(java.lang.StringBuffer,java.lang.String,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Less -> org.matheclipse.core.form.mathml.reflection.Less:
org.matheclipse.core.form.mathml.reflection.LessEqual -> org.matheclipse.core.form.mathml.reflection.LessEqual:
org.matheclipse.core.form.mathml.reflection.List -> org.matheclipse.core.form.mathml.reflection.List:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.MatrixForm -> org.matheclipse.core.form.mathml.reflection.MatrixForm:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Not -> org.matheclipse.core.form.mathml.reflection.Not:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Or -> org.matheclipse.core.form.mathml.reflection.Or:
org.matheclipse.core.form.mathml.reflection.Part -> org.matheclipse.core.form.mathml.reflection.Part:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Plus -> org.matheclipse.core.form.mathml.reflection.Plus:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Power -> org.matheclipse.core.form.mathml.reflection.Power:
org.matheclipse.core.form.mathml.reflection.Product -> org.matheclipse.core.form.mathml.reflection.Product:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Rational -> org.matheclipse.core.form.mathml.reflection.Rational:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Rule -> org.matheclipse.core.form.mathml.reflection.Rule:
org.matheclipse.core.form.mathml.reflection.RuleDelayed -> org.matheclipse.core.form.mathml.reflection.RuleDelayed:
org.matheclipse.core.form.mathml.reflection.Set -> org.matheclipse.core.form.mathml.reflection.Set:
org.matheclipse.core.form.mathml.reflection.SetDelayed -> org.matheclipse.core.form.mathml.reflection.SetDelayed:
org.matheclipse.core.form.mathml.reflection.Sqrt -> org.matheclipse.core.form.mathml.reflection.Sqrt:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Sum -> org.matheclipse.core.form.mathml.reflection.Sum:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
    boolean iteratorStep(java.lang.StringBuffer,java.lang.String,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.mathml.reflection.Times -> org.matheclipse.core.form.mathml.reflection.Times:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int,int) -> a
    boolean convertMultiply(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int,int) -> b
org.matheclipse.core.form.output.OutputFormFactory -> sd:
    boolean fRelaxedSyntax -> b
    boolean fIgnoreNewLine -> a
    boolean fEmpty -> c
    int fColumnCounter -> a
    org.matheclipse.core.form.output.OutputFormFactory get(boolean) -> a
    void convertDoubleValue(java.lang.Appendable,java.lang.String,int,boolean) -> a
    void convertDoubleComplex(java.lang.Appendable,org.matheclipse.core.interfaces.IComplexNum,int) -> a
    void convertApcomplex(java.lang.Appendable,org.apfloat.Apcomplex,int) -> a
    void convertInteger(java.lang.Appendable,org.matheclipse.core.interfaces.IInteger,int) -> a
    void convertFraction(java.lang.Appendable,org.apache.commons.math3.fraction.BigFraction,int) -> a
    void convertComplex(java.lang.Appendable,org.matheclipse.core.interfaces.IComplex,int) -> a
    void convertSymbol(java.lang.Appendable,org.matheclipse.core.interfaces.ISymbol) -> a
    void convert(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr) -> a
    void convertNumber(java.lang.Appendable,org.matheclipse.core.interfaces.INumber,int) -> a
    void convert(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr,int) -> a
    void convertAST(java.lang.Appendable,org.matheclipse.core.interfaces.IAST) -> a
    void newLine(java.lang.Appendable) -> a
    void append(java.lang.Appendable,java.lang.String) -> a
    void append(java.lang.Appendable,char) -> a
org.matheclipse.core.form.tex.AbstractConverter -> org.matheclipse.core.form.tex.AbstractConverter:
    org.matheclipse.core.form.tex.AbstractTeXFormFactory fFactory -> a
    void setFactory(org.matheclipse.core.form.tex.AbstractTeXFormFactory) -> a
org.matheclipse.core.form.tex.AbstractOperator -> org.matheclipse.core.form.tex.AbstractOperator:
    int fPrecedence -> a
    java.lang.String fOperator -> a
    void precedenceOpen(java.lang.StringBuffer,int) -> a
    void precedenceClose(java.lang.StringBuffer,int) -> b
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.AbstractTeXFormFactory -> se:
    org.matheclipse.core.form.mathml.IConverter reflection$6a0851f1(java.lang.String) -> a
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> a
    void convert(java.lang.StringBuffer,java.lang.Object,int) -> a
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,java.lang.String) -> a
    void convertSubExpr(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> a
org.matheclipse.core.form.tex.TeXFormFactory -> sf:
    java.util.Hashtable CONSTANT_SYMBOLS -> a
    java.util.Hashtable operTab -> b
    int plusPrec -> a
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> a
    void convert(java.lang.StringBuffer,java.lang.Object,int) -> a
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,java.lang.String) -> a
    org.matheclipse.core.form.mathml.IConverter reflection$6a0851f1(java.lang.String) -> a
    void convertSubExpr(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> a
org.matheclipse.core.form.tex.TeXFormFactory$Operator -> sg:
    java.lang.String toString() -> toString
org.matheclipse.core.form.tex.TeXFunction -> org.matheclipse.core.form.tex.TeXFunction:
    java.lang.String fFunctionName -> a
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.TeXPostfix -> org.matheclipse.core.form.tex.TeXPostfix:
    java.lang.String fOperator -> a
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Abs -> org.matheclipse.core.form.tex.reflection.Abs:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.And -> org.matheclipse.core.form.tex.reflection.And:
org.matheclipse.core.form.tex.reflection.Binomial -> org.matheclipse.core.form.tex.reflection.Binomial:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Ceiling -> org.matheclipse.core.form.tex.reflection.Ceiling:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Complex -> org.matheclipse.core.form.tex.reflection.Complex:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.CompoundExpression -> org.matheclipse.core.form.tex.reflection.CompoundExpression:
org.matheclipse.core.form.tex.reflection.D -> org.matheclipse.core.form.tex.reflection.D:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.DirectedInfinity -> org.matheclipse.core.form.tex.reflection.DirectedInfinity:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Equal -> org.matheclipse.core.form.tex.reflection.Equal:
org.matheclipse.core.form.tex.reflection.Factorial -> org.matheclipse.core.form.tex.reflection.Factorial:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Factorial2 -> org.matheclipse.core.form.tex.reflection.Factorial2:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Floor -> org.matheclipse.core.form.tex.reflection.Floor:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Greater -> org.matheclipse.core.form.tex.reflection.Greater:
org.matheclipse.core.form.tex.reflection.GreaterEqual -> org.matheclipse.core.form.tex.reflection.GreaterEqual:
org.matheclipse.core.form.tex.reflection.HarmonicNumber -> org.matheclipse.core.form.tex.reflection.HarmonicNumber:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.HurwitzZeta -> org.matheclipse.core.form.tex.reflection.HurwitzZeta:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Integrate -> org.matheclipse.core.form.tex.reflection.Integrate:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
    boolean iteratorStep(java.lang.StringBuffer,java.lang.String,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Less -> org.matheclipse.core.form.tex.reflection.Less:
org.matheclipse.core.form.tex.reflection.LessEqual -> org.matheclipse.core.form.tex.reflection.LessEqual:
org.matheclipse.core.form.tex.reflection.Limit -> org.matheclipse.core.form.tex.reflection.Limit:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.List -> org.matheclipse.core.form.tex.reflection.List:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.MatrixForm -> org.matheclipse.core.form.tex.reflection.MatrixForm:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Not -> org.matheclipse.core.form.tex.reflection.Not:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Or -> org.matheclipse.core.form.tex.reflection.Or:
org.matheclipse.core.form.tex.reflection.Plus -> org.matheclipse.core.form.tex.reflection.Plus:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Power -> org.matheclipse.core.form.tex.reflection.Power:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Product -> org.matheclipse.core.form.tex.reflection.Product:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Rational -> org.matheclipse.core.form.tex.reflection.Rational:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Rule -> org.matheclipse.core.form.tex.reflection.Rule:
org.matheclipse.core.form.tex.reflection.RuleDelayed -> org.matheclipse.core.form.tex.reflection.RuleDelayed:
org.matheclipse.core.form.tex.reflection.Set -> org.matheclipse.core.form.tex.reflection.Set:
org.matheclipse.core.form.tex.reflection.SetDelayed -> org.matheclipse.core.form.tex.reflection.SetDelayed:
org.matheclipse.core.form.tex.reflection.Sqrt -> org.matheclipse.core.form.tex.reflection.Sqrt:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Subscript -> org.matheclipse.core.form.tex.reflection.Subscript:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Subsuperscript -> org.matheclipse.core.form.tex.reflection.Subsuperscript:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Sum -> org.matheclipse.core.form.tex.reflection.Sum:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
    boolean iteratorStep(java.lang.StringBuffer,java.lang.String,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Superscript -> org.matheclipse.core.form.tex.reflection.Superscript:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.form.tex.reflection.Times -> org.matheclipse.core.form.tex.reflection.Times:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int,int) -> a
    boolean convertMultiply(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int,int) -> b
org.matheclipse.core.form.tex.reflection.Zeta -> org.matheclipse.core.form.tex.reflection.Zeta:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.generic.BinaryApply -> sh:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.BinaryBindIth1st -> si:
    org.matheclipse.core.interfaces.IAST fConstant1 -> a
    org.matheclipse.core.interfaces.IAST fConstant2 -> b
    java.lang.Object apply(int,java.lang.Object) -> a
org.matheclipse.core.generic.BinaryEval -> sj:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.BinaryMap -> sk:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.ExprComparator -> sl:
    org.matheclipse.core.generic.ExprComparator CONS -> a
    int compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.generic.Functors -> sm:
    com.google.common.base.Predicate PATTERNQ_PREDICATE -> a
    com.google.common.base.Function scan(org.matheclipse.core.interfaces.IAST,java.util.Collection) -> a
    com.google.common.base.Function append(org.matheclipse.core.interfaces.IAST) -> a
    com.google.common.base.Function apply(org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Function collect(java.util.Collection) -> a
    com.google.common.base.Function replaceAll(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Function replaceArg(org.matheclipse.core.interfaces.IAST,int) -> a
    com.google.common.base.Function rules(java.util.Map) -> a
    com.google.common.base.Function rules(java.lang.String[]) -> a
    com.google.common.base.Function rules(org.matheclipse.core.interfaces.IAST) -> b
    void addRuleToCollection(java.util.Map,java.util.List,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.generic.Functors$1 -> sn:
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$AppendFunctor -> so:
    org.matheclipse.core.interfaces.IAST fAST -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ApplyFunctor -> sp:
    org.matheclipse.core.interfaces.IExpr fConstant -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$CollectFunctor -> sq:
    java.util.Collection resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ReplaceAllFunctor -> sr:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    org.matheclipse.core.interfaces.IExpr fLHS -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ReplaceArgFunctor -> ss:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    int fPosition -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$RulesFunctor -> st:
    java.util.Map fEqualRules -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$RulesPatternFunctor -> su:
    java.util.Map fEqualRules -> a
    java.util.List fMatchers -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ScanFunctor -> sv:
    org.matheclipse.core.interfaces.IAST fAST -> a
    java.util.Collection resultCollection -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT -> sw:
    int TRUE$1c342bc9 -> a
    int FALSE$1c342bc9 -> b
    int UNDEFINED$1c342bc9 -> c
org.matheclipse.core.generic.IsBinaryFalse -> sx:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    int compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.IsLEOrdered -> sy:
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.IsUnaryVariable -> org.matheclipse.core.generic.IsUnaryVariable:
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.IsUnaryVariableOrPattern -> org.matheclipse.core.generic.IsUnaryVariableOrPattern:
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.MultipleArrayFunction -> sz:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fHeadAST -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.MultipleConstArrayFunction -> sA:
    org.matheclipse.core.interfaces.IExpr fConstantExpr -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.PositionConverter -> sB:
    int toInt(org.matheclipse.core.interfaces.IExpr) -> a
    int toInt(java.lang.Object) -> a
    java.lang.Object toObject(int) -> a
org.matheclipse.core.generic.Predicates$4 -> org.matheclipse.core.generic.Predicates$4:
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$6 -> org.matheclipse.core.generic.Predicates$6:
    org.matheclipse.core.interfaces.ISymbol[] val$heads -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$InASTPredicate -> org.matheclipse.core.generic.Predicates$InASTPredicate:
    org.matheclipse.core.interfaces.IAST target -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$IsUnaryTrue -> org.matheclipse.core.generic.Predicates$IsUnaryTrue:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.UnaryArrayFunction -> sC:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IExpr fValue -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.UnaryCollect -> org.matheclipse.core.generic.UnaryCollect:
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.UnaryNumerical -> org.matheclipse.core.generic.UnaryNumerical:
    org.matheclipse.core.interfaces.IExpr fFunction -> a
    org.matheclipse.core.interfaces.ISymbol fVariable -> a
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    double value(double) -> a
    org.apache.commons.math3.analysis.UnivariateFunction derivative() -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.UnaryRangeFunction -> sD:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.UnaryVariable2Slot -> org.matheclipse.core.generic.UnaryVariable2Slot:
    java.util.Map fMap -> a
    java.util.List fVariableList -> a
    int fSlotCounter -> a
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr) -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.interfaces.BiFunction -> sE:
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.interfaces.BiPredicate -> sF:
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.generic.interfaces.IArrayFunction -> sG:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> a
org.matheclipse.core.generic.interfaces.IIterator -> sH:
    boolean setUp() -> a
    void tearDown() -> a
org.matheclipse.core.generic.interfaces.INumericFunction -> sI:
    java.lang.Object apply(double) -> a
org.matheclipse.core.generic.interfaces.IPositionConverter -> sJ:
    java.lang.Object toObject(int) -> a
    int toInt(java.lang.Object) -> a
org.matheclipse.core.generic.interfaces.IUnaryIndexFunction -> sK:
    java.lang.Object apply(int,java.lang.Object) -> a
org.matheclipse.core.integrate.rubi45.IntIntegerQ -> org.matheclipse.core.integrate.rubi45.IntIntegerQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.integrate.rubi45.IntRules0 -> sL:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules1 -> sM:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules10 -> sN:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules100 -> sO:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules101 -> sP:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules102 -> sQ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules103 -> sR:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules104 -> sS:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules105 -> sT:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules106 -> sU:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules107 -> sV:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules108 -> sW:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules109 -> sX:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules11 -> sY:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules110 -> sZ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules111 -> ta:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules112 -> tb:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules113 -> tc:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules114 -> td:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules115 -> te:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules116 -> tf:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules117 -> tg:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules118 -> th:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules119 -> ti:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules12 -> tj:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules120 -> tk:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules121 -> tl:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules122 -> tm:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules123 -> tn:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules124 -> to:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules125 -> tp:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules126 -> tq:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules127 -> tr:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules128 -> ts:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules129 -> tt:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules13 -> tu:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules130 -> tv:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules131 -> tw:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules132 -> tx:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules133 -> ty:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules134 -> tz:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules135 -> tA:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules136 -> tB:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules137 -> tC:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules138 -> tD:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules139 -> tE:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules14 -> tF:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules15 -> tG:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules16 -> tH:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules17 -> tI:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules18 -> tJ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules19 -> tK:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules2 -> tL:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules20 -> tM:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules21 -> tN:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules22 -> tO:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules23 -> tP:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules24 -> tQ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules25 -> tR:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules26 -> tS:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules27 -> tT:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules28 -> tU:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules29 -> tV:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules3 -> tW:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules30 -> tX:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules31 -> tY:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules32 -> tZ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules33 -> ua:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules34 -> ub:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules35 -> uc:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules36 -> ud:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules37 -> ue:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules38 -> uf:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules39 -> ug:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules4 -> uh:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules40 -> ui:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules41 -> uj:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules42 -> uk:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules43 -> ul:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules44 -> um:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules45 -> un:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules46 -> uo:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules47 -> up:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules48 -> uq:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules49 -> ur:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules5 -> us:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules50 -> ut:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules51 -> uu:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules52 -> uv:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules53 -> uw:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules54 -> ux:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules55 -> uy:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules56 -> uz:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules57 -> uA:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules58 -> uB:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules59 -> uC:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules6 -> uD:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules60 -> uE:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules61 -> uF:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules62 -> uG:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules63 -> uH:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules64 -> uI:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules65 -> uJ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules66 -> uK:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules67 -> uL:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules68 -> uM:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules69 -> uN:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules7 -> uO:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules70 -> uP:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules71 -> uQ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules72 -> uR:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules73 -> uS:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules74 -> uT:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules75 -> uU:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules76 -> uV:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules77 -> uW:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules78 -> uX:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules79 -> uY:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules8 -> uZ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules80 -> va:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules81 -> vb:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules82 -> vc:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules83 -> vd:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules84 -> ve:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules85 -> vf:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules86 -> vg:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules87 -> vh:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules88 -> vi:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules89 -> vj:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules9 -> vk:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules90 -> vl:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules91 -> vm:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules92 -> vn:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules93 -> vo:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules94 -> vp:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules95 -> vq:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules96 -> vr:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules97 -> vs:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules98 -> vt:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.IntRules99 -> vu:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors -> vv:
    org.matheclipse.core.interfaces.ISymbol F -> a
    org.matheclipse.core.interfaces.ISymbol G -> b
    org.matheclipse.core.interfaces.ISymbol H -> c
    org.matheclipse.core.interfaces.IAST F(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST F(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST G(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST G(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST H(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST H(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST H(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST Int(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST Dist(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST Dist(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST AbsorbMinusSign(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST AbsurdNumberFactors(org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST AbsurdNumberGCD(org.matheclipse.core.interfaces.IExpr[]) -> a
    org.matheclipse.core.interfaces.IAST AbsurdNumberGCDList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST AbsurdNumberQ(org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST ActivateTrig(org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST AlgebraicFunctionFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST AlgebraicFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST AlgebraicTrigFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST BinomialDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST BinomialMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST BinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST BinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST BinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST CalculusFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> n
    org.matheclipse.core.interfaces.IAST CalculusQ(org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST CancelCommonFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> o
    org.matheclipse.core.interfaces.IAST CollectReciprocals(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> p
    org.matheclipse.core.interfaces.IAST CombineExponents(org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST CommonFactors(org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST CommonNumericFactors(org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST ComplexFreeQ(org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST ConstantFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> q
    org.matheclipse.core.interfaces.IAST ContentFactor(org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST ContentFactorAux(org.matheclipse.core.interfaces.IExpr) -> n
    org.matheclipse.core.interfaces.IAST CosQ(org.matheclipse.core.interfaces.IExpr) -> o
    org.matheclipse.core.interfaces.IAST CoshQ(org.matheclipse.core.interfaces.IExpr) -> p
    org.matheclipse.core.interfaces.IAST CotQ(org.matheclipse.core.interfaces.IExpr) -> q
    org.matheclipse.core.interfaces.IAST CothQ(org.matheclipse.core.interfaces.IExpr) -> r
    org.matheclipse.core.interfaces.IAST CscQ(org.matheclipse.core.interfaces.IExpr) -> s
    org.matheclipse.core.interfaces.IAST CschQ(org.matheclipse.core.interfaces.IExpr) -> t
    org.matheclipse.core.interfaces.IAST CubicMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> r
    org.matheclipse.core.interfaces.IAST DeactivateTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> s
    org.matheclipse.core.interfaces.IAST DeactivateTrigAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> t
    org.matheclipse.core.interfaces.IAST DerivativeDivides(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST Distrib(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> u
    org.matheclipse.core.interfaces.IAST DivideDegreesOfFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> v
    org.matheclipse.core.interfaces.IAST Divides(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST EasyDQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> w
    org.matheclipse.core.interfaces.IAST EulerIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> x
    org.matheclipse.core.interfaces.IAST EvenQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> y
    org.matheclipse.core.interfaces.IAST ExpQ(org.matheclipse.core.interfaces.IExpr) -> u
    org.matheclipse.core.interfaces.IAST ExpandAlgebraicFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> z
    org.matheclipse.core.interfaces.IAST ExpandCleanup(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> A
    org.matheclipse.core.interfaces.IAST ExpandExpression(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> B
    org.matheclipse.core.interfaces.IAST ExpandIntegrand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> C
    org.matheclipse.core.interfaces.IAST ExpandIntegrand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST ExpandLinearProduct(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST ExpandToSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST ExpandToSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST ExpandTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> E
    org.matheclipse.core.interfaces.IAST ExpandTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST ExpandTrigExpand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST ExpandTrigReduce(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST ExpandTrigReduce(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST ExpandTrigReduceAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST ExpandTrigToExp(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST ExpandTrigToExp(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST ExponentIn(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST ExponentInAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST FactorAbsurdNumber(org.matheclipse.core.interfaces.IExpr) -> v
    org.matheclipse.core.interfaces.IAST FactorNumericGcd(org.matheclipse.core.interfaces.IExpr) -> w
    org.matheclipse.core.interfaces.IAST FactorOrder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> I
    org.matheclipse.core.interfaces.IAST FalseQ(org.matheclipse.core.interfaces.IExpr) -> x
    org.matheclipse.core.interfaces.IAST FindTrigFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST FixInertTrigFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> J
    org.matheclipse.core.interfaces.IAST FixIntRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> K
    org.matheclipse.core.interfaces.IAST FixRhsIntRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> L
    org.matheclipse.core.interfaces.IAST FixSimplify(org.matheclipse.core.interfaces.IExpr) -> y
    org.matheclipse.core.interfaces.IAST FractionOrNegativeQ(org.matheclipse.core.interfaces.IExpr[]) -> b
    org.matheclipse.core.interfaces.IAST FractionQ(org.matheclipse.core.interfaces.IExpr[]) -> c
    org.matheclipse.core.interfaces.IAST FractionalPowerFreeQ(org.matheclipse.core.interfaces.IExpr) -> z
    org.matheclipse.core.interfaces.IAST FractionalPowerOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST FractionalPowerOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST FractionalPowerOfSquareQ(org.matheclipse.core.interfaces.IExpr) -> A
    org.matheclipse.core.interfaces.IAST FractionalPowerQ(org.matheclipse.core.interfaces.IExpr) -> B
    org.matheclipse.core.interfaces.IAST FractionalPowerSubexpressionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST FreeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> M
    org.matheclipse.core.interfaces.IAST FreeTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IAST FunctionOfCosQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST FunctionOfCoshQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> n
    org.matheclipse.core.interfaces.IAST FunctionOfDensePolynomialsQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST FunctionOfExpnQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> o
    org.matheclipse.core.interfaces.IAST FunctionOfExponential(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> P
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Q
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialFunctionAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> R
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> S
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> T
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialTestAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> p
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> U
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> q
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolicQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> r
    org.matheclipse.core.interfaces.IAST FunctionOfInverseLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> V
    org.matheclipse.core.interfaces.IAST FunctionOfInverseLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> s
    org.matheclipse.core.interfaces.IAST FunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> W
    org.matheclipse.core.interfaces.IAST FunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST FunctionOfLinearSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST FunctionOfLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> X
    org.matheclipse.core.interfaces.IAST FunctionOfLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST FunctionOfQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> t
    org.matheclipse.core.interfaces.IAST FunctionOfQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST FunctionOfSinQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> u
    org.matheclipse.core.interfaces.IAST FunctionOfSinhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> v
    org.matheclipse.core.interfaces.IAST FunctionOfSquareRootOfQuadratic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Y
    org.matheclipse.core.interfaces.IAST FunctionOfSquareRootOfQuadratic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> w
    org.matheclipse.core.interfaces.IAST FunctionOfTanQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> x
    org.matheclipse.core.interfaces.IAST FunctionOfTanWeight(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> y
    org.matheclipse.core.interfaces.IAST FunctionOfTanhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> z
    org.matheclipse.core.interfaces.IAST FunctionOfTanhWeight(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> A
    org.matheclipse.core.interfaces.IAST FunctionOfTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Z
    org.matheclipse.core.interfaces.IAST FunctionOfTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> B
    org.matheclipse.core.interfaces.IAST FunctionOfTrigOfLinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aa
    org.matheclipse.core.interfaces.IAST FunctionOfTrigQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> C
    org.matheclipse.core.interfaces.IAST GE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ab
    org.matheclipse.core.interfaces.IAST GE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST GT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ac
    org.matheclipse.core.interfaces.IAST GT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> E
    org.matheclipse.core.interfaces.IAST Gcd(org.matheclipse.core.interfaces.IExpr[]) -> d
    org.matheclipse.core.interfaces.IAST Gcd(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ad
    org.matheclipse.core.interfaces.IAST GeneralizedBinomialDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ae
    org.matheclipse.core.interfaces.IAST GeneralizedBinomialMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> af
    org.matheclipse.core.interfaces.IAST GeneralizedBinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ag
    org.matheclipse.core.interfaces.IAST GeneralizedBinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ah
    org.matheclipse.core.interfaces.IAST GeneralizedTrinomialDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ai
    org.matheclipse.core.interfaces.IAST GeneralizedTrinomialMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aj
    org.matheclipse.core.interfaces.IAST GeneralizedTrinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ak
    org.matheclipse.core.interfaces.IAST GeneralizedTrinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> al
    org.matheclipse.core.interfaces.IAST GensymSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST HeldFormQ(org.matheclipse.core.interfaces.IExpr) -> C
    org.matheclipse.core.interfaces.IAST HyperbolicQ(org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST ImaginaryNumericQ(org.matheclipse.core.interfaces.IExpr) -> E
    org.matheclipse.core.interfaces.IAST ImaginaryQ(org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST IndependentQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> am
    org.matheclipse.core.interfaces.IAST InertReciprocalQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> an
    org.matheclipse.core.interfaces.IAST InertTrigFreeQ(org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST InertTrigQ(org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST InertTrigQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ao
    org.matheclipse.core.interfaces.IAST InertTrigQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST InertTrigSumQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST IntSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ap
    org.matheclipse.core.interfaces.IAST IntTerm(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aq
    org.matheclipse.core.interfaces.IAST IntegerPowerQ(org.matheclipse.core.interfaces.IExpr) -> I
    org.matheclipse.core.interfaces.IAST IntegerQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ar
    org.matheclipse.core.interfaces.IAST IntegersQ(org.matheclipse.core.interfaces.IExpr[]) -> e
    org.matheclipse.core.interfaces.IAST InverseFunctionFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> as
    org.matheclipse.core.interfaces.IAST InverseFunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> at
    org.matheclipse.core.interfaces.IAST InverseFunctionOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> au
    org.matheclipse.core.interfaces.IAST InverseFunctionQ(org.matheclipse.core.interfaces.IExpr) -> J
    org.matheclipse.core.interfaces.IAST InverseHyperbolicQ(org.matheclipse.core.interfaces.IExpr) -> K
    org.matheclipse.core.interfaces.IAST InverseTrigQ(org.matheclipse.core.interfaces.IExpr) -> L
    org.matheclipse.core.interfaces.IAST KernelSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> I
    org.matheclipse.core.interfaces.IAST KnownCotangentIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> av
    org.matheclipse.core.interfaces.IAST KnownSecantIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aw
    org.matheclipse.core.interfaces.IAST KnownSineIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ax
    org.matheclipse.core.interfaces.IAST KnownTangentIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ay
    org.matheclipse.core.interfaces.IAST KnownTrigIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> J
    org.matheclipse.core.interfaces.IAST LE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> az
    org.matheclipse.core.interfaces.IAST LE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> K
    org.matheclipse.core.interfaces.IAST LT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aA
    org.matheclipse.core.interfaces.IAST LT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> L
    org.matheclipse.core.interfaces.IAST LeadBase(org.matheclipse.core.interfaces.IExpr) -> M
    org.matheclipse.core.interfaces.IAST LeadDegree(org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IAST LeadFactor(org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST LeadTerm(org.matheclipse.core.interfaces.IExpr) -> P
    org.matheclipse.core.interfaces.IAST LinearMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aB
    org.matheclipse.core.interfaces.IAST LinearPairQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> M
    org.matheclipse.core.interfaces.IAST LinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aC
    org.matheclipse.core.interfaces.IAST LogQ(org.matheclipse.core.interfaces.IExpr) -> Q
    org.matheclipse.core.interfaces.IAST MakeAssocList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aD
    org.matheclipse.core.interfaces.IAST MakeAssocList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IAST Map2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST MapAnd(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aE
    org.matheclipse.core.interfaces.IAST MapAnd(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> P
    org.matheclipse.core.interfaces.IAST MapOr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aF
    org.matheclipse.core.interfaces.IAST MergeFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Q
    org.matheclipse.core.interfaces.IAST MergeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aG
    org.matheclipse.core.interfaces.IAST MergeMonomials(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aH
    org.matheclipse.core.interfaces.IAST MergeableFactorQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> R
    org.matheclipse.core.interfaces.IAST MinimumDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aI
    org.matheclipse.core.interfaces.IAST MinimumMonomialExponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aJ
    org.matheclipse.core.interfaces.IAST MonomialExponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aK
    org.matheclipse.core.interfaces.IAST MonomialFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aL
    org.matheclipse.core.interfaces.IAST MonomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aM
    org.matheclipse.core.interfaces.IAST MonomialSumQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aN
    org.matheclipse.core.interfaces.IAST MostMainFactorPosition(org.matheclipse.core.interfaces.IExpr) -> R
    org.matheclipse.core.interfaces.IAST NegQ(org.matheclipse.core.interfaces.IExpr) -> S
    org.matheclipse.core.interfaces.IAST NegativeCoefficientQ(org.matheclipse.core.interfaces.IExpr) -> T
    org.matheclipse.core.interfaces.IAST NegativeIntegerQ(org.matheclipse.core.interfaces.IExpr[]) -> f
    org.matheclipse.core.interfaces.IAST NegativeOrZeroQ(org.matheclipse.core.interfaces.IExpr) -> U
    org.matheclipse.core.interfaces.IAST NegativeQ(org.matheclipse.core.interfaces.IExpr) -> V
    org.matheclipse.core.interfaces.IAST NiceSqrtAuxQ(org.matheclipse.core.interfaces.IExpr) -> W
    org.matheclipse.core.interfaces.IAST NiceSqrtQ(org.matheclipse.core.interfaces.IExpr) -> X
    org.matheclipse.core.interfaces.IAST NonabsurdNumberFactors(org.matheclipse.core.interfaces.IExpr) -> Y
    org.matheclipse.core.interfaces.IAST NonalgebraicFunctionFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aO
    org.matheclipse.core.interfaces.IAST NonfreeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aP
    org.matheclipse.core.interfaces.IAST NonfreeTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aQ
    org.matheclipse.core.interfaces.IAST NonnumericFactors(org.matheclipse.core.interfaces.IExpr) -> Z
    org.matheclipse.core.interfaces.IAST NonpolynomialTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aR
    org.matheclipse.core.interfaces.IAST NonpositiveFactors(org.matheclipse.core.interfaces.IExpr) -> aa
    org.matheclipse.core.interfaces.IAST NonrationalFunctionFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aS
    org.matheclipse.core.interfaces.IAST NonsumQ(org.matheclipse.core.interfaces.IExpr) -> ab
    org.matheclipse.core.interfaces.IAST NonzeroQ(org.matheclipse.core.interfaces.IExpr) -> ac
    org.matheclipse.core.interfaces.IAST NormalizeIntegrand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aT
    org.matheclipse.core.interfaces.IAST NormalizeIntegrandAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aU
    org.matheclipse.core.interfaces.IAST NormalizeIntegrandFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aV
    org.matheclipse.core.interfaces.IAST NormalizeIntegrandFactorBase(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aW
    org.matheclipse.core.interfaces.IAST NormalizeLeadTermSigns(org.matheclipse.core.interfaces.IExpr) -> ad
    org.matheclipse.core.interfaces.IAST NormalizePowerOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aX
    org.matheclipse.core.interfaces.IAST NormalizeSumFactors(org.matheclipse.core.interfaces.IExpr) -> ae
    org.matheclipse.core.interfaces.IAST NormalizeTogether(org.matheclipse.core.interfaces.IExpr) -> af
    org.matheclipse.core.interfaces.IAST NormalizeTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aY
    org.matheclipse.core.interfaces.IAST NotFalseQ(org.matheclipse.core.interfaces.IExpr) -> ag
    org.matheclipse.core.interfaces.IAST NotIntegrableQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aZ
    org.matheclipse.core.interfaces.IAST NumericFactor(org.matheclipse.core.interfaces.IExpr) -> ah
    org.matheclipse.core.interfaces.IAST OddHyperbolicPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> S
    org.matheclipse.core.interfaces.IAST OddQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ba
    org.matheclipse.core.interfaces.IAST OddTrigPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> T
    org.matheclipse.core.interfaces.IAST OneQ(org.matheclipse.core.interfaces.IExpr) -> ai
    org.matheclipse.core.interfaces.IAST OneQ(org.matheclipse.core.interfaces.IExpr[]) -> g
    org.matheclipse.core.interfaces.IAST PerfectPowerTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bb
    org.matheclipse.core.interfaces.IAST PerfectSquareQ(org.matheclipse.core.interfaces.IExpr) -> aj
    org.matheclipse.core.interfaces.IAST PiecewiseLinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bc
    org.matheclipse.core.interfaces.IAST PiecewiseLinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> U
    org.matheclipse.core.interfaces.IAST PolyQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> V
    org.matheclipse.core.interfaces.IAST PolynomialDivide(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> W
    org.matheclipse.core.interfaces.IAST PolynomialDivide(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST PolynomialInAuxQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> X
    org.matheclipse.core.interfaces.IAST PolynomialInQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Y
    org.matheclipse.core.interfaces.IAST PolynomialInSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Z
    org.matheclipse.core.interfaces.IAST PolynomialInSubstAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aa
    org.matheclipse.core.interfaces.IAST PolynomialTermQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bd
    org.matheclipse.core.interfaces.IAST PolynomialTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> be
    org.matheclipse.core.interfaces.IAST PosAux(org.matheclipse.core.interfaces.IExpr) -> ak
    org.matheclipse.core.interfaces.IAST PosQ(org.matheclipse.core.interfaces.IExpr) -> al
    org.matheclipse.core.interfaces.IAST PositiveFactors(org.matheclipse.core.interfaces.IExpr) -> am
    org.matheclipse.core.interfaces.IAST PositiveIntegerPowerQ(org.matheclipse.core.interfaces.IExpr) -> an
    org.matheclipse.core.interfaces.IAST PositiveIntegerQ(org.matheclipse.core.interfaces.IExpr[]) -> h
    org.matheclipse.core.interfaces.IAST PositiveOrZeroQ(org.matheclipse.core.interfaces.IExpr) -> ao
    org.matheclipse.core.interfaces.IAST PositiveQ(org.matheclipse.core.interfaces.IExpr) -> ap
    org.matheclipse.core.interfaces.IAST PowerOfLinearMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bf
    org.matheclipse.core.interfaces.IAST PowerOfLinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bg
    org.matheclipse.core.interfaces.IAST PowerQ(org.matheclipse.core.interfaces.IExpr) -> aq
    org.matheclipse.core.interfaces.IAST PowerVariableDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST PowerVariableExpn(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ab
    org.matheclipse.core.interfaces.IAST PowerVariableSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ac
    org.matheclipse.core.interfaces.IAST ProductOfLinearPowersQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bh
    org.matheclipse.core.interfaces.IAST ProductQ(org.matheclipse.core.interfaces.IExpr) -> ar
    org.matheclipse.core.interfaces.IAST PureFunctionOfCosQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ad
    org.matheclipse.core.interfaces.IAST PureFunctionOfCoshQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ae
    org.matheclipse.core.interfaces.IAST PureFunctionOfCotQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> af
    org.matheclipse.core.interfaces.IAST PureFunctionOfCothQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ag
    org.matheclipse.core.interfaces.IAST PureFunctionOfSinQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ah
    org.matheclipse.core.interfaces.IAST PureFunctionOfSinhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ai
    org.matheclipse.core.interfaces.IAST PureFunctionOfTanQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aj
    org.matheclipse.core.interfaces.IAST PureFunctionOfTanhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ak
    org.matheclipse.core.interfaces.IAST QuadraticMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bi
    org.matheclipse.core.interfaces.IAST QuadraticQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bj
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bk
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsP(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bl
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsParts(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bm
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bn
    org.matheclipse.core.interfaces.IAST RationalFunctionExpand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bo
    org.matheclipse.core.interfaces.IAST RationalFunctionExponents(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bp
    org.matheclipse.core.interfaces.IAST RationalFunctionFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bq
    org.matheclipse.core.interfaces.IAST RationalFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> br
    org.matheclipse.core.interfaces.IAST RationalPowerQ(org.matheclipse.core.interfaces.IExpr) -> as
    org.matheclipse.core.interfaces.IAST RationalQ(org.matheclipse.core.interfaces.IExpr[]) -> i
    org.matheclipse.core.interfaces.IAST RealNumericQ(org.matheclipse.core.interfaces.IExpr) -> at
    org.matheclipse.core.interfaces.IAST RealQ(org.matheclipse.core.interfaces.IExpr) -> au
    org.matheclipse.core.interfaces.IAST ReapList(org.matheclipse.core.interfaces.IExpr) -> av
    org.matheclipse.core.interfaces.IAST RectifyCotangent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST RectifyCotangent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST RectifyTangent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST RectifyTangent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST RemainingFactors(org.matheclipse.core.interfaces.IExpr) -> aw
    org.matheclipse.core.interfaces.IAST RemainingTerms(org.matheclipse.core.interfaces.IExpr) -> ax
    org.matheclipse.core.interfaces.IAST RemoveContent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bs
    org.matheclipse.core.interfaces.IAST Rt(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bt
    org.matheclipse.core.interfaces.IAST RtAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bu
    org.matheclipse.core.interfaces.IAST SecQ(org.matheclipse.core.interfaces.IExpr) -> ay
    org.matheclipse.core.interfaces.IAST SechQ(org.matheclipse.core.interfaces.IExpr) -> az
    org.matheclipse.core.interfaces.IAST SignOfFactor(org.matheclipse.core.interfaces.IExpr) -> aA
    org.matheclipse.core.interfaces.IAST Simp(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bv
    org.matheclipse.core.interfaces.IAST SimpFixFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bw
    org.matheclipse.core.interfaces.IAST SimpHelp(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bx
    org.matheclipse.core.interfaces.IAST SimplerIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> al
    org.matheclipse.core.interfaces.IAST SimplerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> by
    org.matheclipse.core.interfaces.IAST SimplerSqrtQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bz
    org.matheclipse.core.interfaces.IAST SimplifyAntiderivative(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bA
    org.matheclipse.core.interfaces.IAST SimplifyAntiderivativeSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bB
    org.matheclipse.core.interfaces.IAST SimplifyIntegrand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bC
    org.matheclipse.core.interfaces.IAST SimplifyTerm(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bD
    org.matheclipse.core.interfaces.IAST SinCosQ(org.matheclipse.core.interfaces.IExpr) -> aB
    org.matheclipse.core.interfaces.IAST SinQ(org.matheclipse.core.interfaces.IExpr) -> aC
    org.matheclipse.core.interfaces.IAST SinhCoshQ(org.matheclipse.core.interfaces.IExpr) -> aD
    org.matheclipse.core.interfaces.IAST SinhQ(org.matheclipse.core.interfaces.IExpr) -> aE
    org.matheclipse.core.interfaces.IAST Smallest(org.matheclipse.core.interfaces.IExpr) -> aF
    org.matheclipse.core.interfaces.IAST Smallest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bE
    org.matheclipse.core.interfaces.IAST SmartApart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bF
    org.matheclipse.core.interfaces.IAST SmartApart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> am
    org.matheclipse.core.interfaces.IAST SmartDenominator(org.matheclipse.core.interfaces.IExpr) -> aG
    org.matheclipse.core.interfaces.IAST SmartNumerator(org.matheclipse.core.interfaces.IExpr) -> aH
    org.matheclipse.core.interfaces.IAST SmartSimplify(org.matheclipse.core.interfaces.IExpr) -> aI
    org.matheclipse.core.interfaces.IAST SplitFreeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bG
    org.matheclipse.core.interfaces.IAST SqrtNumberQ(org.matheclipse.core.interfaces.IExpr) -> aJ
    org.matheclipse.core.interfaces.IAST SqrtNumberSumQ(org.matheclipse.core.interfaces.IExpr) -> aK
    org.matheclipse.core.interfaces.IAST SqrtQ(org.matheclipse.core.interfaces.IExpr) -> aL
    org.matheclipse.core.interfaces.IAST SquareRootOfQuadraticSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST Subst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> an
    org.matheclipse.core.interfaces.IAST SubstAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ao
    org.matheclipse.core.interfaces.IAST SubstFor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ap
    org.matheclipse.core.interfaces.IAST SubstFor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> l
    org.matheclipse.core.interfaces.IAST SubstForAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> aq
    org.matheclipse.core.interfaces.IAST SubstForExpn(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ar
    org.matheclipse.core.interfaces.IAST SubstForFractionalPower(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerAuxQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> as
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bH
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bI
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> at
    org.matheclipse.core.interfaces.IAST SubstForHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST SubstForInverseFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> au
    org.matheclipse.core.interfaces.IAST SubstForInverseFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> m
    org.matheclipse.core.interfaces.IAST SubstForInverseFunctionOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bJ
    org.matheclipse.core.interfaces.IAST SubstForTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST SumQ(org.matheclipse.core.interfaces.IExpr) -> aM
    org.matheclipse.core.interfaces.IAST SumSimplerAuxQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bK
    org.matheclipse.core.interfaces.IAST SumSimplerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bL
    org.matheclipse.core.interfaces.IAST TanQ(org.matheclipse.core.interfaces.IExpr) -> aN
    org.matheclipse.core.interfaces.IAST TanhQ(org.matheclipse.core.interfaces.IExpr) -> aO
    org.matheclipse.core.interfaces.IAST TogetherSimplify(org.matheclipse.core.interfaces.IExpr) -> aP
    org.matheclipse.core.interfaces.IAST TrigHyperbolicFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bM
    org.matheclipse.core.interfaces.IAST TrigQ(org.matheclipse.core.interfaces.IExpr) -> aQ
    org.matheclipse.core.interfaces.IAST TrigSimplify(org.matheclipse.core.interfaces.IExpr) -> aR
    org.matheclipse.core.interfaces.IAST TrigSimplifyAux(org.matheclipse.core.interfaces.IExpr) -> aS
    org.matheclipse.core.interfaces.IAST TrigSimplifyQ(org.matheclipse.core.interfaces.IExpr) -> aT
    org.matheclipse.core.interfaces.IAST TrigSimplifyRecur(org.matheclipse.core.interfaces.IExpr) -> aU
    org.matheclipse.core.interfaces.IAST TrinomialDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bN
    org.matheclipse.core.interfaces.IAST TrinomialMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bO
    org.matheclipse.core.interfaces.IAST TrinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bP
    org.matheclipse.core.interfaces.IAST TrinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bQ
    org.matheclipse.core.interfaces.IAST TryPureTanSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bR
    org.matheclipse.core.interfaces.IAST TryPureTanhSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bS
    org.matheclipse.core.interfaces.IAST TryTanhSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bT
    org.matheclipse.core.interfaces.IAST UnifyNegativeBaseFactors(org.matheclipse.core.interfaces.IExpr) -> aV
    org.matheclipse.core.interfaces.IAST UnifySum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bU
    org.matheclipse.core.interfaces.IAST UnifyTerm(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> av
    org.matheclipse.core.interfaces.IAST UnifyTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> bV
    org.matheclipse.core.interfaces.IAST ZeroQ(org.matheclipse.core.interfaces.IExpr) -> aW
org.matheclipse.core.integrate.rubi45.UtilityFunctions -> vw:
    org.matheclipse.core.interfaces.ISymbol pa -> a
    org.matheclipse.core.interfaces.ISymbol pb -> b
    org.matheclipse.core.interfaces.ISymbol pc -> c
    org.matheclipse.core.interfaces.ISymbol pd -> d
    org.matheclipse.core.interfaces.ISymbol pe -> e
    org.matheclipse.core.interfaces.ISymbol pf -> f
    org.matheclipse.core.interfaces.ISymbol pg -> g
    org.matheclipse.core.interfaces.ISymbol ph -> h
    org.matheclipse.core.interfaces.ISymbol pi -> i
    org.matheclipse.core.interfaces.ISymbol pj -> j
    org.matheclipse.core.interfaces.ISymbol pk -> k
    org.matheclipse.core.interfaces.ISymbol pl -> l
    org.matheclipse.core.interfaces.ISymbol pm -> m
    org.matheclipse.core.interfaces.ISymbol pn -> n
    org.matheclipse.core.interfaces.ISymbol po -> o
    org.matheclipse.core.interfaces.ISymbol pp -> p
    org.matheclipse.core.interfaces.ISymbol pq -> q
    org.matheclipse.core.interfaces.ISymbol pr -> r
    org.matheclipse.core.interfaces.ISymbol ps -> s
    org.matheclipse.core.interfaces.ISymbol pt -> t
    org.matheclipse.core.interfaces.ISymbol pu -> u
    org.matheclipse.core.interfaces.ISymbol pv -> v
    org.matheclipse.core.interfaces.ISymbol pw -> w
    org.matheclipse.core.interfaces.ISymbol px -> x
    org.matheclipse.core.interfaces.ISymbol py -> y
    org.matheclipse.core.interfaces.ISymbol pz -> z
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST AppellF1(org.matheclipse.core.interfaces.IExpr[]) -> a
    org.matheclipse.core.interfaces.IAST CosIntegral(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST EllipticE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST EllipticF(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST EllipticPi(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST FresnelC(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST FresnelS(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST HypergeometricPFQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST Hypergeometric2F1(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST SinIntegral(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST CoshIntegral(org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST SinhIntegral(org.matheclipse.core.interfaces.IExpr) -> f
    org.matheclipse.core.interfaces.IAST Erfi(org.matheclipse.core.interfaces.IExpr) -> g
    org.matheclipse.core.interfaces.IAST ExpIntegralEi(org.matheclipse.core.interfaces.IExpr) -> h
    org.matheclipse.core.interfaces.IAST LogIntegral(org.matheclipse.core.interfaces.IExpr) -> i
    org.matheclipse.core.interfaces.IAST PolyLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST Erfc(org.matheclipse.core.interfaces.IExpr) -> j
    org.matheclipse.core.interfaces.IAST LogGamma(org.matheclipse.core.interfaces.IExpr) -> k
    org.matheclipse.core.interfaces.IAST Zeta(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST PolyGamma(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e
    org.matheclipse.core.interfaces.IAST ExpIntegralE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> f
    void init() -> a
org.matheclipse.core.integrate.rubi45.UtilityFunctions0 -> vx:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.UtilityFunctions1 -> vy:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.UtilityFunctions2 -> vz:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.UtilityFunctions3 -> vA:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.UtilityFunctions4 -> vB:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.UtilityFunctions5 -> vC:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.integrate.rubi45.UtilityFunctions6 -> vD:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.interfaces.IAST -> org.matheclipse.core.interfaces.IAST:
    boolean addAll(java.util.List) -> addAll
    boolean addAll(java.util.List,int,int) -> addAll
    org.matheclipse.core.interfaces.IAST addAtClone(int,org.matheclipse.core.interfaces.IExpr) -> addAtClone
    void addEvalFlags(int) -> addEvalFlags
    org.matheclipse.core.interfaces.IAST addOneIdentity(org.matheclipse.core.interfaces.IAST) -> addOneIdentity
    org.matheclipse.core.interfaces.IAST appendClone(org.matheclipse.core.interfaces.IExpr) -> appendClone
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr) -> apply
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr,int) -> apply
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr,int,int) -> apply
    org.matheclipse.core.interfaces.IExpr arg1() -> arg1
    org.matheclipse.core.interfaces.IExpr arg2() -> arg2
    org.matheclipse.core.interfaces.IExpr arg3() -> arg3
    org.matheclipse.core.interfaces.IExpr arg4() -> arg4
    org.matheclipse.core.interfaces.IExpr arg5() -> arg5
    org.matheclipse.core.expression.ASTRange args() -> args
    org.matheclipse.core.interfaces.IAST clone() -> clone
    org.matheclipse.core.interfaces.IAST copyHead() -> copyHead
    org.matheclipse.core.interfaces.IAST copyUntil(int) -> copyUntil
    boolean equalsAt(int,org.matheclipse.core.interfaces.IExpr) -> equalsAt
    int findFirstEquals(org.matheclipse.core.interfaces.IExpr) -> findFirstEquals
    org.matheclipse.core.interfaces.IAST[] filter(com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate,int) -> filter
    org.matheclipse.core.interfaces.IAST[] filter(com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST getAST(int) -> getAST
    int getEvalFlags() -> getEvalFlags
    org.matheclipse.core.interfaces.IInteger getInt(int) -> getInt
    org.matheclipse.core.interfaces.IAST getList(int) -> getList
    org.matheclipse.core.interfaces.INumber getNumber(int) -> getNumber
    org.matheclipse.core.interfaces.IExpr getOneIdentity(org.matheclipse.core.interfaces.IExpr) -> getOneIdentity
    org.matheclipse.core.interfaces.IExpr getPart(int[]) -> getPart
    org.matheclipse.core.interfaces.IExpr getPart(java.util.List) -> getPart
    java.lang.Object getProperty(org.matheclipse.core.interfaces.IAST$PROPERTY) -> getProperty
    boolean isEvalFlagOff(int) -> isEvalFlagOff
    boolean isEvalFlagOn(int) -> isEvalFlagOn
    boolean isFreeAt(int,org.matheclipse.core.interfaces.IExpr) -> isFreeAt
    boolean isList() -> isList
    boolean isPlus() -> isPlus
    boolean isPower() -> isPower
    boolean isTimes() -> isTimes
    java.util.Iterator iterator() -> iterator
    java.util.Iterator iterator0() -> iterator0
    org.matheclipse.core.interfaces.IExpr last() -> last
    org.matheclipse.core.interfaces.IAST map(com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.interfaces.BiFunction) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST mapAt(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int) -> mapAt
    org.matheclipse.core.interfaces.IAST mapAt(org.matheclipse.core.interfaces.IAST,int) -> mapAt
    int patternHashCode() -> patternHashCode
    org.matheclipse.core.interfaces.IAST prependClone(org.matheclipse.core.interfaces.IExpr) -> prependClone
    java.lang.Object putProperty(org.matheclipse.core.interfaces.IAST$PROPERTY,java.lang.Object) -> putProperty
    org.matheclipse.core.expression.ASTRange range() -> range
    org.matheclipse.core.expression.ASTRange range(int) -> range
    org.matheclipse.core.expression.ASTRange range(int,int) -> range
    org.matheclipse.core.interfaces.IAST removeAtClone(int) -> removeAtClone
    org.matheclipse.core.interfaces.IAST setAtClone(int,org.matheclipse.core.interfaces.IExpr) -> setAtClone
    void setEvalFlags(int) -> setEvalFlags
    org.matheclipse.core.interfaces.ISymbol topHead() -> topHead
org.matheclipse.core.interfaces.IAST$PROPERTY -> vE:
    org.matheclipse.core.interfaces.IAST$PROPERTY CSS -> a
org.matheclipse.core.interfaces.IBigNumber -> org.matheclipse.core.interfaces.IBigNumber:
    org.matheclipse.core.interfaces.INumber numericNumber() -> numericNumber
org.matheclipse.core.interfaces.IComplex -> org.matheclipse.core.interfaces.IComplex:
    org.matheclipse.core.interfaces.IComplex conjugate() -> conjugate
    org.matheclipse.core.interfaces.IComplex add(org.matheclipse.core.interfaces.IComplex) -> add
    org.apache.commons.math3.fraction.BigFraction getImaginaryPart() -> getImaginaryPart
    org.apache.commons.math3.fraction.BigFraction getRealPart() -> getRealPart
    org.matheclipse.core.interfaces.IComplex multiply(org.matheclipse.core.interfaces.IComplex) -> multiply
    org.matheclipse.core.interfaces.IComplex pow(int) -> pow
    org.matheclipse.core.interfaces.INumber normalize() -> normalize
org.matheclipse.core.interfaces.IComplexNum -> org.matheclipse.core.interfaces.IComplexNum:
    double dabs() -> dabs
    double getRealPart() -> getRealPart
    double getImaginaryPart() -> getImaginaryPart
    org.matheclipse.core.interfaces.IComplexNum conjugate() -> conjugate
    org.matheclipse.core.interfaces.IComplexNum add(org.matheclipse.core.interfaces.IComplexNum) -> add
    org.matheclipse.core.interfaces.IComplexNum multiply(org.matheclipse.core.interfaces.IComplexNum) -> multiply
    org.matheclipse.core.interfaces.IComplexNum pow(org.matheclipse.core.interfaces.IComplexNum) -> pow
org.matheclipse.core.interfaces.IEvaluator -> vF:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.interfaces.IExpr -> org.matheclipse.core.interfaces.IExpr:
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr[]) -> apply
    org.matheclipse.core.interfaces.IExpr apply(java.util.List) -> apply
    java.lang.Object asType(java.lang.Class) -> asType
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.IExpr divide(org.matheclipse.core.interfaces.IExpr) -> divide
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    java.lang.String fullFormString() -> fullFormString
    org.matheclipse.core.interfaces.IExpr getAt(int) -> getAt
    org.matheclipse.core.interfaces.IExpr head() -> head
    int hierarchy() -> hierarchy
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    boolean isAnd() -> isAnd
    boolean isArcCos() -> isArcCos
    boolean isArcCosh() -> isArcCosh
    boolean isArcSin() -> isArcSin
    boolean isArcSinh() -> isArcSinh
    boolean isArcTan() -> isArcTan
    boolean isArcTanh() -> isArcTanh
    boolean isAST() -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,org.matheclipse.core.interfaces.IExpr[]) -> isAST
    boolean isAST(java.lang.String) -> isAST
    boolean isAST(java.lang.String,int) -> isAST
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> isASTSizeGE
    boolean isAtom() -> isAtom
    boolean isComplex() -> isComplex
    boolean isComplexInfinity() -> isComplexInfinity
    boolean isComplexNumeric() -> isComplexNumeric
    boolean isCondition() -> isCondition
    boolean isConstant() -> isConstant
    boolean isCos() -> isCos
    boolean isCosh() -> isCosh
    boolean isDirectedInfinity() -> isDirectedInfinity
    boolean isE() -> isE
    boolean isFalse() -> isFalse
    boolean isFlatAST() -> isFlatAST
    boolean isFraction() -> isFraction
    boolean isFree(org.matheclipse.core.interfaces.IExpr) -> isFree
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> isFree
    boolean isFree(com.google.common.base.Predicate,boolean) -> isFree
    boolean isFreeAST(org.matheclipse.core.interfaces.IExpr) -> isFreeAST
    boolean isFreeAST(com.google.common.base.Predicate) -> isFreeAST
    boolean isFunction() -> isFunction
    boolean isGEOrdered(org.matheclipse.core.interfaces.IExpr) -> isGEOrdered
    boolean isGTOrdered(org.matheclipse.core.interfaces.IExpr) -> isGTOrdered
    boolean isIndeterminate() -> isIndeterminate
    boolean isInfinity() -> isInfinity
    boolean isInteger() -> isInteger
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> isLEOrdered
    boolean isList() -> isList
    boolean isListOfLists() -> isListOfLists
    boolean isLog() -> isLog
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> isLTOrdered
    int[] isMatrix() -> isMatrix
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> isMember
    boolean isMember(com.google.common.base.Predicate,boolean) -> isMember
    boolean isMinusOne() -> isMinusOne
    boolean isModule() -> isModule
    boolean isNegative() -> isNegative
    boolean isNegativeInfinity() -> isNegativeInfinity
    boolean isNot() -> isNot
    boolean isNumber() -> isNumber
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumeric() -> isNumeric
    boolean isNumericFunction() -> isNumericFunction
    boolean isNumericMode() -> isNumericMode
    boolean isNumIntValue() -> isNumIntValue
    boolean isOne() -> isOne
    boolean isONE() -> isONE
    boolean isOr() -> isOr
    boolean isOrderlessAST() -> isOrderlessAST
    boolean isPattern() -> isPattern
    boolean isPatternDefault() -> isPatternDefault
    boolean isPatternExpr() -> isPatternExpr
    boolean isPatternSequence() -> isPatternSequence
    boolean isPi() -> isPi
    boolean isPlus() -> isPlus
    boolean isPolynomial(org.matheclipse.core.interfaces.ISymbol) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.IAST) -> isPolynomial
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.ISymbol,long) -> isPolynomialOfMaxDegree
    boolean isPositive() -> isPositive
    boolean isPower() -> isPower
    boolean isRational() -> isRational
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isRealFunction() -> isRealFunction
    boolean isRuleAST() -> isRuleAST
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> isSame
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    boolean isSequence() -> isSequence
    boolean isSignedNumber() -> isSignedNumber
    boolean isSin() -> isSin
    boolean isSinh() -> isSinh
    boolean isSlot() -> isSlot
    boolean isSlotSequence() -> isSlotSequence
    boolean isSymbol() -> isSymbol
    boolean isTan() -> isTan
    boolean isTanh() -> isTanh
    boolean isTimes() -> isTimes
    boolean isTrue() -> isTrue
    boolean isValue() -> isValue
    boolean isVariable() -> isVariable
    int isVector() -> isVector
    boolean isZero() -> isZero
    boolean isZERO() -> isZERO
    long leafCount() -> leafCount
    java.util.List leaves() -> leaves
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IExpr negative() -> negative
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr power(org.matheclipse.core.interfaces.IExpr) -> power
    org.matheclipse.core.interfaces.IExpr power(long) -> power
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> replacePart
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> replaceSlots
    int signum() -> signum
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.ISymbol topHead() -> topHead
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
org.matheclipse.core.interfaces.IFraction -> org.matheclipse.core.interfaces.IFraction:
    org.matheclipse.core.interfaces.IFraction abs() -> abs
    org.matheclipse.core.interfaces.IFraction add(org.matheclipse.core.interfaces.IFraction) -> add
    java.math.BigInteger[] divideAndRemainder() -> divideAndRemainder
    org.apache.commons.math3.fraction.BigFraction getRational() -> getRational
    java.math.BigInteger getBigDenominator() -> getBigDenominator
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.matheclipse.core.interfaces.IFraction multiply(org.matheclipse.core.interfaces.IFraction) -> multiply
    org.matheclipse.core.interfaces.IFraction pow(int) -> pow
    org.matheclipse.core.interfaces.INumber normalize() -> normalize
org.matheclipse.core.interfaces.IInteger -> org.matheclipse.core.interfaces.IInteger:
    org.matheclipse.core.interfaces.IInteger add(org.matheclipse.core.interfaces.IInteger) -> add
    boolean isEven() -> isEven
    boolean isOdd() -> isOdd
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.matheclipse.core.interfaces.IInteger multiply(org.matheclipse.core.interfaces.IInteger) -> multiply
    org.matheclipse.core.interfaces.IInteger subtract(org.matheclipse.core.interfaces.IInteger) -> subtract
    org.matheclipse.core.interfaces.IInteger pow(int) -> pow
    int intValue() -> intValue
    long longValue() -> longValue
    org.matheclipse.core.interfaces.IInteger gcd(org.matheclipse.core.interfaces.IInteger) -> gcd
    org.matheclipse.core.interfaces.IInteger lcm(org.matheclipse.core.interfaces.IInteger) -> lcm
    org.matheclipse.core.interfaces.IInteger nthRoot(int) -> nthRoot
    org.matheclipse.core.interfaces.IInteger[] nthRootSplit(int) -> nthRootSplit
org.matheclipse.core.interfaces.INum -> org.matheclipse.core.interfaces.INum:
    double getRealPart() -> getRealPart
    org.matheclipse.core.interfaces.INum add(org.matheclipse.core.interfaces.INum) -> add
    org.matheclipse.core.interfaces.INum multiply(org.matheclipse.core.interfaces.INum) -> multiply
    org.matheclipse.core.interfaces.INum pow(org.matheclipse.core.interfaces.INum) -> pow
    boolean isNumIntValue() -> isNumIntValue
    int intValue() -> intValue
    int toInt() -> toInt
org.matheclipse.core.interfaces.INumber -> org.matheclipse.core.interfaces.INumber:
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber floor() -> floor
org.matheclipse.core.interfaces.IPattern -> org.matheclipse.core.interfaces.IPattern:
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    boolean isConditionMatched(org.matheclipse.core.interfaces.IExpr) -> isConditionMatched
    boolean isBlank() -> isBlank
    boolean isPatternDefault() -> isPatternDefault
org.matheclipse.core.interfaces.IPatternObject -> vG:
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> b
    int getIndex(org.matheclipse.core.patternmatching.PatternMap) -> a
org.matheclipse.core.interfaces.IPatternSequence -> org.matheclipse.core.interfaces.IPatternSequence:
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    boolean isConditionMatchedSequence(org.matheclipse.core.interfaces.IAST) -> isConditionMatchedSequence
    boolean isBlank() -> isBlank
    boolean isDefault() -> isDefault
org.matheclipse.core.interfaces.IRational -> org.matheclipse.core.interfaces.IRational:
    org.matheclipse.core.interfaces.IRational abs() -> abs
    org.matheclipse.core.interfaces.IInteger getDenominator() -> getDenominator
    org.matheclipse.core.interfaces.IInteger getNumerator() -> getNumerator
    org.apache.commons.math3.fraction.BigFraction getFraction() -> getFraction
org.matheclipse.core.interfaces.ISignedNumber -> org.matheclipse.core.interfaces.ISignedNumber:
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    boolean isNegative() -> isNegative
    boolean isPositive() -> isPositive
    boolean isZero() -> isZero
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    int sign() -> sign
    int toInt() -> toInt
    long toLong() -> toLong
    org.matheclipse.core.interfaces.IInteger round() -> round
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    double doubleValue() -> doubleValue
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
org.matheclipse.core.interfaces.IStringX -> org.matheclipse.core.interfaces.IStringX:
org.matheclipse.core.interfaces.ISymbol -> org.matheclipse.core.interfaces.ISymbol:
    org.matheclipse.core.interfaces.IEvaluator getEvaluator() -> getEvaluator
    java.lang.String getSymbolName() -> getSymbolName
    void setEvaluator(org.matheclipse.core.interfaces.IEvaluator) -> setEvaluator
    boolean isString(java.lang.String) -> isString
    boolean isSymbolName(java.lang.String) -> isSymbolName
    org.matheclipse.core.interfaces.IExpr mapConstantDouble(org.matheclipse.core.generic.interfaces.INumericFunction) -> mapConstantDouble
    int getAttributes() -> getAttributes
    void setAttributes(int) -> setAttributes
    void pushLocalVariable() -> pushLocalVariable
    void pushLocalVariable(org.matheclipse.core.interfaces.IExpr) -> pushLocalVariable
    void popLocalVariable() -> popLocalVariable
    boolean hasAssignedSymbolValue() -> hasAssignedSymbolValue
    boolean hasLocalVariableStack() -> hasLocalVariableStack
    org.matheclipse.core.interfaces.IExpr get() -> get
    void set(org.matheclipse.core.interfaces.IExpr) -> set
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int,boolean) -> putDownRule
    org.matheclipse.core.patternmatching.PatternMatcher putDownRule(org.matheclipse.core.patternmatching.PatternMatcherAndInvoker) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> putUpRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> putUpRule
    org.matheclipse.core.interfaces.IExpr evalDownRule$6c3927ef(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction,org.matheclipse.core.interfaces.IExpr) -> evalDownRule$6c3927ef
    org.matheclipse.core.interfaces.IExpr evalUpRule$6c3927ef(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction,org.matheclipse.core.interfaces.IExpr) -> evalUpRule$6c3927ef
    org.matheclipse.core.interfaces.IExpr getDefaultValue() -> getDefaultValue
    org.matheclipse.core.interfaces.IExpr getDefaultValue(int) -> getDefaultValue
    void setDefaultValue(org.matheclipse.core.interfaces.IExpr) -> setDefaultValue
    void setDefaultValue(int,org.matheclipse.core.interfaces.IExpr) -> setDefaultValue
    org.matheclipse.core.interfaces.IExpr getAssignedValue() -> getAssignedValue
    org.matheclipse.core.interfaces.IExpr[] reassignSymbolValue(com.google.common.base.Function,org.matheclipse.core.interfaces.ISymbol) -> reassignSymbolValue
    void clear(org.matheclipse.core.eval.EvalEngine) -> clear
    void clearAll(org.matheclipse.core.eval.EvalEngine) -> clearAll
    java.util.List definition() -> definition
    java.lang.String definitionToString() -> definitionToString
    void readSymbol(java.io.ObjectInputStream) -> readSymbol
    void writeSymbol(java.io.ObjectOutputStream) -> writeSymbol
org.matheclipse.core.patternmatching.AbstractHashedPatternRules -> vH:
    int hash1 -> a
    int hash2 -> b
    int hashSum -> c
    org.matheclipse.core.patternmatching.DownRulesData fRulesData -> a
    org.matheclipse.core.interfaces.IExpr fLHSPattern1 -> a
    org.matheclipse.core.interfaces.IExpr fLHSPattern2 -> b
    int hashCode() -> hashCode
    int getHash1() -> a
    int getHash2() -> b
    boolean isPattern1() -> a
    boolean isPattern2() -> b
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.patternmatching.DownRulesData -> vI:
    java.util.Map fEqualDownRules -> a
    com.google.common.collect.TreeMultimap fSimplePatternDownRules -> a
    java.util.TreeSet fPatternDownRules -> a
    org.matheclipse.core.interfaces.IExpr evalDownRule$6c3927ef(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.patternmatching.PatternMatcher addSimplePatternDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher) -> a
    boolean isComplicatedPatternRule(org.matheclipse.core.interfaces.IExpr) -> a
    java.util.Map getEqualDownRules() -> a
    java.util.TreeSet getPatternDownRules() -> a
    com.google.common.collect.TreeMultimap getSimplePatternDownRules() -> a
    java.util.List definition() -> a
    java.lang.String toString() -> toString
org.matheclipse.core.patternmatching.FlatOrderlessStepVisitor -> vJ:
    int[] multiset -> a
    int[] getMultisetArray() -> a
org.matheclipse.core.patternmatching.FlatStepVisitor -> vK:
    org.matheclipse.core.interfaces.ISymbol fSymbol -> a
    org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher stackMatcher -> a
    org.matheclipse.core.patternmatching.PatternMap fPatternMap -> a
    org.matheclipse.core.interfaces.IExpr[] patternValues -> a
    org.matheclipse.core.interfaces.IAST fLhsPatternAST -> a
    boolean fOneIdentity -> a
    boolean visit(int[][]) -> a
    boolean matchSinglePartition(int[][],org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
org.matheclipse.core.patternmatching.HashedOrderlessMatcher -> vL:
    com.google.common.collect.ArrayListMultimap fHashRuleMap -> a
    com.google.common.collect.ArrayListMultimap fPatternHashRuleMap -> b
    void defineHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    void defineHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    void definePatternHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void definePatternHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST evaluateHashedValues(org.matheclipse.core.interfaces.IAST,com.google.common.collect.ArrayListMultimap,int[]) -> a
    boolean updateHashValues(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.AbstractHashedPatternRules,int[],int,int) -> a
org.matheclipse.core.patternmatching.HashedPatternFunction -> vM:
    org.matheclipse.core.generic.interfaces.BiFunction function$50401816 -> a
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.patternmatching.HashedPatternRules -> vN:
    org.matheclipse.core.interfaces.IExpr fCondition -> c
    org.matheclipse.core.interfaces.IExpr fRHS -> d
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.patternmatching.IPatternMatcher -> org.matheclipse.core.patternmatching.IPatternMatcher:
    org.matheclipse.core.interfaces.IExpr fLhsPatternExpr -> a
    org.matheclipse.core.interfaces.IExpr getLHS() -> a
    org.matheclipse.core.interfaces.IExpr getRHS() -> b
    int getPriority() -> a
    boolean isRuleWithoutPatterns() -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    java.lang.Object clone() -> clone
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.patternmatching.OrderlessStepVisitor -> vO:
    boolean matchSinglePartition(int[][],org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
org.matheclipse.core.patternmatching.PatternMap -> vP:
    int fPriority -> a
    int fPatternCounter -> b
    boolean fRuleWithoutPattern -> a
    org.matheclipse.core.interfaces.ISymbol[] fSymbolsArray -> a
    org.matheclipse.core.interfaces.IExpr[] fPatternValuesArray -> a
    void addPattern(java.util.Map,org.matheclipse.core.interfaces.IPatternObject) -> a
    org.matheclipse.core.patternmatching.PatternMap clone() -> a
    org.matheclipse.core.interfaces.IExpr[] copyPattern() -> a
    int determinePatterns(org.matheclipse.core.interfaces.IExpr) -> a
    int determinePatternsRecursive(java.util.Map,org.matheclipse.core.interfaces.IAST,int) -> a
    int get(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr getValue(org.matheclipse.core.interfaces.IPatternObject) -> a
    void initPattern() -> a
    void resetPattern(org.matheclipse.core.interfaces.IExpr[]) -> a
    void setValue(org.matheclipse.core.interfaces.IPatternObject,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr substitutePatternSymbols(org.matheclipse.core.interfaces.IExpr) -> a
    java.lang.Object clone() -> clone
org.matheclipse.core.patternmatching.PatternMatcher -> org.matheclipse.core.patternmatching.PatternMatcher:
    int fPriority -> a
    org.matheclipse.core.interfaces.IExpr fPatternCondition -> b
    org.matheclipse.core.patternmatching.PatternMap fPatternMap -> a
    boolean checkRHSCondition(org.matheclipse.core.eval.EvalEngine) -> a
    boolean checkCondition() -> b
    boolean equivalent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> a
    org.matheclipse.core.interfaces.IExpr getPatternValue0() -> c
    int getPriority() -> a
    boolean isRuleWithoutPatterns() -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    boolean matchExpr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    boolean matchExpr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    boolean matchFlatAndFlatOrderlessAST(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    boolean matchAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    boolean matchASTSequence(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    org.matheclipse.core.interfaces.IExpr evalAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    boolean matchPattern(org.matheclipse.core.interfaces.IPattern,org.matheclipse.core.interfaces.IExpr) -> a
    boolean matchPatternSequence(org.matheclipse.core.interfaces.IPatternSequence,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object clone() -> clone
    org.matheclipse.core.interfaces.IExpr getCondition() -> d
    void setCondition(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evalLeftHandSide(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.EvalEngine) -> a
    int equivalent(java.lang.Object) -> a
    boolean apply(java.lang.Object) -> apply
    int compareTo(java.lang.Object) -> compareTo
    boolean access$000(org.matheclipse.core.patternmatching.PatternMatcher,org.matheclipse.core.interfaces.IPattern,org.matheclipse.core.interfaces.IExpr) -> a
    boolean access$100(org.matheclipse.core.patternmatching.PatternMatcher,org.matheclipse.core.interfaces.IPatternSequence,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.patternmatching.PatternMatcher$Entry -> vQ:
    org.matheclipse.core.interfaces.IExpr fPatternExpr -> a
    org.matheclipse.core.interfaces.IExpr fEvalExpr -> b
org.matheclipse.core.patternmatching.PatternMatcher$OrderlessMatcher -> vR:
    org.matheclipse.core.interfaces.IAST fLHSPatternAST -> a
    org.matheclipse.core.interfaces.IAST fLHSEvalAST -> b
    int[] fUsedIndex -> a
    org.matheclipse.core.patternmatching.PatternMatcher this$0 -> a
    boolean matchOrderlessAST(int,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher -> vS:
    java.util.ArrayList fStack -> a
    org.matheclipse.core.patternmatching.PatternMatcher this$0 -> a
    void removeFrom(int) -> a
    boolean push(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    boolean matchRest() -> a
org.matheclipse.core.patternmatching.PatternMatcherAndEvaluator -> org.matheclipse.core.patternmatching.PatternMatcherAndEvaluator:
    org.matheclipse.core.interfaces.IExpr fRightHandSide -> b
    org.matheclipse.core.interfaces.ISymbol fSetSymbol -> a
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    boolean equivalentRHS(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> b
    int hashCode() -> hashCode
    boolean checkRHSCondition(org.matheclipse.core.eval.EvalEngine) -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getRHS() -> b
    int equivalent(java.lang.Object) -> a
org.matheclipse.core.patternmatching.PatternMatcherAndInvoker -> org.matheclipse.core.patternmatching.PatternMatcherAndInvoker:
    java.lang.reflect.Method fMethod -> a
    java.lang.reflect.Type[] fTypes -> a
    org.matheclipse.core.eval.interfaces.IFunctionEvaluator fInstance -> a
    java.lang.Object clone() -> clone
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.core.patternmatching.PatternMatcherEquals -> org.matheclipse.core.patternmatching.PatternMatcherEquals:
    org.matheclipse.core.interfaces.IExpr fRightHandSide -> b
    org.matheclipse.core.interfaces.ISymbol fSetSymbol -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> a
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getRHS() -> b
    org.matheclipse.core.interfaces.ISymbol getSetSymbol() -> a
    int hashCode() -> hashCode
    boolean isRuleWithoutPatterns() -> a
    void setRHS(org.matheclipse.core.interfaces.IExpr) -> a
    int getPriority() -> a
    boolean apply(java.lang.Object) -> apply
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.patternmatching.UpRulesData -> vT:
    java.util.Map fEqualUpRules -> a
    com.google.common.collect.TreeMultimap fSimplePatternUpRules -> a
    org.matheclipse.core.interfaces.IExpr evalUpRule$6c3927ef(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.patternmatching.PatternMatcher addSimplePatternUpRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher) -> a
    java.util.Map getEqualUpRules() -> a
    java.util.List definition() -> a
    void readSymbol(java.io.ObjectInputStream) -> a
    java.lang.String toString() -> toString
org.matheclipse.core.polynomials.ExponentArray -> vU:
    long sum -> a
    long[] fExponents -> a
    java.util.Comparator degreeLexicographic() -> a
    java.util.Comparator lexicographic() -> b
    org.matheclipse.core.polynomials.ExponentArray clone() -> a
    int compareTo(org.matheclipse.core.polynomials.ExponentArray) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object clone() -> clone
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.polynomials.ExponentArray$1 -> vV:
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExponentArray$2 -> vW:
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.HornerScheme -> vX:
    java.util.TreeMap map -> a
    org.matheclipse.core.interfaces.IAST generate(boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr getCoefficient(org.matheclipse.core.interfaces.ISignedNumber) -> a
    org.matheclipse.core.interfaces.IAST addToMap(org.matheclipse.core.interfaces.ISignedNumber,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.polynomials.HornerScheme$1 -> vY:
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.IPartialFractionGenerator -> vZ:
    void setJAS(org.matheclipse.core.convert.JASConvert) -> a
    org.matheclipse.core.interfaces.IAST getResult() -> a
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> a
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> a
org.matheclipse.core.polynomials.Monomial -> wa:
    org.matheclipse.core.polynomials.ExponentArray fExpArray -> a
    org.matheclipse.core.interfaces.IExpr fCoefficient -> a
    void appendToString(java.lang.StringBuilder,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.polynomials.Monomial clone() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void timesByMonomial(org.matheclipse.core.interfaces.IExpr) -> a
    void timesByMonomial(int) -> a
    void timesByMonomial(org.matheclipse.core.polynomials.Monomial) -> a
    java.lang.String toString() -> toString
    java.lang.Object clone() -> clone
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.polynomials.PartialFractionGenerator -> wb:
    org.matheclipse.core.interfaces.IAST result -> a
    org.matheclipse.core.convert.JASConvert jas -> a
    void setJAS(org.matheclipse.core.convert.JASConvert) -> a
    org.matheclipse.core.interfaces.IAST getResult() -> a
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> a
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> a
org.matheclipse.core.polynomials.PartialFractionIntegrateGenerator -> wc:
    org.matheclipse.core.interfaces.IAST result -> a
    org.matheclipse.core.convert.JASConvert jas -> a
    org.matheclipse.core.interfaces.ISymbol x -> a
    void setJAS(org.matheclipse.core.convert.JASConvert) -> a
    org.matheclipse.core.interfaces.IAST getResult() -> a
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> a
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> a
    boolean isQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigRational[]) -> a
org.matheclipse.core.polynomials.Polynomial -> wd:
    org.matheclipse.core.polynomials.Polynomial$polyType fPolynomialType -> a
    java.util.SortedMap fMonomials -> a
    org.matheclipse.core.interfaces.IAST fVariables -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    int fLength -> a
    boolean fIsPolynomial -> a
    void addMonomial(org.matheclipse.core.polynomials.Monomial) -> a
    void addMonomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExponentArray) -> a
    boolean createPolynomial(org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> a
    org.matheclipse.core.polynomials.Monomial createMonomial(org.matheclipse.core.interfaces.IAST,boolean,boolean) -> a
    org.matheclipse.core.polynomials.Monomial createPowerExponent(org.matheclipse.core.interfaces.IAST,boolean,boolean) -> b
    boolean isPowerExponent(org.matheclipse.core.interfaces.IAST) -> a
    boolean isMonomial(org.matheclipse.core.interfaces.IAST) -> b
    boolean isCoefficient(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    int isVariable(org.matheclipse.core.interfaces.IExpr) -> a
    long maximumDegree() -> a
    org.matheclipse.core.interfaces.IAST coefficientList() -> a
    org.matheclipse.core.polynomials.Polynomial derivative() -> a
    org.matheclipse.core.interfaces.IAST monomialList() -> b
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr getExpr() -> a
org.matheclipse.core.polynomials.Polynomial$polyType -> we:
    org.matheclipse.core.polynomials.Polynomial$polyType Undefined -> a
    org.matheclipse.core.polynomials.Polynomial$polyType Integer -> b
    org.matheclipse.core.polynomials.Polynomial$polyType Rational -> c
    org.matheclipse.core.polynomials.Polynomial$polyType Complex -> d
    org.matheclipse.core.polynomials.Polynomial$polyType Numeric -> e
    org.matheclipse.core.polynomials.Polynomial$polyType ComplexNumeric -> f
    org.matheclipse.core.polynomials.Polynomial$polyType Expr -> g
org.matheclipse.core.polynomials.PolynomialsUtils -> wf:
    java.util.List CHEBYSHEV_COEFFICIENTS -> a
    java.util.List HERMITE_COEFFICIENTS -> b
    java.util.List LAGUERRE_COEFFICIENTS -> c
    java.util.List LEGENDRE_COEFFICIENTS -> d
    org.matheclipse.core.interfaces.IAST createChebyshevPolynomial(int,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST createHermitePolynomial(int,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IAST createLaguerrePolynomial(int,org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IAST createLegendrePolynomial(int,org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST buildPolynomial(int,org.matheclipse.core.interfaces.IExpr,java.util.List,org.matheclipse.core.polynomials.PolynomialsUtils$RecurrenceCoefficientsGenerator) -> a
org.matheclipse.core.polynomials.PolynomialsUtils$1 -> wg:
    org.apache.commons.math3.fraction.BigFraction[] coeffs -> a
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> a
org.matheclipse.core.polynomials.PolynomialsUtils$2 -> wh:
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> a
org.matheclipse.core.polynomials.PolynomialsUtils$3 -> wi:
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> a
org.matheclipse.core.polynomials.PolynomialsUtils$4 -> wj:
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> a
org.matheclipse.core.polynomials.PolynomialsUtils$RecurrenceCoefficientsGenerator -> wk:
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> a
org.matheclipse.core.reflection.system.Abs -> org.matheclipse.core.reflection.system.Abs:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Abs$AbsNumericFunction -> wl:
    org.matheclipse.core.interfaces.ISymbol symbol -> a
    java.lang.Object apply(double) -> a
org.matheclipse.core.reflection.system.Abs$AbsTimesFunction -> wm:
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.AddTo -> org.matheclipse.core.reflection.system.AddTo:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.AddTo$AddToFunction -> wn:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Apart -> org.matheclipse.core.reflection.system.Apart:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST partialFractionDecompositionRational(org.matheclipse.core.polynomials.IPartialFractionGenerator,org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr[] getFractionalPartsRational(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr[] getFractionalParts(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr[] getFractionalPartsTimes(org.matheclipse.core.interfaces.IAST,boolean) -> a
    org.matheclipse.core.interfaces.IExpr getFractionalPartsPower(org.matheclipse.core.interfaces.IAST) -> c
org.matheclipse.core.reflection.system.ArcCos -> org.matheclipse.core.reflection.system.ArcCos:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCosh -> org.matheclipse.core.reflection.system.ArcCosh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCot -> org.matheclipse.core.reflection.system.ArcCot:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCoth -> org.matheclipse.core.reflection.system.ArcCoth:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCsc -> org.matheclipse.core.reflection.system.ArcCsc:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcCsch -> org.matheclipse.core.reflection.system.ArcCsch:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcSec -> org.matheclipse.core.reflection.system.ArcSec:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcSech -> org.matheclipse.core.reflection.system.ArcSech:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcSin -> org.matheclipse.core.reflection.system.ArcSin:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcSinh -> org.matheclipse.core.reflection.system.ArcSinh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcTan -> org.matheclipse.core.reflection.system.ArcTan:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArcTanh -> org.matheclipse.core.reflection.system.ArcTanh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Arg -> org.matheclipse.core.reflection.system.Arg:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArrayDepth -> org.matheclipse.core.reflection.system.ArrayDepth:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ArrayQ -> org.matheclipse.core.reflection.system.ArrayQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    int determineDepth(org.matheclipse.core.interfaces.IExpr,int,com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.BernoulliB -> org.matheclipse.core.reflection.system.BernoulliB:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.apache.commons.math3.fraction.BigFraction bernoulliNumber(java.math.BigInteger) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Binomial -> org.matheclipse.core.reflection.system.Binomial:
    java.math.BigInteger binomial(java.math.BigInteger,java.math.BigInteger) -> a
    java.math.BigInteger binomial(int,int) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.Boole -> org.matheclipse.core.reflection.system.Boole:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.BooleanConvert -> org.matheclipse.core.reflection.system.BooleanConvert:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.BooleanConvert$BooleanConvertVisitor -> wo:
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST convertNand(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST convertNor(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IAST convertXor(org.matheclipse.core.interfaces.IAST) -> c
org.matheclipse.core.reflection.system.BooleanMinimize -> org.matheclipse.core.reflection.system.BooleanMinimize:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Cancel -> org.matheclipse.core.reflection.system.Cancel:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr cancelPowerTimes(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr[] cancelGCD(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Cancel$PolynomialPredicate -> wp:
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.CartesianProduct -> org.matheclipse.core.reflection.system.CartesianProduct:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.CartesianProduct$CartesianProductIterator -> wq:
    java.util.List comps -> a
    java.util.List compit -> b
    org.matheclipse.core.interfaces.IAST current -> a
    boolean empty -> a
    boolean hasNext() -> hasNext
    org.matheclipse.core.interfaces.IAST next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.CartesianProduct$CartesianProductList -> wr:
    java.util.List comps -> a
    org.matheclipse.core.interfaces.IAST fEmptyResultList -> a
    org.matheclipse.core.reflection.system.CartesianProduct this$0 -> a
    java.util.Iterator iterator() -> iterator
org.matheclipse.core.reflection.system.CatalanNumber -> org.matheclipse.core.reflection.system.CatalanNumber:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Ceiling -> org.matheclipse.core.reflection.system.Ceiling:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Ceiling$CeilingPlusFunction -> ws:
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.CharacteristicPolynomial -> org.matheclipse.core.reflection.system.CharacteristicPolynomial:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.ChebyshevT -> org.matheclipse.core.reflection.system.ChebyshevT:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.ChessboardDistance -> org.matheclipse.core.reflection.system.ChessboardDistance:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Coefficient -> org.matheclipse.core.reflection.system.Coefficient:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.CoefficientList -> org.matheclipse.core.reflection.system.CoefficientList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    double[] coefficientList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Collect -> org.matheclipse.core.reflection.system.Collect:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr collectSingleVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
    void collectToMap(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.IPatternMatcher,java.util.Map,org.matheclipse.core.interfaces.IAST) -> a
    void addOneIdentityPowerFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,java.util.Map) -> a
    void addPowerFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,java.util.Map) -> a
    boolean isPowerMatched(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.IPatternMatcher) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Complement -> org.matheclipse.core.reflection.system.Complement:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.ComplexExpand -> org.matheclipse.core.reflection.system.ComplexExpand:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr complexExpand(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr complexExpandNull(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr access$000(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr access$100(org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.ComplexExpand$ComplexExpandVisitor -> wt:
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.ComposeList -> org.matheclipse.core.reflection.system.ComposeList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateComposeList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Conjugate -> org.matheclipse.core.reflection.system.Conjugate:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.ConjugateTranspose -> org.matheclipse.core.reflection.system.ConjugateTranspose:
    org.matheclipse.core.interfaces.IExpr transform(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.ConstantArray -> org.matheclipse.core.reflection.system.ConstantArray:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArray(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ConstantArray$ArrayIterator -> wu:
    int fCurrent -> a
    int fFrom -> b
    int fTo -> c
    boolean setUp() -> a
    void tearDown() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.ContinuedFraction -> org.matheclipse.core.reflection.system.ContinuedFraction:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.CoprimeQ -> org.matheclipse.core.reflection.system.CoprimeQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Cos -> org.matheclipse.core.reflection.system.Cos:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Cosh -> org.matheclipse.core.reflection.system.Cosh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Cot -> org.matheclipse.core.reflection.system.Cot:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Coth -> org.matheclipse.core.reflection.system.Coth:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Count -> org.matheclipse.core.reflection.system.Count:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Count$CountFunctor -> wv:
    org.matheclipse.core.patternmatching.IPatternMatcher matcher -> a
    int counter -> a
    int getCounter() -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Cross -> org.matheclipse.core.reflection.system.Cross:
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.Csc -> org.matheclipse.core.reflection.system.Csc:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Csch -> org.matheclipse.core.reflection.system.Csch:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Curl -> org.matheclipse.core.reflection.system.Curl:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.D -> org.matheclipse.core.reflection.system.D:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Decrement -> org.matheclipse.core.reflection.system.Decrement:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    com.google.common.base.Function getFunction() -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
    org.matheclipse.core.interfaces.IExpr getResult(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Decrement$DecrementFunction -> ww:
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Default -> org.matheclipse.core.reflection.system.Default:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.DeleteDuplicates -> org.matheclipse.core.reflection.system.DeleteDuplicates:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Denominator -> org.matheclipse.core.reflection.system.Denominator:
    org.matheclipse.core.interfaces.ISymbol[] NUMERATOR_SYMBOLS -> a
    org.matheclipse.core.interfaces.ISymbol[] DENOMINATOR_SYMBOLS -> b
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IAST getDenominatorForm(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Derivative -> org.matheclipse.core.reflection.system.Derivative:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Det -> org.matheclipse.core.reflection.system.Det:
    org.matheclipse.core.expression.ExprFieldElement matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.reflection.system.DiagonalMatrix -> org.matheclipse.core.reflection.system.DiagonalMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.DigitQ -> org.matheclipse.core.reflection.system.DigitQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Dimensions -> org.matheclipse.core.reflection.system.Dimensions:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.util.ArrayList getDimensions(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> a
    java.util.ArrayList getDimensions(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int,java.util.ArrayList) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Discriminant -> org.matheclipse.core.reflection.system.Discriminant:
    org.matheclipse.core.interfaces.IExpr QUADRATIC -> a
    org.matheclipse.core.interfaces.IExpr CUBIC -> b
    org.matheclipse.core.interfaces.IExpr QUARTIC -> c
    org.matheclipse.core.interfaces.IExpr QUINTIC -> d
    org.matheclipse.core.interfaces.ISymbol[] vars -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Distribute -> org.matheclipse.core.reflection.system.Distribute:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void distributePosition(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.reflection.system.Divergence -> org.matheclipse.core.reflection.system.Divergence:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.DivideBy -> org.matheclipse.core.reflection.system.DivideBy:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
org.matheclipse.core.reflection.system.DivideBy$DivideByFunction -> wx:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Divisible -> org.matheclipse.core.reflection.system.Divisible:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr isSignedNumberDivisible(org.matheclipse.core.interfaces.ISignedNumber) -> a
org.matheclipse.core.reflection.system.Divisors -> org.matheclipse.core.reflection.system.Divisors:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Dot -> org.matheclipse.core.reflection.system.Dot:
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Eigenvalues -> org.matheclipse.core.reflection.system.Eigenvalues:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
    org.matheclipse.core.expression.ExprFieldElement matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.reflection.system.Eigenvectors -> org.matheclipse.core.reflection.system.Eigenvectors:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
    org.matheclipse.core.expression.ExprFieldElement matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.reflection.system.Eliminate -> org.matheclipse.core.reflection.system.Eliminate:
    org.matheclipse.core.interfaces.IExpr extractVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IAST eliminateOneVariable(java.util.ArrayList,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Eliminate$VariableCounterVisitor -> wy:
    int fVariableCounter -> a
    int fNodeCounter -> b
    int fMaxVariableDepth -> c
    int fCurrentDepth -> d
    org.matheclipse.core.interfaces.IExpr fVariable -> a
    org.matheclipse.core.interfaces.IAST fExpr -> a
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> a
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> a
    boolean visit(org.matheclipse.core.interfaces.INum) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    boolean visit(org.matheclipse.core.interfaces.IPattern) -> a
    boolean visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    boolean visit(org.matheclipse.core.interfaces.IStringX) -> a
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.Equal -> org.matheclipse.core.reflection.system.Equal:
    org.matheclipse.core.interfaces.IExpr createComparatorResult(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Equivalent -> org.matheclipse.core.reflection.system.Equivalent:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Erf -> org.matheclipse.core.reflection.system.Erf:
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.EuclidianDistance -> org.matheclipse.core.reflection.system.EuclidianDistance:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.EulerE -> org.matheclipse.core.reflection.system.EulerE:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void set(java.util.ArrayList,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.EulerPhi -> org.matheclipse.core.reflection.system.EulerPhi:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Exp -> org.matheclipse.core.reflection.system.Exp:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.Expand -> org.matheclipse.core.reflection.system.Expand:
    org.matheclipse.core.interfaces.IExpr expand(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Expand$Expander -> wz:
    boolean expandNegativePowers -> a
    boolean distributePlus -> b
    org.matheclipse.core.interfaces.IExpr pattern -> a
    org.matheclipse.core.interfaces.IExpr expandAST(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr expandPowerNull(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr expandPower(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr expandTimes(org.matheclipse.core.interfaces.IAST) -> c
    org.matheclipse.core.interfaces.IExpr expandExprTimesPlus(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
    void evalAndExpandAST(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Expand$NumberPartititon -> wA:
    org.matheclipse.core.interfaces.IAST expandedResult -> a
    int m -> b
    int n -> a
    int[] parts -> a
    org.matheclipse.core.interfaces.IAST precalculatedPowerASTs -> b
    void partition(int,int,int) -> a
org.matheclipse.core.reflection.system.ExpandAll -> org.matheclipse.core.reflection.system.ExpandAll:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr expandAll(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> a
org.matheclipse.core.reflection.system.Exponent -> org.matheclipse.core.reflection.system.Exponent:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void timesExponent(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.IPatternMatcher,java.util.Set) -> a
org.matheclipse.core.reflection.system.ExtendedGCD -> org.matheclipse.core.reflection.system.ExtendedGCD:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object[] extendedGCD(java.math.BigInteger,java.math.BigInteger) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Extract -> org.matheclipse.core.reflection.system.Extract:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr extract(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Factor -> org.matheclipse.core.reflection.system.Factor:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr factor(org.matheclipse.core.interfaces.IExpr,java.util.List,boolean) -> a
    org.matheclipse.core.interfaces.IExpr factorWithOption(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,java.util.List,boolean) -> a
    org.matheclipse.core.interfaces.IAST factorComplex(org.matheclipse.core.interfaces.IExpr,java.util.List,org.matheclipse.core.interfaces.ISymbol,boolean,boolean) -> a
    org.matheclipse.core.interfaces.IAST factorModulus(org.matheclipse.core.interfaces.IExpr,java.util.List,boolean,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST factorModulus(org.matheclipse.core.convert.JASModInteger,edu.jas.arith.ModLongRing,edu.jas.poly.GenPolynomial,boolean) -> a
org.matheclipse.core.reflection.system.FactorInteger -> org.matheclipse.core.reflection.system.FactorInteger:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FactorSquareFree -> org.matheclipse.core.reflection.system.FactorSquareFree:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.FactorSquareFreeList -> org.matheclipse.core.reflection.system.FactorSquareFreeList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.FactorTerms -> org.matheclipse.core.reflection.system.FactorTerms:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Factorial -> org.matheclipse.core.reflection.system.Factorial:
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    java.math.BigInteger factorial(java.math.BigInteger) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Factorial2 -> org.matheclipse.core.reflection.system.Factorial2:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Fibonacci -> org.matheclipse.core.reflection.system.Fibonacci:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FindRoot -> org.matheclipse.core.reflection.system.FindRoot:
    org.matheclipse.core.interfaces.ISymbol Newton -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Fit -> org.matheclipse.core.reflection.system.Fit:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Floor -> org.matheclipse.core.reflection.system.Floor:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Floor$FloorPlusFunction -> wB:
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.FractionalPart -> org.matheclipse.core.reflection.system.FractionalPart:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FrobeniusSolve -> org.matheclipse.core.reflection.system.FrobeniusSolve:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FromCharacterCode -> org.matheclipse.core.reflection.system.FromCharacterCode:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FromContinuedFraction -> org.matheclipse.core.reflection.system.FromContinuedFraction:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.FullSimplify -> org.matheclipse.core.reflection.system.FullSimplify:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.GCD -> org.matheclipse.core.reflection.system.GCD:
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Gamma -> org.matheclipse.core.reflection.system.Gamma:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.GeometricMean -> org.matheclipse.core.reflection.system.GeometricMean:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Greater -> org.matheclipse.core.reflection.system.Greater:
    org.matheclipse.core.reflection.system.Greater CONST -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr createComparatorResult(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    int prepareCompare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.GreaterEqual -> org.matheclipse.core.reflection.system.GreaterEqual:
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.GroebnerBasis -> org.matheclipse.core.reflection.system.GroebnerBasis:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.HarmonicNumber -> org.matheclipse.core.reflection.system.HarmonicNumber:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.HermiteH -> org.matheclipse.core.reflection.system.HermiteH:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.HilbertMatrix -> org.matheclipse.core.reflection.system.HilbertMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.HilbertMatrix$HilbertFunctionDiagonal -> wC:
    java.lang.Object evaluate(int[]) -> a
org.matheclipse.core.reflection.system.Horner -> org.matheclipse.core.reflection.system.Horner:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.HornerForm -> org.matheclipse.core.reflection.system.HornerForm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.IdentityMatrix -> org.matheclipse.core.reflection.system.IdentityMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST diagonalMatrix(org.matheclipse.core.interfaces.IExpr[],int) -> a
org.matheclipse.core.reflection.system.Im -> org.matheclipse.core.reflection.system.Im:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr imPowerComplex(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Increment -> org.matheclipse.core.reflection.system.Increment:
    com.google.common.base.Function getFunction() -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
org.matheclipse.core.reflection.system.Increment$IncrementFunction -> wD:
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Inner -> org.matheclipse.core.reflection.system.Inner:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Inner$InnerAlgorithm -> wE:
    org.matheclipse.core.interfaces.IExpr f -> a
    org.matheclipse.core.interfaces.IExpr g -> b
    org.matheclipse.core.interfaces.IExpr head -> c
    org.matheclipse.core.interfaces.IAST list1 -> a
    org.matheclipse.core.interfaces.IAST list2 -> b
    int list2Dim0 -> a
    org.matheclipse.core.interfaces.IAST recursion(java.util.ArrayList,java.util.ArrayList,java.util.List,java.util.List) -> a
org.matheclipse.core.reflection.system.IntegerPart -> org.matheclipse.core.reflection.system.IntegerPart:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.IntegerPartitions -> org.matheclipse.core.reflection.system.IntegerPartitions:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.IntegerPartitions$NumberPartitionsIterable -> wF:
    int n -> a
    int len -> b
    int[] fPartititionsIndex -> a
    int i -> c
    int k -> d
    int[] fCopiedResultIndex -> b
    int[] fResultIndex -> c
    int[] nextBeforehand() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.Integrate -> org.matheclipse.core.reflection.system.Integrate:
    java.util.Set INT_FUNCTIONS -> a
    java.util.Set DEBUG_EXPR -> b
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr integrateByRubiRules(org.matheclipse.core.interfaces.IAST) -> c
    org.matheclipse.core.interfaces.IExpr integrateByParts(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    void collectPolynomialTerms(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IAST getUtilityFunctionsRuleAST() -> b
org.matheclipse.core.reflection.system.Integrate$1 -> wG:
    org.matheclipse.core.interfaces.ISymbol val$x -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.InterpolatingFunction -> org.matheclipse.core.reflection.system.InterpolatingFunction:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.InterpolatingPolynomial -> org.matheclipse.core.reflection.system.InterpolatingPolynomial:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Intersection -> org.matheclipse.core.reflection.system.Intersection:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Inverse -> org.matheclipse.core.reflection.system.Inverse:
    org.apache.commons.math3.linear.FieldMatrix matrixEval(org.apache.commons.math3.linear.FieldMatrix) -> a
    org.apache.commons.math3.linear.RealMatrix realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> a
org.matheclipse.core.reflection.system.InverseErf -> org.matheclipse.core.reflection.system.InverseErf:
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.InverseFunction -> org.matheclipse.core.reflection.system.InverseFunction:
    java.util.Map UNARY_INVERSE_FUNCTIONS -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST getUnaryInverseFunction(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.JacobiMatrix -> org.matheclipse.core.reflection.system.JacobiMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.JacobiSymbol -> org.matheclipse.core.reflection.system.JacobiSymbol:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Join -> org.matheclipse.core.reflection.system.Join:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.KOrderlessPartitions -> org.matheclipse.core.reflection.system.KOrderlessPartitions:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.KPartitions -> org.matheclipse.core.reflection.system.KPartitions:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.KPartitions$KPartitionsIterable -> wH:
    int fLength -> b
    int fNumberOfParts -> a
    int[] fPartitionsIndex -> a
    int[] fCopiedResultIndex -> c
    int[] fResultIndex -> b
    int[] nextBeforehand() -> a
    int[] next() -> b
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.KPartitions$KPartitionsList -> wI:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    org.matheclipse.core.reflection.system.KPartitions$KPartitionsIterable fIterable -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.LCM -> org.matheclipse.core.reflection.system.LCM:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.LUDecomposition -> org.matheclipse.core.reflection.system.LUDecomposition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.LaguerreL -> org.matheclipse.core.reflection.system.LaguerreL:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.LegendreP -> org.matheclipse.core.reflection.system.LegendreP:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Less -> org.matheclipse.core.reflection.system.Less:
    org.matheclipse.core.reflection.system.Less CONST -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.LessEqual -> org.matheclipse.core.reflection.system.LessEqual:
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    int compare$151896ea(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.LetterQ -> org.matheclipse.core.reflection.system.LetterQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Level -> org.matheclipse.core.reflection.system.Level:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Limit -> org.matheclipse.core.reflection.system.Limit:
    org.matheclipse.core.interfaces.IExpr lHospitalesRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr evalLimit(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int,boolean) -> a
    org.matheclipse.core.interfaces.IExpr mapLimit(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numeratorDenominatorLimit(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> b
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
org.matheclipse.core.reflection.system.LinearProgramming -> org.matheclipse.core.reflection.system.LinearProgramming:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.LinearSolve -> org.matheclipse.core.reflection.system.LinearSolve:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Log -> org.matheclipse.core.reflection.system.Log:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr baseBLog(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> b
    org.matheclipse.core.generic.interfaces.BiFunction getFunction$5f4b86eb() -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.Log$1 -> wJ:
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.reflection.system.Log10 -> org.matheclipse.core.reflection.system.Log10:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.Log2 -> org.matheclipse.core.reflection.system.Log2:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.LogicalExpand -> org.matheclipse.core.reflection.system.LogicalExpand:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.LowerCaseQ -> org.matheclipse.core.reflection.system.LowerCaseQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.ManhattanDistance -> org.matheclipse.core.reflection.system.ManhattanDistance:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Map -> org.matheclipse.core.reflection.system.Map:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.MapAll -> org.matheclipse.core.reflection.system.MapAll:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.MapThread -> org.matheclipse.core.reflection.system.MapThread:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.MapThread$UnaryMapThread -> wK:
    org.matheclipse.core.interfaces.IExpr fConstant -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.MatchQ -> org.matheclipse.core.reflection.system.MatchQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.MatrixPower -> org.matheclipse.core.reflection.system.MatrixPower:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.MatrixQ -> org.matheclipse.core.reflection.system.MatrixQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.MatrixRank -> org.matheclipse.core.reflection.system.MatrixRank:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Max -> org.matheclipse.core.reflection.system.Max:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Mean -> org.matheclipse.core.reflection.system.Mean:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Median -> org.matheclipse.core.reflection.system.Median:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Min -> org.matheclipse.core.reflection.system.Min:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Mod -> org.matheclipse.core.reflection.system.Mod:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.MoebiusMu -> org.matheclipse.core.reflection.system.MoebiusMu:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.MonomialList -> org.matheclipse.core.reflection.system.MonomialList:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST monomialListModulus$3f73e28d(org.matheclipse.core.interfaces.IExpr,java.util.List,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.Most -> org.matheclipse.core.reflection.system.Most:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Multinomial -> org.matheclipse.core.reflection.system.Multinomial:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.math.BigInteger multinomial(int[],int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NFourierTransform -> org.matheclipse.core.reflection.system.NFourierTransform:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NIntegrate -> org.matheclipse.core.reflection.system.NIntegrate:
    org.matheclipse.core.interfaces.ISymbol LegendreGauss -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NRoots -> org.matheclipse.core.reflection.system.NRoots:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.NSolve -> org.matheclipse.core.reflection.system.NSolve:
    org.matheclipse.core.interfaces.IAST analyzeSublist(java.util.ArrayList,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.NSolve$ExprAnalyzer -> wL:
    int equationType -> a
    org.matheclipse.core.interfaces.IExpr expr -> a
    org.matheclipse.core.interfaces.IExpr numer -> b
    org.matheclipse.core.interfaces.IExpr denom -> c
    int leafCount -> b
    org.matheclipse.core.interfaces.IAST row -> a
    java.util.HashSet symbolSet -> a
    org.matheclipse.core.interfaces.IAST value -> b
    org.matheclipse.core.interfaces.IAST vars -> c
    void analyze() -> a
    void getPlusEquationType(org.matheclipse.core.interfaces.IExpr) -> a
    void getTimesEquationType(org.matheclipse.core.interfaces.IExpr) -> b
    void reset() -> b
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.NSolve$NoSolution -> wM:
    int solType -> a
org.matheclipse.core.reflection.system.Negative -> org.matheclipse.core.reflection.system.Negative:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NextPrime -> org.matheclipse.core.reflection.system.NextPrime:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.NonCommutativeMultiply -> org.matheclipse.core.reflection.system.NonCommutativeMultiply:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.NonNegative -> org.matheclipse.core.reflection.system.NonNegative:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Norm -> org.matheclipse.core.reflection.system.Norm:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Not -> org.matheclipse.core.reflection.system.Not:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.NullSpace -> org.matheclipse.core.reflection.system.NullSpace:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Numerator -> org.matheclipse.core.reflection.system.Numerator:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Order -> org.matheclipse.core.reflection.system.Order:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.OrderedQ -> org.matheclipse.core.reflection.system.OrderedQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean apply(org.matheclipse.core.interfaces.IAST) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Out -> org.matheclipse.core.reflection.system.Out:
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1IntArg(org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.Outer -> org.matheclipse.core.reflection.system.Outer:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Outer$OuterAlgorithm -> wN:
    org.matheclipse.core.interfaces.IAST ast -> a
    org.matheclipse.core.interfaces.IExpr f -> a
    org.matheclipse.core.interfaces.IExpr head -> b
    org.matheclipse.core.interfaces.IAST outer(int,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.PadLeft -> org.matheclipse.core.reflection.system.PadLeft:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr padLeftAtom(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.PadRight -> org.matheclipse.core.reflection.system.PadRight:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr padRightAtom(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.Part -> org.matheclipse.core.reflection.system.Part:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr getPart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr getIndex(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Partition -> org.matheclipse.core.reflection.system.Partition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Permutations -> org.matheclipse.core.reflection.system.Permutations:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Permutations$KPermutationsIterable -> wO:
    int n -> a
    int k -> b
    int[] fPermutationsIndex -> a
    int[] y -> b
    boolean first -> a
    int h -> c
    int i -> d
    int m -> e
    int[] fCopiedResultIndex -> c
    int[] fResultIndex -> d
    int[] nextBeforehand() -> b
    int[] next() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.Permutations$KPermutationsList -> wP:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    org.matheclipse.core.reflection.system.Permutations$KPermutationsIterable fIterable -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.Piecewise -> org.matheclipse.core.reflection.system.Piecewise:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Plus -> org.matheclipse.core.reflection.system.Plus:
    org.matheclipse.core.reflection.system.Plus CONST -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> a
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Pochhammer -> org.matheclipse.core.reflection.system.Pochhammer:
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PolynomialExtendedGCD -> org.matheclipse.core.reflection.system.PolynomialExtendedGCD:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PolynomialGCD -> org.matheclipse.core.reflection.system.PolynomialGCD:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr modulusGCD(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.convert.VariablesSet,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PolynomialLCM -> org.matheclipse.core.reflection.system.PolynomialLCM:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PolynomialQ -> org.matheclipse.core.reflection.system.PolynomialQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    edu.jas.poly.GenPolynomial polynomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,boolean) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object,java.lang.Object) -> a
org.matheclipse.core.reflection.system.PolynomialQuotient -> org.matheclipse.core.reflection.system.PolynomialQuotient:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.PolynomialQuotientRemainder -> org.matheclipse.core.reflection.system.PolynomialQuotientRemainder:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr[] quotientRemainder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr[] quotientRemainderModInteger(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.PolynomialRemainder -> org.matheclipse.core.reflection.system.PolynomialRemainder:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Positive -> org.matheclipse.core.reflection.system.Positive:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PossibleZeroQ -> org.matheclipse.core.reflection.system.PossibleZeroQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean possibleZeroQ(org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Power -> org.matheclipse.core.reflection.system.Power:
    org.matheclipse.core.reflection.system.Power CONST -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e2ApcomplexArg(org.matheclipse.core.expression.ApcomplexNum,org.matheclipse.core.expression.ApcomplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr e2ApfloatArg(org.matheclipse.core.expression.ApfloatNum,org.matheclipse.core.expression.ApfloatNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IInteger[] calculateRoot(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr eComFraArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IFraction) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.PowerExpand -> org.matheclipse.core.reflection.system.PowerExpand:
    java.lang.String[] REPLACE_STRINGS -> a
    com.google.common.base.Function REPLACE_RULES -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PowerMod -> org.matheclipse.core.reflection.system.PowerMod:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PreDecrement -> org.matheclipse.core.reflection.system.PreDecrement:
    org.matheclipse.core.interfaces.IExpr getResult(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
org.matheclipse.core.reflection.system.PreIncrement -> org.matheclipse.core.reflection.system.PreIncrement:
    com.google.common.base.Function getFunction() -> a
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> a
org.matheclipse.core.reflection.system.PreIncrement$IncrementFunction -> wQ:
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Prime -> org.matheclipse.core.reflection.system.Prime:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.PrimeQ -> org.matheclipse.core.reflection.system.PrimeQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.PrimitiveRoots -> org.matheclipse.core.reflection.system.PrimitiveRoots:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Product -> org.matheclipse.core.reflection.system.Product:
    org.matheclipse.core.interfaces.IAST RULES -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ProductLog -> org.matheclipse.core.reflection.system.ProductLog:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Quotient -> org.matheclipse.core.reflection.system.Quotient:
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
org.matheclipse.core.reflection.system.RandomInteger -> org.matheclipse.core.reflection.system.RandomInteger:
    java.util.Random RANDOM -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.RandomReal -> org.matheclipse.core.reflection.system.RandomReal:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.RandomSample -> org.matheclipse.core.reflection.system.RandomSample:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Range -> org.matheclipse.core.reflection.system.Range:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateTable(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Rationalize -> org.matheclipse.core.reflection.system.Rationalize:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Re -> org.matheclipse.core.reflection.system.Re:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr rePowerComplex(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ReplaceAll -> org.matheclipse.core.reflection.system.ReplaceAll:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ReplacePart -> org.matheclipse.core.reflection.system.ReplacePart:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ReplaceRepeated -> org.matheclipse.core.reflection.system.ReplaceRepeated:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Resultant -> org.matheclipse.core.reflection.system.Resultant:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr resultant(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Reverse -> org.matheclipse.core.reflection.system.Reverse:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.RootIntervals -> org.matheclipse.core.reflection.system.RootIntervals:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST croots(org.matheclipse.core.interfaces.IExpr,boolean) -> a
org.matheclipse.core.reflection.system.Roots -> org.matheclipse.core.reflection.system.Roots:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST findRoots(double[]) -> a
    org.matheclipse.core.interfaces.IAST rootsOfVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,boolean) -> a
org.matheclipse.core.reflection.system.Round -> org.matheclipse.core.reflection.system.Round:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Round$RoundPlusFunction -> wR:
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.RowReduce -> org.matheclipse.core.reflection.system.RowReduce:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.SameQ -> org.matheclipse.core.reflection.system.SameQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Scan -> org.matheclipse.core.reflection.system.Scan:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Sec -> org.matheclipse.core.reflection.system.Sec:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Sech -> org.matheclipse.core.reflection.system.Sech:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Select -> org.matheclipse.core.reflection.system.Select:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Sign -> org.matheclipse.core.reflection.system.Sign:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SignCmp -> org.matheclipse.core.reflection.system.SignCmp:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Simplify -> org.matheclipse.core.reflection.system.Simplify:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Simplify$IsBasicExpressionVisitor -> org.matheclipse.core.reflection.system.Simplify$IsBasicExpressionVisitor:
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> a
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> a
    boolean visit(org.matheclipse.core.interfaces.INum) -> a
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Simplify$SimplifyVisitor -> wS:
    org.matheclipse.core.reflection.system.Simplify$IsBasicExpressionVisitor isBasicAST -> a
    org.matheclipse.core.interfaces.IExpr tryExpandAllTransformation(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr tryTransformations(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr tryExpandAll(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Sin -> org.matheclipse.core.reflection.system.Sin:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Sinc -> org.matheclipse.core.reflection.system.Sinc:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SingularValueDecomposition -> org.matheclipse.core.reflection.system.SingularValueDecomposition:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Sinh -> org.matheclipse.core.reflection.system.Sinh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Solve -> org.matheclipse.core.reflection.system.Solve:
    org.matheclipse.core.interfaces.IAST analyzeSublist(java.util.ArrayList,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Solve$ExprAnalyzer -> wT:
    int fEquationType -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    org.matheclipse.core.interfaces.IExpr fNumer -> b
    org.matheclipse.core.interfaces.IExpr fDenom -> c
    long fLeafCount -> a
    java.util.HashSet fSymbolSet -> a
    org.matheclipse.core.interfaces.IAST fMatrixRow -> a
    org.matheclipse.core.interfaces.IAST fPlusAST -> b
    org.matheclipse.core.interfaces.IAST vars -> c
    void simplifyAndAnalyze() -> a
    org.matheclipse.core.interfaces.IExpr rewriteInverseFunction(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    void getPlusArgumentEquationType(org.matheclipse.core.interfaces.IExpr) -> a
    void getTimesArgumentEquationType(org.matheclipse.core.interfaces.IExpr) -> b
    void reset() -> b
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.Solve$NoSolution -> wU:
    int solType -> a
org.matheclipse.core.reflection.system.Sort -> org.matheclipse.core.reflection.system.Sort:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Sqrt -> org.matheclipse.core.reflection.system.Sqrt:
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SquareFreeQ -> org.matheclipse.core.reflection.system.SquareFreeQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.SquaredEuclidianDistance -> org.matheclipse.core.reflection.system.SquaredEuclidianDistance:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.StirlingS2 -> org.matheclipse.core.reflection.system.StirlingS2:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.StringDrop -> org.matheclipse.core.reflection.system.StringDrop:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.StringJoin -> org.matheclipse.core.reflection.system.StringJoin:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.StringLength -> org.matheclipse.core.reflection.system.StringLength:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.StringTake -> org.matheclipse.core.reflection.system.StringTake:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Subfactorial -> org.matheclipse.core.reflection.system.Subfactorial:
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Subsets -> org.matheclipse.core.reflection.system.Subsets:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.reflection.system.Subsets$KSubsetsList createKSubsets(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.reflection.system.Subsets$KSubsetsIterable -> wV:
    int n -> a
    int k -> b
    int[] x -> a
    long bin -> a
    boolean first -> a
    long binomial(long,long) -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.Subsets$KSubsetsList -> wW:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    java.util.Iterator fIterable -> a
    int fK -> b
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.SubtractFrom -> org.matheclipse.core.reflection.system.SubtractFrom:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.SubtractFrom$SubtractFromFunction -> wX:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Sum -> org.matheclipse.core.reflection.system.Sum:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr sumPower(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr sumPowerFormula(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IInteger) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Sum$1 -> wY:
    org.matheclipse.core.interfaces.ISymbol val$var -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Sum$2 -> wZ:
    org.matheclipse.core.interfaces.ISymbol val$var -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Surd -> org.matheclipse.core.reflection.system.Surd:
    org.matheclipse.core.interfaces.IExpr e2ApfloatArg(org.matheclipse.core.expression.ApfloatNum,org.matheclipse.core.expression.ApfloatNum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.SyntaxLength -> org.matheclipse.core.reflection.system.SyntaxLength:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.SyntaxQ -> org.matheclipse.core.reflection.system.SyntaxQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(java.lang.String) -> a
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Table -> org.matheclipse.core.reflection.system.Table:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evaluateTable(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evaluateLast(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.util.Iterator,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evalBlockWithoutReap(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Take -> org.matheclipse.core.reflection.system.Take:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST take(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.eval.util.ISequence[]) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Tan -> org.matheclipse.core.reflection.system.Tan:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Tanh -> org.matheclipse.core.reflection.system.Tanh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> a
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> a
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> a
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> a
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> a
    double evalReal(double[],int,int) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Taylor -> org.matheclipse.core.reflection.system.Taylor:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Thread -> org.matheclipse.core.reflection.system.Thread:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST threadList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int) -> a
org.matheclipse.core.reflection.system.Through -> org.matheclipse.core.reflection.system.Through:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Times -> org.matheclipse.core.reflection.system.Times:
    org.matheclipse.core.reflection.system.Times CONST -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> a
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr eInfinity(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    double evalReal(double[],int,int) -> a
org.matheclipse.core.reflection.system.TimesBy -> org.matheclipse.core.reflection.system.TimesBy:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.TimesBy$TimesByFunction -> xa:
    org.matheclipse.core.interfaces.IExpr value -> a
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Timing -> org.matheclipse.core.reflection.system.Timing:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.ToCharacterCode -> org.matheclipse.core.reflection.system.ToCharacterCode:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    java.util.List toCharacterCode(java.lang.String,java.lang.String,java.util.List) -> a
org.matheclipse.core.reflection.system.ToString -> org.matheclipse.core.reflection.system.ToString:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.String outputForm(org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.ToUnicode -> org.matheclipse.core.reflection.system.ToUnicode:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.String toUnicodeString(java.lang.String,java.lang.String) -> a
org.matheclipse.core.reflection.system.Together -> org.matheclipse.core.reflection.system.Together:
    org.matheclipse.core.interfaces.IExpr together(org.matheclipse.core.interfaces.IAST) -> c
    org.matheclipse.core.interfaces.IAST togetherForEach(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr togetherNull(org.matheclipse.core.interfaces.IAST) -> d
    org.matheclipse.core.interfaces.IAST togetherPlus(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr togetherPlusTimesPower(org.matheclipse.core.interfaces.IAST) -> e
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Total -> org.matheclipse.core.reflection.system.Total:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Tr -> org.matheclipse.core.reflection.system.Tr:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Transpose -> org.matheclipse.core.reflection.system.Transpose:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr transform(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.TrigExpand -> org.matheclipse.core.reflection.system.TrigExpand:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr expandSinPlus(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr expandCosPlus(org.matheclipse.core.interfaces.IAST,int) -> b
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.TrigReduce -> org.matheclipse.core.reflection.system.TrigReduce:
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher access$000() -> a
org.matheclipse.core.reflection.system.TrigReduce$TrigReduceVisitor -> xb:
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> b
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.TrigToExp -> org.matheclipse.core.reflection.system.TrigToExp:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.TrigToExp$TrigToExpVisitor -> xc:
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.TrueQ -> org.matheclipse.core.reflection.system.TrueQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Tuples -> org.matheclipse.core.reflection.system.Tuples:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void tuples(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void tuplesOfLists(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Unequal -> org.matheclipse.core.reflection.system.Unequal:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Union -> org.matheclipse.core.reflection.system.Union:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.UnitStep -> org.matheclipse.core.reflection.system.UnitStep:
    double evalReal(double[],int,int) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> b
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.UnitVector -> org.matheclipse.core.reflection.system.UnitVector:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.UnsameQ -> org.matheclipse.core.reflection.system.UnsameQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.UpperCaseQ -> org.matheclipse.core.reflection.system.UpperCaseQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> b
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.VandermondeMatrix -> org.matheclipse.core.reflection.system.VandermondeMatrix:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.VandermondeMatrix$1 -> xd:
    org.matheclipse.core.expression.AST val$lst -> a
    java.lang.Object evaluate(int[]) -> a
org.matheclipse.core.reflection.system.Variables -> org.matheclipse.core.reflection.system.Variables:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.VectorQ -> org.matheclipse.core.reflection.system.VectorQ:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.Xor -> org.matheclipse.core.reflection.system.Xor:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.reflection.system.rules.AbsRules -> xe:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcCosRules -> xf:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcCoshRules -> xg:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcCotRules -> xh:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcCothRules -> xi:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcCscRules -> xj:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcCschRules -> xk:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcSecRules -> xl:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcSechRules -> xm:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcSinRules -> xn:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcSinhRules -> xo:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcTanRules -> xp:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ArcTanhRules -> xq:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.CosRules -> xr:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.CoshRules -> xs:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.CotRules -> xt:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.CothRules -> xu:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.CscRules -> xv:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.CschRules -> xw:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.DerivativeRules -> xx:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.LimitRules -> xy:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.LogRules -> xz:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.PowerRules -> xA:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.ProductLogRules -> xB:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.SecRules -> xC:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.SechRules -> xD:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.SinRules -> xE:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.SincRules -> xF:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.SinhRules -> xG:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.SumRules -> xH:
    org.matheclipse.core.interfaces.IAST RULES1 -> a
    org.matheclipse.core.interfaces.IAST RULES2 -> b
org.matheclipse.core.reflection.system.rules.TanRules -> xI:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.reflection.system.rules.TanhRules -> xJ:
    org.matheclipse.core.interfaces.IAST RULES -> a
org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic -> xK:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> a
    long getN() -> a
    void clear() -> a
    org.matheclipse.core.interfaces.IExpr getResult() -> a
    void increment(org.matheclipse.core.interfaces.IExpr) -> a
    boolean test(org.matheclipse.core.interfaces.IAST,int,int,boolean) -> a
org.matheclipse.core.stat.descriptive.SymbolicGeometricMean -> xL:
    org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic product -> a
    void increment(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getResult() -> a
    void clear() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> a
    long getN() -> a
org.matheclipse.core.stat.descriptive.SymbolicStatUtils -> xM:
    org.matheclipse.core.stat.descriptive.SymbolicGeometricMean GEOMETRIC_MEAN -> a
    org.matheclipse.core.interfaces.IExpr geometricMean(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.stat.descriptive.summary.SymbolicProduct -> xN:
    long n -> a
    org.matheclipse.core.interfaces.IExpr value -> a
    void increment(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getResult() -> a
    long getN() -> a
    void clear() -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> a
org.matheclipse.core.util.OpenIntToIExprHashMap -> xO:
    int[] keys -> a
    org.matheclipse.core.interfaces.IExpr[] values -> a
    byte[] states -> a
    int size -> a
    int mask -> b
    int count -> c
    org.matheclipse.core.interfaces.IExpr get(int) -> a
    int findInsertionIndex(int[],byte[],int,int) -> a
    int probe(int,int) -> a
    boolean containsKey(int,int) -> a
    org.matheclipse.core.interfaces.IExpr put(int,org.matheclipse.core.interfaces.IExpr) -> a
    int hashOf(int) -> a
org.matheclipse.core.visit.AbstractVisitor -> org.matheclipse.core.visit.AbstractVisitor:
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
org.matheclipse.core.visit.AbstractVisitorBoolean -> org.matheclipse.core.visit.AbstractVisitorBoolean:
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> a
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> a
    boolean visit(org.matheclipse.core.interfaces.INum) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean visit(org.matheclipse.core.interfaces.IPattern) -> a
    boolean visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    boolean visit(org.matheclipse.core.interfaces.IStringX) -> a
org.matheclipse.core.visit.AbstractVisitorInt -> org.matheclipse.core.visit.AbstractVisitorInt:
    int visit(org.matheclipse.core.interfaces.IInteger) -> a
    int visit(org.matheclipse.core.interfaces.IFraction) -> a
    int visit(org.matheclipse.core.interfaces.IComplex) -> a
    int visit(org.matheclipse.core.interfaces.INum) -> a
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    int visit(org.matheclipse.core.interfaces.ISymbol) -> a
    int visit(org.matheclipse.core.interfaces.IPattern) -> a
    int visit(org.matheclipse.core.interfaces.IStringX) -> a
org.matheclipse.core.visit.AbstractVisitorLong -> org.matheclipse.core.visit.AbstractVisitorLong:
    long visit$2ed48855() -> a
    long visit$f81862f() -> b
    long visit$4d323d9f() -> c
org.matheclipse.core.visit.HashValueVisitor -> org.matheclipse.core.visit.HashValueVisitor:
    int visit(org.matheclipse.core.interfaces.IAST) -> a
    int visit(org.matheclipse.core.interfaces.IComplex) -> a
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    int visit(org.matheclipse.core.interfaces.IFraction) -> a
    int visit(org.matheclipse.core.interfaces.IInteger) -> a
    int visit(org.matheclipse.core.interfaces.INum) -> a
    int visit(org.matheclipse.core.interfaces.IPattern) -> a
    int visit(org.matheclipse.core.interfaces.IStringX) -> a
    int visit(org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.visit.IVisitor -> xP:
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.IVisitorBoolean -> xQ:
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> a
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> a
    boolean visit(org.matheclipse.core.interfaces.INum) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean visit(org.matheclipse.core.interfaces.IPattern) -> a
    boolean visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    boolean visit(org.matheclipse.core.interfaces.IStringX) -> a
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.IVisitorInt -> xR:
    int visit(org.matheclipse.core.interfaces.IInteger) -> a
    int visit(org.matheclipse.core.interfaces.IFraction) -> a
    int visit(org.matheclipse.core.interfaces.IComplex) -> a
    int visit(org.matheclipse.core.interfaces.INum) -> a
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    int visit(org.matheclipse.core.interfaces.ISymbol) -> a
    int visit(org.matheclipse.core.interfaces.IPattern) -> a
    int visit(org.matheclipse.core.interfaces.IStringX) -> a
    int visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.IVisitorLong -> xS:
    long visit$2ed48855() -> a
    long visit$f81862f() -> b
    long visit$4d323d9f() -> c
    long visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorCollectionBoolean -> org.matheclipse.core.visit.VisitorCollectionBoolean:
    int fHeadOffset -> a
    java.util.Collection fCollection -> a
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorExpr -> org.matheclipse.core.visit.VisitorExpr:
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPattern) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IStringX) -> a
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorFunction -> org.matheclipse.core.visit.VisitorFunction:
    com.google.common.base.Function fFunction -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorLevelSpecification -> org.matheclipse.core.visit.VisitorLevelSpecification:
    com.google.common.base.Function fFunction -> a
    int fFromLevel -> b
    int fToLevel -> c
    int fFromDepth -> d
    int fToDepth -> e
    boolean fIncludeHeads -> a
    int fCurrentLevel -> a
    int fCurrentDepth -> f
    boolean isInRange(int,int) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorPredicate -> org.matheclipse.core.visit.VisitorPredicate:
    com.google.common.base.Predicate fMatcher -> a
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> a
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> a
    boolean visit(org.matheclipse.core.interfaces.INum) -> a
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> a
    boolean visit(org.matheclipse.core.interfaces.IPattern) -> a
    boolean visit(org.matheclipse.core.interfaces.IPatternSequence) -> a
    boolean visit(org.matheclipse.core.interfaces.IStringX) -> a
    boolean visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorReplaceAll -> org.matheclipse.core.visit.VisitorReplaceAll:
    com.google.common.base.Function fFunction -> a
    int fOffset -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IFraction) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplex) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.INum) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPattern) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IStringX) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorReplacePart -> org.matheclipse.core.visit.VisitorReplacePart:
    org.matheclipse.core.interfaces.IExpr fReplaceExpr -> a
    int[] fPositions -> a
    org.matheclipse.core.interfaces.IExpr visitIndex(org.matheclipse.core.interfaces.IAST,int) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.visit.VisitorReplaceSlots -> org.matheclipse.core.visit.VisitorReplaceSlots:
    org.matheclipse.core.interfaces.IAST astSlots -> a
    org.matheclipse.core.interfaces.IExpr getSlot(org.matheclipse.core.interfaces.IInteger) -> b
    int getSlotSequence(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.parser.client.Parser -> org.matheclipse.parser.client.Parser:
    boolean fRelaxedSyntax -> a
    boolean fPackageMode -> b
    java.util.List fNodeList -> b
    org.matheclipse.parser.client.ast.SymbolNode DERIVATIVE -> a
    void setFactory(org.matheclipse.parser.client.ast.IParserFactory) -> setFactory
    org.matheclipse.parser.client.ast.IParserFactory getFactory() -> getFactory
    void getArguments(org.matheclipse.parser.client.ast.FunctionNode) -> a
    org.matheclipse.parser.client.operator.PostfixOperator determinePostfixOperator() -> a
    org.matheclipse.parser.client.operator.InfixOperator determineBinaryOperator() -> a
    org.matheclipse.parser.client.ast.ASTNode parseArguments(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.ASTNode parsePrimary() -> a
    org.matheclipse.parser.client.ast.ASTNode parseLookaheadOperator(int) -> a
    org.matheclipse.parser.client.ast.ASTNode parseOperators(org.matheclipse.parser.client.ast.ASTNode,int) -> a
    org.matheclipse.parser.client.ast.ASTNode parse(java.lang.String) -> parse
    java.util.List parseList(java.lang.String) -> parseList
    org.matheclipse.parser.client.ast.ASTNode getNumber(boolean) -> a
    int getIntegerNumber() -> a
    org.matheclipse.parser.client.ast.SymbolNode getSymbol() -> a
    org.matheclipse.parser.client.ast.FunctionNode getFunctionArguments(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.ASTNode getPart() -> b
org.matheclipse.parser.client.Scanner -> xT:
    java.lang.String fInputString -> a
    char fLastChar -> a
    char fCurrentChar -> b
    int fCurrentPosition -> a
    int fToken -> b
    java.lang.String fOperatorString -> b
    java.util.List fOperList -> a
    int rowCount -> c
    int fCurrentColumnStartPosition -> d
    int numFormat -> e
    org.matheclipse.parser.client.ast.IParserFactory fFactory -> a
    java.util.HashMap CHAR_MAP -> a
    void initialize(java.lang.String) -> a
    void initializeNullScanner() -> b
    void getChar() -> c
    void getNextChar() -> d
    void getNextToken() -> a
    void getComment() -> e
    void throwSyntaxError(java.lang.String) -> b
    void throwSyntaxError(java.lang.String,int) -> a
    java.lang.String getErrorLine() -> b
    java.lang.String getIdentifier() -> a
    java.lang.Object[] getNumberString() -> a
    java.lang.StringBuffer getStringBuffer() -> a
org.matheclipse.parser.client.SyntaxError -> org.matheclipse.parser.client.SyntaxError:
    int fStartOffset -> a
    int fRowIndex -> b
    int fColumnIndex -> c
    java.lang.String fCurrentLine -> a
    java.lang.String fError -> b
    java.lang.String getMessage() -> getMessage
org.matheclipse.parser.client.ast.ASTNode -> org.matheclipse.parser.client.ast.ASTNode:
    java.lang.String fStringValue -> a
    java.lang.String getString() -> getString
    java.lang.String toString() -> toString
    boolean dependsOn(java.lang.String) -> dependsOn
    boolean isFree(org.matheclipse.parser.client.ast.ASTNode) -> isFree
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FloatNode -> org.matheclipse.parser.client.ast.FloatNode:
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FractionNode -> org.matheclipse.parser.client.ast.FractionNode:
    org.matheclipse.parser.client.ast.IntegerNode fNumerator -> a
    org.matheclipse.parser.client.ast.IntegerNode fDenominator -> b
    org.matheclipse.parser.client.ast.IntegerNode getDenominator() -> a
    org.matheclipse.parser.client.ast.IntegerNode getNumerator() -> b
    java.lang.String toString() -> toString
    double doubleValue() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FunctionNode -> org.matheclipse.parser.client.ast.FunctionNode:
    java.util.ArrayList fNodesList -> a
    boolean add(org.matheclipse.parser.client.ast.ASTNode) -> a
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.parser.client.ast.ASTNode get(int) -> a
    org.matheclipse.parser.client.ast.ASTNode getNode(int) -> b
    int hashCode() -> hashCode
    int indexOf(java.lang.Object) -> indexOf
    boolean isEmpty() -> isEmpty
    boolean isFree(org.matheclipse.parser.client.ast.ASTNode) -> isFree
    java.util.Iterator iterator() -> iterator
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.util.ListIterator listIterator() -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    org.matheclipse.parser.client.ast.ASTNode set(int,org.matheclipse.parser.client.ast.ASTNode) -> a
    int size() -> size
    java.util.List subList(int,int) -> subList
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    java.lang.String toString() -> toString
    boolean dependsOn(java.lang.String) -> dependsOn
    java.lang.Object remove(int) -> remove
    void add(int,java.lang.Object) -> add
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    boolean add(java.lang.Object) -> add
org.matheclipse.parser.client.ast.IParserFactory -> xU:
    java.lang.String getOperatorCharacters() -> a
    org.matheclipse.parser.client.operator.Operator get(java.lang.String) -> a
    java.util.List getOperatorList(java.lang.String) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createAST(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.ASTNode createDouble(java.lang.String) -> a
    org.matheclipse.parser.client.ast.IntegerNode createInteger(java.lang.String,int) -> a
    org.matheclipse.parser.client.ast.IntegerNode createInteger(int) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern2(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> b
    org.matheclipse.parser.client.ast.PatternNode createPattern3(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> c
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> a
    org.matheclipse.parser.client.ast.StringNode createString(java.lang.StringBuffer) -> a
    org.matheclipse.parser.client.ast.SymbolNode createSymbol(java.lang.String) -> a
org.matheclipse.parser.client.ast.IntegerNode -> org.matheclipse.parser.client.ast.IntegerNode:
    org.matheclipse.parser.client.ast.IntegerNode C1 -> a
    int fNumberFormat -> a
    int fIntValue -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.NumberNode -> org.matheclipse.parser.client.ast.NumberNode:
    boolean sign -> a
    void toggleSign() -> a
    java.lang.String getString() -> getString
    java.lang.String toString() -> toString
    boolean isSign() -> a
    double doubleValue() -> a
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.Pattern2Node -> org.matheclipse.parser.client.ast.Pattern2Node:
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.Pattern3Node -> org.matheclipse.parser.client.ast.Pattern3Node:
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.PatternNode -> org.matheclipse.parser.client.ast.PatternNode:
    org.matheclipse.parser.client.ast.SymbolNode fSymbol -> a
    boolean fDefault -> a
    org.matheclipse.parser.client.ast.ASTNode fConstraint -> a
    org.matheclipse.parser.client.ast.ASTNode getConstraint() -> a
    org.matheclipse.parser.client.ast.SymbolNode getSymbol() -> a
    boolean isDefault() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.StringNode -> org.matheclipse.parser.client.ast.StringNode:
org.matheclipse.parser.client.ast.SymbolNode -> org.matheclipse.parser.client.ast.SymbolNode:
    boolean dependsOn(java.lang.String) -> dependsOn
org.matheclipse.parser.client.eval.ComplexEvalVisitor -> xV:
    java.util.Map SYMBOL_MAP -> a
    java.util.Map SYMBOL_BOOLEAN_MAP -> b
    java.util.Map FUNCTION_MAP -> c
    java.util.Map FUNCTION_BOOLEAN_MAP -> d
    boolean fRelaxedSyntax -> a
org.matheclipse.parser.client.eval.ComplexEvalVisitor$1 -> xW:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.ComplexEvalVisitor$10 -> xX:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$11 -> xY:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$12 -> xZ:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$13 -> ya:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$14 -> yb:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$15 -> yc:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$16 -> yd:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$17 -> ye:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$2 -> yf:
    boolean evaluate(boolean) -> a
org.matheclipse.parser.client.eval.ComplexEvalVisitor$3 -> yg:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.ComplexEvalVisitor$4 -> yh:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$5 -> yi:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$6 -> yj:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$7 -> yk:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$8 -> yl:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$9 -> ym:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$ArcTanFunction -> yn:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$CompoundExpressionFunction -> yo:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$LogFunction -> yp:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$PlusFunction -> yq:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$SetFunction -> yr:
org.matheclipse.parser.client.eval.ComplexEvalVisitor$TimesFunction -> ys:
org.matheclipse.parser.client.eval.ComplexEvaluator -> org.matheclipse.parser.client.eval.ComplexEvaluator:
    java.lang.String toString(org.matheclipse.parser.client.math.Complex) -> a
org.matheclipse.parser.client.eval.ComplexNode -> org.matheclipse.parser.client.eval.ComplexNode:
    org.matheclipse.parser.client.math.Complex value -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.eval.DoubleEvaluator -> org.matheclipse.parser.client.eval.DoubleEvaluator:
    double EPSILON -> a
    java.util.Map SYMBOL_DOUBLE_MAP -> a
    java.util.Map SYMBOL_BOOLEAN_MAP -> b
    java.util.Map FUNCTION_DOUBLE_MAP -> c
    java.util.Map FUNCTION_BOOLEAN_MAP -> d
    org.matheclipse.parser.client.eval.IDoubleCallbackFunction fCallbackFunction -> a
    java.util.Map fVariableMap -> e
    java.util.Map fBooleanVariables -> f
    org.matheclipse.parser.client.ast.ASTNode fNode -> a
    boolean fRelaxedSyntax -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory fASTFactory -> a
    org.matheclipse.parser.client.eval.IDoubleCallbackFunction getCallbackFunction() -> getCallbackFunction
    void setCallbackFunction(org.matheclipse.parser.client.eval.IDoubleCallbackFunction) -> setCallbackFunction
    org.matheclipse.parser.client.ast.ASTNode parse(java.lang.String) -> parse
    org.matheclipse.parser.client.ast.ASTNode parseNode(java.lang.String,boolean) -> parseNode
    double evaluate(java.lang.String) -> evaluate
    double evaluate() -> evaluate
    double evaluateNode(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNode
    double evaluateFunction(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunction
    boolean isSymbol(org.matheclipse.parser.client.ast.SymbolNode,java.lang.String) -> isSymbol
    boolean isSymbol(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.SymbolNode) -> isSymbol
    org.matheclipse.parser.client.ast.ASTNode derivative(org.matheclipse.parser.client.ast.ASTNode,java.lang.String) -> derivative
    org.matheclipse.parser.client.ast.ASTNode derivative(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.SymbolNode) -> derivative
    org.matheclipse.parser.client.ast.ASTNode getDerivativeResult(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.FunctionNode) -> a
    boolean evaluateNodeLogical(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNodeLogical
    boolean evaluateFunctionLogical(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunctionLogical
    org.matheclipse.parser.client.ast.ASTNode optimizeFunction(org.matheclipse.parser.client.ast.FunctionNode) -> optimizeFunction
    void defineVariable(java.lang.String,double) -> defineVariable
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.IDoubleValue) -> defineVariable
    void defineVariable(java.lang.String) -> defineVariable
    org.matheclipse.parser.client.eval.IDoubleValue getVariable(java.lang.String) -> getVariable
    void defineVariable$7b85584e(java.lang.String,org.apache.commons.math3.dfp.DfpField) -> defineVariable$7b85584e
    void clearVariables() -> clearVariables
    void getVariables(java.lang.String,java.util.Set) -> getVariables
    void getVariables(java.lang.String,java.util.Set,boolean) -> getVariables
    void getVariables(org.matheclipse.parser.client.ast.ASTNode,java.util.Set) -> getVariables
org.matheclipse.parser.client.eval.DoubleEvaluator$1 -> yt:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$11 -> yu:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$12 -> yv:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$13 -> yw:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$14 -> yx:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$15 -> yy:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$16 -> yz:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$17 -> yA:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$18 -> yB:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$19 -> yC:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$2 -> yD:
    boolean evaluate(boolean) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$20 -> yE:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$21 -> yF:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$22 -> yG:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$23 -> yH:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$24 -> yI:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$25 -> yJ:
    double evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$3 -> yK:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$4 -> yL:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$5 -> yM:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$6 -> yN:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$7 -> yO:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$8 -> yP:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$9 -> yQ:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$ArcTanFunction -> yR:
    double evaluate(double) -> a
    double evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$CompoundExpressionFunction -> yS:
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$LogFunction -> yT:
    double evaluate(double) -> a
    double evaluate(double,double) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$MaxFunction -> yU:
    double evaluate(double,double) -> a
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$MinFunction -> yV:
    double evaluate(double,double) -> a
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$PlusFunction -> yW:
    double evaluate(double,double) -> a
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$SetFunction -> yX:
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleEvaluator$TimesFunction -> yY:
    double evaluate(double,double) -> a
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.DoubleNode -> org.matheclipse.parser.client.eval.DoubleNode:
    double value -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.eval.DoubleVariable -> yZ:
    double value -> a
    double getValue() -> a
    void setValue(double) -> a
org.matheclipse.parser.client.eval.IBooleanBoolean1Function -> za:
    boolean evaluate(boolean) -> a
org.matheclipse.parser.client.eval.IBooleanBoolean2Function -> zb:
    boolean evaluate(boolean,boolean) -> a
org.matheclipse.parser.client.eval.IBooleanDouble2Function -> zc:
    boolean evaluate(double,double) -> a
org.matheclipse.parser.client.eval.IDouble0Function -> zd:
    double evaluate() -> a
org.matheclipse.parser.client.eval.IDouble1Function -> ze:
    double evaluate(double) -> a
org.matheclipse.parser.client.eval.IDouble2Function -> zf:
    double evaluate(double,double) -> a
org.matheclipse.parser.client.eval.IDoubleCallbackFunction -> zg:
    double evaluate$5bc7c9e6(org.matheclipse.parser.client.ast.FunctionNode,double[]) -> a
org.matheclipse.parser.client.eval.IDoubleFunction -> zh:
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> a
org.matheclipse.parser.client.eval.IDoubleValue -> zi:
    double getValue() -> a
    void setValue(double) -> a
org.matheclipse.parser.client.eval.api.IASTVisitor -> zj:
org.matheclipse.parser.client.eval.api.ObjectEvaluator -> zk:
org.matheclipse.parser.client.eval.dfp.DfpNode -> org.matheclipse.parser.client.eval.dfp.DfpNode:
    org.apache.commons.math3.dfp.Dfp value -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.math.ArithmeticMathException -> org.matheclipse.parser.client.math.ArithmeticMathException:
org.matheclipse.parser.client.math.Complex -> zl:
    double imaginary -> a
    double real -> b
    boolean isNaN -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.matheclipse.parser.client.math.MathException -> org.matheclipse.parser.client.math.MathException:
org.matheclipse.parser.client.operator.ASTNodeFactory -> zm:
    java.lang.String[] HEADER_STRINGS -> a
    java.lang.String[] OPERATOR_STRINGS -> b
    org.matheclipse.parser.client.operator.Operator[] OPERATORS -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory MMA_STYLE_FACTORY -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory RELAXED_STYLE_FACTORY -> b
    java.util.HashMap fOperatorMap -> a
    java.util.HashMap fOperatorTokenStartSet -> b
    boolean fIgnoreCase -> a
    java.lang.String getOperatorCharacters() -> a
    org.matheclipse.parser.client.operator.Operator get(java.lang.String) -> a
    java.util.List getOperatorList(java.lang.String) -> a
    org.matheclipse.parser.client.ast.ASTNode createDouble(java.lang.String) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.FunctionNode createAST(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.IntegerNode createInteger(java.lang.String,int) -> a
    org.matheclipse.parser.client.ast.IntegerNode createInteger(int) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> a
    org.matheclipse.parser.client.ast.PatternNode createPattern2(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> b
    org.matheclipse.parser.client.ast.PatternNode createPattern3(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> c
    org.matheclipse.parser.client.ast.StringNode createString(java.lang.StringBuffer) -> a
    org.matheclipse.parser.client.ast.SymbolNode createSymbol(java.lang.String) -> a
org.matheclipse.parser.client.operator.DivideOperator -> zn:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.InfixOperator -> zo:
    int fGrouping -> a
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.Operator -> zp:
    java.lang.String fFunctionName -> a
    java.lang.String fOperatorString -> b
    int fPrecedence -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String getFunctionName() -> a
    java.lang.String getOperatorString() -> b
    int getPrecedence() -> a
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.matheclipse.parser.client.operator.PostfixOperator -> zq:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.PreMinusOperator -> zr:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.PrePlusOperator -> zs:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.PrefixOperator -> zt:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> a
org.matheclipse.parser.client.operator.SubtractOperator -> zu:
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> a
