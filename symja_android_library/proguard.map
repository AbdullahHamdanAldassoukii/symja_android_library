cc.redberry.concurrent.OutputPortUnsafe -> a:
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.DummySolutionProvider -> b:
    int[] solution -> a
    int[] currentRemainder -> b
    void <init>(int[],int[]) -> <init>
    boolean tick() -> a
    int[] currentRemainders() -> a
    java.lang.Object take() -> a
    java.lang.String toLowerCase(java.lang.String) -> a
    boolean isUpperCase(char) -> a
    boolean equal(java.lang.Object,java.lang.Object) -> a
    java.lang.Object firstNonNull(java.lang.Object,java.lang.Object) -> a
    void checkArgument(boolean) -> a
    void checkArgument(boolean,java.lang.Object) -> a
    void checkArgument(boolean,java.lang.String,java.lang.Object[]) -> a
    void checkState(boolean) -> b
    void checkState(boolean,java.lang.Object) -> b
    void checkState(boolean,java.lang.String,java.lang.Object[]) -> b
    java.lang.Object checkNotNull(java.lang.Object) -> a
    java.lang.Object checkNotNull(java.lang.Object,java.lang.Object) -> b
    int checkElementIndex(int,int) -> a
    int checkPositionIndex(int,int) -> b
    java.lang.String badPositionIndex(int,int,java.lang.String) -> a
    void checkPositionIndexes(int,int,int) -> a
    java.lang.String format(java.lang.String,java.lang.Object[]) -> a
    void checkEntryNotNull(java.lang.Object,java.lang.Object) -> a
    int checkNonnegative(int,java.lang.String) -> a
    java.lang.Object getOnlyElement(java.lang.Iterable) -> a
    java.lang.Object[] toArray(java.lang.Iterable) -> a
    java.lang.Object getFirst(java.lang.Iterable,java.lang.Object) -> a
    java.util.ArrayList newArrayList(java.lang.Iterable) -> a
    java.util.ArrayList newArrayList(java.util.Iterator) -> a
    void populateMultiset(com.google.common.collect.Multiset,java.io.ObjectInputStream,int) -> a
    void writeMultimap(com.google.common.collect.Multimap,java.io.ObjectOutputStream) -> a
    void populateMultimap(com.google.common.collect.Multimap,java.io.ObjectInputStream) -> a
    void populateMultimap(com.google.common.collect.Multimap,java.io.ObjectInputStream,int) -> a
    com.google.common.collect.Serialization$FieldSetter getFieldSetter(java.lang.Class,java.lang.String) -> a
    java.util.HashSet newHashSet(java.lang.Iterable) -> a
    com.google.common.collect.Sets$SetView difference(java.util.Set,java.util.Set) -> a
    int hashCodeImpl(java.util.Set) -> a
    boolean equalsImpl(java.util.Set,java.lang.Object) -> a
    java.util.NavigableSet unmodifiableNavigableSet(java.util.NavigableSet) -> a
    boolean removeAllImpl(java.util.Set,java.util.Iterator) -> a
    boolean removeAllImpl(java.util.Set,java.util.Collection) -> a
    boolean hasSameComparator(java.util.Comparator,java.lang.Iterable) -> a
    java.util.Comparator comparator(java.util.SortedSet) -> a
    int binarySearch(java.util.List,java.lang.Object,java.util.Comparator,com.google.common.collect.SortedLists$KeyPresentBehavior,com.google.common.collect.SortedLists$KeyAbsentBehavior) -> a
    int checkNonNegative(java.lang.String,int) -> a
    long checkNonNegative(java.lang.String,long) -> a
    void checkRoundingUnnecessary(boolean) -> c
    void checkInRange(boolean) -> d
    int saturatedCast(long) -> a
    int compare(int,int) -> c
    double cheby(double,double[]) -> a
    java.lang.String nextString(java.io.Reader) -> a
    java.lang.String nextPairedString(java.io.Reader,char,char) -> a
    java.util.List map(java.util.List,edu.jas.structure.UnaryFunctor) -> a
    org.apache.commons.math3.analysis.UnivariateFunction fix2ndArgument(org.apache.commons.math3.analysis.BivariateFunction,double) -> a
    boolean isBracketing(org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    void verifyInterval(double,double) -> a
    org.apache.commons.math3.complex.Complex[] convertToComplex(double[]) -> a
    org.apache.commons.math3.dfp.Dfp[] split(org.apache.commons.math3.dfp.Dfp) -> a
    org.apache.commons.math3.dfp.Dfp[] splitMult(org.apache.commons.math3.dfp.Dfp[],org.apache.commons.math3.dfp.Dfp[]) -> a
    org.apache.commons.math3.dfp.Dfp splitPow(org.apache.commons.math3.dfp.Dfp[],int) -> a
    org.apache.commons.math3.dfp.Dfp pow(org.apache.commons.math3.dfp.Dfp,int) -> a
    org.apache.commons.math3.dfp.Dfp exp(org.apache.commons.math3.dfp.Dfp) -> a
    org.apache.commons.math3.dfp.Dfp log(org.apache.commons.math3.dfp.Dfp) -> b
    org.apache.commons.math3.dfp.Dfp pow(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> a
    org.apache.commons.math3.dfp.Dfp sinInternal(org.apache.commons.math3.dfp.Dfp[]) -> a
    org.apache.commons.math3.dfp.Dfp cosInternal(org.apache.commons.math3.dfp.Dfp[]) -> b
    org.apache.commons.math3.dfp.Dfp sin(org.apache.commons.math3.dfp.Dfp) -> c
    org.apache.commons.math3.dfp.Dfp cos(org.apache.commons.math3.dfp.Dfp) -> d
    org.apache.commons.math3.dfp.Dfp tan(org.apache.commons.math3.dfp.Dfp) -> e
    org.apache.commons.math3.dfp.Dfp atan(org.apache.commons.math3.dfp.Dfp) -> f
    org.apache.commons.math3.dfp.Dfp asin(org.apache.commons.math3.dfp.Dfp) -> g
    org.apache.commons.math3.dfp.Dfp acos(org.apache.commons.math3.dfp.Dfp) -> h
    java.lang.Object[] flatten(java.lang.Object[]) -> a
    org.apache.commons.math3.random.RandomGenerator createRandomGenerator(java.util.Random) -> a
    double erf(double) -> a
    double erfc(double) -> b
    double erf(double,double) -> a
    double erfInv(double) -> c
    int gcd(int,int) -> d
    int mulAndCheck(int,int) -> e
    long mulAndCheck(long,long) -> a
    java.math.BigInteger pow(java.math.BigInteger,long) -> a
    java.math.BigInteger pow(java.math.BigInteger,java.math.BigInteger) -> a
    java.text.NumberFormat getDefaultNumberFormat(java.util.Locale) -> a
    java.lang.StringBuffer formatDouble(double,java.text.NumberFormat,java.lang.StringBuffer,java.text.FieldPosition) -> a
    boolean checkOrder(double[],org.apache.commons.math3.util.MathArrays$OrderDirection,boolean,boolean) -> a
    void checkOrder(double[]) -> a
    void checkNotNaN(double[]) -> b
    double linearCombination(double[],double[]) -> a
    double linearCombination(double,double,double,double) -> a
    double linearCombination(double,double,double,double,double,double) -> a
    double linearCombination(double,double,double,double,double,double,double,double) -> a
    java.lang.Object[] buildArray(org.apache.commons.math3.Field,int) -> a
    java.lang.Object[][] buildArray(org.apache.commons.math3.Field,int,int) -> a
    void shuffle(int[],org.apache.commons.math3.random.RandomGenerator) -> a
    int[] natural(int) -> a
    boolean verifyValues(double[],int,int,boolean) -> a
    boolean verifyValues(double[],double[],int,int,boolean) -> a
    int hash(double) -> a
    boolean equals(double,double) -> a
    void checkNotNull(java.lang.Object,org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> a
    void checkNotNull(java.lang.Object) -> a
    org.apfloat.Aprational scale(org.apfloat.Aprational,long) -> a
    java.io.Writer wrapAppendableWriter(java.lang.Appendable) -> a
    java.io.Writer wrapPadWriter(java.io.Writer,boolean) -> a
    void finishPad(java.io.Writer,long) -> a
    void pad(java.lang.Appendable,long) -> a
    org.apfloat.Apfloat toRadixNormalizedPart(org.apfloat.Apfloat,int,long,org.apfloat.RadixConversionHelper$RadixPowerList) -> a
    org.apfloat.Apfloat split(org.apfloat.Apfloat,int,long,long,org.apfloat.RadixConversionHelper$RadixPowerList) -> a
    long getPrecision(long,int,int) -> a
    void scramble(double[],int,int[]) -> a
    void scramble(float[],int,int[]) -> a
    void scramble(int[],int,int[]) -> a
    void scramble(long[],int,int[]) -> a
    org.matheclipse.core.interfaces.IExpr[] buildArray(int) -> a
    org.matheclipse.core.interfaces.IExpr[][] buildArray(int,int) -> a
cc.redberry.core.math.frobenius.FinalSolutionProvider -> c:
    boolean $assertionsDisabled -> a
    void <init>(cc.redberry.core.math.frobenius.SolutionProvider,int,int[]) -> <init>
    java.lang.Object take() -> a
    void <clinit>() -> <clinit>
cc.redberry.core.math.frobenius.FrobeniusSolver -> d:
    cc.redberry.concurrent.OutputPortUnsafe provider -> a
    void <init>(int[][]) -> <init>
    int[] take() -> a
    boolean assertEq(int[]) -> a
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.SingleSolutionProvider -> e:
    void <init>(cc.redberry.core.math.frobenius.SolutionProvider,int,int[]) -> <init>
    java.lang.Object take() -> a
cc.redberry.core.math.frobenius.SolutionProvider -> f:
    boolean tick() -> a
    int[] currentRemainders() -> a
cc.redberry.core.math.frobenius.SolutionProviderAbstract -> g:
    cc.redberry.core.math.frobenius.SolutionProvider provider -> a
    int position -> a
    int[] coefficients -> a
    int[] currentSolution -> b
    int currentCounter -> b
    int[] currentRemainder -> c
    void <init>(cc.redberry.core.math.frobenius.SolutionProvider,int,int[]) -> <init>
    boolean tick() -> a
    int[] currentRemainders() -> a
cc.redberry.core.math.frobenius.TotalSolutionProvider -> h:
    cc.redberry.core.math.frobenius.SolutionProvider[] providers -> a
    boolean inited -> a
    boolean $assertionsDisabled -> b
    void <init>(cc.redberry.core.math.frobenius.SolutionProvider[]) -> <init>
    java.lang.Object take() -> a
    void <clinit>() -> <clinit>
com.google.common.base.CharMatcher -> com.google.common.base.CharMatcher:
    com.google.common.base.CharMatcher BREAKING_WHITESPACE -> BREAKING_WHITESPACE
    com.google.common.base.CharMatcher ASCII -> ASCII
    java.lang.String NINES -> a
    com.google.common.base.CharMatcher DIGIT -> DIGIT
    com.google.common.base.CharMatcher JAVA_DIGIT -> JAVA_DIGIT
    com.google.common.base.CharMatcher JAVA_LETTER -> JAVA_LETTER
    com.google.common.base.CharMatcher JAVA_LETTER_OR_DIGIT -> JAVA_LETTER_OR_DIGIT
    com.google.common.base.CharMatcher JAVA_UPPER_CASE -> JAVA_UPPER_CASE
    com.google.common.base.CharMatcher JAVA_LOWER_CASE -> JAVA_LOWER_CASE
    com.google.common.base.CharMatcher JAVA_ISO_CONTROL -> JAVA_ISO_CONTROL
    com.google.common.base.CharMatcher INVISIBLE -> INVISIBLE
    com.google.common.base.CharMatcher SINGLE_WIDTH -> SINGLE_WIDTH
    com.google.common.base.CharMatcher ANY -> ANY
    com.google.common.base.CharMatcher NONE -> NONE
    java.lang.String description -> description
    int WHITESPACE_SHIFT -> a
    com.google.common.base.CharMatcher WHITESPACE -> WHITESPACE
    java.lang.String showCharacter(char) -> a
    com.google.common.base.CharMatcher is(char) -> is
    com.google.common.base.CharMatcher isNot(char) -> isNot
    com.google.common.base.CharMatcher anyOf(java.lang.CharSequence) -> anyOf
    com.google.common.base.CharMatcher isEither(char,char) -> a
    com.google.common.base.CharMatcher noneOf(java.lang.CharSequence) -> noneOf
    com.google.common.base.CharMatcher inRange(char,char) -> inRange
    com.google.common.base.CharMatcher inRange(char,char,java.lang.String) -> a
    com.google.common.base.CharMatcher forPredicate(com.google.common.base.Predicate) -> forPredicate
    void <init>(java.lang.String) -> <init>
    void <init>() -> <init>
    boolean matches(char) -> matches
    com.google.common.base.CharMatcher negate() -> negate
    com.google.common.base.CharMatcher and(com.google.common.base.CharMatcher) -> and
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> or
    com.google.common.base.CharMatcher precomputed() -> precomputed
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
    com.google.common.base.CharMatcher precomputedInternal() -> precomputedInternal
    com.google.common.base.CharMatcher precomputedPositive(int,java.util.BitSet,java.lang.String) -> precomputedPositive
    void setBits(java.util.BitSet) -> setBits
    boolean matchesAnyOf(java.lang.CharSequence) -> matchesAnyOf
    boolean matchesAllOf(java.lang.CharSequence) -> matchesAllOf
    boolean matchesNoneOf(java.lang.CharSequence) -> matchesNoneOf
    int indexIn(java.lang.CharSequence) -> indexIn
    int indexIn(java.lang.CharSequence,int) -> indexIn
    int lastIndexIn(java.lang.CharSequence) -> lastIndexIn
    int countIn(java.lang.CharSequence) -> countIn
    java.lang.String removeFrom(java.lang.CharSequence) -> removeFrom
    java.lang.String retainFrom(java.lang.CharSequence) -> retainFrom
    java.lang.String replaceFrom(java.lang.CharSequence,char) -> replaceFrom
    java.lang.String replaceFrom(java.lang.CharSequence,java.lang.CharSequence) -> replaceFrom
    java.lang.String trimFrom(java.lang.CharSequence) -> trimFrom
    java.lang.String trimLeadingFrom(java.lang.CharSequence) -> trimLeadingFrom
    java.lang.String trimTrailingFrom(java.lang.CharSequence) -> trimTrailingFrom
    java.lang.String collapseFrom(java.lang.CharSequence,char) -> collapseFrom
    java.lang.String trimAndCollapseFrom(java.lang.CharSequence,char) -> trimAndCollapseFrom
    java.lang.String finishCollapseFrom(java.lang.CharSequence,int,int,char,java.lang.StringBuilder,boolean) -> a
    boolean apply(java.lang.Character) -> apply
    java.lang.String toString() -> toString
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
com.google.common.base.CharMatcher$1 -> i:
    void <init>() -> <init>
    boolean matches(char) -> matches
    java.lang.String toString() -> toString
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$10 -> j:
    char val$match -> a
    void <init>(java.lang.String,char) -> <init>
    boolean matches(char) -> matches
    com.google.common.base.CharMatcher and(com.google.common.base.CharMatcher) -> and
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> or
    void setBits(java.util.BitSet) -> setBits
    com.google.common.base.CharMatcher negate() -> negate
com.google.common.base.CharMatcher$11 -> k:
    char[] val$chars -> a
    void <init>(java.lang.String,char[]) -> <init>
    boolean matches(char) -> matches
    void setBits(java.util.BitSet) -> setBits
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$12 -> l:
    char val$match1 -> a
    char val$match2 -> b
    void <init>(java.lang.String,char,char) -> <init>
    boolean matches(char) -> matches
    void setBits(java.util.BitSet) -> setBits
com.google.common.base.CharMatcher$13 -> m:
    char val$startInclusive -> a
    char val$endInclusive -> b
    void <init>(java.lang.String,char,char) -> <init>
    boolean matches(char) -> matches
    void setBits(java.util.BitSet) -> setBits
com.google.common.base.CharMatcher$14 -> n:
    com.google.common.base.Predicate val$predicate -> a
    void <init>(java.lang.String,com.google.common.base.Predicate) -> <init>
    boolean matches(char) -> matches
    boolean apply(java.lang.Character) -> apply
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$15 -> o:
    void <init>(java.lang.String) -> <init>
    boolean matches(char) -> matches
    void setBits(java.util.BitSet) -> setBits
com.google.common.base.CharMatcher$2 -> p:
    void <init>(java.lang.String) -> <init>
    boolean matches(char) -> matches
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$3 -> q:
    void <init>(java.lang.String) -> <init>
    boolean matches(char) -> matches
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$4 -> r:
    void <init>(java.lang.String) -> <init>
    boolean matches(char) -> matches
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$5 -> s:
    void <init>(java.lang.String) -> <init>
    boolean matches(char) -> matches
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$6 -> t:
    void <init>(java.lang.String) -> <init>
    boolean matches(char) -> matches
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$7 -> u:
    void <init>(java.lang.String) -> <init>
    boolean matches(char) -> matches
    int indexIn(java.lang.CharSequence) -> indexIn
    int indexIn(java.lang.CharSequence,int) -> indexIn
    int lastIndexIn(java.lang.CharSequence) -> lastIndexIn
    boolean matchesAllOf(java.lang.CharSequence) -> matchesAllOf
    boolean matchesNoneOf(java.lang.CharSequence) -> matchesNoneOf
    java.lang.String removeFrom(java.lang.CharSequence) -> removeFrom
    java.lang.String replaceFrom(java.lang.CharSequence,char) -> replaceFrom
    java.lang.String replaceFrom(java.lang.CharSequence,java.lang.CharSequence) -> replaceFrom
    java.lang.String collapseFrom(java.lang.CharSequence,char) -> collapseFrom
    java.lang.String trimFrom(java.lang.CharSequence) -> trimFrom
    int countIn(java.lang.CharSequence) -> countIn
    com.google.common.base.CharMatcher and(com.google.common.base.CharMatcher) -> and
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> or
    com.google.common.base.CharMatcher negate() -> negate
com.google.common.base.CharMatcher$8 -> v:
    void <init>(java.lang.String) -> <init>
    boolean matches(char) -> matches
    int indexIn(java.lang.CharSequence) -> indexIn
    int indexIn(java.lang.CharSequence,int) -> indexIn
    int lastIndexIn(java.lang.CharSequence) -> lastIndexIn
    boolean matchesAllOf(java.lang.CharSequence) -> matchesAllOf
    boolean matchesNoneOf(java.lang.CharSequence) -> matchesNoneOf
    java.lang.String removeFrom(java.lang.CharSequence) -> removeFrom
    java.lang.String replaceFrom(java.lang.CharSequence,char) -> replaceFrom
    java.lang.String replaceFrom(java.lang.CharSequence,java.lang.CharSequence) -> replaceFrom
    java.lang.String collapseFrom(java.lang.CharSequence,char) -> collapseFrom
    java.lang.String trimFrom(java.lang.CharSequence) -> trimFrom
    java.lang.String trimLeadingFrom(java.lang.CharSequence) -> trimLeadingFrom
    java.lang.String trimTrailingFrom(java.lang.CharSequence) -> trimTrailingFrom
    int countIn(java.lang.CharSequence) -> countIn
    com.google.common.base.CharMatcher and(com.google.common.base.CharMatcher) -> and
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> or
    com.google.common.base.CharMatcher negate() -> negate
com.google.common.base.CharMatcher$9 -> w:
    char val$match -> a
    void <init>(java.lang.String,char) -> <init>
    boolean matches(char) -> matches
    java.lang.String replaceFrom(java.lang.CharSequence,char) -> replaceFrom
    com.google.common.base.CharMatcher and(com.google.common.base.CharMatcher) -> and
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> or
    com.google.common.base.CharMatcher negate() -> negate
    void setBits(java.util.BitSet) -> setBits
com.google.common.base.CharMatcher$And -> x:
    com.google.common.base.CharMatcher first -> a
    com.google.common.base.CharMatcher second -> b
    void <init>(com.google.common.base.CharMatcher,com.google.common.base.CharMatcher) -> <init>
    void <init>(com.google.common.base.CharMatcher,com.google.common.base.CharMatcher,java.lang.String) -> <init>
    boolean matches(char) -> matches
    void setBits(java.util.BitSet) -> setBits
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$BitSetMatcher -> y:
    java.util.BitSet table -> a
    void <init>(java.util.BitSet,java.lang.String) -> <init>
    boolean matches(char) -> matches
    void setBits(java.util.BitSet) -> setBits
    void <init>(java.util.BitSet,java.lang.String,byte) -> <init>
com.google.common.base.CharMatcher$FastMatcher -> z:
    void <init>(java.lang.String) -> <init>
    com.google.common.base.CharMatcher precomputed() -> precomputed
    com.google.common.base.CharMatcher negate() -> negate
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$NegatedFastMatcher -> com.google.common.base.CharMatcher$NegatedFastMatcher:
    void <init>(com.google.common.base.CharMatcher) -> <init>
    void <init>(java.lang.String,com.google.common.base.CharMatcher) -> <init>
    com.google.common.base.CharMatcher precomputed() -> precomputed
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
com.google.common.base.CharMatcher$NegatedMatcher -> A:
    com.google.common.base.CharMatcher original -> a
    void <init>(java.lang.String,com.google.common.base.CharMatcher) -> <init>
    void <init>(com.google.common.base.CharMatcher) -> <init>
    boolean matches(char) -> matches
    boolean matchesAllOf(java.lang.CharSequence) -> matchesAllOf
    boolean matchesNoneOf(java.lang.CharSequence) -> matchesNoneOf
    int countIn(java.lang.CharSequence) -> countIn
    void setBits(java.util.BitSet) -> setBits
    com.google.common.base.CharMatcher negate() -> negate
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$Or -> B:
    com.google.common.base.CharMatcher first -> a
    com.google.common.base.CharMatcher second -> b
    void <init>(com.google.common.base.CharMatcher,com.google.common.base.CharMatcher,java.lang.String) -> <init>
    void <init>(com.google.common.base.CharMatcher,com.google.common.base.CharMatcher) -> <init>
    void setBits(java.util.BitSet) -> setBits
    boolean matches(char) -> matches
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
    boolean apply(java.lang.Object) -> apply
com.google.common.base.CharMatcher$RangesMatcher -> C:
    char[] rangeStarts -> a
    char[] rangeEnds -> b
    void <init>(java.lang.String,char[],char[]) -> <init>
    boolean matches(char) -> matches
    boolean apply(java.lang.Object) -> apply
com.google.common.base.Converter -> com.google.common.base.Converter:
    boolean handleNullAutomatically -> handleNullAutomatically
    com.google.common.base.Converter reverse -> a
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    java.lang.Object doForward(java.lang.Object) -> doForward
    java.lang.Object doBackward(java.lang.Object) -> doBackward
    java.lang.Object convert(java.lang.Object) -> convert
    java.lang.Object correctedDoForward(java.lang.Object) -> correctedDoForward
    java.lang.Object correctedDoBackward(java.lang.Object) -> correctedDoBackward
    java.lang.Iterable convertAll(java.lang.Iterable) -> convertAll
    com.google.common.base.Converter reverse() -> reverse
    com.google.common.base.Converter andThen(com.google.common.base.Converter) -> andThen
    java.lang.Object apply(java.lang.Object) -> apply
    boolean equals(java.lang.Object) -> equals
    com.google.common.base.Converter identity() -> identity
com.google.common.base.Converter$1 -> D:
    java.lang.Iterable val$fromIterable -> a
    com.google.common.base.Converter this$0 -> a
    void <init>(com.google.common.base.Converter,java.lang.Iterable) -> <init>
    java.util.Iterator iterator() -> iterator
com.google.common.base.Converter$1$1 -> E:
    java.util.Iterator fromIterator -> a
    com.google.common.base.Converter$1 this$1 -> a
    void <init>(com.google.common.base.Converter$1) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.base.Converter$ConverterComposition -> com.google.common.base.Converter$ConverterComposition:
    com.google.common.base.Converter first -> first
    com.google.common.base.Converter second -> second
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.base.Converter,com.google.common.base.Converter) -> <init>
    java.lang.Object doForward(java.lang.Object) -> doForward
    java.lang.Object doBackward(java.lang.Object) -> doBackward
    java.lang.Object correctedDoForward(java.lang.Object) -> correctedDoForward
    java.lang.Object correctedDoBackward(java.lang.Object) -> correctedDoBackward
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.base.Converter$IdentityConverter -> com.google.common.base.Converter$IdentityConverter:
    com.google.common.base.Converter$IdentityConverter INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.lang.Object doForward(java.lang.Object) -> doForward
    java.lang.Object doBackward(java.lang.Object) -> doBackward
    com.google.common.base.Converter$IdentityConverter reverse() -> reverse
    com.google.common.base.Converter andThen(com.google.common.base.Converter) -> andThen
    java.lang.String toString() -> toString
    java.lang.Object readResolve() -> readResolve
    com.google.common.base.Converter reverse() -> reverse
    void <clinit>() -> <clinit>
com.google.common.base.Converter$ReverseConverter -> com.google.common.base.Converter$ReverseConverter:
    com.google.common.base.Converter original -> original
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.base.Converter) -> <init>
    java.lang.Object doForward(java.lang.Object) -> doForward
    java.lang.Object doBackward(java.lang.Object) -> doBackward
    java.lang.Object correctedDoForward(java.lang.Object) -> correctedDoForward
    java.lang.Object correctedDoBackward(java.lang.Object) -> correctedDoBackward
    com.google.common.base.Converter reverse() -> reverse
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.base.Equivalence -> com.google.common.base.Equivalence:
    void <init>() -> <init>
    boolean equivalent(java.lang.Object,java.lang.Object) -> equivalent
    boolean doEquivalent(java.lang.Object,java.lang.Object) -> doEquivalent
    int hash(java.lang.Object) -> hash
    int doHash(java.lang.Object) -> doHash
    com.google.common.base.Equivalence onResultOf(com.google.common.base.Function) -> onResultOf
    com.google.common.base.Equivalence$Wrapper wrap(java.lang.Object) -> wrap
    com.google.common.base.Equivalence pairwise() -> pairwise
    com.google.common.base.Predicate equivalentTo(java.lang.Object) -> equivalentTo
    com.google.common.base.Equivalence equals() -> equals
    com.google.common.base.Equivalence identity() -> identity
com.google.common.base.Equivalence$Equals -> com.google.common.base.Equivalence$Equals:
    com.google.common.base.Equivalence$Equals INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    boolean doEquivalent(java.lang.Object,java.lang.Object) -> doEquivalent
    int doHash(java.lang.Object) -> doHash
    java.lang.Object readResolve() -> readResolve
    void <clinit>() -> <clinit>
com.google.common.base.Equivalence$EquivalentToPredicate -> com.google.common.base.Equivalence$EquivalentToPredicate:
    com.google.common.base.Equivalence equivalence -> equivalence
    java.lang.Object target -> target
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.base.Equivalence,java.lang.Object) -> <init>
    boolean apply(java.lang.Object) -> apply
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.base.Equivalence$Identity -> com.google.common.base.Equivalence$Identity:
    com.google.common.base.Equivalence$Identity INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    boolean doEquivalent(java.lang.Object,java.lang.Object) -> doEquivalent
    int doHash(java.lang.Object) -> doHash
    java.lang.Object readResolve() -> readResolve
    void <clinit>() -> <clinit>
com.google.common.base.Equivalence$Wrapper -> com.google.common.base.Equivalence$Wrapper:
    com.google.common.base.Equivalence equivalence -> equivalence
    java.lang.Object reference -> reference
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.base.Equivalence,java.lang.Object) -> <init>
    java.lang.Object get() -> get
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    void <init>(com.google.common.base.Equivalence,java.lang.Object,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
com.google.common.base.FinalizablePhantomReference -> com.google.common.base.FinalizablePhantomReference:
    void <init>(java.lang.Object,com.google.common.base.FinalizableReferenceQueue) -> <init>
com.google.common.base.FinalizableReference -> com.google.common.base.FinalizableReference:
    void finalizeReferent() -> finalizeReferent
com.google.common.base.FinalizableReferenceQueue -> F:
    java.util.logging.Logger logger -> a
    java.lang.reflect.Method startFinalizer -> a
    java.lang.ref.ReferenceQueue queue -> a
    java.lang.ref.PhantomReference frqRef -> a
    boolean threadStarted -> a
    void <init>() -> <init>
    void close() -> close
    void cleanUp() -> a
    java.lang.reflect.Method getStartFinalizer(java.lang.Class) -> a
    java.util.logging.Logger access$000() -> a
    void <clinit>() -> <clinit>
com.google.common.base.FinalizableReferenceQueue$DecoupledLoader -> G:
    void <init>() -> <init>
    java.lang.Class loadFinalizer() -> a
com.google.common.base.FinalizableReferenceQueue$DirectLoader -> H:
    void <init>() -> <init>
    java.lang.Class loadFinalizer() -> a
com.google.common.base.FinalizableReferenceQueue$FinalizerLoader -> I:
    java.lang.Class loadFinalizer() -> a
com.google.common.base.FinalizableReferenceQueue$SystemLoader -> J:
    void <init>() -> <init>
    java.lang.Class loadFinalizer() -> a
com.google.common.base.FinalizableSoftReference -> com.google.common.base.FinalizableSoftReference:
    void <init>(java.lang.Object,com.google.common.base.FinalizableReferenceQueue) -> <init>
com.google.common.base.FinalizableWeakReference -> com.google.common.base.FinalizableWeakReference:
    void <init>(java.lang.Object,com.google.common.base.FinalizableReferenceQueue) -> <init>
com.google.common.base.Function -> com.google.common.base.Function:
    java.lang.Object apply(java.lang.Object) -> apply
    boolean equals(java.lang.Object) -> equals
com.google.common.base.FunctionalEquivalence -> com.google.common.base.FunctionalEquivalence:
    long serialVersionUID -> serialVersionUID
    com.google.common.base.Function function -> function
    com.google.common.base.Equivalence resultEquivalence -> resultEquivalence
    void <init>(com.google.common.base.Function,com.google.common.base.Equivalence) -> <init>
    boolean doEquivalent(java.lang.Object,java.lang.Object) -> doEquivalent
    int doHash(java.lang.Object) -> doHash
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.base.Joiner -> K:
    java.lang.String separator -> a
    void <init>(java.lang.String) -> <init>
    void <init>(com.google.common.base.Joiner) -> <init>
    java.lang.StringBuilder appendTo(java.lang.StringBuilder,java.util.Iterator) -> a
    com.google.common.base.Joiner useForNull(java.lang.String) -> a
    java.lang.CharSequence toString(java.lang.Object) -> a
    void <init>(com.google.common.base.Joiner,byte) -> <init>
com.google.common.base.Joiner$1 -> L:
    java.lang.String val$nullText -> b
    com.google.common.base.Joiner this$0 -> a
    void <init>(com.google.common.base.Joiner,com.google.common.base.Joiner,java.lang.String) -> <init>
    java.lang.CharSequence toString(java.lang.Object) -> a
    com.google.common.base.Joiner useForNull(java.lang.String) -> a
com.google.common.base.Joiner$MapJoiner -> M:
    com.google.common.base.Joiner joiner -> a
    java.lang.String keyValueSeparator -> a
    void <init>(com.google.common.base.Joiner,java.lang.String) -> <init>
    java.lang.StringBuilder appendTo(java.lang.StringBuilder,java.util.Iterator) -> a
    void <init>(com.google.common.base.Joiner,java.lang.String,byte) -> <init>
com.google.common.base.Objects$ToStringHelper -> N:
    java.lang.String className -> a
    com.google.common.base.Objects$ToStringHelper$ValueHolder holderHead -> a
    com.google.common.base.Objects$ToStringHelper$ValueHolder holderTail -> b
    boolean omitNullValues -> a
    void <init>(java.lang.String) -> <init>
    com.google.common.base.Objects$ToStringHelper add(java.lang.String,int) -> a
    com.google.common.base.Objects$ToStringHelper addValue(java.lang.Object) -> a
    java.lang.String toString() -> toString
    com.google.common.base.Objects$ToStringHelper$ValueHolder addHolder() -> a
    com.google.common.base.Objects$ToStringHelper addHolder(java.lang.String,java.lang.Object) -> a
    void <init>(java.lang.String,byte) -> <init>
com.google.common.base.Objects$ToStringHelper$ValueHolder -> O:
    java.lang.String name -> a
    java.lang.Object value -> a
    com.google.common.base.Objects$ToStringHelper$ValueHolder next -> a
    void <init>() -> <init>
    void <init>(byte) -> <init>
com.google.common.base.PairwiseEquivalence -> com.google.common.base.PairwiseEquivalence:
    com.google.common.base.Equivalence elementEquivalence -> elementEquivalence
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.base.Equivalence) -> <init>
    boolean doEquivalent(java.lang.Iterable,java.lang.Iterable) -> doEquivalent
    int doHash(java.lang.Iterable) -> doHash
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int doHash(java.lang.Object) -> doHash
    boolean doEquivalent(java.lang.Object,java.lang.Object) -> doEquivalent
com.google.common.base.Predicate -> com.google.common.base.Predicate:
    boolean apply(java.lang.Object) -> apply
    boolean equals(java.lang.Object) -> equals
com.google.common.base.Predicates -> com.google.common.base.Predicates:
    com.google.common.base.Predicate not(com.google.common.base.Predicate) -> a
    com.google.common.base.Predicate equalTo(java.lang.Object) -> a
    com.google.common.base.Predicate in(java.util.Collection) -> a
    void <clinit>() -> <clinit>
com.google.common.base.Predicates$InPredicate -> com.google.common.base.Predicates$InPredicate:
    java.util.Collection target -> target
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Collection) -> <init>
    boolean apply(java.lang.Object) -> apply
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    void <init>(java.util.Collection,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
com.google.common.base.Predicates$IsEqualToPredicate -> com.google.common.base.Predicates$IsEqualToPredicate:
    java.lang.Object target -> target
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Object) -> <init>
    boolean apply(java.lang.Object) -> apply
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    void <init>(java.lang.Object,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
com.google.common.base.Predicates$NotPredicate -> com.google.common.base.Predicates$NotPredicate:
    com.google.common.base.Predicate predicate -> predicate
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.base.Predicate) -> <init>
    boolean apply(java.lang.Object) -> apply
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.google.common.base.Predicates$ObjectPredicate -> com.google.common.base.Predicates$ObjectPredicate:
    com.google.common.base.Predicates$ObjectPredicate ALWAYS_TRUE -> ALWAYS_TRUE
    com.google.common.base.Predicates$ObjectPredicate ALWAYS_FALSE -> ALWAYS_FALSE
    com.google.common.base.Predicates$ObjectPredicate IS_NULL -> IS_NULL
    com.google.common.base.Predicates$ObjectPredicate NOT_NULL -> NOT_NULL
    com.google.common.base.Predicates$ObjectPredicate[] $VALUES -> a
    com.google.common.base.Predicates$ObjectPredicate[] values() -> values
    com.google.common.base.Predicates$ObjectPredicate valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    com.google.common.base.Predicate withNarrowedType() -> withNarrowedType
    void <init>(java.lang.String,int,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
    void <clinit>() -> <clinit>
com.google.common.base.Predicates$ObjectPredicate$1 -> com.google.common.base.Predicates$ObjectPredicate$1:
    void <init>(java.lang.String,int) -> <init>
    boolean apply(java.lang.Object) -> apply
    java.lang.String toString() -> toString
com.google.common.base.Predicates$ObjectPredicate$2 -> com.google.common.base.Predicates$ObjectPredicate$2:
    void <init>(java.lang.String,int) -> <init>
    boolean apply(java.lang.Object) -> apply
    java.lang.String toString() -> toString
com.google.common.base.Predicates$ObjectPredicate$3 -> com.google.common.base.Predicates$ObjectPredicate$3:
    void <init>(java.lang.String,int) -> <init>
    boolean apply(java.lang.Object) -> apply
    java.lang.String toString() -> toString
com.google.common.base.Predicates$ObjectPredicate$4 -> com.google.common.base.Predicates$ObjectPredicate$4:
    void <init>(java.lang.String,int) -> <init>
    boolean apply(java.lang.Object) -> apply
    java.lang.String toString() -> toString
com.google.common.base.SmallCharMatcher -> P:
    char[] table -> a
    boolean containsZero -> a
    long filter -> a
    void <init>(char[],long,boolean,java.lang.String) -> <init>
    int smear(int) -> a
    boolean matches(char) -> matches
    void setBits(java.util.BitSet) -> setBits
com.google.common.base.Ticker -> Q:
    com.google.common.base.Ticker SYSTEM_TICKER -> a
    void <init>() -> <init>
    long read() -> a
    com.google.common.base.Ticker systemTicker() -> a
    void <clinit>() -> <clinit>
com.google.common.base.Ticker$1 -> R:
    void <init>() -> <init>
    long read() -> a
com.google.common.base.internal.Finalizer -> S:
    java.util.logging.Logger logger -> a
    java.lang.ref.WeakReference finalizableReferenceClassReference -> a
    java.lang.ref.PhantomReference frqReference -> a
    java.lang.ref.ReferenceQueue queue -> a
    void run() -> run
    boolean cleanUp(java.lang.ref.Reference) -> a
    java.lang.reflect.Method getFinalizeReferentMethod() -> a
    java.lang.reflect.Field getInheritableThreadLocalsField() -> a
    void <clinit>() -> <clinit>
com.google.common.collect.AbstractIndexedListIterator -> T:
    int size -> a
    int position -> b
    java.lang.Object get(int) -> a
    void <init>(int,int) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    int nextIndex() -> nextIndex
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int previousIndex() -> previousIndex
com.google.common.collect.AbstractIterator -> com.google.common.collect.AbstractIterator:
    com.google.common.collect.AbstractIterator$State state -> a
    java.lang.Object next -> a
    void <init>() -> <init>
    java.lang.Object computeNext() -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.AbstractIterator$1 -> U:
    int[] $SwitchMap$com$google$common$collect$AbstractIterator$State -> a
    void <clinit>() -> <clinit>
com.google.common.collect.AbstractIterator$State -> com.google.common.collect.AbstractIterator$State:
    com.google.common.collect.AbstractIterator$State READY -> READY
    com.google.common.collect.AbstractIterator$State NOT_READY -> NOT_READY
    com.google.common.collect.AbstractIterator$State DONE -> DONE
    com.google.common.collect.AbstractIterator$State FAILED -> FAILED
    com.google.common.collect.AbstractIterator$State[] $VALUES -> a
    com.google.common.collect.AbstractIterator$State[] values() -> values
    com.google.common.collect.AbstractIterator$State valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.AbstractListMultimap -> com.google.common.collect.AbstractListMultimap:
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Map) -> <init>
    java.util.List createCollection() -> createCollection
    java.util.List createUnmodifiableEmptyCollection() -> createUnmodifiableEmptyCollection
    java.util.List get(java.lang.Object) -> get
    java.util.List removeAll(java.lang.Object) -> removeAll
    java.util.List replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    boolean put(java.lang.Object,java.lang.Object) -> put
    java.util.Map asMap() -> asMap
    boolean equals(java.lang.Object) -> equals
    java.util.Collection get(java.lang.Object) -> get
    java.util.Collection removeAll(java.lang.Object) -> removeAll
    java.util.Collection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Collection createCollection() -> createCollection
    java.util.Collection createUnmodifiableEmptyCollection() -> createUnmodifiableEmptyCollection
com.google.common.collect.AbstractMapBasedMultimap -> com.google.common.collect.AbstractMapBasedMultimap:
    java.util.Map map -> a
    int totalSize -> a
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Map) -> <init>
    void setMap(java.util.Map) -> setMap
    java.util.Collection createUnmodifiableEmptyCollection() -> createUnmodifiableEmptyCollection
    java.util.Collection createCollection() -> createCollection
    java.util.Collection createCollection(java.lang.Object) -> createCollection
    java.util.Map backingMap() -> backingMap
    int size() -> size
    boolean containsKey(java.lang.Object) -> containsKey
    boolean put(java.lang.Object,java.lang.Object) -> put
    java.util.Collection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Collection removeAll(java.lang.Object) -> removeAll
    java.util.Collection unmodifiableCollectionSubclass(java.util.Collection) -> unmodifiableCollectionSubclass
    void clear() -> clear
    java.util.Collection get(java.lang.Object) -> get
    java.util.Collection wrapCollection(java.lang.Object,java.util.Collection) -> wrapCollection
    java.util.List wrapList(java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> a
    java.util.Set createKeySet() -> createKeySet
    java.util.Collection values() -> values
    java.util.Iterator valueIterator() -> valueIterator
    java.util.Collection entries() -> entries
    java.util.Iterator entryIterator() -> entryIterator
    java.util.Map createAsMap() -> createAsMap
    java.util.Map access$000(com.google.common.collect.AbstractMapBasedMultimap) -> access$000
    java.util.Iterator access$100(com.google.common.collect.AbstractMapBasedMultimap,java.util.Collection) -> access$100
    int access$210(com.google.common.collect.AbstractMapBasedMultimap) -> access$210
    int access$208(com.google.common.collect.AbstractMapBasedMultimap) -> access$208
    int access$212(com.google.common.collect.AbstractMapBasedMultimap,int) -> access$212
    int access$220(com.google.common.collect.AbstractMapBasedMultimap,int) -> access$220
    java.util.List access$300(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> access$300
    int access$400(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object) -> access$400
com.google.common.collect.AbstractMapBasedMultimap$1 -> V:
    void <init>(com.google.common.collect.AbstractMapBasedMultimap) -> <init>
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.AbstractMapBasedMultimap$2 -> W:
    void <init>(com.google.common.collect.AbstractMapBasedMultimap) -> <init>
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.AbstractMapBasedMultimap$AsMap -> X:
    java.util.Map submap -> a
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.util.Map) -> <init>
    java.util.Set createEntrySet() -> a
    boolean containsKey(java.lang.Object) -> containsKey
    java.util.Set keySet() -> keySet
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    void clear() -> clear
    java.util.Map$Entry wrapEntry(java.util.Map$Entry) -> a
    java.lang.Object remove(java.lang.Object) -> remove
    java.lang.Object get(java.lang.Object) -> get
com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapEntries -> Y:
    com.google.common.collect.AbstractMapBasedMultimap$AsMap this$1 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap$AsMap) -> <init>
    java.util.Map map() -> a
    java.util.Iterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapIterator -> Z:
    java.util.Iterator delegateIterator -> a
    java.util.Collection collection -> a
    com.google.common.collect.AbstractMapBasedMultimap$AsMap this$1 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap$AsMap) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
com.google.common.collect.AbstractMapBasedMultimap$Itr -> aa:
    java.util.Iterator keyIterator -> a
    java.lang.Object key -> a
    java.util.Collection collection -> a
    java.util.Iterator valueIterator -> b
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap) -> <init>
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapBasedMultimap$KeySet -> ab:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.util.Map) -> <init>
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
    boolean containsAll(java.util.Collection) -> containsAll
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.google.common.collect.AbstractMapBasedMultimap$KeySet$1 -> ac:
    java.util.Map$Entry entry -> a
    java.util.Iterator val$entryIterator -> a
    com.google.common.collect.AbstractMapBasedMultimap$KeySet this$1 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap$KeySet,java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapBasedMultimap$NavigableAsMap -> ad:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.util.NavigableMap) -> <init>
    java.util.Map$Entry lowerEntry(java.lang.Object) -> lowerEntry
    java.lang.Object lowerKey(java.lang.Object) -> lowerKey
    java.util.Map$Entry floorEntry(java.lang.Object) -> floorEntry
    java.lang.Object floorKey(java.lang.Object) -> floorKey
    java.util.Map$Entry ceilingEntry(java.lang.Object) -> ceilingEntry
    java.lang.Object ceilingKey(java.lang.Object) -> ceilingKey
    java.util.Map$Entry higherEntry(java.lang.Object) -> higherEntry
    java.lang.Object higherKey(java.lang.Object) -> higherKey
    java.util.Map$Entry firstEntry() -> firstEntry
    java.util.Map$Entry lastEntry() -> lastEntry
    java.util.Map$Entry pollFirstEntry() -> pollFirstEntry
    java.util.Map$Entry pollLastEntry() -> pollLastEntry
    java.util.Map$Entry pollAsMapEntry(java.util.Iterator) -> a
    java.util.NavigableMap descendingMap() -> descendingMap
    java.util.NavigableSet createKeySet() -> a
    java.util.NavigableSet navigableKeySet() -> navigableKeySet
    java.util.NavigableSet descendingKeySet() -> descendingKeySet
    java.util.NavigableMap subMap(java.lang.Object,boolean,java.lang.Object,boolean) -> subMap
    java.util.NavigableMap headMap(java.lang.Object,boolean) -> headMap
    java.util.NavigableMap tailMap(java.lang.Object,boolean) -> tailMap
    java.util.SortedSet createKeySet() -> a
    java.util.SortedSet keySet() -> b
    java.util.SortedMap tailMap(java.lang.Object) -> tailMap
    java.util.SortedMap subMap(java.lang.Object,java.lang.Object) -> subMap
    java.util.SortedMap headMap(java.lang.Object) -> headMap
    java.util.SortedMap sortedMap() -> a
    java.util.Set keySet() -> keySet
    java.util.Set createKeySet() -> b
com.google.common.collect.AbstractMapBasedMultimap$NavigableKeySet -> ae:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.util.NavigableMap) -> <init>
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.lang.Object pollFirst() -> pollFirst
    java.lang.Object pollLast() -> pollLast
    java.util.NavigableSet descendingSet() -> descendingSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedMap sortedMap() -> a
com.google.common.collect.AbstractMapBasedMultimap$RandomAccessWrappedList -> af:
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> <init>
com.google.common.collect.AbstractMapBasedMultimap$SortedAsMap -> ag:
    java.util.SortedSet sortedKeySet -> a
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.util.SortedMap) -> <init>
    java.util.SortedMap sortedMap() -> a
    java.util.Comparator comparator() -> comparator
    java.lang.Object firstKey() -> firstKey
    java.lang.Object lastKey() -> lastKey
    java.util.SortedMap headMap(java.lang.Object) -> headMap
    java.util.SortedMap subMap(java.lang.Object,java.lang.Object) -> subMap
    java.util.SortedMap tailMap(java.lang.Object) -> tailMap
    java.util.SortedSet keySet() -> b
    java.util.SortedSet createKeySet() -> a
    java.util.Set keySet() -> keySet
    java.util.Set createKeySet() -> b
com.google.common.collect.AbstractMapBasedMultimap$SortedKeySet -> ah:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.util.SortedMap) -> <init>
    java.util.SortedMap sortedMap() -> a
    java.util.Comparator comparator() -> comparator
    java.lang.Object first() -> first
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.lang.Object last() -> last
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection -> ai:
    java.lang.Object key -> a
    java.util.Collection delegate -> a
    com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection ancestor -> a
    java.util.Collection ancestorDelegate -> b
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.Collection,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> <init>
    void refreshIfEmpty() -> a
    void removeIfEmpty() -> b
    void addToMap() -> c
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    boolean add(java.lang.Object) -> add
    boolean addAll(java.util.Collection) -> addAll
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    void clear() -> clear
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator -> aj:
    java.util.Iterator delegateIterator -> a
    java.util.Collection originalDelegate -> a
    com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection this$1 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> <init>
    void <init>(com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection,java.util.Iterator) -> <init>
    void validateIterator() -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapBasedMultimap$WrappedList -> ak:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.List,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> <init>
    java.util.List getListDelegate() -> a
    boolean addAll(int,java.util.Collection) -> addAll
    java.lang.Object get(int) -> get
    java.lang.Object set(int,java.lang.Object) -> set
    void add(int,java.lang.Object) -> add
    java.lang.Object remove(int) -> remove
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.util.ListIterator listIterator() -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.List subList(int,int) -> subList
com.google.common.collect.AbstractMapBasedMultimap$WrappedList$WrappedListIterator -> al:
    com.google.common.collect.AbstractMapBasedMultimap$WrappedList this$1 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultimap$WrappedList) -> <init>
    void <init>(com.google.common.collect.AbstractMapBasedMultimap$WrappedList,int) -> <init>
    java.util.ListIterator getDelegateListIterator() -> a
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
    void set(java.lang.Object) -> set
    void add(java.lang.Object) -> add
com.google.common.collect.AbstractMapBasedMultimap$WrappedNavigableSet -> am:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.NavigableSet,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> <init>
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.lang.Object pollFirst() -> pollFirst
    java.lang.Object pollLast() -> pollLast
    java.util.NavigableSet wrap(java.util.NavigableSet) -> a
    java.util.NavigableSet descendingSet() -> descendingSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.SortedSet getSortedSetDelegate() -> a
com.google.common.collect.AbstractMapBasedMultimap$WrappedSet -> an:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.Set) -> <init>
    boolean removeAll(java.util.Collection) -> removeAll
com.google.common.collect.AbstractMapBasedMultimap$WrappedSortedSet -> ao:
    com.google.common.collect.AbstractMapBasedMultimap this$0 -> b
    void <init>(com.google.common.collect.AbstractMapBasedMultimap,java.lang.Object,java.util.SortedSet,com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection) -> <init>
    java.util.SortedSet getSortedSetDelegate() -> a
    java.util.Comparator comparator() -> comparator
    java.lang.Object first() -> first
    java.lang.Object last() -> last
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
com.google.common.collect.AbstractMapBasedMultiset -> com.google.common.collect.AbstractMapBasedMultiset:
    java.util.Map backingMap -> a
    long size -> a
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Map) -> <init>
    void setBackingMap(java.util.Map) -> setBackingMap
    java.util.Set entrySet() -> entrySet
    java.util.Iterator entryIterator() -> entryIterator
    void clear() -> clear
    int distinctElements() -> distinctElements
    int size() -> size
    java.util.Iterator iterator() -> iterator
    int count(java.lang.Object) -> count
    int add(java.lang.Object,int) -> add
    int remove(java.lang.Object,int) -> remove
    int setCount(java.lang.Object,int) -> setCount
    int getAndSet(com.google.common.collect.Count,int) -> a
    java.util.Map access$000(com.google.common.collect.AbstractMapBasedMultiset) -> access$000
    long access$122(com.google.common.collect.AbstractMapBasedMultiset,long) -> access$122
    long access$110(com.google.common.collect.AbstractMapBasedMultiset) -> access$110
com.google.common.collect.AbstractMapBasedMultiset$1 -> ap:
    java.util.Map$Entry toRemove -> a
    java.util.Iterator val$backingEntries -> a
    com.google.common.collect.AbstractMapBasedMultiset this$0 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultiset,java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
com.google.common.collect.AbstractMapBasedMultiset$1$1 -> aq:
    java.util.Map$Entry val$mapEntry -> a
    com.google.common.collect.AbstractMapBasedMultiset$1 this$1 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultiset$1,java.util.Map$Entry) -> <init>
    java.lang.Object getElement() -> getElement
    int getCount() -> getCount
com.google.common.collect.AbstractMapBasedMultiset$MapBasedMultisetIterator -> ar:
    java.util.Iterator entryIterator -> a
    java.util.Map$Entry currentEntry -> a
    int occurrencesLeft -> a
    boolean canRemove -> a
    com.google.common.collect.AbstractMapBasedMultiset this$0 -> a
    void <init>(com.google.common.collect.AbstractMapBasedMultiset) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.AbstractMapEntry -> as:
    void <init>() -> <init>
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.AbstractMultimap -> at:
    java.util.Collection entries -> a
    java.util.Set keySet -> a
    com.google.common.collect.Multiset keys -> a
    java.util.Collection values -> b
    java.util.Map asMap -> a
    void <init>() -> <init>
    boolean isEmpty() -> isEmpty
    boolean containsValue(java.lang.Object) -> containsValue
    boolean containsEntry(java.lang.Object,java.lang.Object) -> containsEntry
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    boolean put(java.lang.Object,java.lang.Object) -> put
    boolean putAll(java.lang.Object,java.lang.Iterable) -> putAll
    boolean putAll(com.google.common.collect.Multimap) -> putAll
    java.util.Collection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Collection entries() -> entries
    java.util.Collection createEntries() -> createEntries
    java.util.Iterator entryIterator() -> entryIterator
    java.util.Set keySet() -> keySet
    java.util.Set createKeySet() -> createKeySet
    com.google.common.collect.Multiset keys() -> keys
    com.google.common.collect.Multiset createKeys() -> createKeys
    java.util.Collection values() -> values
    java.util.Collection createValues() -> createValues
    java.util.Iterator valueIterator() -> valueIterator
    java.util.Map asMap() -> asMap
    java.util.Map createAsMap() -> createAsMap
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.AbstractMultimap$Entries -> au:
    com.google.common.collect.AbstractMultimap this$0 -> a
    void <init>(com.google.common.collect.AbstractMultimap) -> <init>
    com.google.common.collect.Multimap multimap() -> a
    java.util.Iterator iterator() -> iterator
    void <init>(com.google.common.collect.AbstractMultimap,byte) -> <init>
com.google.common.collect.AbstractMultimap$EntrySet -> av:
    void <init>(com.google.common.collect.AbstractMultimap) -> <init>
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    void <init>(com.google.common.collect.AbstractMultimap,byte) -> <init>
com.google.common.collect.AbstractMultimap$Values -> aw:
    com.google.common.collect.AbstractMultimap this$0 -> a
    void <init>(com.google.common.collect.AbstractMultimap) -> <init>
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    void clear() -> clear
com.google.common.collect.AbstractMultiset -> ax:
    java.util.Set elementSet -> a
    java.util.Set entrySet -> b
    void <init>() -> <init>
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    java.util.Iterator iterator() -> iterator
    int count(java.lang.Object) -> count
    boolean add(java.lang.Object) -> add
    int add(java.lang.Object,int) -> add
    boolean remove(java.lang.Object) -> remove
    int remove(java.lang.Object,int) -> remove
    int setCount(java.lang.Object,int) -> setCount
    boolean setCount(java.lang.Object,int,int) -> setCount
    boolean addAll(java.util.Collection) -> addAll
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    java.util.Set elementSet() -> elementSet
    java.util.Set createElementSet() -> createElementSet
    java.util.Iterator entryIterator() -> entryIterator
    int distinctElements() -> distinctElements
    java.util.Set entrySet() -> entrySet
    java.util.Set createEntrySet() -> createEntrySet
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.AbstractMultiset$ElementSet -> ay:
    com.google.common.collect.AbstractMultiset this$0 -> a
    void <init>(com.google.common.collect.AbstractMultiset) -> <init>
    com.google.common.collect.Multiset multiset() -> a
com.google.common.collect.AbstractMultiset$EntrySet -> az:
    com.google.common.collect.AbstractMultiset this$0 -> a
    void <init>(com.google.common.collect.AbstractMultiset) -> <init>
    com.google.common.collect.Multiset multiset() -> a
    java.util.Iterator iterator() -> iterator
    int size() -> size
com.google.common.collect.AbstractSequentialIterator -> aA:
    java.lang.Object nextOrNull -> a
    void <init>(java.lang.Object) -> <init>
    java.lang.Object computeNext(java.lang.Object) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.AbstractSetMultimap -> com.google.common.collect.AbstractSetMultimap:
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Map) -> <init>
    java.util.Set createCollection() -> createCollection
    java.util.Set createUnmodifiableEmptyCollection() -> createUnmodifiableEmptyCollection
    java.util.Set get(java.lang.Object) -> get
    java.util.Set entries() -> entries
    java.util.Set removeAll(java.lang.Object) -> removeAll
    java.util.Set replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Map asMap() -> asMap
    boolean put(java.lang.Object,java.lang.Object) -> put
    boolean equals(java.lang.Object) -> equals
    java.util.Collection entries() -> entries
    java.util.Collection get(java.lang.Object) -> get
    java.util.Collection removeAll(java.lang.Object) -> removeAll
    java.util.Collection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Collection createCollection() -> createCollection
    java.util.Collection createUnmodifiableEmptyCollection() -> createUnmodifiableEmptyCollection
com.google.common.collect.AbstractSortedKeySortedSetMultimap -> com.google.common.collect.AbstractSortedKeySortedSetMultimap:
    void <init>(java.util.SortedMap) -> <init>
    java.util.SortedMap asMap() -> asMap
    java.util.SortedMap backingMap() -> backingMap
    java.util.SortedSet keySet() -> keySet
    java.util.Map asMap() -> asMap
    java.util.Set keySet() -> keySet
    java.util.Map backingMap() -> backingMap
com.google.common.collect.AbstractSortedSetMultimap -> com.google.common.collect.AbstractSortedSetMultimap:
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Map) -> <init>
    java.util.SortedSet createCollection() -> createCollection
    java.util.SortedSet createUnmodifiableEmptyCollection() -> createUnmodifiableEmptyCollection
    java.util.SortedSet get(java.lang.Object) -> get
    java.util.SortedSet removeAll(java.lang.Object) -> removeAll
    java.util.SortedSet replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Map asMap() -> asMap
    java.util.Collection values() -> values
    java.util.Set replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Set removeAll(java.lang.Object) -> removeAll
    java.util.Set get(java.lang.Object) -> get
    java.util.Set createUnmodifiableEmptyCollection() -> createUnmodifiableEmptyCollection
    java.util.Set createCollection() -> createCollection
    java.util.Collection get(java.lang.Object) -> get
    java.util.Collection removeAll(java.lang.Object) -> removeAll
    java.util.Collection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Collection createCollection() -> createCollection
    java.util.Collection createUnmodifiableEmptyCollection() -> createUnmodifiableEmptyCollection
com.google.common.collect.AllEqualOrdering -> com.google.common.collect.AllEqualOrdering:
    com.google.common.collect.AllEqualOrdering INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    java.util.List sortedCopy(java.lang.Iterable) -> sortedCopy
    com.google.common.collect.ImmutableList immutableSortedCopy(java.lang.Iterable) -> immutableSortedCopy
    com.google.common.collect.Ordering reverse() -> reverse
    java.lang.Object readResolve() -> readResolve
    java.lang.String toString() -> toString
    void <clinit>() -> <clinit>
com.google.common.collect.ArrayListMultimap -> com.google.common.collect.ArrayListMultimap:
    int expectedValuesPerKey -> expectedValuesPerKey
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.ArrayListMultimap create() -> create
    com.google.common.collect.ArrayListMultimap create(int,int) -> create
    com.google.common.collect.ArrayListMultimap create(com.google.common.collect.Multimap) -> create
    void <init>() -> <init>
    void <init>(int,int) -> <init>
    void <init>(com.google.common.collect.Multimap) -> <init>
    java.util.List createCollection() -> createCollection
    void trimToSize() -> trimToSize
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
    boolean equals(java.lang.Object) -> equals
    java.util.Map asMap() -> asMap
    boolean put(java.lang.Object,java.lang.Object) -> put
    java.util.List replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.List removeAll(java.lang.Object) -> removeAll
    java.util.List get(java.lang.Object) -> get
    java.util.Collection entries() -> entries
    java.util.Collection values() -> values
    void clear() -> clear
    boolean containsKey(java.lang.Object) -> containsKey
    int size() -> size
    java.util.Collection createCollection() -> createCollection
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    com.google.common.collect.Multiset keys() -> keys
    java.util.Set keySet() -> keySet
    boolean putAll(com.google.common.collect.Multimap) -> putAll
    boolean putAll(java.lang.Object,java.lang.Iterable) -> putAll
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    boolean containsEntry(java.lang.Object,java.lang.Object) -> containsEntry
    boolean containsValue(java.lang.Object) -> containsValue
    boolean isEmpty() -> isEmpty
com.google.common.collect.BiMap -> aB:
com.google.common.collect.BoundType -> com.google.common.collect.BoundType:
    com.google.common.collect.BoundType OPEN -> OPEN
    com.google.common.collect.BoundType CLOSED -> CLOSED
    com.google.common.collect.BoundType[] $VALUES -> a
    com.google.common.collect.BoundType[] values() -> values
    com.google.common.collect.BoundType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.BoundType forBoolean(boolean) -> forBoolean
    com.google.common.collect.BoundType flip() -> flip
    void <init>(java.lang.String,int,com.google.common.collect.BoundType$1) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.BoundType$1 -> com.google.common.collect.BoundType$1:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.BoundType flip() -> flip
com.google.common.collect.BoundType$2 -> com.google.common.collect.BoundType$2:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.BoundType flip() -> flip
com.google.common.collect.ByFunctionOrdering -> com.google.common.collect.ByFunctionOrdering:
    com.google.common.base.Function function -> function
    com.google.common.collect.Ordering ordering -> ordering
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.base.Function,com.google.common.collect.Ordering) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.Collections2 -> aC:
    com.google.common.base.Joiner STANDARD_JOINER -> a
    boolean safeContains(java.util.Collection,java.lang.Object) -> a
    boolean containsAllImpl(java.util.Collection,java.util.Collection) -> a
    java.lang.String toStringImpl(java.util.Collection) -> a
    java.lang.StringBuilder newStringBuilderForCollection(int) -> a
    java.util.Collection cast(java.lang.Iterable) -> a
    void <clinit>() -> <clinit>
com.google.common.collect.Collections2$1 -> aD:
    java.util.Collection val$collection -> a
    void <init>(java.util.Collection) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.ComparatorOrdering -> com.google.common.collect.ComparatorOrdering:
    java.util.Comparator comparator -> comparator
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Comparator) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.ComparisonChain -> aE:
    com.google.common.collect.ComparisonChain ACTIVE -> a
    com.google.common.collect.ComparisonChain LESS -> b
    com.google.common.collect.ComparisonChain GREATER -> c
    void <init>() -> <init>
    com.google.common.collect.ComparisonChain start() -> a
    com.google.common.collect.ComparisonChain compare(java.lang.Comparable,java.lang.Comparable) -> a
    int result() -> a
    void <init>(byte) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.ComparisonChain$1 -> aF:
    void <init>() -> <init>
    com.google.common.collect.ComparisonChain compare(java.lang.Comparable,java.lang.Comparable) -> a
    int result() -> a
com.google.common.collect.ComparisonChain$InactiveComparisonChain -> aG:
    int result -> a
    void <init>(int) -> <init>
    com.google.common.collect.ComparisonChain compare(java.lang.Comparable,java.lang.Comparable) -> a
    int result() -> a
com.google.common.collect.CompoundOrdering -> com.google.common.collect.CompoundOrdering:
    com.google.common.collect.ImmutableList comparators -> comparators
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Comparator,java.util.Comparator) -> <init>
    void <init>(java.lang.Iterable) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.ComputationException -> com.google.common.collect.ComputationException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Throwable) -> <init>
com.google.common.collect.ComputingConcurrentHashMap -> com.google.common.collect.ComputingConcurrentHashMap:
    com.google.common.base.Function computingFunction -> computingFunction
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.MapMaker,com.google.common.base.Function) -> <init>
    com.google.common.collect.MapMakerInternalMap$Segment createSegment(int,int) -> createSegment
    com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment segmentFor(int) -> segmentFor
    java.lang.Object getOrCompute(java.lang.Object) -> getOrCompute
    java.lang.Object writeReplace() -> writeReplace
    com.google.common.collect.MapMakerInternalMap$Segment segmentFor(int) -> segmentFor
com.google.common.collect.ComputingConcurrentHashMap$ComputationExceptionReference -> aH:
    java.lang.Throwable t -> a
    void <init>(java.lang.Throwable) -> <init>
    java.lang.Object get() -> get
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry() -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    boolean isComputingReference() -> a
    java.lang.Object waitForValue() -> a
    void clear(com.google.common.collect.MapMakerInternalMap$ValueReference) -> a
com.google.common.collect.ComputingConcurrentHashMap$ComputedReference -> aI:
    java.lang.Object value -> a
    void <init>(java.lang.Object) -> <init>
    java.lang.Object get() -> get
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry() -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    boolean isComputingReference() -> a
    java.lang.Object waitForValue() -> a
    void clear(com.google.common.collect.MapMakerInternalMap$ValueReference) -> a
com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment -> com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment:
    void <init>(com.google.common.collect.MapMakerInternalMap,int,int) -> <init>
    java.lang.Object getOrCompute(java.lang.Object,int,com.google.common.base.Function) -> getOrCompute
    java.lang.Object compute(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference) -> compute
com.google.common.collect.ComputingConcurrentHashMap$ComputingSerializationProxy -> com.google.common.collect.ComputingConcurrentHashMap$ComputingSerializationProxy:
    com.google.common.base.Function computingFunction -> computingFunction
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.MapMakerInternalMap$Strength,com.google.common.collect.MapMakerInternalMap$Strength,com.google.common.base.Equivalence,com.google.common.base.Equivalence,long,long,int,int,com.google.common.collect.MapMaker$RemovalListener,java.util.concurrent.ConcurrentMap,com.google.common.base.Function) -> <init>
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference -> aJ:
    com.google.common.base.Function computingFunction -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference computedReference -> a
    void <init>(com.google.common.base.Function) -> <init>
    java.lang.Object get() -> get
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry() -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    boolean isComputingReference() -> a
    java.lang.Object waitForValue() -> a
    void clear(com.google.common.collect.MapMakerInternalMap$ValueReference) -> a
    java.lang.Object compute$1fb5a060(java.lang.Object) -> a
    void setValueReference(com.google.common.collect.MapMakerInternalMap$ValueReference) -> b
com.google.common.collect.ContiguousSet -> com.google.common.collect.ContiguousSet:
    com.google.common.collect.DiscreteDomain domain -> domain
    com.google.common.collect.ContiguousSet create(com.google.common.collect.Range,com.google.common.collect.DiscreteDomain) -> create
    void <init>(com.google.common.collect.DiscreteDomain) -> <init>
    com.google.common.collect.ContiguousSet headSet(java.lang.Comparable) -> headSet
    com.google.common.collect.ContiguousSet headSet(java.lang.Comparable,boolean) -> headSet
    com.google.common.collect.ContiguousSet subSet(java.lang.Comparable,java.lang.Comparable) -> subSet
    com.google.common.collect.ContiguousSet subSet(java.lang.Comparable,boolean,java.lang.Comparable,boolean) -> subSet
    com.google.common.collect.ContiguousSet tailSet(java.lang.Comparable) -> tailSet
    com.google.common.collect.ContiguousSet tailSet(java.lang.Comparable,boolean) -> tailSet
    com.google.common.collect.ContiguousSet headSetImpl(java.lang.Comparable,boolean) -> headSetImpl
    com.google.common.collect.ContiguousSet subSetImpl(java.lang.Comparable,boolean,java.lang.Comparable,boolean) -> subSetImpl
    com.google.common.collect.ContiguousSet tailSetImpl(java.lang.Comparable,boolean) -> tailSetImpl
    com.google.common.collect.ContiguousSet intersection(com.google.common.collect.ContiguousSet) -> intersection
    com.google.common.collect.Range range() -> range
    com.google.common.collect.Range range(com.google.common.collect.BoundType,com.google.common.collect.BoundType) -> range
    java.lang.String toString() -> toString
    com.google.common.collect.ImmutableSortedSet$Builder builder() -> builder
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> tailSetImpl
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> subSetImpl
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> headSetImpl
    com.google.common.collect.ImmutableSortedSet tailSet(java.lang.Object,boolean) -> tailSet
    com.google.common.collect.ImmutableSortedSet tailSet(java.lang.Object) -> tailSet
    com.google.common.collect.ImmutableSortedSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    com.google.common.collect.ImmutableSortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    com.google.common.collect.ImmutableSortedSet headSet(java.lang.Object,boolean) -> headSet
    com.google.common.collect.ImmutableSortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
com.google.common.collect.Count -> com.google.common.collect.Count:
    int value -> value
    void <init>(int) -> <init>
    int get() -> get
    int getAndAdd(int) -> getAndAdd
    int addAndGet(int) -> addAndGet
    void set(int) -> set
    int getAndSet(int) -> getAndSet
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.google.common.collect.Cut -> com.google.common.collect.Cut:
    java.lang.Comparable endpoint -> endpoint
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Comparable) -> <init>
    boolean isLessThan(java.lang.Comparable) -> isLessThan
    com.google.common.collect.BoundType typeAsLowerBound() -> typeAsLowerBound
    com.google.common.collect.BoundType typeAsUpperBound() -> typeAsUpperBound
    com.google.common.collect.Cut withLowerBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withLowerBoundType
    com.google.common.collect.Cut withUpperBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withUpperBoundType
    void describeAsLowerBound(java.lang.StringBuilder) -> describeAsLowerBound
    void describeAsUpperBound(java.lang.StringBuilder) -> describeAsUpperBound
    java.lang.Comparable leastValueAbove(com.google.common.collect.DiscreteDomain) -> leastValueAbove
    java.lang.Comparable greatestValueBelow(com.google.common.collect.DiscreteDomain) -> greatestValueBelow
    com.google.common.collect.Cut canonical(com.google.common.collect.DiscreteDomain) -> canonical
    int compareTo(com.google.common.collect.Cut) -> compareTo
    java.lang.Comparable endpoint() -> endpoint
    boolean equals(java.lang.Object) -> equals
    com.google.common.collect.Cut belowAll() -> belowAll
    com.google.common.collect.Cut aboveAll() -> aboveAll
    com.google.common.collect.Cut belowValue(java.lang.Comparable) -> belowValue
    com.google.common.collect.Cut aboveValue(java.lang.Comparable) -> aboveValue
    int compareTo(java.lang.Object) -> compareTo
com.google.common.collect.Cut$1 -> aK:
    int[] $SwitchMap$com$google$common$collect$BoundType -> a
    void <clinit>() -> <clinit>
com.google.common.collect.Cut$AboveAll -> com.google.common.collect.Cut$AboveAll:
    com.google.common.collect.Cut$AboveAll INSTANCE -> a
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.lang.Comparable endpoint() -> endpoint
    boolean isLessThan(java.lang.Comparable) -> isLessThan
    com.google.common.collect.BoundType typeAsLowerBound() -> typeAsLowerBound
    com.google.common.collect.BoundType typeAsUpperBound() -> typeAsUpperBound
    com.google.common.collect.Cut withLowerBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withLowerBoundType
    com.google.common.collect.Cut withUpperBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withUpperBoundType
    void describeAsLowerBound(java.lang.StringBuilder) -> describeAsLowerBound
    void describeAsUpperBound(java.lang.StringBuilder) -> describeAsUpperBound
    java.lang.Comparable leastValueAbove(com.google.common.collect.DiscreteDomain) -> leastValueAbove
    java.lang.Comparable greatestValueBelow(com.google.common.collect.DiscreteDomain) -> greatestValueBelow
    int compareTo(com.google.common.collect.Cut) -> compareTo
    java.lang.String toString() -> toString
    java.lang.Object readResolve() -> readResolve
    int compareTo(java.lang.Object) -> compareTo
    com.google.common.collect.Cut$AboveAll access$100() -> access$100
    void <clinit>() -> <clinit>
com.google.common.collect.Cut$AboveValue -> com.google.common.collect.Cut$AboveValue:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Comparable) -> <init>
    boolean isLessThan(java.lang.Comparable) -> isLessThan
    com.google.common.collect.BoundType typeAsLowerBound() -> typeAsLowerBound
    com.google.common.collect.BoundType typeAsUpperBound() -> typeAsUpperBound
    com.google.common.collect.Cut withLowerBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withLowerBoundType
    com.google.common.collect.Cut withUpperBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withUpperBoundType
    void describeAsLowerBound(java.lang.StringBuilder) -> describeAsLowerBound
    void describeAsUpperBound(java.lang.StringBuilder) -> describeAsUpperBound
    java.lang.Comparable leastValueAbove(com.google.common.collect.DiscreteDomain) -> leastValueAbove
    java.lang.Comparable greatestValueBelow(com.google.common.collect.DiscreteDomain) -> greatestValueBelow
    com.google.common.collect.Cut canonical(com.google.common.collect.DiscreteDomain) -> canonical
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compareTo(java.lang.Object) -> compareTo
com.google.common.collect.Cut$BelowAll -> com.google.common.collect.Cut$BelowAll:
    com.google.common.collect.Cut$BelowAll INSTANCE -> a
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.lang.Comparable endpoint() -> endpoint
    boolean isLessThan(java.lang.Comparable) -> isLessThan
    com.google.common.collect.BoundType typeAsLowerBound() -> typeAsLowerBound
    com.google.common.collect.BoundType typeAsUpperBound() -> typeAsUpperBound
    com.google.common.collect.Cut withLowerBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withLowerBoundType
    com.google.common.collect.Cut withUpperBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withUpperBoundType
    void describeAsLowerBound(java.lang.StringBuilder) -> describeAsLowerBound
    void describeAsUpperBound(java.lang.StringBuilder) -> describeAsUpperBound
    java.lang.Comparable leastValueAbove(com.google.common.collect.DiscreteDomain) -> leastValueAbove
    java.lang.Comparable greatestValueBelow(com.google.common.collect.DiscreteDomain) -> greatestValueBelow
    com.google.common.collect.Cut canonical(com.google.common.collect.DiscreteDomain) -> canonical
    int compareTo(com.google.common.collect.Cut) -> compareTo
    java.lang.String toString() -> toString
    java.lang.Object readResolve() -> readResolve
    int compareTo(java.lang.Object) -> compareTo
    com.google.common.collect.Cut$BelowAll access$000() -> access$000
    void <clinit>() -> <clinit>
com.google.common.collect.Cut$BelowValue -> com.google.common.collect.Cut$BelowValue:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Comparable) -> <init>
    boolean isLessThan(java.lang.Comparable) -> isLessThan
    com.google.common.collect.BoundType typeAsLowerBound() -> typeAsLowerBound
    com.google.common.collect.BoundType typeAsUpperBound() -> typeAsUpperBound
    com.google.common.collect.Cut withLowerBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withLowerBoundType
    com.google.common.collect.Cut withUpperBoundType(com.google.common.collect.BoundType,com.google.common.collect.DiscreteDomain) -> withUpperBoundType
    void describeAsLowerBound(java.lang.StringBuilder) -> describeAsLowerBound
    void describeAsUpperBound(java.lang.StringBuilder) -> describeAsUpperBound
    java.lang.Comparable leastValueAbove(com.google.common.collect.DiscreteDomain) -> leastValueAbove
    java.lang.Comparable greatestValueBelow(com.google.common.collect.DiscreteDomain) -> greatestValueBelow
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compareTo(java.lang.Object) -> compareTo
com.google.common.collect.DescendingImmutableSortedSet -> com.google.common.collect.DescendingImmutableSortedSet:
    com.google.common.collect.ImmutableSortedSet forward -> forward
    void <init>(com.google.common.collect.ImmutableSortedSet) -> <init>
    int size() -> size
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> headSetImpl
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> subSetImpl
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> tailSetImpl
    com.google.common.collect.ImmutableSortedSet descendingSet() -> descendingSet
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> descendingIterator
    com.google.common.collect.ImmutableSortedSet createDescendingSet() -> createDescendingSet
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    int indexOf(java.lang.Object) -> indexOf
    boolean isPartialView() -> isPartialView
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet descendingSet() -> descendingSet
    java.util.Iterator iterator() -> iterator
com.google.common.collect.DiscreteDomain -> com.google.common.collect.DiscreteDomain:
    com.google.common.collect.DiscreteDomain integers() -> integers
    com.google.common.collect.DiscreteDomain longs() -> longs
    com.google.common.collect.DiscreteDomain bigIntegers() -> bigIntegers
    void <init>() -> <init>
    java.lang.Comparable next(java.lang.Comparable) -> next
    java.lang.Comparable previous(java.lang.Comparable) -> previous
    long distance(java.lang.Comparable,java.lang.Comparable) -> distance
    java.lang.Comparable minValue() -> minValue
    java.lang.Comparable maxValue() -> maxValue
com.google.common.collect.DiscreteDomain$BigIntegerDomain -> com.google.common.collect.DiscreteDomain$BigIntegerDomain:
    com.google.common.collect.DiscreteDomain$BigIntegerDomain INSTANCE -> a
    java.math.BigInteger MIN_LONG -> a
    java.math.BigInteger MAX_LONG -> b
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.math.BigInteger next(java.math.BigInteger) -> next
    java.math.BigInteger previous(java.math.BigInteger) -> previous
    long distance(java.math.BigInteger,java.math.BigInteger) -> distance
    java.lang.Object readResolve() -> readResolve
    java.lang.String toString() -> toString
    long distance(java.lang.Comparable,java.lang.Comparable) -> distance
    java.lang.Comparable previous(java.lang.Comparable) -> previous
    java.lang.Comparable next(java.lang.Comparable) -> next
    com.google.common.collect.DiscreteDomain$BigIntegerDomain access$200() -> access$200
    void <clinit>() -> <clinit>
com.google.common.collect.DiscreteDomain$IntegerDomain -> com.google.common.collect.DiscreteDomain$IntegerDomain:
    com.google.common.collect.DiscreteDomain$IntegerDomain INSTANCE -> a
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.lang.Integer next(java.lang.Integer) -> next
    java.lang.Integer previous(java.lang.Integer) -> previous
    long distance(java.lang.Integer,java.lang.Integer) -> distance
    java.lang.Integer minValue() -> minValue
    java.lang.Integer maxValue() -> maxValue
    java.lang.Object readResolve() -> readResolve
    java.lang.String toString() -> toString
    java.lang.Comparable maxValue() -> maxValue
    java.lang.Comparable minValue() -> minValue
    long distance(java.lang.Comparable,java.lang.Comparable) -> distance
    java.lang.Comparable previous(java.lang.Comparable) -> previous
    java.lang.Comparable next(java.lang.Comparable) -> next
    com.google.common.collect.DiscreteDomain$IntegerDomain access$000() -> access$000
    void <clinit>() -> <clinit>
com.google.common.collect.DiscreteDomain$LongDomain -> com.google.common.collect.DiscreteDomain$LongDomain:
    com.google.common.collect.DiscreteDomain$LongDomain INSTANCE -> a
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.lang.Long next(java.lang.Long) -> next
    java.lang.Long previous(java.lang.Long) -> previous
    long distance(java.lang.Long,java.lang.Long) -> distance
    java.lang.Long minValue() -> minValue
    java.lang.Long maxValue() -> maxValue
    java.lang.Object readResolve() -> readResolve
    java.lang.String toString() -> toString
    java.lang.Comparable maxValue() -> maxValue
    java.lang.Comparable minValue() -> minValue
    long distance(java.lang.Comparable,java.lang.Comparable) -> distance
    java.lang.Comparable previous(java.lang.Comparable) -> previous
    java.lang.Comparable next(java.lang.Comparable) -> next
    com.google.common.collect.DiscreteDomain$LongDomain access$100() -> access$100
    void <clinit>() -> <clinit>
com.google.common.collect.EmptyContiguousSet -> com.google.common.collect.EmptyContiguousSet:
    void <init>(com.google.common.collect.DiscreteDomain) -> <init>
    java.lang.Comparable first() -> first
    java.lang.Comparable last() -> last
    int size() -> size
    com.google.common.collect.ContiguousSet intersection(com.google.common.collect.ContiguousSet) -> intersection
    com.google.common.collect.Range range() -> range
    com.google.common.collect.Range range(com.google.common.collect.BoundType,com.google.common.collect.BoundType) -> range
    com.google.common.collect.ContiguousSet headSetImpl(java.lang.Comparable,boolean) -> headSetImpl
    com.google.common.collect.ContiguousSet subSetImpl(java.lang.Comparable,boolean,java.lang.Comparable,boolean) -> subSetImpl
    com.google.common.collect.ContiguousSet tailSetImpl(java.lang.Comparable,boolean) -> tailSetImpl
    int indexOf(java.lang.Object) -> indexOf
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> descendingIterator
    boolean isPartialView() -> isPartialView
    boolean isEmpty() -> isEmpty
    com.google.common.collect.ImmutableList asList() -> asList
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object writeReplace() -> writeReplace
    com.google.common.collect.ImmutableSortedSet createDescendingSet() -> createDescendingSet
    java.lang.Object last() -> last
    java.lang.Object first() -> first
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> tailSetImpl
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> subSetImpl
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> headSetImpl
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.EmptyContiguousSet$SerializedForm -> com.google.common.collect.EmptyContiguousSet$SerializedForm:
    com.google.common.collect.DiscreteDomain domain -> domain
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.DiscreteDomain) -> <init>
    java.lang.Object readResolve() -> readResolve
    void <init>(com.google.common.collect.DiscreteDomain,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
com.google.common.collect.EmptyImmutableBiMap -> com.google.common.collect.EmptyImmutableBiMap:
    com.google.common.collect.EmptyImmutableBiMap INSTANCE -> INSTANCE
    void <init>() -> <init>
    com.google.common.collect.ImmutableBiMap inverse() -> inverse
    int size() -> size
    boolean isEmpty() -> isEmpty
    java.lang.Object get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSet entrySet() -> entrySet
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    com.google.common.collect.ImmutableSetMultimap asMultimap() -> asMultimap
    com.google.common.collect.ImmutableSet keySet() -> keySet
    boolean isPartialView() -> isPartialView
    java.lang.Object readResolve() -> readResolve
    com.google.common.collect.BiMap inverse() -> inverse
    java.util.Set entrySet() -> entrySet
    java.util.Set keySet() -> keySet
    void <clinit>() -> <clinit>
com.google.common.collect.EmptyImmutableListMultimap -> com.google.common.collect.EmptyImmutableListMultimap:
    com.google.common.collect.EmptyImmutableListMultimap INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.lang.Object readResolve() -> readResolve
    void <clinit>() -> <clinit>
com.google.common.collect.EmptyImmutableSet -> com.google.common.collect.EmptyImmutableSet:
    com.google.common.collect.EmptyImmutableSet INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    boolean isPartialView() -> isPartialView
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    com.google.common.collect.ImmutableList asList() -> asList
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isHashCodeFast() -> isHashCodeFast
    java.lang.String toString() -> toString
    java.lang.Object readResolve() -> readResolve
    java.util.Iterator iterator() -> iterator
    void <clinit>() -> <clinit>
com.google.common.collect.EmptyImmutableSetMultimap -> com.google.common.collect.EmptyImmutableSetMultimap:
    com.google.common.collect.EmptyImmutableSetMultimap INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.lang.Object readResolve() -> readResolve
    void <clinit>() -> <clinit>
com.google.common.collect.EmptyImmutableSortedMap -> com.google.common.collect.EmptyImmutableSortedMap:
    com.google.common.collect.ImmutableSortedSet keySet -> a
    void <init>(java.util.Comparator) -> <init>
    void <init>(java.util.Comparator,com.google.common.collect.ImmutableSortedMap) -> <init>
    java.lang.Object get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSortedSet keySet() -> keySet
    int size() -> size
    boolean isEmpty() -> isEmpty
    com.google.common.collect.ImmutableCollection values() -> values
    java.lang.String toString() -> toString
    boolean isPartialView() -> isPartialView
    com.google.common.collect.ImmutableSet entrySet() -> entrySet
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    com.google.common.collect.ImmutableSetMultimap asMultimap() -> asMultimap
    com.google.common.collect.ImmutableSortedMap headMap(java.lang.Object,boolean) -> headMap
    com.google.common.collect.ImmutableSortedMap tailMap(java.lang.Object,boolean) -> tailMap
    com.google.common.collect.ImmutableSortedMap createDescendingMap() -> createDescendingMap
    java.util.NavigableMap tailMap(java.lang.Object,boolean) -> tailMap
    java.util.NavigableMap headMap(java.lang.Object,boolean) -> headMap
    java.util.Set entrySet() -> entrySet
    java.util.Collection values() -> values
    java.util.Set keySet() -> keySet
    com.google.common.collect.ImmutableSet keySet() -> keySet
com.google.common.collect.EmptyImmutableSortedSet -> com.google.common.collect.EmptyImmutableSortedSet:
    void <init>(java.util.Comparator) -> <init>
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> descendingIterator
    boolean isPartialView() -> isPartialView
    com.google.common.collect.ImmutableList asList() -> asList
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.Object first() -> first
    java.lang.Object last() -> last
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> headSetImpl
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> subSetImpl
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> tailSetImpl
    int indexOf(java.lang.Object) -> indexOf
    com.google.common.collect.ImmutableSortedSet createDescendingSet() -> createDescendingSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ExplicitOrdering -> com.google.common.collect.ExplicitOrdering:
    com.google.common.collect.ImmutableMap rankMap -> rankMap
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.List) -> <init>
    void <init>(com.google.common.collect.ImmutableMap) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    int rank(java.lang.Object) -> a
    com.google.common.collect.ImmutableMap buildRankMap(java.util.List) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.FluentIterable -> aL:
    java.lang.Iterable iterable -> a
    void <init>() -> <init>
    java.lang.String toString() -> toString
com.google.common.collect.ForwardingCollection -> aM:
    void <init>() -> <init>
    java.util.Collection delegate() -> delegate
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean removeAll(java.util.Collection) -> removeAll
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean add(java.lang.Object) -> add
    boolean remove(java.lang.Object) -> remove
    boolean containsAll(java.util.Collection) -> containsAll
    boolean addAll(java.util.Collection) -> addAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    boolean standardContains(java.lang.Object) -> standardContains
    boolean standardContainsAll(java.util.Collection) -> standardContainsAll
    boolean standardAddAll(java.util.Collection) -> standardAddAll
    boolean standardRemove(java.lang.Object) -> standardRemove
    boolean standardRemoveAll(java.util.Collection) -> standardRemoveAll
    boolean standardRetainAll(java.util.Collection) -> standardRetainAll
    void standardClear() -> standardClear
    boolean standardIsEmpty() -> standardIsEmpty
    java.lang.String standardToString() -> standardToString
    java.lang.Object[] standardToArray() -> standardToArray
    java.lang.Object[] standardToArray(java.lang.Object[]) -> standardToArray
    java.lang.Object delegate() -> delegate
com.google.common.collect.ForwardingConcurrentMap -> aN:
    void <init>() -> <init>
    java.util.concurrent.ConcurrentMap delegate() -> delegate
    java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object) -> putIfAbsent
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    java.lang.Object replace(java.lang.Object,java.lang.Object) -> replace
    boolean replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    java.util.Map delegate() -> delegate
    java.lang.Object delegate() -> delegate
com.google.common.collect.ForwardingMap -> aO:
    void <init>() -> <init>
    java.util.Map delegate() -> delegate
    int size() -> size
    boolean isEmpty() -> isEmpty
    java.lang.Object remove(java.lang.Object) -> remove
    void clear() -> clear
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    void putAll(java.util.Map) -> putAll
    java.util.Set keySet() -> keySet
    java.util.Collection values() -> values
    java.util.Set entrySet() -> entrySet
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void standardPutAll(java.util.Map) -> standardPutAll
    java.lang.Object standardRemove(java.lang.Object) -> standardRemove
    void standardClear() -> standardClear
    boolean standardContainsKey(java.lang.Object) -> standardContainsKey
    boolean standardContainsValue(java.lang.Object) -> standardContainsValue
    boolean standardIsEmpty() -> standardIsEmpty
    boolean standardEquals(java.lang.Object) -> standardEquals
    int standardHashCode() -> standardHashCode
    java.lang.String standardToString() -> standardToString
    java.lang.Object delegate() -> delegate
com.google.common.collect.ForwardingObject -> aP:
    void <init>() -> <init>
    java.lang.Object delegate() -> delegate
    java.lang.String toString() -> toString
com.google.common.collect.ForwardingSet -> aQ:
    void <init>() -> <init>
    java.util.Set delegate() -> delegate
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean standardRemoveAll(java.util.Collection) -> standardRemoveAll
    boolean standardEquals(java.lang.Object) -> standardEquals
    int standardHashCode() -> standardHashCode
    java.util.Collection delegate() -> delegate
    java.lang.Object delegate() -> delegate
com.google.common.collect.ForwardingSortedSet -> aR:
    void <init>() -> <init>
    java.util.SortedSet delegate() -> delegate
    java.util.Comparator comparator() -> comparator
    java.lang.Object first() -> first
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.lang.Object last() -> last
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
    int unsafeCompare(java.lang.Object,java.lang.Object) -> a
    boolean standardContains(java.lang.Object) -> standardContains
    boolean standardRemove(java.lang.Object) -> standardRemove
    java.util.SortedSet standardSubSet(java.lang.Object,java.lang.Object) -> standardSubSet
    java.util.Set delegate() -> delegate
    java.util.Collection delegate() -> delegate
    java.lang.Object delegate() -> delegate
com.google.common.collect.GenericMapMaker -> com.google.common.collect.GenericMapMaker:
    com.google.common.collect.MapMaker$RemovalListener removalListener -> a
    void <init>() -> <init>
    com.google.common.collect.MapMaker$RemovalListener getRemovalListener() -> a
    java.util.concurrent.ConcurrentMap makeComputingMap(com.google.common.base.Function) -> a
com.google.common.collect.GenericMapMaker$NullListener -> com.google.common.collect.GenericMapMaker$NullListener:
    com.google.common.collect.GenericMapMaker$NullListener INSTANCE -> INSTANCE
    com.google.common.collect.GenericMapMaker$NullListener[] $VALUES -> a
    com.google.common.collect.GenericMapMaker$NullListener[] values() -> values
    com.google.common.collect.GenericMapMaker$NullListener valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void onRemoval(com.google.common.collect.MapMaker$RemovalNotification) -> onRemoval
    void <clinit>() -> <clinit>
com.google.common.collect.Hashing -> aS:
    int MAX_TABLE_SIZE -> a
    int smear(int) -> a
    int closedTableSize(int,double) -> a
    void <clinit>() -> <clinit>
com.google.common.collect.ImmutableAsList -> com.google.common.collect.ImmutableAsList:
    void <init>() -> <init>
    com.google.common.collect.ImmutableCollection delegateCollection() -> delegateCollection
    boolean contains(java.lang.Object) -> contains
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean isPartialView() -> isPartialView
    void readObject(java.io.ObjectInputStream) -> readObject
    java.lang.Object writeReplace() -> writeReplace
com.google.common.collect.ImmutableAsList$SerializedForm -> com.google.common.collect.ImmutableAsList$SerializedForm:
    com.google.common.collect.ImmutableCollection collection -> collection
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableCollection) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableBiMap -> com.google.common.collect.ImmutableBiMap:
    java.util.Map$Entry[] EMPTY_ENTRY_ARRAY -> a
    com.google.common.collect.ImmutableBiMap of() -> of
    com.google.common.collect.ImmutableBiMap of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableBiMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableBiMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableBiMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableBiMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableBiMap$Builder builder() -> builder
    com.google.common.collect.ImmutableBiMap copyOf(java.util.Map) -> copyOf
    void <init>() -> <init>
    com.google.common.collect.ImmutableBiMap inverse() -> inverse
    com.google.common.collect.ImmutableSet values() -> values
    java.lang.Object forcePut(java.lang.Object,java.lang.Object) -> forcePut
    java.lang.Object writeReplace() -> writeReplace
    com.google.common.collect.ImmutableCollection values() -> values
    java.util.Collection values() -> values
    com.google.common.collect.BiMap inverse() -> inverse
    java.util.Set values() -> values
    void <clinit>() -> <clinit>
com.google.common.collect.ImmutableBiMap$Builder -> aT:
    void <init>() -> <init>
    com.google.common.collect.ImmutableMap build() -> a
    com.google.common.collect.ImmutableMap$Builder put(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.ImmutableBiMap$SerializedForm -> com.google.common.collect.ImmutableBiMap$SerializedForm:
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableBiMap) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableCollection -> com.google.common.collect.ImmutableCollection:
    com.google.common.collect.ImmutableList asList -> a
    void <init>() -> <init>
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    boolean contains(java.lang.Object) -> contains
    boolean add(java.lang.Object) -> add
    boolean remove(java.lang.Object) -> remove
    boolean addAll(java.util.Collection) -> addAll
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    com.google.common.collect.ImmutableList asList() -> asList
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    boolean isPartialView() -> isPartialView
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    java.lang.Object writeReplace() -> writeReplace
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableCollection$ArrayBasedBuilder -> aU:
    java.lang.Object[] contents -> a
    int size -> a
    void <init>(int) -> <init>
    void ensureCapacity(int) -> a
    com.google.common.collect.ImmutableCollection$ArrayBasedBuilder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object) -> a
com.google.common.collect.ImmutableCollection$Builder -> aV:
    int expandedCapacity(int,int) -> a
    void <init>() -> <init>
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableCollection$Builder addAll(java.util.Iterator) -> a
com.google.common.collect.ImmutableEntry -> com.google.common.collect.ImmutableEntry:
    java.lang.Object key -> key
    java.lang.Object value -> value
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Object,java.lang.Object) -> <init>
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
com.google.common.collect.ImmutableEnumMap -> com.google.common.collect.ImmutableEnumMap:
    java.util.EnumMap delegate -> a
    com.google.common.collect.ImmutableMap asImmutable(java.util.EnumMap) -> asImmutable
    void <init>(java.util.EnumMap) -> <init>
    com.google.common.collect.ImmutableSet createKeySet() -> createKeySet
    int size() -> size
    boolean containsKey(java.lang.Object) -> containsKey
    java.lang.Object get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    boolean isPartialView() -> isPartialView
    java.lang.Object writeReplace() -> writeReplace
    java.util.EnumMap access$000(com.google.common.collect.ImmutableEnumMap) -> access$000
    void <init>(java.util.EnumMap,com.google.common.collect.ImmutableEnumMap$1) -> <init>
com.google.common.collect.ImmutableEnumMap$1 -> com.google.common.collect.ImmutableEnumMap$1:
    com.google.common.collect.ImmutableEnumMap this$0 -> this$0
    void <init>(com.google.common.collect.ImmutableEnumMap) -> <init>
    boolean contains(java.lang.Object) -> contains
    int size() -> size
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    boolean isPartialView() -> isPartialView
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableEnumMap$2 -> com.google.common.collect.ImmutableEnumMap$2:
    com.google.common.collect.ImmutableEnumMap this$0 -> this$0
    void <init>(com.google.common.collect.ImmutableEnumMap) -> <init>
    com.google.common.collect.ImmutableMap map() -> map
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableEnumMap$2$1 -> aW:
    java.util.Iterator backingIterator -> a
    com.google.common.collect.ImmutableEnumMap$2 this$1 -> a
    void <init>(com.google.common.collect.ImmutableEnumMap$2) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.ImmutableEnumMap$EnumSerializedForm -> com.google.common.collect.ImmutableEnumMap$EnumSerializedForm:
    java.util.EnumMap delegate -> delegate
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.EnumMap) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableEnumSet -> com.google.common.collect.ImmutableEnumSet:
    java.util.EnumSet delegate -> a
    int hashCode -> a
    com.google.common.collect.ImmutableSet asImmutable(java.util.EnumSet) -> asImmutable
    void <init>(java.util.EnumSet) -> <init>
    boolean isPartialView() -> isPartialView
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean isEmpty() -> isEmpty
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.Object writeReplace() -> writeReplace
    java.util.Iterator iterator() -> iterator
    void <init>(java.util.EnumSet,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
com.google.common.collect.ImmutableEnumSet$EnumSerializedForm -> com.google.common.collect.ImmutableEnumSet$EnumSerializedForm:
    java.util.EnumSet delegate -> delegate
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.EnumSet) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableList -> com.google.common.collect.ImmutableList:
    com.google.common.collect.ImmutableList EMPTY -> a
    com.google.common.collect.ImmutableList of() -> of
    com.google.common.collect.ImmutableList of(java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableList of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> of
    com.google.common.collect.ImmutableList copyOf(java.lang.Iterable) -> copyOf
    com.google.common.collect.ImmutableList copyOf(java.util.Collection) -> copyOf
    com.google.common.collect.ImmutableList copyOf(java.util.Iterator) -> copyOf
    com.google.common.collect.ImmutableList copyOf(java.lang.Object[]) -> copyOf
    com.google.common.collect.ImmutableList asImmutableList(java.lang.Object[]) -> asImmutableList
    com.google.common.collect.ImmutableList asImmutableList(java.lang.Object[],int) -> asImmutableList
    void <init>() -> <init>
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.UnmodifiableListIterator listIterator() -> listIterator
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> listIterator
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.ImmutableList subList(int,int) -> subList
    com.google.common.collect.ImmutableList subListUnchecked(int,int) -> subListUnchecked
    boolean addAll(int,java.util.Collection) -> addAll
    java.lang.Object set(int,java.lang.Object) -> set
    void add(int,java.lang.Object) -> add
    java.lang.Object remove(int) -> remove
    com.google.common.collect.ImmutableList asList() -> asList
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    com.google.common.collect.ImmutableList reverse() -> reverse
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void readObject(java.io.ObjectInputStream) -> readObject
    java.lang.Object writeReplace() -> writeReplace
    com.google.common.collect.ImmutableList$Builder builder() -> builder
    java.util.Iterator iterator() -> iterator
    java.util.List subList(int,int) -> subList
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator() -> listIterator
    void <clinit>() -> <clinit>
com.google.common.collect.ImmutableList$1 -> aX:
    com.google.common.collect.ImmutableList this$0 -> a
    void <init>(com.google.common.collect.ImmutableList,int,int) -> <init>
    java.lang.Object get(int) -> a
com.google.common.collect.ImmutableList$Builder -> aY:
    void <init>() -> <init>
    void <init>(int) -> <init>
    com.google.common.collect.ImmutableList$Builder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableList$Builder addAll(java.util.Iterator) -> a
    com.google.common.collect.ImmutableList build() -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableCollection$ArrayBasedBuilder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableCollection$Builder addAll(java.util.Iterator) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object) -> a
com.google.common.collect.ImmutableList$ReverseImmutableList -> com.google.common.collect.ImmutableList$ReverseImmutableList:
    com.google.common.collect.ImmutableList forwardList -> a
    void <init>(com.google.common.collect.ImmutableList) -> <init>
    int reverseIndex(int) -> a
    com.google.common.collect.ImmutableList reverse() -> reverse
    boolean contains(java.lang.Object) -> contains
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    com.google.common.collect.ImmutableList subList(int,int) -> subList
    java.lang.Object get(int) -> get
    int size() -> size
    boolean isPartialView() -> isPartialView
    java.util.List subList(int,int) -> subList
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator() -> listIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableList$SerializedForm -> com.google.common.collect.ImmutableList$SerializedForm:
    java.lang.Object[] elements -> elements
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Object[]) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableList$SubList -> com.google.common.collect.ImmutableList$SubList:
    int offset -> offset
    int length -> length
    com.google.common.collect.ImmutableList this$0 -> this$0
    void <init>(com.google.common.collect.ImmutableList,int,int) -> <init>
    int size() -> size
    java.lang.Object get(int) -> get
    com.google.common.collect.ImmutableList subList(int,int) -> subList
    boolean isPartialView() -> isPartialView
    java.util.List subList(int,int) -> subList
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator() -> listIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableListMultimap -> com.google.common.collect.ImmutableListMultimap:
    com.google.common.collect.ImmutableListMultimap inverse -> a
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.ImmutableListMultimap of() -> of
    com.google.common.collect.ImmutableListMultimap of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableListMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableListMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableListMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableListMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableListMultimap$Builder builder() -> builder
    com.google.common.collect.ImmutableListMultimap copyOf(com.google.common.collect.Multimap) -> copyOf
    void <init>(com.google.common.collect.ImmutableMap,int) -> <init>
    com.google.common.collect.ImmutableList get(java.lang.Object) -> get
    com.google.common.collect.ImmutableListMultimap inverse() -> inverse
    com.google.common.collect.ImmutableList removeAll(java.lang.Object) -> removeAll
    com.google.common.collect.ImmutableList replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
    com.google.common.collect.ImmutableMultimap inverse() -> inverse
    com.google.common.collect.ImmutableCollection get(java.lang.Object) -> get
    com.google.common.collect.ImmutableCollection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    com.google.common.collect.ImmutableCollection removeAll(java.lang.Object) -> removeAll
    java.util.Collection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Collection get(java.lang.Object) -> get
    java.util.Collection removeAll(java.lang.Object) -> removeAll
    java.util.List replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.List removeAll(java.lang.Object) -> removeAll
    java.util.List get(java.lang.Object) -> get
com.google.common.collect.ImmutableListMultimap$Builder -> aZ:
    void <init>() -> <init>
    com.google.common.collect.ImmutableListMultimap$Builder put(java.lang.Object,java.lang.Object) -> a
    com.google.common.collect.ImmutableListMultimap build() -> a
    com.google.common.collect.ImmutableMultimap build() -> a
    com.google.common.collect.ImmutableMultimap$Builder put(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.ImmutableMap -> com.google.common.collect.ImmutableMap:
    java.util.Map$Entry[] EMPTY_ENTRY_ARRAY -> a
    com.google.common.collect.ImmutableSet entrySet -> a
    com.google.common.collect.ImmutableSet keySet -> b
    com.google.common.collect.ImmutableCollection values -> a
    com.google.common.collect.ImmutableSetMultimap multimapView -> a
    com.google.common.collect.ImmutableMap of() -> of
    com.google.common.collect.ImmutableMap of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMapEntry$TerminalEntry entryOf(java.lang.Object,java.lang.Object) -> entryOf
    com.google.common.collect.ImmutableMap$Builder builder() -> builder
    void checkNoConflict(boolean,java.lang.String,java.util.Map$Entry,java.util.Map$Entry) -> checkNoConflict
    com.google.common.collect.ImmutableMap copyOf(java.util.Map) -> copyOf
    void <init>() -> <init>
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object remove(java.lang.Object) -> remove
    void putAll(java.util.Map) -> putAll
    void clear() -> clear
    boolean isEmpty() -> isEmpty
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    java.lang.Object get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSet entrySet() -> entrySet
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    com.google.common.collect.ImmutableSet keySet() -> keySet
    com.google.common.collect.ImmutableSet createKeySet() -> createKeySet
    com.google.common.collect.ImmutableCollection values() -> values
    com.google.common.collect.ImmutableSetMultimap asMultimap() -> asMultimap
    boolean equals(java.lang.Object) -> equals
    boolean isPartialView() -> isPartialView
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.Object writeReplace() -> writeReplace
    java.util.Set entrySet() -> entrySet
    java.util.Collection values() -> values
    java.util.Set keySet() -> keySet
    void <clinit>() -> <clinit>
com.google.common.collect.ImmutableMap$Builder -> ba:
    com.google.common.collect.ImmutableMapEntry$TerminalEntry[] entries -> a
    int size -> a
    void <init>() -> <init>
    void <init>(int) -> <init>
    com.google.common.collect.ImmutableMap$Builder put(java.lang.Object,java.lang.Object) -> a
    com.google.common.collect.ImmutableMap build() -> a
com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets -> com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets:
    com.google.common.collect.ImmutableMap delegate -> delegate
    void <init>(com.google.common.collect.ImmutableMap) -> <init>
    int size() -> size
    boolean containsKey(java.lang.Object) -> containsKey
    com.google.common.collect.ImmutableSet get(java.lang.Object) -> get
    boolean isPartialView() -> isPartialView
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    java.lang.Object get(java.lang.Object) -> get
    java.util.Set entrySet() -> entrySet
    java.util.Collection values() -> values
    java.util.Set keySet() -> keySet
    com.google.common.collect.ImmutableMap access$000(com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets) -> access$000
com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1 -> com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1:
    com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets this$0 -> this$0
    void <init>(com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets) -> <init>
    com.google.common.collect.ImmutableMap map() -> map
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1$1 -> bb:
    java.util.Iterator val$backingIterator -> a
    void <init>(com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1,java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1$1$1 -> bc:
    java.util.Map$Entry val$backingEntry -> a
    void <init>(com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1$1,java.util.Map$Entry) -> <init>
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
com.google.common.collect.ImmutableMap$SerializedForm -> com.google.common.collect.ImmutableMap$SerializedForm:
    java.lang.Object[] keys -> keys
    java.lang.Object[] values -> values
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableMap) -> <init>
    java.lang.Object readResolve() -> readResolve
    java.lang.Object createMap(com.google.common.collect.ImmutableMap$Builder) -> createMap
com.google.common.collect.ImmutableMapEntry -> com.google.common.collect.ImmutableMapEntry:
    void <init>(java.lang.Object,java.lang.Object) -> <init>
    void <init>(com.google.common.collect.ImmutableMapEntry) -> <init>
    com.google.common.collect.ImmutableMapEntry getNextInKeyBucket() -> getNextInKeyBucket
    com.google.common.collect.ImmutableMapEntry getNextInValueBucket() -> getNextInValueBucket
com.google.common.collect.ImmutableMapEntry$TerminalEntry -> com.google.common.collect.ImmutableMapEntry$TerminalEntry:
    void <init>(com.google.common.collect.ImmutableMapEntry) -> <init>
    void <init>(java.lang.Object,java.lang.Object) -> <init>
    com.google.common.collect.ImmutableMapEntry getNextInKeyBucket() -> getNextInKeyBucket
    com.google.common.collect.ImmutableMapEntry getNextInValueBucket() -> getNextInValueBucket
com.google.common.collect.ImmutableMapEntrySet -> com.google.common.collect.ImmutableMapEntrySet:
    void <init>() -> <init>
    com.google.common.collect.ImmutableMap map() -> map
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    boolean isPartialView() -> isPartialView
    java.lang.Object writeReplace() -> writeReplace
com.google.common.collect.ImmutableMapEntrySet$EntrySetSerializedForm -> com.google.common.collect.ImmutableMapEntrySet$EntrySetSerializedForm:
    com.google.common.collect.ImmutableMap map -> map
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableMap) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableMapKeySet -> com.google.common.collect.ImmutableMapKeySet:
    com.google.common.collect.ImmutableMap map -> map
    void <init>(com.google.common.collect.ImmutableMap) -> <init>
    int size() -> size
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    boolean isPartialView() -> isPartialView
    java.lang.Object writeReplace() -> writeReplace
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableMapKeySet$1 -> com.google.common.collect.ImmutableMapKeySet$1:
    com.google.common.collect.ImmutableList val$entryList -> val$entryList
    com.google.common.collect.ImmutableMapKeySet this$0 -> this$0
    void <init>(com.google.common.collect.ImmutableMapKeySet,com.google.common.collect.ImmutableList) -> <init>
    java.lang.Object get(int) -> get
    com.google.common.collect.ImmutableCollection delegateCollection() -> delegateCollection
com.google.common.collect.ImmutableMapKeySet$KeySetSerializedForm -> com.google.common.collect.ImmutableMapKeySet$KeySetSerializedForm:
    com.google.common.collect.ImmutableMap map -> map
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableMap) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableMapValues -> com.google.common.collect.ImmutableMapValues:
    com.google.common.collect.ImmutableMap map -> map
    void <init>(com.google.common.collect.ImmutableMap) -> <init>
    int size() -> size
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
    boolean isPartialView() -> isPartialView
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    java.lang.Object writeReplace() -> writeReplace
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableMapValues$1 -> com.google.common.collect.ImmutableMapValues$1:
    com.google.common.collect.ImmutableList val$entryList -> val$entryList
    com.google.common.collect.ImmutableMapValues this$0 -> this$0
    void <init>(com.google.common.collect.ImmutableMapValues,com.google.common.collect.ImmutableList) -> <init>
    java.lang.Object get(int) -> get
    com.google.common.collect.ImmutableCollection delegateCollection() -> delegateCollection
com.google.common.collect.ImmutableMapValues$SerializedForm -> com.google.common.collect.ImmutableMapValues$SerializedForm:
    com.google.common.collect.ImmutableMap map -> map
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableMap) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableMultimap -> com.google.common.collect.ImmutableMultimap:
    com.google.common.collect.ImmutableMap map -> map
    int size -> size
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.ImmutableMultimap of() -> of
    com.google.common.collect.ImmutableMultimap of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultimap$Builder builder() -> builder
    com.google.common.collect.ImmutableMultimap copyOf(com.google.common.collect.Multimap) -> copyOf
    void <init>(com.google.common.collect.ImmutableMap,int) -> <init>
    com.google.common.collect.ImmutableCollection removeAll(java.lang.Object) -> removeAll
    com.google.common.collect.ImmutableCollection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    void clear() -> clear
    com.google.common.collect.ImmutableCollection get(java.lang.Object) -> get
    com.google.common.collect.ImmutableMultimap inverse() -> inverse
    boolean put(java.lang.Object,java.lang.Object) -> put
    boolean putAll(java.lang.Object,java.lang.Iterable) -> putAll
    boolean putAll(com.google.common.collect.Multimap) -> putAll
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    boolean isPartialView() -> isPartialView
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    int size() -> size
    com.google.common.collect.ImmutableSet keySet() -> keySet
    com.google.common.collect.ImmutableMap asMap() -> asMap
    java.util.Map createAsMap() -> createAsMap
    com.google.common.collect.ImmutableCollection entries() -> entries
    com.google.common.collect.ImmutableCollection createEntries() -> createEntries
    com.google.common.collect.UnmodifiableIterator entryIterator() -> entryIterator
    com.google.common.collect.ImmutableMultiset keys() -> keys
    com.google.common.collect.ImmutableMultiset createKeys() -> createKeys
    com.google.common.collect.ImmutableCollection values() -> values
    com.google.common.collect.ImmutableCollection createValues() -> createValues
    com.google.common.collect.UnmodifiableIterator valueIterator() -> valueIterator
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.util.Map asMap() -> asMap
    java.util.Iterator valueIterator() -> valueIterator
    java.util.Collection createValues() -> createValues
    java.util.Collection values() -> values
    com.google.common.collect.Multiset createKeys() -> createKeys
    com.google.common.collect.Multiset keys() -> keys
    java.util.Set keySet() -> keySet
    java.util.Iterator entryIterator() -> entryIterator
    java.util.Collection createEntries() -> createEntries
    java.util.Collection entries() -> entries
    java.util.Collection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    boolean containsEntry(java.lang.Object,java.lang.Object) -> containsEntry
    boolean isEmpty() -> isEmpty
    java.util.Collection get(java.lang.Object) -> get
    java.util.Collection removeAll(java.lang.Object) -> removeAll
com.google.common.collect.ImmutableMultimap$1 -> bd:
    void <init>(com.google.common.collect.ImmutableMultimap) -> <init>
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.ImmutableMultimap$2 -> be:
    void <init>(com.google.common.collect.ImmutableMultimap) -> <init>
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.ImmutableMultimap$Builder -> bf:
    com.google.common.collect.Multimap builderMultimap -> a
    void <init>() -> <init>
    com.google.common.collect.ImmutableMultimap$Builder put(java.lang.Object,java.lang.Object) -> a
    com.google.common.collect.ImmutableMultimap build() -> a
com.google.common.collect.ImmutableMultimap$BuilderMultimap -> com.google.common.collect.ImmutableMultimap$BuilderMultimap:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.util.Collection createCollection() -> createCollection
com.google.common.collect.ImmutableMultimap$EntryCollection -> com.google.common.collect.ImmutableMultimap$EntryCollection:
    com.google.common.collect.ImmutableMultimap multimap -> multimap
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableMultimap) -> <init>
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    boolean isPartialView() -> isPartialView
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableMultimap$FieldSettersHolder -> bg:
    com.google.common.collect.Serialization$FieldSetter MAP_FIELD_SETTER -> a
    com.google.common.collect.Serialization$FieldSetter SIZE_FIELD_SETTER -> b
    com.google.common.collect.Serialization$FieldSetter EMPTY_SET_FIELD_SETTER -> c
    void <clinit>() -> <clinit>
com.google.common.collect.ImmutableMultimap$Itr -> bh:
    java.util.Iterator mapIterator -> a
    java.lang.Object key -> a
    java.util.Iterator valueIterator -> b
    com.google.common.collect.ImmutableMultimap this$0 -> a
    void <init>(com.google.common.collect.ImmutableMultimap) -> <init>
    java.lang.Object output(java.lang.Object,java.lang.Object) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void <init>(com.google.common.collect.ImmutableMultimap,byte) -> <init>
com.google.common.collect.ImmutableMultimap$Keys -> com.google.common.collect.ImmutableMultimap$Keys:
    com.google.common.collect.ImmutableMultimap this$0 -> this$0
    void <init>(com.google.common.collect.ImmutableMultimap) -> <init>
    boolean contains(java.lang.Object) -> contains
    int count(java.lang.Object) -> count
    java.util.Set elementSet() -> elementSet
    int size() -> size
    com.google.common.collect.Multiset$Entry getEntry(int) -> getEntry
    boolean isPartialView() -> isPartialView
com.google.common.collect.ImmutableMultimap$Values -> com.google.common.collect.ImmutableMultimap$Values:
    com.google.common.collect.ImmutableMultimap multimap -> a
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableMultimap) -> <init>
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    int size() -> size
    boolean isPartialView() -> isPartialView
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableMultiset -> com.google.common.collect.ImmutableMultiset:
    com.google.common.collect.ImmutableMultiset EMPTY -> a
    com.google.common.collect.ImmutableSet entrySet -> a
    com.google.common.collect.ImmutableMultiset of() -> of
    com.google.common.collect.ImmutableMultiset of(java.lang.Object) -> of
    com.google.common.collect.ImmutableMultiset of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultiset of(java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultiset of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultiset of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableMultiset of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> of
    com.google.common.collect.ImmutableMultiset copyOf(java.lang.Object[]) -> copyOf
    com.google.common.collect.ImmutableMultiset copyOf(java.lang.Iterable) -> copyOf
    com.google.common.collect.ImmutableMultiset copyOfInternal(com.google.common.collect.Multiset) -> a
    com.google.common.collect.ImmutableMultiset copyFromEntries(java.util.Collection) -> copyFromEntries
    com.google.common.collect.ImmutableMultiset copyOf(java.util.Iterator) -> copyOf
    void <init>() -> <init>
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    int add(java.lang.Object,int) -> add
    int remove(java.lang.Object,int) -> remove
    int setCount(java.lang.Object,int) -> setCount
    boolean setCount(java.lang.Object,int,int) -> setCount
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    com.google.common.collect.ImmutableSet entrySet() -> entrySet
    com.google.common.collect.Multiset$Entry getEntry(int) -> getEntry
    java.lang.Object writeReplace() -> writeReplace
    com.google.common.collect.ImmutableMultiset$Builder builder() -> builder
    java.util.Iterator iterator() -> iterator
    java.util.Set entrySet() -> entrySet
    void <clinit>() -> <clinit>
com.google.common.collect.ImmutableMultiset$1 -> bi:
    int remaining -> a
    java.lang.Object element -> a
    java.util.Iterator val$entryIterator -> a
    void <init>(com.google.common.collect.ImmutableMultiset,java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.ImmutableMultiset$Builder -> bj:
    com.google.common.collect.Multiset contents -> a
    void <init>() -> <init>
    void <init>(com.google.common.collect.Multiset) -> <init>
    com.google.common.collect.ImmutableMultiset$Builder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableMultiset$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableCollection$Builder addAll(java.util.Iterator) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object) -> a
com.google.common.collect.ImmutableMultiset$EntrySet -> com.google.common.collect.ImmutableMultiset$EntrySet:
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.ImmutableMultiset this$0 -> this$0
    void <init>(com.google.common.collect.ImmutableMultiset) -> <init>
    boolean isPartialView() -> isPartialView
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    int hashCode() -> hashCode
    java.lang.Object writeReplace() -> writeReplace
    java.util.Iterator iterator() -> iterator
    void <init>(com.google.common.collect.ImmutableMultiset,com.google.common.collect.ImmutableMultiset$1) -> <init>
com.google.common.collect.ImmutableMultiset$EntrySet$1 -> com.google.common.collect.ImmutableMultiset$EntrySet$1:
    com.google.common.collect.ImmutableMultiset$EntrySet this$1 -> this$1
    void <init>(com.google.common.collect.ImmutableMultiset$EntrySet) -> <init>
    com.google.common.collect.Multiset$Entry get(int) -> get
    com.google.common.collect.ImmutableCollection delegateCollection() -> delegateCollection
    java.lang.Object get(int) -> get
com.google.common.collect.ImmutableMultiset$EntrySetSerializedForm -> com.google.common.collect.ImmutableMultiset$EntrySetSerializedForm:
    com.google.common.collect.ImmutableMultiset multiset -> multiset
    void <init>(com.google.common.collect.ImmutableMultiset) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableMultiset$SerializedForm -> com.google.common.collect.ImmutableMultiset$SerializedForm:
    java.lang.Object[] elements -> elements
    int[] counts -> counts
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.Multiset) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableSet -> com.google.common.collect.ImmutableSet:
    int MAX_TABLE_SIZE -> MAX_TABLE_SIZE
    com.google.common.collect.ImmutableSet of() -> of
    com.google.common.collect.ImmutableSet of(java.lang.Object) -> of
    com.google.common.collect.ImmutableSet of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSet of(java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSet of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSet of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSet of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> of
    com.google.common.collect.ImmutableSet construct(int,java.lang.Object[]) -> a
    int chooseTableSize(int) -> chooseTableSize
    com.google.common.collect.ImmutableSet copyOf(java.lang.Object[]) -> copyOf
    com.google.common.collect.ImmutableSet copyOf(java.lang.Iterable) -> copyOf
    com.google.common.collect.ImmutableSet copyOf(java.util.Iterator) -> copyOf
    com.google.common.collect.ImmutableSet copyOf(java.util.Collection) -> copyOf
    void <init>() -> <init>
    boolean isHashCodeFast() -> isHashCodeFast
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    java.lang.Object writeReplace() -> writeReplace
    com.google.common.collect.ImmutableSet$Builder builder() -> builder
    java.util.Iterator iterator() -> iterator
    com.google.common.collect.ImmutableSet access$000(int,java.lang.Object[]) -> access$000
com.google.common.collect.ImmutableSet$Builder -> bk:
    void <init>() -> <init>
    void <init>(int) -> <init>
    com.google.common.collect.ImmutableSet$Builder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableSet$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableSet$Builder addAll(java.util.Iterator) -> a
    com.google.common.collect.ImmutableSet build() -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableCollection$ArrayBasedBuilder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableCollection$Builder addAll(java.util.Iterator) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object) -> a
com.google.common.collect.ImmutableSet$SerializedForm -> com.google.common.collect.ImmutableSet$SerializedForm:
    java.lang.Object[] elements -> elements
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Object[]) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableSetMultimap -> com.google.common.collect.ImmutableSetMultimap:
    com.google.common.collect.ImmutableSet emptySet -> a
    com.google.common.collect.ImmutableSetMultimap inverse -> a
    com.google.common.collect.ImmutableSet entries -> b
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.ImmutableSetMultimap of() -> of
    com.google.common.collect.ImmutableSetMultimap of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSetMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSetMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSetMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSetMultimap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSetMultimap$Builder builder() -> builder
    com.google.common.collect.ImmutableSetMultimap copyOf(com.google.common.collect.Multimap) -> copyOf
    com.google.common.collect.ImmutableSetMultimap copyOf(com.google.common.collect.Multimap,java.util.Comparator) -> a
    void <init>(com.google.common.collect.ImmutableMap,int,java.util.Comparator) -> <init>
    com.google.common.collect.ImmutableSet get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSetMultimap inverse() -> inverse
    com.google.common.collect.ImmutableSet removeAll(java.lang.Object) -> removeAll
    com.google.common.collect.ImmutableSet replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    com.google.common.collect.ImmutableSet entries() -> entries
    com.google.common.collect.ImmutableSet valueSet(java.util.Comparator,java.util.Collection) -> a
    com.google.common.collect.ImmutableSet emptySet(java.util.Comparator) -> a
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    java.util.Comparator valueComparator() -> valueComparator
    void readObject(java.io.ObjectInputStream) -> readObject
    com.google.common.collect.ImmutableCollection entries() -> entries
    com.google.common.collect.ImmutableMultimap inverse() -> inverse
    com.google.common.collect.ImmutableCollection get(java.lang.Object) -> get
    com.google.common.collect.ImmutableCollection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    com.google.common.collect.ImmutableCollection removeAll(java.lang.Object) -> removeAll
    java.util.Collection entries() -> entries
    java.util.Collection replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Collection get(java.lang.Object) -> get
    java.util.Collection removeAll(java.lang.Object) -> removeAll
    java.util.Set entries() -> entries
    java.util.Set replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.Set removeAll(java.lang.Object) -> removeAll
    java.util.Set get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSetMultimap access$000(com.google.common.collect.Multimap,java.util.Comparator) -> access$000
com.google.common.collect.ImmutableSetMultimap$Builder -> bl:
    void <init>() -> <init>
    com.google.common.collect.ImmutableSetMultimap$Builder put(java.lang.Object,java.lang.Object) -> a
    com.google.common.collect.ImmutableSetMultimap build() -> a
    com.google.common.collect.ImmutableMultimap build() -> a
    com.google.common.collect.ImmutableMultimap$Builder put(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.ImmutableSetMultimap$BuilderMultimap -> com.google.common.collect.ImmutableSetMultimap$BuilderMultimap:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    java.util.Collection createCollection() -> createCollection
com.google.common.collect.ImmutableSetMultimap$EntrySet -> com.google.common.collect.ImmutableSetMultimap$EntrySet:
    com.google.common.collect.ImmutableSetMultimap multimap -> a
    void <init>(com.google.common.collect.ImmutableSetMultimap) -> <init>
    boolean contains(java.lang.Object) -> contains
    int size() -> size
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    boolean isPartialView() -> isPartialView
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableSortedAsList -> com.google.common.collect.ImmutableSortedAsList:
    void <init>(com.google.common.collect.ImmutableSortedSet,com.google.common.collect.ImmutableList) -> <init>
    com.google.common.collect.ImmutableSortedSet delegateCollection() -> delegateCollection
    java.util.Comparator comparator() -> comparator
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.ImmutableList subListUnchecked(int,int) -> subListUnchecked
    com.google.common.collect.ImmutableCollection delegateCollection() -> delegateCollection
com.google.common.collect.ImmutableSortedMap -> com.google.common.collect.ImmutableSortedMap:
    java.util.Comparator NATURAL_ORDER -> a
    com.google.common.collect.ImmutableSortedMap NATURAL_EMPTY_MAP -> a
    com.google.common.collect.ImmutableSortedMap descendingMap -> b
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.ImmutableSortedMap emptyMap(java.util.Comparator) -> emptyMap
    com.google.common.collect.ImmutableSortedMap fromSortedEntries(java.util.Comparator,int,java.util.Map$Entry[]) -> fromSortedEntries
    com.google.common.collect.ImmutableSortedMap from(com.google.common.collect.ImmutableSortedSet,com.google.common.collect.ImmutableList) -> from
    com.google.common.collect.ImmutableSortedMap of() -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Comparable,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object,java.lang.Comparable,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap copyOf(java.util.Map) -> copyOf
    com.google.common.collect.ImmutableSortedMap copyOf(java.util.Map,java.util.Comparator) -> copyOf
    com.google.common.collect.ImmutableSortedMap copyOfSorted(java.util.SortedMap) -> copyOfSorted
    com.google.common.collect.ImmutableSortedMap copyOfInternal(java.util.Map,java.util.Comparator) -> a
    com.google.common.collect.ImmutableSortedMap fromEntries(java.util.Comparator,boolean,int,java.util.Map$Entry[]) -> fromEntries
    com.google.common.collect.ImmutableSortedMap$Builder naturalOrder() -> naturalOrder
    com.google.common.collect.ImmutableSortedMap$Builder orderedBy(java.util.Comparator) -> orderedBy
    com.google.common.collect.ImmutableSortedMap$Builder reverseOrder() -> reverseOrder
    void <init>() -> <init>
    void <init>(com.google.common.collect.ImmutableSortedMap) -> <init>
    int size() -> size
    boolean containsValue(java.lang.Object) -> containsValue
    boolean isPartialView() -> isPartialView
    com.google.common.collect.ImmutableSet entrySet() -> entrySet
    com.google.common.collect.ImmutableSortedSet keySet() -> keySet
    com.google.common.collect.ImmutableCollection values() -> values
    java.util.Comparator comparator() -> comparator
    java.lang.Object firstKey() -> firstKey
    java.lang.Object lastKey() -> lastKey
    com.google.common.collect.ImmutableSortedMap headMap(java.lang.Object) -> headMap
    com.google.common.collect.ImmutableSortedMap headMap(java.lang.Object,boolean) -> headMap
    com.google.common.collect.ImmutableSortedMap subMap(java.lang.Object,java.lang.Object) -> subMap
    com.google.common.collect.ImmutableSortedMap subMap(java.lang.Object,boolean,java.lang.Object,boolean) -> subMap
    com.google.common.collect.ImmutableSortedMap tailMap(java.lang.Object) -> tailMap
    com.google.common.collect.ImmutableSortedMap tailMap(java.lang.Object,boolean) -> tailMap
    java.util.Map$Entry lowerEntry(java.lang.Object) -> lowerEntry
    java.lang.Object lowerKey(java.lang.Object) -> lowerKey
    java.util.Map$Entry floorEntry(java.lang.Object) -> floorEntry
    java.lang.Object floorKey(java.lang.Object) -> floorKey
    java.util.Map$Entry ceilingEntry(java.lang.Object) -> ceilingEntry
    java.lang.Object ceilingKey(java.lang.Object) -> ceilingKey
    java.util.Map$Entry higherEntry(java.lang.Object) -> higherEntry
    java.lang.Object higherKey(java.lang.Object) -> higherKey
    java.util.Map$Entry firstEntry() -> firstEntry
    java.util.Map$Entry lastEntry() -> lastEntry
    java.util.Map$Entry pollFirstEntry() -> pollFirstEntry
    java.util.Map$Entry pollLastEntry() -> pollLastEntry
    com.google.common.collect.ImmutableSortedMap descendingMap() -> descendingMap
    com.google.common.collect.ImmutableSortedMap createDescendingMap() -> createDescendingMap
    com.google.common.collect.ImmutableSortedSet navigableKeySet() -> navigableKeySet
    com.google.common.collect.ImmutableSortedSet descendingKeySet() -> descendingKeySet
    java.lang.Object writeReplace() -> writeReplace
    com.google.common.collect.ImmutableSet keySet() -> keySet
    java.util.Set entrySet() -> entrySet
    java.util.Collection values() -> values
    java.util.Set keySet() -> keySet
    java.util.SortedMap tailMap(java.lang.Object) -> tailMap
    java.util.SortedMap headMap(java.lang.Object) -> headMap
    java.util.SortedMap subMap(java.lang.Object,java.lang.Object) -> subMap
    java.util.NavigableMap tailMap(java.lang.Object,boolean) -> tailMap
    java.util.NavigableMap headMap(java.lang.Object,boolean) -> headMap
    java.util.NavigableMap subMap(java.lang.Object,boolean,java.lang.Object,boolean) -> subMap
    java.util.NavigableSet descendingKeySet() -> descendingKeySet
    java.util.NavigableSet navigableKeySet() -> navigableKeySet
    java.util.NavigableMap descendingMap() -> descendingMap
    void <clinit>() -> <clinit>
com.google.common.collect.ImmutableSortedMap$Builder -> bm:
    java.util.Comparator comparator -> a
    void <init>(java.util.Comparator) -> <init>
    com.google.common.collect.ImmutableMap build() -> a
    com.google.common.collect.ImmutableMap$Builder put(java.lang.Object,java.lang.Object) -> a
com.google.common.collect.ImmutableSortedMap$SerializedForm -> com.google.common.collect.ImmutableSortedMap$SerializedForm:
    java.util.Comparator comparator -> comparator
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableSortedMap) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableSortedMapFauxverideShim -> com.google.common.collect.ImmutableSortedMapFauxverideShim:
    void <init>() -> <init>
    com.google.common.collect.ImmutableSortedMap$Builder builder() -> builder
    com.google.common.collect.ImmutableSortedMap of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedMap of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
com.google.common.collect.ImmutableSortedSet -> com.google.common.collect.ImmutableSortedSet:
    java.util.Comparator NATURAL_ORDER -> a
    com.google.common.collect.ImmutableSortedSet NATURAL_EMPTY_SET -> a
    java.util.Comparator comparator -> comparator
    com.google.common.collect.ImmutableSortedSet descendingSet -> descendingSet
    com.google.common.collect.ImmutableSortedSet emptySet(java.util.Comparator) -> emptySet
    com.google.common.collect.ImmutableSortedSet of() -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Comparable) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Comparable,java.lang.Comparable) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Comparable,java.lang.Comparable,java.lang.Comparable) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable[]) -> of
    com.google.common.collect.ImmutableSortedSet copyOf(java.lang.Comparable[]) -> copyOf
    com.google.common.collect.ImmutableSortedSet copyOf(java.lang.Iterable) -> copyOf
    com.google.common.collect.ImmutableSortedSet copyOf(java.util.Collection) -> copyOf
    com.google.common.collect.ImmutableSortedSet copyOf(java.util.Iterator) -> copyOf
    com.google.common.collect.ImmutableSortedSet copyOf(java.util.Comparator,java.util.Iterator) -> copyOf
    com.google.common.collect.ImmutableSortedSet copyOf(java.util.Comparator,java.lang.Iterable) -> copyOf
    com.google.common.collect.ImmutableSortedSet copyOf(java.util.Comparator,java.util.Collection) -> copyOf
    com.google.common.collect.ImmutableSortedSet copyOfSorted(java.util.SortedSet) -> copyOfSorted
    com.google.common.collect.ImmutableSortedSet construct(java.util.Comparator,int,java.lang.Object[]) -> construct
    com.google.common.collect.ImmutableSortedSet$Builder orderedBy(java.util.Comparator) -> orderedBy
    com.google.common.collect.ImmutableSortedSet$Builder reverseOrder() -> reverseOrder
    com.google.common.collect.ImmutableSortedSet$Builder naturalOrder() -> naturalOrder
    int unsafeCompare(java.lang.Object,java.lang.Object) -> unsafeCompare
    int unsafeCompare(java.util.Comparator,java.lang.Object,java.lang.Object) -> unsafeCompare
    void <init>(java.util.Comparator) -> <init>
    java.util.Comparator comparator() -> comparator
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.ImmutableSortedSet headSet(java.lang.Object) -> headSet
    com.google.common.collect.ImmutableSortedSet headSet(java.lang.Object,boolean) -> headSet
    com.google.common.collect.ImmutableSortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    com.google.common.collect.ImmutableSortedSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    com.google.common.collect.ImmutableSortedSet tailSet(java.lang.Object) -> tailSet
    com.google.common.collect.ImmutableSortedSet tailSet(java.lang.Object,boolean) -> tailSet
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> headSetImpl
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> subSetImpl
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> tailSetImpl
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.lang.Object first() -> first
    java.lang.Object last() -> last
    java.lang.Object pollFirst() -> pollFirst
    java.lang.Object pollLast() -> pollLast
    com.google.common.collect.ImmutableSortedSet descendingSet() -> descendingSet
    com.google.common.collect.ImmutableSortedSet createDescendingSet() -> createDescendingSet
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> descendingIterator
    int indexOf(java.lang.Object) -> indexOf
    void readObject(java.io.ObjectInputStream) -> readObject
    java.lang.Object writeReplace() -> writeReplace
    java.util.Iterator iterator() -> iterator
    java.util.SortedSet tailSet(java.lang.Object) -> tailSet
    java.util.SortedSet headSet(java.lang.Object) -> headSet
    java.util.SortedSet subSet(java.lang.Object,java.lang.Object) -> subSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet descendingSet() -> descendingSet
    void <clinit>() -> <clinit>
com.google.common.collect.ImmutableSortedSet$Builder -> bn:
    java.util.Comparator comparator -> a
    void <init>(java.util.Comparator) -> <init>
    com.google.common.collect.ImmutableSortedSet$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableSortedSet$Builder addAll(java.util.Iterator) -> a
    com.google.common.collect.ImmutableSortedSet build() -> a
    com.google.common.collect.ImmutableSet build() -> a
    com.google.common.collect.ImmutableSet$Builder addAll(java.util.Iterator) -> a
    com.google.common.collect.ImmutableSet$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableSet$Builder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableCollection$ArrayBasedBuilder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableCollection$Builder addAll(java.util.Iterator) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object) -> a
com.google.common.collect.ImmutableSortedSet$SerializedForm -> com.google.common.collect.ImmutableSortedSet$SerializedForm:
    java.util.Comparator comparator -> comparator
    java.lang.Object[] elements -> elements
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.Comparator,java.lang.Object[]) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.ImmutableSortedSetFauxverideShim -> com.google.common.collect.ImmutableSortedSetFauxverideShim:
    void <init>() -> <init>
    com.google.common.collect.ImmutableSortedSet$Builder builder() -> builder
    com.google.common.collect.ImmutableSortedSet of(java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> of
    com.google.common.collect.ImmutableSortedSet of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> of
    com.google.common.collect.ImmutableSortedSet copyOf(java.lang.Object[]) -> copyOf
com.google.common.collect.Iterables$8 -> bo:
    java.lang.Iterable val$fromIterable -> a
    com.google.common.base.Function val$function -> a
    void <init>(java.lang.Iterable,com.google.common.base.Function) -> <init>
    java.util.Iterator iterator() -> iterator
com.google.common.collect.Iterators -> bp:
    com.google.common.collect.UnmodifiableListIterator EMPTY_LIST_ITERATOR -> a
    java.util.Iterator EMPTY_MODIFIABLE_ITERATOR -> a
    com.google.common.collect.UnmodifiableIterator emptyIterator() -> a
    java.util.Iterator emptyModifiableIterator() -> a
    com.google.common.collect.UnmodifiableIterator unmodifiableIterator(java.util.Iterator) -> a
    int size(java.util.Iterator) -> a
    boolean contains(java.util.Iterator,java.lang.Object) -> a
    boolean removeAll(java.util.Iterator,java.util.Collection) -> a
    boolean removeIf(java.util.Iterator,com.google.common.base.Predicate) -> b
    boolean retainAll(java.util.Iterator,java.util.Collection) -> b
    boolean elementsEqual(java.util.Iterator,java.util.Iterator) -> a
    java.lang.String toString(java.util.Iterator) -> a
    java.lang.Object getOnlyElement(java.util.Iterator) -> a
    boolean addAll(java.util.Collection,java.util.Iterator) -> a
    java.util.Iterator concat(java.util.Iterator,java.util.Iterator) -> a
    com.google.common.collect.UnmodifiableIterator filter(java.util.Iterator,com.google.common.base.Predicate) -> a
    boolean all(java.util.Iterator,com.google.common.base.Predicate) -> a
    java.util.Iterator transform(java.util.Iterator,com.google.common.base.Function) -> a
    java.lang.Object getNext(java.util.Iterator,java.lang.Object) -> a
    java.lang.Object pollNext(java.util.Iterator) -> b
    void clear(java.util.Iterator) -> a
    com.google.common.collect.UnmodifiableIterator forArray(java.lang.Object[]) -> a
    com.google.common.collect.UnmodifiableListIterator forArray(java.lang.Object[],int,int,int) -> a
    com.google.common.collect.UnmodifiableIterator singletonIterator(java.lang.Object) -> a
    com.google.common.collect.PeekingIterator peekingIterator(java.util.Iterator) -> a
    void <clinit>() -> <clinit>
com.google.common.collect.Iterators$1 -> bq:
    void <init>() -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
com.google.common.collect.Iterators$11 -> br:
    java.lang.Object[] val$array -> a
    int val$offset -> a
    void <init>(int,int,java.lang.Object[],int) -> <init>
    java.lang.Object get(int) -> a
com.google.common.collect.Iterators$12 -> bs:
    boolean done -> a
    java.lang.Object val$value -> a
    void <init>(java.lang.Object) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.Iterators$2 -> bt:
    void <init>() -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.Iterators$3 -> bu:
    java.util.Iterator val$iterator -> a
    void <init>(java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.Iterators$5 -> bv:
    java.util.Iterator current -> a
    java.util.Iterator removeFrom -> b
    java.util.Iterator val$inputs -> c
    void <init>(java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.Iterators$7 -> bw:
    java.util.Iterator val$unfiltered -> a
    com.google.common.base.Predicate val$predicate -> a
    void <init>(java.util.Iterator,com.google.common.base.Predicate) -> <init>
    java.lang.Object computeNext() -> a
com.google.common.collect.Iterators$8 -> bx:
    com.google.common.base.Function val$function -> a
    void <init>(java.util.Iterator,com.google.common.base.Function) -> <init>
    java.lang.Object transform(java.lang.Object) -> a
com.google.common.collect.Iterators$PeekingImpl -> by:
    java.util.Iterator iterator -> a
    boolean hasPeeked -> a
    java.lang.Object peekedElement -> a
    void <init>(java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
    java.lang.Object peek() -> a
com.google.common.collect.LexicographicalOrdering -> com.google.common.collect.LexicographicalOrdering:
    com.google.common.collect.Ordering elementOrder -> elementOrder
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.Ordering) -> <init>
    int compare(java.lang.Iterable,java.lang.Iterable) -> compare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.common.collect.LinkedHashMultiset -> com.google.common.collect.LinkedHashMultiset:
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.LinkedHashMultiset create() -> create
    com.google.common.collect.LinkedHashMultiset create(int) -> create
    com.google.common.collect.LinkedHashMultiset create(java.lang.Iterable) -> create
    void <init>() -> <init>
    void <init>(int) -> <init>
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
    int setCount(java.lang.Object,int) -> setCount
    int remove(java.lang.Object,int) -> remove
    int add(java.lang.Object,int) -> add
    int count(java.lang.Object) -> count
    java.util.Iterator iterator() -> iterator
    int size() -> size
    void clear() -> clear
    java.util.Set entrySet() -> entrySet
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.util.Set elementSet() -> elementSet
    boolean retainAll(java.util.Collection) -> retainAll
    boolean removeAll(java.util.Collection) -> removeAll
    boolean addAll(java.util.Collection) -> addAll
    boolean setCount(java.lang.Object,int,int) -> setCount
    boolean remove(java.lang.Object) -> remove
    boolean add(java.lang.Object) -> add
    boolean contains(java.lang.Object) -> contains
    boolean isEmpty() -> isEmpty
com.google.common.collect.ListMultimap -> bz:
com.google.common.collect.Lists$OnePlusArrayList -> com.google.common.collect.Lists$OnePlusArrayList:
    java.lang.Object first -> first
    java.lang.Object[] rest -> rest
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Object,java.lang.Object[]) -> <init>
    int size() -> size
    java.lang.Object get(int) -> get
com.google.common.collect.MapMaker -> com.google.common.collect.MapMaker:
    boolean useCustomMap -> a
    int initialCapacity -> a
    int concurrencyLevel -> b
    int maximumSize -> c
    com.google.common.collect.MapMakerInternalMap$Strength keyStrength -> b
    com.google.common.collect.MapMakerInternalMap$Strength valueStrength -> a
    long expireAfterWriteNanos -> a
    long expireAfterAccessNanos -> b
    com.google.common.collect.MapMaker$RemovalCause nullRemovalCause -> a
    com.google.common.base.Equivalence keyEquivalence -> a
    void <init>() -> <init>
    int getInitialCapacity() -> a
    int getConcurrencyLevel() -> b
    com.google.common.collect.MapMaker setKeyStrength(com.google.common.collect.MapMakerInternalMap$Strength) -> a
    com.google.common.collect.MapMakerInternalMap$Strength getKeyStrength() -> a
    void checkExpiration(long,java.util.concurrent.TimeUnit) -> a
    java.util.concurrent.ConcurrentMap makeComputingMap(com.google.common.base.Function) -> a
    java.lang.String toString() -> toString
com.google.common.collect.MapMaker$ComputingMapAdapter -> com.google.common.collect.MapMaker$ComputingMapAdapter:
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.MapMaker,com.google.common.base.Function) -> <init>
    java.lang.Object get(java.lang.Object) -> get
com.google.common.collect.MapMaker$NullComputingConcurrentMap -> com.google.common.collect.MapMaker$NullComputingConcurrentMap:
    long serialVersionUID -> serialVersionUID
    com.google.common.base.Function computingFunction -> computingFunction
    void <init>(com.google.common.collect.MapMaker,com.google.common.base.Function) -> <init>
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object compute(java.lang.Object) -> a
com.google.common.collect.MapMaker$NullConcurrentMap -> com.google.common.collect.MapMaker$NullConcurrentMap:
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.MapMaker$RemovalListener removalListener -> removalListener
    com.google.common.collect.MapMaker$RemovalCause removalCause -> removalCause
    void <init>(com.google.common.collect.MapMaker) -> <init>
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    java.lang.Object get(java.lang.Object) -> get
    void notifyRemoval(java.lang.Object,java.lang.Object) -> notifyRemoval
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object) -> putIfAbsent
    java.lang.Object remove(java.lang.Object) -> remove
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    java.lang.Object replace(java.lang.Object,java.lang.Object) -> replace
    boolean replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    java.util.Set entrySet() -> entrySet
com.google.common.collect.MapMaker$RemovalCause -> com.google.common.collect.MapMaker$RemovalCause:
    com.google.common.collect.MapMaker$RemovalCause EXPLICIT -> EXPLICIT
    com.google.common.collect.MapMaker$RemovalCause REPLACED -> REPLACED
    com.google.common.collect.MapMaker$RemovalCause COLLECTED -> COLLECTED
    com.google.common.collect.MapMaker$RemovalCause EXPIRED -> EXPIRED
    com.google.common.collect.MapMaker$RemovalCause SIZE -> SIZE
    com.google.common.collect.MapMaker$RemovalCause[] $VALUES -> a
    com.google.common.collect.MapMaker$RemovalCause[] values() -> values
    com.google.common.collect.MapMaker$RemovalCause valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    boolean wasEvicted() -> wasEvicted
    void <init>(java.lang.String,int,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.MapMaker$RemovalCause$1 -> com.google.common.collect.MapMaker$RemovalCause$1:
    void <init>(java.lang.String,int) -> <init>
    boolean wasEvicted() -> wasEvicted
com.google.common.collect.MapMaker$RemovalCause$2 -> com.google.common.collect.MapMaker$RemovalCause$2:
    void <init>(java.lang.String,int) -> <init>
    boolean wasEvicted() -> wasEvicted
com.google.common.collect.MapMaker$RemovalCause$3 -> com.google.common.collect.MapMaker$RemovalCause$3:
    void <init>(java.lang.String,int) -> <init>
    boolean wasEvicted() -> wasEvicted
com.google.common.collect.MapMaker$RemovalCause$4 -> com.google.common.collect.MapMaker$RemovalCause$4:
    void <init>(java.lang.String,int) -> <init>
    boolean wasEvicted() -> wasEvicted
com.google.common.collect.MapMaker$RemovalCause$5 -> com.google.common.collect.MapMaker$RemovalCause$5:
    void <init>(java.lang.String,int) -> <init>
    boolean wasEvicted() -> wasEvicted
com.google.common.collect.MapMaker$RemovalListener -> bA:
    void onRemoval(com.google.common.collect.MapMaker$RemovalNotification) -> onRemoval
com.google.common.collect.MapMaker$RemovalNotification -> com.google.common.collect.MapMaker$RemovalNotification:
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.MapMaker$RemovalCause cause -> cause
    void <init>(java.lang.Object,java.lang.Object,com.google.common.collect.MapMaker$RemovalCause) -> <init>
    com.google.common.collect.MapMaker$RemovalCause getCause() -> getCause
    boolean wasEvicted() -> wasEvicted
com.google.common.collect.MapMakerInternalMap -> com.google.common.collect.MapMakerInternalMap:
    int MAXIMUM_CAPACITY -> MAXIMUM_CAPACITY
    int MAX_SEGMENTS -> MAX_SEGMENTS
    int CONTAINS_VALUE_RETRIES -> CONTAINS_VALUE_RETRIES
    int DRAIN_THRESHOLD -> DRAIN_THRESHOLD
    int DRAIN_MAX -> DRAIN_MAX
    long CLEANUP_EXECUTOR_DELAY_SECS -> CLEANUP_EXECUTOR_DELAY_SECS
    java.util.logging.Logger logger -> a
    int segmentMask -> segmentMask
    int segmentShift -> segmentShift
    com.google.common.collect.MapMakerInternalMap$Segment[] segments -> segments
    int concurrencyLevel -> concurrencyLevel
    com.google.common.base.Equivalence keyEquivalence -> keyEquivalence
    com.google.common.base.Equivalence valueEquivalence -> valueEquivalence
    com.google.common.collect.MapMakerInternalMap$Strength keyStrength -> keyStrength
    com.google.common.collect.MapMakerInternalMap$Strength valueStrength -> valueStrength
    int maximumSize -> maximumSize
    long expireAfterAccessNanos -> expireAfterAccessNanos
    long expireAfterWriteNanos -> expireAfterWriteNanos
    java.util.Queue removalNotificationQueue -> removalNotificationQueue
    com.google.common.collect.MapMaker$RemovalListener removalListener -> removalListener
    com.google.common.collect.MapMakerInternalMap$EntryFactory entryFactory -> entryFactory
    com.google.common.base.Ticker ticker -> ticker
    com.google.common.collect.MapMakerInternalMap$ValueReference UNSET -> UNSET
    java.util.Queue DISCARDING_QUEUE -> DISCARDING_QUEUE
    java.util.Set keySet -> keySet
    java.util.Collection values -> values
    java.util.Set entrySet -> entrySet
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.MapMaker) -> <init>
    boolean evictsBySize() -> evictsBySize
    boolean expires() -> expires
    boolean expiresAfterWrite() -> expiresAfterWrite
    boolean expiresAfterAccess() -> expiresAfterAccess
    boolean usesKeyReferences() -> usesKeyReferences
    boolean usesValueReferences() -> usesValueReferences
    com.google.common.collect.MapMakerInternalMap$ValueReference unset() -> unset
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nullEntry() -> nullEntry
    java.util.Queue discardingQueue() -> discardingQueue
    int rehash(int) -> rehash
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
    com.google.common.collect.MapMakerInternalMap$ValueReference newValueReference(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,java.lang.Object) -> newValueReference
    int hash(java.lang.Object) -> hash
    void reclaimValue(com.google.common.collect.MapMakerInternalMap$ValueReference) -> reclaimValue
    void reclaimKey(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> reclaimKey
    boolean isLive(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> isLive
    com.google.common.collect.MapMakerInternalMap$Segment segmentFor(int) -> segmentFor
    com.google.common.collect.MapMakerInternalMap$Segment createSegment(int,int) -> createSegment
    java.lang.Object getLiveValue(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> getLiveValue
    boolean isExpired(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> isExpired
    boolean isExpired(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,long) -> isExpired
    void connectExpirables(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> connectExpirables
    void nullifyExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> nullifyExpirable
    void processPendingNotifications() -> processPendingNotifications
    void connectEvictables(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> connectEvictables
    void nullifyEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> nullifyEvictable
    com.google.common.collect.MapMakerInternalMap$Segment[] newSegmentArray(int) -> newSegmentArray
    boolean isEmpty() -> isEmpty
    int size() -> size
    java.lang.Object get(java.lang.Object) -> get
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry(java.lang.Object) -> getEntry
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object) -> putIfAbsent
    void putAll(java.util.Map) -> putAll
    java.lang.Object remove(java.lang.Object) -> remove
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    boolean replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    java.lang.Object replace(java.lang.Object,java.lang.Object) -> replace
    void clear() -> clear
    java.util.Set keySet() -> keySet
    java.util.Collection values() -> values
    java.util.Set entrySet() -> entrySet
    java.lang.Object writeReplace() -> writeReplace
    void <clinit>() -> <clinit>
com.google.common.collect.MapMakerInternalMap$1 -> bB:
    void <init>() -> <init>
    java.lang.Object get() -> get
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry() -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    boolean isComputingReference() -> a
    java.lang.Object waitForValue() -> a
    void clear(com.google.common.collect.MapMakerInternalMap$ValueReference) -> a
com.google.common.collect.MapMakerInternalMap$2 -> bC:
    void <init>() -> <init>
    boolean offer(java.lang.Object) -> offer
    java.lang.Object peek() -> peek
    java.lang.Object poll() -> poll
    int size() -> size
    java.util.Iterator iterator() -> iterator
com.google.common.collect.MapMakerInternalMap$AbstractReferenceEntry -> bD:
    void <init>() -> <init>
    com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference() -> getValueReference
    void setValueReference(com.google.common.collect.MapMakerInternalMap$ValueReference) -> setValueReference
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNext() -> getNext
    int getHash() -> getHash
    java.lang.Object getKey() -> getKey
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
com.google.common.collect.MapMakerInternalMap$AbstractSerializationProxy -> com.google.common.collect.MapMakerInternalMap$AbstractSerializationProxy:
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.MapMakerInternalMap$Strength keyStrength -> keyStrength
    com.google.common.collect.MapMakerInternalMap$Strength valueStrength -> valueStrength
    com.google.common.base.Equivalence keyEquivalence -> keyEquivalence
    com.google.common.base.Equivalence valueEquivalence -> valueEquivalence
    long expireAfterWriteNanos -> expireAfterWriteNanos
    long expireAfterAccessNanos -> expireAfterAccessNanos
    int maximumSize -> maximumSize
    int concurrencyLevel -> concurrencyLevel
    com.google.common.collect.MapMaker$RemovalListener removalListener -> removalListener
    java.util.concurrent.ConcurrentMap delegate -> delegate
    void <init>(com.google.common.collect.MapMakerInternalMap$Strength,com.google.common.collect.MapMakerInternalMap$Strength,com.google.common.base.Equivalence,com.google.common.base.Equivalence,long,long,int,int,com.google.common.collect.MapMaker$RemovalListener,java.util.concurrent.ConcurrentMap) -> <init>
    java.util.concurrent.ConcurrentMap delegate() -> delegate
    void writeMapTo(java.io.ObjectOutputStream) -> writeMapTo
    com.google.common.collect.MapMaker readMapMaker(java.io.ObjectInputStream) -> readMapMaker
    void readEntries(java.io.ObjectInputStream) -> readEntries
    java.util.Map delegate() -> delegate
    java.lang.Object delegate() -> delegate
com.google.common.collect.MapMakerInternalMap$EntryFactory -> com.google.common.collect.MapMakerInternalMap$EntryFactory:
    com.google.common.collect.MapMakerInternalMap$EntryFactory STRONG -> STRONG
    com.google.common.collect.MapMakerInternalMap$EntryFactory STRONG_EXPIRABLE -> STRONG_EXPIRABLE
    com.google.common.collect.MapMakerInternalMap$EntryFactory STRONG_EVICTABLE -> STRONG_EVICTABLE
    com.google.common.collect.MapMakerInternalMap$EntryFactory STRONG_EXPIRABLE_EVICTABLE -> STRONG_EXPIRABLE_EVICTABLE
    com.google.common.collect.MapMakerInternalMap$EntryFactory WEAK -> WEAK
    com.google.common.collect.MapMakerInternalMap$EntryFactory WEAK_EXPIRABLE -> WEAK_EXPIRABLE
    com.google.common.collect.MapMakerInternalMap$EntryFactory WEAK_EVICTABLE -> WEAK_EVICTABLE
    com.google.common.collect.MapMakerInternalMap$EntryFactory WEAK_EXPIRABLE_EVICTABLE -> WEAK_EXPIRABLE_EVICTABLE
    int EXPIRABLE_MASK -> EXPIRABLE_MASK
    int EVICTABLE_MASK -> EVICTABLE_MASK
    com.google.common.collect.MapMakerInternalMap$EntryFactory[][] factories -> factories
    com.google.common.collect.MapMakerInternalMap$EntryFactory[] $VALUES -> a
    com.google.common.collect.MapMakerInternalMap$EntryFactory[] values() -> values
    com.google.common.collect.MapMakerInternalMap$EntryFactory valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$EntryFactory getFactory(com.google.common.collect.MapMakerInternalMap$Strength,boolean,boolean) -> getFactory
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
    void copyExpirableEntry(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyExpirableEntry
    void copyEvictableEntry(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEvictableEntry
    void <init>(java.lang.String,int,com.google.common.collect.MapMakerInternalMap$1) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.MapMakerInternalMap$EntryFactory$1 -> com.google.common.collect.MapMakerInternalMap$EntryFactory$1:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
com.google.common.collect.MapMakerInternalMap$EntryFactory$2 -> com.google.common.collect.MapMakerInternalMap$EntryFactory$2:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
com.google.common.collect.MapMakerInternalMap$EntryFactory$3 -> com.google.common.collect.MapMakerInternalMap$EntryFactory$3:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
com.google.common.collect.MapMakerInternalMap$EntryFactory$4 -> com.google.common.collect.MapMakerInternalMap$EntryFactory$4:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
com.google.common.collect.MapMakerInternalMap$EntryFactory$5 -> com.google.common.collect.MapMakerInternalMap$EntryFactory$5:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
com.google.common.collect.MapMakerInternalMap$EntryFactory$6 -> com.google.common.collect.MapMakerInternalMap$EntryFactory$6:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
com.google.common.collect.MapMakerInternalMap$EntryFactory$7 -> com.google.common.collect.MapMakerInternalMap$EntryFactory$7:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
com.google.common.collect.MapMakerInternalMap$EntryFactory$8 -> com.google.common.collect.MapMakerInternalMap$EntryFactory$8:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(com.google.common.collect.MapMakerInternalMap$Segment,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
com.google.common.collect.MapMakerInternalMap$EntryIterator -> bE:
    void <init>(com.google.common.collect.MapMakerInternalMap) -> <init>
    java.lang.Object next() -> next
com.google.common.collect.MapMakerInternalMap$EntrySet -> bF:
    com.google.common.collect.MapMakerInternalMap this$0 -> a
    void <init>(com.google.common.collect.MapMakerInternalMap) -> <init>
    java.util.Iterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    int size() -> size
    boolean isEmpty() -> isEmpty
    void clear() -> clear
com.google.common.collect.MapMakerInternalMap$EvictionQueue -> bG:
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry head -> a
    void <init>() -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry peek() -> a
    boolean remove(java.lang.Object) -> remove
    boolean contains(java.lang.Object) -> contains
    boolean isEmpty() -> isEmpty
    int size() -> size
    void clear() -> clear
    java.util.Iterator iterator() -> iterator
    java.lang.Object peek() -> peek
    java.lang.Object poll() -> poll
    boolean offer(java.lang.Object) -> offer
com.google.common.collect.MapMakerInternalMap$EvictionQueue$1 -> bH:
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextEvictable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousEvictable -> b
    void <init>(com.google.common.collect.MapMakerInternalMap$EvictionQueue) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
com.google.common.collect.MapMakerInternalMap$EvictionQueue$2 -> bI:
    com.google.common.collect.MapMakerInternalMap$EvictionQueue this$0 -> a
    void <init>(com.google.common.collect.MapMakerInternalMap$EvictionQueue,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    java.lang.Object computeNext(java.lang.Object) -> a
com.google.common.collect.MapMakerInternalMap$ExpirationQueue -> bJ:
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry head -> a
    void <init>() -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry peek() -> a
    boolean remove(java.lang.Object) -> remove
    boolean contains(java.lang.Object) -> contains
    boolean isEmpty() -> isEmpty
    int size() -> size
    void clear() -> clear
    java.util.Iterator iterator() -> iterator
    java.lang.Object peek() -> peek
    java.lang.Object poll() -> poll
    boolean offer(java.lang.Object) -> offer
com.google.common.collect.MapMakerInternalMap$ExpirationQueue$1 -> bK:
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextExpirable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousExpirable -> b
    void <init>(com.google.common.collect.MapMakerInternalMap$ExpirationQueue) -> <init>
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
com.google.common.collect.MapMakerInternalMap$ExpirationQueue$2 -> bL:
    com.google.common.collect.MapMakerInternalMap$ExpirationQueue this$0 -> a
    void <init>(com.google.common.collect.MapMakerInternalMap$ExpirationQueue,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    java.lang.Object computeNext(java.lang.Object) -> a
com.google.common.collect.MapMakerInternalMap$HashIterator -> bM:
    int nextSegmentIndex -> a
    int nextTableIndex -> b
    com.google.common.collect.MapMakerInternalMap$Segment currentSegment -> a
    java.util.concurrent.atomic.AtomicReferenceArray currentTable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextEntry -> a
    com.google.common.collect.MapMakerInternalMap$WriteThroughEntry nextExternal -> a
    com.google.common.collect.MapMakerInternalMap$WriteThroughEntry lastReturned -> b
    com.google.common.collect.MapMakerInternalMap this$0 -> a
    void <init>(com.google.common.collect.MapMakerInternalMap) -> <init>
    void advance() -> a
    boolean nextInChain() -> a
    boolean nextInTable() -> b
    boolean advanceTo(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    boolean hasNext() -> hasNext
    com.google.common.collect.MapMakerInternalMap$WriteThroughEntry nextEntry() -> a
    void remove() -> remove
com.google.common.collect.MapMakerInternalMap$KeyIterator -> bN:
    void <init>(com.google.common.collect.MapMakerInternalMap) -> <init>
    java.lang.Object next() -> next
com.google.common.collect.MapMakerInternalMap$KeySet -> bO:
    com.google.common.collect.MapMakerInternalMap this$0 -> a
    void <init>(com.google.common.collect.MapMakerInternalMap) -> <init>
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
com.google.common.collect.MapMakerInternalMap$NullEntry -> com.google.common.collect.MapMakerInternalMap$NullEntry:
    com.google.common.collect.MapMakerInternalMap$NullEntry INSTANCE -> INSTANCE
    com.google.common.collect.MapMakerInternalMap$NullEntry[] $VALUES -> a
    com.google.common.collect.MapMakerInternalMap$NullEntry[] values() -> values
    com.google.common.collect.MapMakerInternalMap$NullEntry valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference() -> getValueReference
    void setValueReference(com.google.common.collect.MapMakerInternalMap$ValueReference) -> setValueReference
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNext() -> getNext
    int getHash() -> getHash
    java.lang.Object getKey() -> getKey
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
    void <clinit>() -> <clinit>
com.google.common.collect.MapMakerInternalMap$ReferenceEntry -> bP:
    com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference() -> getValueReference
    void setValueReference(com.google.common.collect.MapMakerInternalMap$ValueReference) -> setValueReference
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNext() -> getNext
    int getHash() -> getHash
    java.lang.Object getKey() -> getKey
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
com.google.common.collect.MapMakerInternalMap$Segment -> com.google.common.collect.MapMakerInternalMap$Segment:
    com.google.common.collect.MapMakerInternalMap map -> map
    int count -> count
    int modCount -> modCount
    int threshold -> threshold
    java.util.concurrent.atomic.AtomicReferenceArray table -> table
    int maxSegmentSize -> maxSegmentSize
    java.lang.ref.ReferenceQueue keyReferenceQueue -> keyReferenceQueue
    java.lang.ref.ReferenceQueue valueReferenceQueue -> valueReferenceQueue
    java.util.Queue recencyQueue -> recencyQueue
    java.util.concurrent.atomic.AtomicInteger readCount -> readCount
    java.util.Queue evictionQueue -> evictionQueue
    java.util.Queue expirationQueue -> expirationQueue
    void <init>(com.google.common.collect.MapMakerInternalMap,int,int) -> <init>
    java.util.concurrent.atomic.AtomicReferenceArray newEntryArray(int) -> newEntryArray
    void initTable(java.util.concurrent.atomic.AtomicReferenceArray) -> initTable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry newEntry(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> newEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry copyEntry(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> copyEntry
    void setValue(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,java.lang.Object) -> setValue
    void tryDrainReferenceQueues() -> tryDrainReferenceQueues
    void drainReferenceQueues() -> drainReferenceQueues
    void drainKeyReferenceQueue() -> drainKeyReferenceQueue
    void drainValueReferenceQueue() -> drainValueReferenceQueue
    void clearReferenceQueues() -> clearReferenceQueues
    void clearKeyReferenceQueue() -> clearKeyReferenceQueue
    void clearValueReferenceQueue() -> clearValueReferenceQueue
    void recordRead(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> recordRead
    void recordLockedRead(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> recordLockedRead
    void recordWrite(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> recordWrite
    void drainRecencyQueue() -> drainRecencyQueue
    void recordExpirationTime(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,long) -> recordExpirationTime
    void tryExpireEntries() -> tryExpireEntries
    void expireEntries() -> expireEntries
    void enqueueNotification(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMaker$RemovalCause) -> enqueueNotification
    void enqueueNotification(java.lang.Object,int,java.lang.Object,com.google.common.collect.MapMaker$RemovalCause) -> enqueueNotification
    boolean evictEntries() -> evictEntries
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getFirst(int) -> getFirst
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry(java.lang.Object,int) -> getEntry
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getLiveEntry(java.lang.Object,int) -> getLiveEntry
    java.lang.Object get(java.lang.Object,int) -> get
    boolean containsKey(java.lang.Object,int) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    java.lang.Object put(java.lang.Object,int,java.lang.Object,boolean) -> put
    void expand() -> expand
    boolean replace(java.lang.Object,int,java.lang.Object,java.lang.Object) -> replace
    java.lang.Object replace(java.lang.Object,int,java.lang.Object) -> replace
    java.lang.Object remove(java.lang.Object,int) -> remove
    boolean remove(java.lang.Object,int,java.lang.Object) -> remove
    void clear() -> clear
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry removeFromChain(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> removeFromChain
    void removeCollectedEntry(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> removeCollectedEntry
    boolean reclaimKey(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,int) -> reclaimKey
    boolean reclaimValue(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ValueReference) -> reclaimValue
    boolean clearValue(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ValueReference) -> clearValue
    boolean removeEntry(com.google.common.collect.MapMakerInternalMap$ReferenceEntry,int,com.google.common.collect.MapMaker$RemovalCause) -> removeEntry
    boolean isCollected(com.google.common.collect.MapMakerInternalMap$ValueReference) -> isCollected
    java.lang.Object getLiveValue(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> getLiveValue
    void postReadCleanup() -> postReadCleanup
    void preWriteCleanup() -> preWriteCleanup
    void postWriteCleanup() -> postWriteCleanup
    void runCleanup() -> runCleanup
    void runLockedCleanup() -> runLockedCleanup
    void runUnlockedCleanup() -> runUnlockedCleanup
com.google.common.collect.MapMakerInternalMap$SerializationProxy -> com.google.common.collect.MapMakerInternalMap$SerializationProxy:
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.MapMakerInternalMap$Strength,com.google.common.collect.MapMakerInternalMap$Strength,com.google.common.base.Equivalence,com.google.common.base.Equivalence,long,long,int,int,com.google.common.collect.MapMaker$RemovalListener,java.util.concurrent.ConcurrentMap) -> <init>
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.MapMakerInternalMap$SoftValueReference -> bQ:
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry entry -> a
    void <init>(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry() -> a
    void clear(com.google.common.collect.MapMakerInternalMap$ValueReference) -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    boolean isComputingReference() -> a
    java.lang.Object waitForValue() -> a
com.google.common.collect.MapMakerInternalMap$Strength -> com.google.common.collect.MapMakerInternalMap$Strength:
    com.google.common.collect.MapMakerInternalMap$Strength STRONG -> STRONG
    com.google.common.collect.MapMakerInternalMap$Strength SOFT -> SOFT
    com.google.common.collect.MapMakerInternalMap$Strength WEAK -> WEAK
    com.google.common.collect.MapMakerInternalMap$Strength[] $VALUES -> a
    com.google.common.collect.MapMakerInternalMap$Strength[] values() -> values
    com.google.common.collect.MapMakerInternalMap$Strength valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ValueReference referenceValue(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,java.lang.Object) -> referenceValue
    com.google.common.base.Equivalence defaultEquivalence() -> defaultEquivalence
    void <init>(java.lang.String,int,com.google.common.collect.MapMakerInternalMap$1) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.MapMakerInternalMap$Strength$1 -> com.google.common.collect.MapMakerInternalMap$Strength$1:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ValueReference referenceValue(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,java.lang.Object) -> referenceValue
    com.google.common.base.Equivalence defaultEquivalence() -> defaultEquivalence
com.google.common.collect.MapMakerInternalMap$Strength$2 -> com.google.common.collect.MapMakerInternalMap$Strength$2:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ValueReference referenceValue(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,java.lang.Object) -> referenceValue
    com.google.common.base.Equivalence defaultEquivalence() -> defaultEquivalence
com.google.common.collect.MapMakerInternalMap$Strength$3 -> com.google.common.collect.MapMakerInternalMap$Strength$3:
    void <init>(java.lang.String,int) -> <init>
    com.google.common.collect.MapMakerInternalMap$ValueReference referenceValue(com.google.common.collect.MapMakerInternalMap$Segment,com.google.common.collect.MapMakerInternalMap$ReferenceEntry,java.lang.Object) -> referenceValue
    com.google.common.base.Equivalence defaultEquivalence() -> defaultEquivalence
com.google.common.collect.MapMakerInternalMap$StrongEntry -> bR:
    java.lang.Object key -> a
    int hash -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry next -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference valueReference -> a
    void <init>(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    java.lang.Object getKey() -> getKey
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
    com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference() -> getValueReference
    void setValueReference(com.google.common.collect.MapMakerInternalMap$ValueReference) -> setValueReference
    int getHash() -> getHash
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNext() -> getNext
com.google.common.collect.MapMakerInternalMap$StrongEvictableEntry -> bS:
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextEvictable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousEvictable -> b
    void <init>(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
com.google.common.collect.MapMakerInternalMap$StrongExpirableEntry -> bT:
    long time -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextExpirable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousExpirable -> b
    void <init>(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
com.google.common.collect.MapMakerInternalMap$StrongExpirableEvictableEntry -> bU:
    long time -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextExpirable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousExpirable -> b
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextEvictable -> c
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousEvictable -> d
    void <init>(java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
com.google.common.collect.MapMakerInternalMap$StrongValueReference -> bV:
    java.lang.Object referent -> a
    void <init>(java.lang.Object) -> <init>
    java.lang.Object get() -> get
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry() -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    boolean isComputingReference() -> a
    java.lang.Object waitForValue() -> a
    void clear(com.google.common.collect.MapMakerInternalMap$ValueReference) -> a
com.google.common.collect.MapMakerInternalMap$ValueIterator -> bW:
    void <init>(com.google.common.collect.MapMakerInternalMap) -> <init>
    java.lang.Object next() -> next
com.google.common.collect.MapMakerInternalMap$ValueReference -> bX:
    java.lang.Object get() -> get
    java.lang.Object waitForValue() -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry() -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    void clear(com.google.common.collect.MapMakerInternalMap$ValueReference) -> a
    boolean isComputingReference() -> a
com.google.common.collect.MapMakerInternalMap$Values -> bY:
    com.google.common.collect.MapMakerInternalMap this$0 -> a
    void <init>(com.google.common.collect.MapMakerInternalMap) -> <init>
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    void clear() -> clear
com.google.common.collect.MapMakerInternalMap$WeakEntry -> bZ:
    int hash -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry next -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference valueReference -> a
    void <init>(java.lang.ref.ReferenceQueue,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    java.lang.Object getKey() -> getKey
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
    com.google.common.collect.MapMakerInternalMap$ValueReference getValueReference() -> getValueReference
    void setValueReference(com.google.common.collect.MapMakerInternalMap$ValueReference) -> setValueReference
    int getHash() -> getHash
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNext() -> getNext
com.google.common.collect.MapMakerInternalMap$WeakEvictableEntry -> ca:
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextEvictable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousEvictable -> b
    void <init>(java.lang.ref.ReferenceQueue,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
com.google.common.collect.MapMakerInternalMap$WeakExpirableEntry -> cb:
    long time -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextExpirable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousExpirable -> b
    void <init>(java.lang.ref.ReferenceQueue,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
com.google.common.collect.MapMakerInternalMap$WeakExpirableEvictableEntry -> cc:
    long time -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextExpirable -> a
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousExpirable -> b
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry nextEvictable -> c
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry previousEvictable -> d
    void <init>(java.lang.ref.ReferenceQueue,java.lang.Object,int,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    long getExpirationTime() -> getExpirationTime
    void setExpirationTime(long) -> setExpirationTime
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextExpirable() -> getNextExpirable
    void setNextExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousExpirable() -> getPreviousExpirable
    void setPreviousExpirable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousExpirable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getNextEvictable() -> getNextEvictable
    void setNextEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setNextEvictable
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getPreviousEvictable() -> getPreviousEvictable
    void setPreviousEvictable(com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> setPreviousEvictable
com.google.common.collect.MapMakerInternalMap$WeakValueReference -> cd:
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry entry -> a
    void <init>(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> <init>
    com.google.common.collect.MapMakerInternalMap$ReferenceEntry getEntry() -> a
    void clear(com.google.common.collect.MapMakerInternalMap$ValueReference) -> a
    com.google.common.collect.MapMakerInternalMap$ValueReference copyFor(java.lang.ref.ReferenceQueue,java.lang.Object,com.google.common.collect.MapMakerInternalMap$ReferenceEntry) -> a
    boolean isComputingReference() -> a
    java.lang.Object waitForValue() -> a
com.google.common.collect.MapMakerInternalMap$WriteThroughEntry -> ce:
    java.lang.Object key -> a
    java.lang.Object value -> b
    com.google.common.collect.MapMakerInternalMap this$0 -> a
    void <init>(com.google.common.collect.MapMakerInternalMap,java.lang.Object,java.lang.Object) -> <init>
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object setValue(java.lang.Object) -> setValue
com.google.common.collect.Maps -> com.google.common.collect.Maps:
    com.google.common.base.Joiner$MapJoiner STANDARD_JOINER -> a
    com.google.common.base.Function keyFunction() -> a
    java.util.Iterator keyIterator(java.util.Iterator) -> a
    java.util.Iterator valueIterator(java.util.Iterator) -> b
    com.google.common.collect.UnmodifiableIterator valueIterator(com.google.common.collect.UnmodifiableIterator) -> a
    java.util.HashMap newHashMapWithExpectedSize(int) -> a
    int capacity(int) -> a
    java.util.Map$Entry immutableEntry(java.lang.Object,java.lang.Object) -> a
    java.lang.Object safeGet(java.util.Map,java.lang.Object) -> a
    boolean safeContainsKey(java.util.Map,java.lang.Object) -> a
    java.lang.Object safeRemove(java.util.Map,java.lang.Object) -> b
    boolean containsKeyImpl(java.util.Map,java.lang.Object) -> b
    boolean containsValueImpl(java.util.Map,java.lang.Object) -> c
    boolean equalsImpl(java.util.Map,java.lang.Object) -> d
    java.lang.String toStringImpl(java.util.Map) -> a
    void putAllImpl(java.util.Map,java.util.Map) -> a
    java.lang.Object keyOrNull(java.util.Map$Entry) -> a
    void <clinit>() -> <clinit>
com.google.common.collect.Maps$1 -> cf:
    com.google.common.collect.UnmodifiableIterator val$entryIterator -> a
    void <init>(com.google.common.collect.UnmodifiableIterator) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.Maps$EntryFunction -> com.google.common.collect.Maps$EntryFunction:
    com.google.common.collect.Maps$EntryFunction KEY -> KEY
    com.google.common.collect.Maps$EntryFunction VALUE -> VALUE
    com.google.common.collect.Maps$EntryFunction[] $VALUES -> a
    com.google.common.collect.Maps$EntryFunction[] values() -> values
    com.google.common.collect.Maps$EntryFunction valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <init>(java.lang.String,int,com.google.common.collect.Maps$1) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.Maps$EntryFunction$1 -> com.google.common.collect.Maps$EntryFunction$1:
    void <init>(java.lang.String,int) -> <init>
    java.lang.Object apply(java.util.Map$Entry) -> apply
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Maps$EntryFunction$2 -> com.google.common.collect.Maps$EntryFunction$2:
    void <init>(java.lang.String,int) -> <init>
    java.lang.Object apply(java.util.Map$Entry) -> apply
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Maps$EntrySet -> cg:
    void <init>() -> <init>
    java.util.Map map() -> a
    int size() -> size
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean isEmpty() -> isEmpty
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.Maps$ImprovedAbstractMap -> ch:
    java.util.Set entrySet -> a
    java.util.Set keySet -> b
    java.util.Collection values -> a
    void <init>() -> <init>
    java.util.Set createEntrySet() -> a
    java.util.Set entrySet() -> entrySet
    java.util.Set keySet() -> keySet
    java.util.Set createKeySet() -> b
    java.util.Collection values() -> values
com.google.common.collect.Maps$KeySet -> ci:
    java.util.Map map -> a
    void <init>(java.util.Map) -> <init>
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
com.google.common.collect.Maps$Values -> cj:
    java.util.Map map -> a
    void <init>(java.util.Map) -> <init>
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    void clear() -> clear
com.google.common.collect.Multimap -> ck:
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsEntry(java.lang.Object,java.lang.Object) -> containsEntry
    boolean put(java.lang.Object,java.lang.Object) -> put
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    java.util.Collection removeAll(java.lang.Object) -> removeAll
    void clear() -> clear
    java.util.Collection get(java.lang.Object) -> get
    java.util.Set keySet() -> keySet
    java.util.Collection entries() -> entries
    java.util.Map asMap() -> asMap
com.google.common.collect.Multimaps$Entries -> cl:
    void <init>() -> <init>
    com.google.common.collect.Multimap multimap() -> a
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
com.google.common.collect.Multimaps$Keys -> cm:
    com.google.common.collect.Multimap multimap -> a
    void <init>(com.google.common.collect.Multimap) -> <init>
    java.util.Iterator entryIterator() -> entryIterator
    int distinctElements() -> distinctElements
    java.util.Set createEntrySet() -> createEntrySet
    boolean contains(java.lang.Object) -> contains
    java.util.Iterator iterator() -> iterator
    int count(java.lang.Object) -> count
    int remove(java.lang.Object,int) -> remove
    void clear() -> clear
    java.util.Set elementSet() -> elementSet
com.google.common.collect.Multimaps$Keys$1 -> cn:
    void <init>(com.google.common.collect.Multimaps$Keys,java.util.Iterator) -> <init>
    java.lang.Object transform(java.lang.Object) -> a
com.google.common.collect.Multimaps$Keys$1$1 -> co:
    java.util.Map$Entry val$backingEntry -> a
    void <init>(com.google.common.collect.Multimaps$Keys$1,java.util.Map$Entry) -> <init>
    java.lang.Object getElement() -> getElement
    int getCount() -> getCount
com.google.common.collect.Multimaps$Keys$KeysEntrySet -> cp:
    com.google.common.collect.Multimaps$Keys this$0 -> a
    void <init>(com.google.common.collect.Multimaps$Keys) -> <init>
    com.google.common.collect.Multiset multiset() -> a
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
com.google.common.collect.Multiset -> cq:
    int count(java.lang.Object) -> count
    int add(java.lang.Object,int) -> add
    int remove(java.lang.Object,int) -> remove
    int setCount(java.lang.Object,int) -> setCount
    boolean setCount(java.lang.Object,int,int) -> setCount
    java.util.Set elementSet() -> elementSet
    java.util.Set entrySet() -> entrySet
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean add(java.lang.Object) -> add
    boolean remove(java.lang.Object) -> remove
com.google.common.collect.Multiset$Entry -> cr:
    java.lang.Object getElement() -> getElement
    int getCount() -> getCount
com.google.common.collect.Multisets -> com.google.common.collect.Multisets:
    com.google.common.collect.Multiset$Entry immutableEntry(java.lang.Object,int) -> a
    int inferDistinctElements(java.lang.Iterable) -> a
    boolean equalsImpl(com.google.common.collect.Multiset,java.lang.Object) -> a
    boolean addAllImpl(com.google.common.collect.Multiset,java.util.Collection) -> a
    boolean removeAllImpl(com.google.common.collect.Multiset,java.util.Collection) -> b
    boolean retainAllImpl(com.google.common.collect.Multiset,java.util.Collection) -> c
    int setCountImpl(com.google.common.collect.Multiset,java.lang.Object,int) -> a
    boolean setCountImpl(com.google.common.collect.Multiset,java.lang.Object,int,int) -> a
    java.util.Iterator iteratorImpl(com.google.common.collect.Multiset) -> a
    int sizeImpl(com.google.common.collect.Multiset) -> a
    com.google.common.collect.Multiset cast(java.lang.Iterable) -> a
    void <clinit>() -> <clinit>
com.google.common.collect.Multisets$5 -> cs:
    void <init>() -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.common.collect.Multisets$AbstractEntry -> ct:
    void <init>() -> <init>
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.Multisets$ElementSet -> cu:
    void <init>() -> <init>
    com.google.common.collect.Multiset multiset() -> a
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean isEmpty() -> isEmpty
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    int size() -> size
com.google.common.collect.Multisets$ElementSet$1 -> cv:
    void <init>(com.google.common.collect.Multisets$ElementSet,java.util.Iterator) -> <init>
    java.lang.Object transform(java.lang.Object) -> a
com.google.common.collect.Multisets$EntrySet -> cw:
    void <init>() -> <init>
    com.google.common.collect.Multiset multiset() -> a
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    void clear() -> clear
com.google.common.collect.Multisets$ImmutableEntry -> com.google.common.collect.Multisets$ImmutableEntry:
    java.lang.Object element -> element
    int count -> count
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Object,int) -> <init>
    java.lang.Object getElement() -> getElement
    int getCount() -> getCount
com.google.common.collect.Multisets$MultisetIteratorImpl -> cx:
    com.google.common.collect.Multiset multiset -> a
    java.util.Iterator entryIterator -> a
    com.google.common.collect.Multiset$Entry currentEntry -> a
    int laterCount -> a
    int totalCount -> b
    boolean canRemove -> a
    void <init>(com.google.common.collect.Multiset,java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.NaturalOrdering -> com.google.common.collect.NaturalOrdering:
    com.google.common.collect.NaturalOrdering INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    int compare(java.lang.Comparable,java.lang.Comparable) -> compare
    com.google.common.collect.Ordering reverse() -> reverse
    java.lang.Object readResolve() -> readResolve
    java.lang.String toString() -> toString
    void <init>() -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    void <clinit>() -> <clinit>
com.google.common.collect.NullsFirstOrdering -> com.google.common.collect.NullsFirstOrdering:
    com.google.common.collect.Ordering ordering -> ordering
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.Ordering) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    com.google.common.collect.Ordering reverse() -> reverse
    com.google.common.collect.Ordering nullsFirst() -> nullsFirst
    com.google.common.collect.Ordering nullsLast() -> nullsLast
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.NullsLastOrdering -> com.google.common.collect.NullsLastOrdering:
    com.google.common.collect.Ordering ordering -> ordering
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.Ordering) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    com.google.common.collect.Ordering reverse() -> reverse
    com.google.common.collect.Ordering nullsFirst() -> nullsFirst
    com.google.common.collect.Ordering nullsLast() -> nullsLast
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.collect.ObjectArrays -> cy:
    java.lang.Object[] EMPTY_ARRAY -> a
    java.lang.Object[] newArray(java.lang.Object[],int) -> a
    java.lang.Object[] arraysCopyOf(java.lang.Object[],int) -> b
    java.lang.Object[] toArrayImpl(java.util.Collection,java.lang.Object[]) -> a
    void swap(java.lang.Object[],int,int) -> a
    java.lang.Object[] checkElementsNotNull(java.lang.Object[]) -> a
    java.lang.Object[] checkElementsNotNull(java.lang.Object[],int) -> c
    java.lang.Object checkElementNotNull(java.lang.Object,int) -> a
    void <clinit>() -> <clinit>
com.google.common.collect.Ordering -> com.google.common.collect.Ordering:
    int LEFT_IS_GREATER -> LEFT_IS_GREATER
    int RIGHT_IS_GREATER -> RIGHT_IS_GREATER
    com.google.common.collect.Ordering natural() -> natural
    com.google.common.collect.Ordering from(java.util.Comparator) -> from
    com.google.common.collect.Ordering from(com.google.common.collect.Ordering) -> from
    com.google.common.collect.Ordering explicit(java.util.List) -> explicit
    com.google.common.collect.Ordering explicit(java.lang.Object,java.lang.Object[]) -> explicit
    com.google.common.collect.Ordering allEqual() -> allEqual
    com.google.common.collect.Ordering usingToString() -> usingToString
    com.google.common.collect.Ordering arbitrary() -> arbitrary
    void <init>() -> <init>
    com.google.common.collect.Ordering reverse() -> reverse
    com.google.common.collect.Ordering nullsFirst() -> nullsFirst
    com.google.common.collect.Ordering nullsLast() -> nullsLast
    com.google.common.collect.Ordering onResultOf(com.google.common.base.Function) -> onResultOf
    com.google.common.collect.Ordering onKeys() -> onKeys
    com.google.common.collect.Ordering compound(java.util.Comparator) -> compound
    com.google.common.collect.Ordering compound(java.lang.Iterable) -> compound
    com.google.common.collect.Ordering lexicographical() -> lexicographical
    int compare(java.lang.Object,java.lang.Object) -> compare
    java.lang.Object min(java.util.Iterator) -> min
    java.lang.Object min(java.lang.Iterable) -> min
    java.lang.Object min(java.lang.Object,java.lang.Object) -> min
    java.lang.Object min(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> min
    java.lang.Object max(java.util.Iterator) -> max
    java.lang.Object max(java.lang.Iterable) -> max
    java.lang.Object max(java.lang.Object,java.lang.Object) -> max
    java.lang.Object max(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> max
    java.util.List leastOf(java.lang.Iterable,int) -> leastOf
    java.util.List leastOf(java.util.Iterator,int) -> leastOf
    java.util.List greatestOf(java.lang.Iterable,int) -> greatestOf
    java.util.List greatestOf(java.util.Iterator,int) -> greatestOf
    java.util.List sortedCopy(java.lang.Iterable) -> sortedCopy
    com.google.common.collect.ImmutableList immutableSortedCopy(java.lang.Iterable) -> immutableSortedCopy
    boolean isOrdered(java.lang.Iterable) -> isOrdered
    boolean isStrictlyOrdered(java.lang.Iterable) -> isStrictlyOrdered
    int binarySearch(java.util.List,java.lang.Object) -> binarySearch
com.google.common.collect.Ordering$ArbitraryOrdering -> cz:
    java.util.Map uids -> a
    void <init>() -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    java.lang.String toString() -> toString
com.google.common.collect.Ordering$ArbitraryOrdering$1 -> cA:
    java.util.concurrent.atomic.AtomicInteger counter -> a
    void <init>(com.google.common.collect.Ordering$ArbitraryOrdering) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Ordering$ArbitraryOrderingHolder -> cB:
    com.google.common.collect.Ordering ARBITRARY_ORDERING -> a
    void <clinit>() -> <clinit>
com.google.common.collect.Ordering$IncomparableValueException -> com.google.common.collect.Ordering$IncomparableValueException:
    java.lang.Object value -> value
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Object) -> <init>
com.google.common.collect.PeekingIterator -> cC:
    java.lang.Object peek() -> a
    java.lang.Object next() -> next
com.google.common.collect.Range -> com.google.common.collect.Range:
    com.google.common.base.Function LOWER_BOUND_FN -> a
    com.google.common.base.Function UPPER_BOUND_FN -> b
    com.google.common.collect.Ordering RANGE_LEX_ORDERING -> RANGE_LEX_ORDERING
    com.google.common.collect.Range ALL -> a
    com.google.common.collect.Cut lowerBound -> lowerBound
    com.google.common.collect.Cut upperBound -> upperBound
    long serialVersionUID -> serialVersionUID
    com.google.common.base.Function lowerBoundFn() -> lowerBoundFn
    com.google.common.base.Function upperBoundFn() -> upperBoundFn
    com.google.common.collect.Range create(com.google.common.collect.Cut,com.google.common.collect.Cut) -> create
    com.google.common.collect.Range open(java.lang.Comparable,java.lang.Comparable) -> open
    com.google.common.collect.Range closed(java.lang.Comparable,java.lang.Comparable) -> closed
    com.google.common.collect.Range closedOpen(java.lang.Comparable,java.lang.Comparable) -> closedOpen
    com.google.common.collect.Range openClosed(java.lang.Comparable,java.lang.Comparable) -> openClosed
    com.google.common.collect.Range range(java.lang.Comparable,com.google.common.collect.BoundType,java.lang.Comparable,com.google.common.collect.BoundType) -> range
    com.google.common.collect.Range lessThan(java.lang.Comparable) -> lessThan
    com.google.common.collect.Range atMost(java.lang.Comparable) -> atMost
    com.google.common.collect.Range upTo(java.lang.Comparable,com.google.common.collect.BoundType) -> upTo
    com.google.common.collect.Range greaterThan(java.lang.Comparable) -> greaterThan
    com.google.common.collect.Range atLeast(java.lang.Comparable) -> atLeast
    com.google.common.collect.Range downTo(java.lang.Comparable,com.google.common.collect.BoundType) -> downTo
    com.google.common.collect.Range all() -> all
    com.google.common.collect.Range singleton(java.lang.Comparable) -> singleton
    com.google.common.collect.Range encloseAll(java.lang.Iterable) -> encloseAll
    void <init>(com.google.common.collect.Cut,com.google.common.collect.Cut) -> <init>
    boolean hasLowerBound() -> hasLowerBound
    java.lang.Comparable lowerEndpoint() -> lowerEndpoint
    com.google.common.collect.BoundType lowerBoundType() -> lowerBoundType
    boolean hasUpperBound() -> hasUpperBound
    java.lang.Comparable upperEndpoint() -> upperEndpoint
    com.google.common.collect.BoundType upperBoundType() -> upperBoundType
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Comparable) -> contains
    boolean apply(java.lang.Comparable) -> apply
    boolean containsAll(java.lang.Iterable) -> containsAll
    boolean encloses(com.google.common.collect.Range) -> encloses
    boolean isConnected(com.google.common.collect.Range) -> isConnected
    com.google.common.collect.Range intersection(com.google.common.collect.Range) -> intersection
    com.google.common.collect.Range span(com.google.common.collect.Range) -> span
    com.google.common.collect.Range canonical(com.google.common.collect.DiscreteDomain) -> canonical
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String toString(com.google.common.collect.Cut,com.google.common.collect.Cut) -> a
    java.lang.Object readResolve() -> readResolve
    int compareOrThrow(java.lang.Comparable,java.lang.Comparable) -> compareOrThrow
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
com.google.common.collect.Range$1 -> cD:
    void <init>() -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Range$2 -> cE:
    void <init>() -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
com.google.common.collect.Range$3 -> cF:
    void <init>() -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.common.collect.Range$4 -> cG:
    int[] $SwitchMap$com$google$common$collect$BoundType -> a
    void <clinit>() -> <clinit>
com.google.common.collect.RegularContiguousSet -> com.google.common.collect.RegularContiguousSet:
    com.google.common.collect.Range range -> range
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.Range,com.google.common.collect.DiscreteDomain) -> <init>
    com.google.common.collect.ContiguousSet intersectionInCurrentDomain(com.google.common.collect.Range) -> a
    com.google.common.collect.ContiguousSet headSetImpl(java.lang.Comparable,boolean) -> headSetImpl
    com.google.common.collect.ContiguousSet subSetImpl(java.lang.Comparable,boolean,java.lang.Comparable,boolean) -> subSetImpl
    com.google.common.collect.ContiguousSet tailSetImpl(java.lang.Comparable,boolean) -> tailSetImpl
    int indexOf(java.lang.Object) -> indexOf
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> descendingIterator
    boolean isPartialView() -> isPartialView
    java.lang.Comparable first() -> first
    java.lang.Comparable last() -> last
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean isEmpty() -> isEmpty
    com.google.common.collect.ContiguousSet intersection(com.google.common.collect.ContiguousSet) -> intersection
    com.google.common.collect.Range range() -> range
    com.google.common.collect.Range range(com.google.common.collect.BoundType,com.google.common.collect.BoundType) -> range
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object writeReplace() -> writeReplace
    java.lang.Object last() -> last
    java.lang.Object first() -> first
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> tailSetImpl
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> subSetImpl
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> headSetImpl
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.Iterator iterator() -> iterator
    boolean access$000(java.lang.Comparable,java.lang.Comparable) -> access$000
com.google.common.collect.RegularContiguousSet$1 -> cH:
    java.lang.Comparable last -> a
    com.google.common.collect.RegularContiguousSet this$0 -> a
    void <init>(com.google.common.collect.RegularContiguousSet,java.lang.Comparable) -> <init>
    java.lang.Object computeNext(java.lang.Object) -> a
com.google.common.collect.RegularContiguousSet$2 -> cI:
    java.lang.Comparable first -> a
    com.google.common.collect.RegularContiguousSet this$0 -> a
    void <init>(com.google.common.collect.RegularContiguousSet,java.lang.Comparable) -> <init>
    java.lang.Object computeNext(java.lang.Object) -> a
com.google.common.collect.RegularContiguousSet$SerializedForm -> com.google.common.collect.RegularContiguousSet$SerializedForm:
    com.google.common.collect.Range range -> range
    com.google.common.collect.DiscreteDomain domain -> domain
    void <init>(com.google.common.collect.Range,com.google.common.collect.DiscreteDomain) -> <init>
    java.lang.Object readResolve() -> readResolve
    void <init>(com.google.common.collect.Range,com.google.common.collect.DiscreteDomain,com.google.common.collect.RegularContiguousSet$1) -> <init>
com.google.common.collect.RegularImmutableAsList -> com.google.common.collect.RegularImmutableAsList:
    com.google.common.collect.ImmutableCollection delegate -> delegate
    com.google.common.collect.ImmutableList delegateList -> delegateList
    void <init>(com.google.common.collect.ImmutableCollection,com.google.common.collect.ImmutableList) -> <init>
    void <init>(com.google.common.collect.ImmutableCollection,java.lang.Object[]) -> <init>
    com.google.common.collect.ImmutableCollection delegateCollection() -> delegateCollection
    com.google.common.collect.ImmutableList delegateList() -> delegateList
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> listIterator
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    java.lang.Object get(int) -> get
    java.util.ListIterator listIterator(int) -> listIterator
com.google.common.collect.RegularImmutableBiMap -> com.google.common.collect.RegularImmutableBiMap:
    double MAX_LOAD_FACTOR -> MAX_LOAD_FACTOR
    com.google.common.collect.ImmutableMapEntry[] keyTable -> a
    com.google.common.collect.ImmutableMapEntry[] valueTable -> b
    com.google.common.collect.ImmutableMapEntry[] entries -> c
    int mask -> a
    int hashCode -> b
    com.google.common.collect.ImmutableBiMap inverse -> a
    void <init>(com.google.common.collect.ImmutableMapEntry$TerminalEntry[]) -> <init>
    void <init>(int,com.google.common.collect.ImmutableMapEntry$TerminalEntry[]) -> <init>
    void <init>(java.util.Map$Entry[]) -> <init>
    java.lang.Object get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    boolean isPartialView() -> isPartialView
    int size() -> size
    com.google.common.collect.ImmutableBiMap inverse() -> inverse
    com.google.common.collect.BiMap inverse() -> inverse
    com.google.common.collect.ImmutableMapEntry[] access$000(com.google.common.collect.RegularImmutableBiMap) -> access$000
    int access$100(com.google.common.collect.RegularImmutableBiMap) -> access$100
    int access$300(com.google.common.collect.RegularImmutableBiMap) -> access$300
    com.google.common.collect.ImmutableMapEntry[] access$400(com.google.common.collect.RegularImmutableBiMap) -> access$400
com.google.common.collect.RegularImmutableBiMap$1 -> com.google.common.collect.RegularImmutableBiMap$1:
    com.google.common.collect.RegularImmutableBiMap this$0 -> this$0
    void <init>(com.google.common.collect.RegularImmutableBiMap) -> <init>
    com.google.common.collect.ImmutableMap map() -> map
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    boolean isHashCodeFast() -> isHashCodeFast
    int hashCode() -> hashCode
    java.util.Iterator iterator() -> iterator
com.google.common.collect.RegularImmutableBiMap$Inverse -> com.google.common.collect.RegularImmutableBiMap$Inverse:
    com.google.common.collect.RegularImmutableBiMap this$0 -> this$0
    void <init>(com.google.common.collect.RegularImmutableBiMap) -> <init>
    int size() -> size
    com.google.common.collect.ImmutableBiMap inverse() -> inverse
    java.lang.Object get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    boolean isPartialView() -> isPartialView
    java.lang.Object writeReplace() -> writeReplace
    com.google.common.collect.BiMap inverse() -> inverse
    void <init>(com.google.common.collect.RegularImmutableBiMap,com.google.common.collect.RegularImmutableBiMap$1) -> <init>
com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet -> com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet:
    com.google.common.collect.RegularImmutableBiMap$Inverse this$1 -> this$1
    void <init>(com.google.common.collect.RegularImmutableBiMap$Inverse) -> <init>
    com.google.common.collect.ImmutableMap map() -> map
    boolean isHashCodeFast() -> isHashCodeFast
    int hashCode() -> hashCode
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    java.util.Iterator iterator() -> iterator
com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet$1 -> com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet$1:
    com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet this$2 -> this$2
    void <init>(com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet) -> <init>
    java.util.Map$Entry get(int) -> get
    com.google.common.collect.ImmutableCollection delegateCollection() -> delegateCollection
    java.lang.Object get(int) -> get
com.google.common.collect.RegularImmutableBiMap$InverseSerializedForm -> com.google.common.collect.RegularImmutableBiMap$InverseSerializedForm:
    com.google.common.collect.ImmutableBiMap forward -> forward
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableBiMap) -> <init>
    java.lang.Object readResolve() -> readResolve
com.google.common.collect.RegularImmutableBiMap$NonTerminalBiMapEntry -> com.google.common.collect.RegularImmutableBiMap$NonTerminalBiMapEntry:
    com.google.common.collect.ImmutableMapEntry nextInKeyBucket -> nextInKeyBucket
    com.google.common.collect.ImmutableMapEntry nextInValueBucket -> nextInValueBucket
    void <init>(java.lang.Object,java.lang.Object,com.google.common.collect.ImmutableMapEntry,com.google.common.collect.ImmutableMapEntry) -> <init>
    void <init>(com.google.common.collect.ImmutableMapEntry,com.google.common.collect.ImmutableMapEntry,com.google.common.collect.ImmutableMapEntry) -> <init>
    com.google.common.collect.ImmutableMapEntry getNextInKeyBucket() -> getNextInKeyBucket
    com.google.common.collect.ImmutableMapEntry getNextInValueBucket() -> getNextInValueBucket
com.google.common.collect.RegularImmutableList -> com.google.common.collect.RegularImmutableList:
    int offset -> a
    int size -> b
    java.lang.Object[] array -> a
    void <init>(java.lang.Object[],int,int) -> <init>
    void <init>(java.lang.Object[]) -> <init>
    int size() -> size
    boolean isPartialView() -> isPartialView
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    java.lang.Object get(int) -> get
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    com.google.common.collect.ImmutableList subListUnchecked(int,int) -> subListUnchecked
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
com.google.common.collect.RegularImmutableMap -> com.google.common.collect.RegularImmutableMap:
    com.google.common.collect.ImmutableMapEntry[] entries -> a
    com.google.common.collect.ImmutableMapEntry[] table -> b
    int mask -> a
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.ImmutableMapEntry$TerminalEntry[]) -> <init>
    void <init>(int,com.google.common.collect.ImmutableMapEntry$TerminalEntry[]) -> <init>
    void <init>(java.util.Map$Entry[]) -> <init>
    void checkNoConflictInBucket(java.lang.Object,com.google.common.collect.ImmutableMapEntry,com.google.common.collect.ImmutableMapEntry) -> a
    java.lang.Object get(java.lang.Object) -> get
    int size() -> size
    boolean isPartialView() -> isPartialView
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    com.google.common.collect.ImmutableMapEntry[] access$100(com.google.common.collect.RegularImmutableMap) -> access$100
com.google.common.collect.RegularImmutableMap$EntrySet -> com.google.common.collect.RegularImmutableMap$EntrySet:
    com.google.common.collect.RegularImmutableMap this$0 -> this$0
    void <init>(com.google.common.collect.RegularImmutableMap) -> <init>
    com.google.common.collect.ImmutableMap map() -> map
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    java.util.Iterator iterator() -> iterator
    void <init>(com.google.common.collect.RegularImmutableMap,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
com.google.common.collect.RegularImmutableMap$NonTerminalMapEntry -> com.google.common.collect.RegularImmutableMap$NonTerminalMapEntry:
    com.google.common.collect.ImmutableMapEntry nextInKeyBucket -> nextInKeyBucket
    void <init>(java.lang.Object,java.lang.Object,com.google.common.collect.ImmutableMapEntry) -> <init>
    void <init>(com.google.common.collect.ImmutableMapEntry,com.google.common.collect.ImmutableMapEntry) -> <init>
    com.google.common.collect.ImmutableMapEntry getNextInKeyBucket() -> getNextInKeyBucket
    com.google.common.collect.ImmutableMapEntry getNextInValueBucket() -> getNextInValueBucket
com.google.common.collect.RegularImmutableMultiset -> com.google.common.collect.RegularImmutableMultiset:
    com.google.common.collect.ImmutableMap map -> a
    int size -> a
    void <init>(com.google.common.collect.ImmutableMap,int) -> <init>
    boolean isPartialView() -> isPartialView
    int count(java.lang.Object) -> count
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.ImmutableSet elementSet() -> elementSet
    com.google.common.collect.Multiset$Entry getEntry(int) -> getEntry
    int hashCode() -> hashCode
    java.util.Set elementSet() -> elementSet
com.google.common.collect.RegularImmutableSet -> com.google.common.collect.RegularImmutableSet:
    java.lang.Object[] elements -> elements
    java.lang.Object[] table -> table
    int mask -> a
    int hashCode -> b
    void <init>(java.lang.Object[],int,java.lang.Object[],int) -> <init>
    boolean contains(java.lang.Object) -> contains
    int size() -> size
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    boolean isPartialView() -> isPartialView
    int hashCode() -> hashCode
    boolean isHashCodeFast() -> isHashCodeFast
    java.util.Iterator iterator() -> iterator
com.google.common.collect.RegularImmutableSortedMap -> com.google.common.collect.RegularImmutableSortedMap:
    com.google.common.collect.RegularImmutableSortedSet keySet -> a
    com.google.common.collect.ImmutableList valueList -> a
    void <init>(com.google.common.collect.RegularImmutableSortedSet,com.google.common.collect.ImmutableList) -> <init>
    void <init>(com.google.common.collect.RegularImmutableSortedSet,com.google.common.collect.ImmutableList,com.google.common.collect.ImmutableSortedMap) -> <init>
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    com.google.common.collect.ImmutableSortedSet keySet() -> keySet
    com.google.common.collect.ImmutableCollection values() -> values
    java.lang.Object get(java.lang.Object) -> get
    com.google.common.collect.ImmutableSortedMap getSubMap(int,int) -> a
    com.google.common.collect.ImmutableSortedMap headMap(java.lang.Object,boolean) -> headMap
    com.google.common.collect.ImmutableSortedMap tailMap(java.lang.Object,boolean) -> tailMap
    com.google.common.collect.ImmutableSortedMap createDescendingMap() -> createDescendingMap
    java.util.NavigableMap tailMap(java.lang.Object,boolean) -> tailMap
    java.util.NavigableMap headMap(java.lang.Object,boolean) -> headMap
    java.util.Collection values() -> values
    java.util.Set keySet() -> keySet
    com.google.common.collect.ImmutableSet keySet() -> keySet
    com.google.common.collect.ImmutableList access$100(com.google.common.collect.RegularImmutableSortedMap) -> access$100
com.google.common.collect.RegularImmutableSortedMap$EntrySet -> com.google.common.collect.RegularImmutableSortedMap$EntrySet:
    com.google.common.collect.RegularImmutableSortedMap this$0 -> this$0
    void <init>(com.google.common.collect.RegularImmutableSortedMap) -> <init>
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    com.google.common.collect.ImmutableMap map() -> map
    java.util.Iterator iterator() -> iterator
    void <init>(com.google.common.collect.RegularImmutableSortedMap,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
com.google.common.collect.RegularImmutableSortedMap$EntrySet$1 -> com.google.common.collect.RegularImmutableSortedMap$EntrySet$1:
    com.google.common.collect.ImmutableList keyList -> keyList
    com.google.common.collect.RegularImmutableSortedMap$EntrySet this$1 -> this$1
    void <init>(com.google.common.collect.RegularImmutableSortedMap$EntrySet) -> <init>
    java.util.Map$Entry get(int) -> get
    com.google.common.collect.ImmutableCollection delegateCollection() -> delegateCollection
    java.lang.Object get(int) -> get
com.google.common.collect.RegularImmutableSortedSet -> com.google.common.collect.RegularImmutableSortedSet:
    com.google.common.collect.ImmutableList elements -> a
    void <init>(com.google.common.collect.ImmutableList,java.util.Comparator) -> <init>
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    com.google.common.collect.UnmodifiableIterator descendingIterator() -> descendingIterator
    boolean isEmpty() -> isEmpty
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean isPartialView() -> isPartialView
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    boolean equals(java.lang.Object) -> equals
    java.lang.Object first() -> first
    java.lang.Object last() -> last
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    com.google.common.collect.ImmutableSortedSet headSetImpl(java.lang.Object,boolean) -> headSetImpl
    int headIndex(java.lang.Object,boolean) -> headIndex
    com.google.common.collect.ImmutableSortedSet subSetImpl(java.lang.Object,boolean,java.lang.Object,boolean) -> subSetImpl
    com.google.common.collect.ImmutableSortedSet tailSetImpl(java.lang.Object,boolean) -> tailSetImpl
    int tailIndex(java.lang.Object,boolean) -> tailIndex
    java.util.Comparator unsafeComparator() -> unsafeComparator
    com.google.common.collect.ImmutableSortedSet getSubSet(int,int) -> getSubSet
    int indexOf(java.lang.Object) -> indexOf
    com.google.common.collect.ImmutableList createAsList() -> createAsList
    com.google.common.collect.ImmutableSortedSet createDescendingSet() -> createDescendingSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ReverseNaturalOrdering -> com.google.common.collect.ReverseNaturalOrdering:
    com.google.common.collect.ReverseNaturalOrdering INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    int compare(java.lang.Comparable,java.lang.Comparable) -> compare
    com.google.common.collect.Ordering reverse() -> reverse
    java.lang.Comparable min(java.lang.Comparable,java.lang.Comparable) -> min
    java.lang.Comparable min(java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable[]) -> min
    java.lang.Comparable min(java.util.Iterator) -> min
    java.lang.Comparable min(java.lang.Iterable) -> min
    java.lang.Comparable max(java.lang.Comparable,java.lang.Comparable) -> max
    java.lang.Comparable max(java.lang.Comparable,java.lang.Comparable,java.lang.Comparable,java.lang.Comparable[]) -> max
    java.lang.Comparable max(java.util.Iterator) -> max
    java.lang.Comparable max(java.lang.Iterable) -> max
    java.lang.Object readResolve() -> readResolve
    java.lang.String toString() -> toString
    void <init>() -> <init>
    java.lang.Object max(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> max
    java.lang.Object max(java.lang.Object,java.lang.Object) -> max
    java.lang.Object max(java.lang.Iterable) -> max
    java.lang.Object max(java.util.Iterator) -> max
    java.lang.Object min(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> min
    java.lang.Object min(java.lang.Object,java.lang.Object) -> min
    java.lang.Object min(java.lang.Iterable) -> min
    java.lang.Object min(java.util.Iterator) -> min
    int compare(java.lang.Object,java.lang.Object) -> compare
    void <clinit>() -> <clinit>
com.google.common.collect.ReverseOrdering -> com.google.common.collect.ReverseOrdering:
    com.google.common.collect.Ordering forwardOrder -> forwardOrder
    long serialVersionUID -> serialVersionUID
    void <init>(com.google.common.collect.Ordering) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
    com.google.common.collect.Ordering reverse() -> reverse
    java.lang.Object min(java.lang.Object,java.lang.Object) -> min
    java.lang.Object min(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> min
    java.lang.Object min(java.util.Iterator) -> min
    java.lang.Object min(java.lang.Iterable) -> min
    java.lang.Object max(java.lang.Object,java.lang.Object) -> max
    java.lang.Object max(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object[]) -> max
    java.lang.Object max(java.util.Iterator) -> max
    java.lang.Object max(java.lang.Iterable) -> max
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.google.common.collect.Serialization$FieldSetter -> cJ:
    java.lang.reflect.Field field -> a
    void <init>(java.lang.reflect.Field) -> <init>
    void set(java.lang.Object,java.lang.Object) -> a
    void set(java.lang.Object,int) -> a
    void <init>(java.lang.reflect.Field,byte) -> <init>
com.google.common.collect.SetMultimap -> cK:
com.google.common.collect.Sets$1 -> cL:
    java.util.Set val$set1 -> a
    java.util.Set val$set2minus1 -> b
    java.util.Set val$set2 -> c
    void <init>(java.util.Set,java.util.Set,java.util.Set) -> <init>
    int size() -> size
    boolean isEmpty() -> isEmpty
    java.util.Iterator iterator() -> iterator
    boolean contains(java.lang.Object) -> contains
com.google.common.collect.Sets$2 -> cM:
    java.util.Set val$set1 -> a
    com.google.common.base.Predicate val$inSet2 -> a
    java.util.Set val$set2 -> b
    void <init>(java.util.Set,com.google.common.base.Predicate,java.util.Set) -> <init>
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
com.google.common.collect.Sets$3 -> cN:
    java.util.Set val$set1 -> a
    com.google.common.base.Predicate val$notInSet2 -> a
    java.util.Set val$set2 -> b
    void <init>(java.util.Set,com.google.common.base.Predicate,java.util.Set) -> <init>
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
com.google.common.collect.Sets$ImprovedAbstractSet -> cO:
    void <init>() -> <init>
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
com.google.common.collect.Sets$SetView -> cP:
    void <init>() -> <init>
    void <init>(byte) -> <init>
com.google.common.collect.Sets$UnmodifiableNavigableSet -> com.google.common.collect.Sets$UnmodifiableNavigableSet:
    java.util.NavigableSet delegate -> delegate
    com.google.common.collect.Sets$UnmodifiableNavigableSet descendingSet -> a
    long serialVersionUID -> serialVersionUID
    void <init>(java.util.NavigableSet) -> <init>
    java.util.SortedSet delegate() -> delegate
    java.lang.Object lower(java.lang.Object) -> lower
    java.lang.Object floor(java.lang.Object) -> floor
    java.lang.Object ceiling(java.lang.Object) -> ceiling
    java.lang.Object higher(java.lang.Object) -> higher
    java.lang.Object pollFirst() -> pollFirst
    java.lang.Object pollLast() -> pollLast
    java.util.NavigableSet descendingSet() -> descendingSet
    java.util.Iterator descendingIterator() -> descendingIterator
    java.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean) -> subSet
    java.util.NavigableSet headSet(java.lang.Object,boolean) -> headSet
    java.util.NavigableSet tailSet(java.lang.Object,boolean) -> tailSet
    java.util.Set delegate() -> delegate
    java.util.Collection delegate() -> delegate
    java.lang.Object delegate() -> delegate
com.google.common.collect.SingletonImmutableBiMap -> com.google.common.collect.SingletonImmutableBiMap:
    java.lang.Object singleKey -> singleKey
    java.lang.Object singleValue -> singleValue
    com.google.common.collect.ImmutableBiMap inverse -> inverse
    void <init>(java.lang.Object,java.lang.Object) -> <init>
    void <init>(java.lang.Object,java.lang.Object,com.google.common.collect.ImmutableBiMap) -> <init>
    void <init>(java.util.Map$Entry) -> <init>
    java.lang.Object get(java.lang.Object) -> get
    int size() -> size
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    boolean isPartialView() -> isPartialView
    com.google.common.collect.ImmutableSet createEntrySet() -> createEntrySet
    com.google.common.collect.ImmutableSet createKeySet() -> createKeySet
    com.google.common.collect.ImmutableBiMap inverse() -> inverse
    com.google.common.collect.BiMap inverse() -> inverse
com.google.common.collect.SingletonImmutableList -> com.google.common.collect.SingletonImmutableList:
    java.lang.Object element -> element
    void <init>(java.lang.Object) -> <init>
    java.lang.Object get(int) -> get
    int indexOf(java.lang.Object) -> indexOf
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    int size() -> size
    com.google.common.collect.ImmutableList subList(int,int) -> subList
    com.google.common.collect.ImmutableList reverse() -> reverse
    boolean contains(java.lang.Object) -> contains
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean isEmpty() -> isEmpty
    boolean isPartialView() -> isPartialView
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    java.util.List subList(int,int) -> subList
    java.util.Iterator iterator() -> iterator
com.google.common.collect.SingletonImmutableSet -> com.google.common.collect.SingletonImmutableSet:
    java.lang.Object element -> element
    int cachedHashCode -> a
    void <init>(java.lang.Object) -> <init>
    void <init>(java.lang.Object,int) -> <init>
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.UnmodifiableIterator iterator() -> iterator
    boolean isPartialView() -> isPartialView
    int copyIntoArray(java.lang.Object[],int) -> copyIntoArray
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isHashCodeFast() -> isHashCodeFast
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
com.google.common.collect.SortedIterable -> cQ:
    java.util.Comparator comparator() -> comparator
com.google.common.collect.SortedLists$KeyAbsentBehavior -> com.google.common.collect.SortedLists$KeyAbsentBehavior:
    com.google.common.collect.SortedLists$KeyAbsentBehavior NEXT_LOWER -> NEXT_LOWER
    com.google.common.collect.SortedLists$KeyAbsentBehavior NEXT_HIGHER -> NEXT_HIGHER
    com.google.common.collect.SortedLists$KeyAbsentBehavior INVERTED_INSERTION_INDEX -> INVERTED_INSERTION_INDEX
    com.google.common.collect.SortedLists$KeyAbsentBehavior[] $VALUES -> a
    com.google.common.collect.SortedLists$KeyAbsentBehavior[] values() -> values
    com.google.common.collect.SortedLists$KeyAbsentBehavior valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(int) -> resultIndex
    void <init>(java.lang.String,int,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.SortedLists$KeyAbsentBehavior$1 -> com.google.common.collect.SortedLists$KeyAbsentBehavior$1:
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(int) -> resultIndex
com.google.common.collect.SortedLists$KeyAbsentBehavior$2 -> com.google.common.collect.SortedLists$KeyAbsentBehavior$2:
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(int) -> resultIndex
com.google.common.collect.SortedLists$KeyAbsentBehavior$3 -> com.google.common.collect.SortedLists$KeyAbsentBehavior$3:
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(int) -> resultIndex
com.google.common.collect.SortedLists$KeyPresentBehavior -> com.google.common.collect.SortedLists$KeyPresentBehavior:
    com.google.common.collect.SortedLists$KeyPresentBehavior ANY_PRESENT -> ANY_PRESENT
    com.google.common.collect.SortedLists$KeyPresentBehavior LAST_PRESENT -> LAST_PRESENT
    com.google.common.collect.SortedLists$KeyPresentBehavior FIRST_PRESENT -> FIRST_PRESENT
    com.google.common.collect.SortedLists$KeyPresentBehavior FIRST_AFTER -> FIRST_AFTER
    com.google.common.collect.SortedLists$KeyPresentBehavior LAST_BEFORE -> LAST_BEFORE
    com.google.common.collect.SortedLists$KeyPresentBehavior[] $VALUES -> a
    com.google.common.collect.SortedLists$KeyPresentBehavior[] values() -> values
    com.google.common.collect.SortedLists$KeyPresentBehavior valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(java.util.Comparator,java.lang.Object,java.util.List,int) -> resultIndex
    void <init>(java.lang.String,int,cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
    void <clinit>() -> <clinit>
com.google.common.collect.SortedLists$KeyPresentBehavior$1 -> com.google.common.collect.SortedLists$KeyPresentBehavior$1:
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(java.util.Comparator,java.lang.Object,java.util.List,int) -> resultIndex
com.google.common.collect.SortedLists$KeyPresentBehavior$2 -> com.google.common.collect.SortedLists$KeyPresentBehavior$2:
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(java.util.Comparator,java.lang.Object,java.util.List,int) -> resultIndex
com.google.common.collect.SortedLists$KeyPresentBehavior$3 -> com.google.common.collect.SortedLists$KeyPresentBehavior$3:
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(java.util.Comparator,java.lang.Object,java.util.List,int) -> resultIndex
com.google.common.collect.SortedLists$KeyPresentBehavior$4 -> com.google.common.collect.SortedLists$KeyPresentBehavior$4:
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(java.util.Comparator,java.lang.Object,java.util.List,int) -> resultIndex
com.google.common.collect.SortedLists$KeyPresentBehavior$5 -> com.google.common.collect.SortedLists$KeyPresentBehavior$5:
    void <init>(java.lang.String,int) -> <init>
    int resultIndex(java.util.Comparator,java.lang.Object,java.util.List,int) -> resultIndex
com.google.common.collect.SortedSetMultimap -> cR:
    java.util.Comparator valueComparator() -> valueComparator
com.google.common.collect.TransformedIterator -> cS:
    java.util.Iterator backingIterator -> a
    void <init>(java.util.Iterator) -> <init>
    java.lang.Object transform(java.lang.Object) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.TreeMultimap -> com.google.common.collect.TreeMultimap:
    java.util.Comparator keyComparator -> a
    java.util.Comparator valueComparator -> b
    long serialVersionUID -> serialVersionUID
    com.google.common.collect.TreeMultimap create() -> create
    com.google.common.collect.TreeMultimap create(java.util.Comparator,java.util.Comparator) -> create
    com.google.common.collect.TreeMultimap create(com.google.common.collect.Multimap) -> create
    void <init>(java.util.Comparator,java.util.Comparator) -> <init>
    void <init>(java.util.Comparator,java.util.Comparator,com.google.common.collect.Multimap) -> <init>
    java.util.SortedSet createCollection() -> createCollection
    java.util.Collection createCollection(java.lang.Object) -> createCollection
    java.util.Comparator keyComparator() -> keyComparator
    java.util.Comparator valueComparator() -> valueComparator
    java.util.NavigableMap backingMap() -> backingMap
    java.util.NavigableSet get(java.lang.Object) -> get
    java.util.Collection unmodifiableCollectionSubclass(java.util.Collection) -> unmodifiableCollectionSubclass
    java.util.Collection wrapCollection(java.lang.Object,java.util.Collection) -> wrapCollection
    java.util.NavigableSet keySet() -> keySet
    java.util.NavigableSet createKeySet() -> createKeySet
    java.util.NavigableMap asMap() -> asMap
    java.util.NavigableMap createAsMap() -> createAsMap
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
    java.util.SortedSet keySet() -> keySet
    java.util.SortedMap backingMap() -> backingMap
    java.util.SortedMap asMap() -> asMap
    java.util.Collection values() -> values
    java.util.Map asMap() -> asMap
    java.util.SortedSet replaceValues(java.lang.Object,java.lang.Iterable) -> replaceValues
    java.util.SortedSet removeAll(java.lang.Object) -> removeAll
    java.util.SortedSet get(java.lang.Object) -> get
    java.util.Set get(java.lang.Object) -> get
    java.util.Set keySet() -> keySet
    java.util.Collection get(java.lang.Object) -> get
    boolean equals(java.lang.Object) -> equals
    boolean put(java.lang.Object,java.lang.Object) -> put
    java.util.Set entries() -> entries
    java.util.Set createCollection() -> createCollection
    java.util.Map createAsMap() -> createAsMap
    java.util.Set createKeySet() -> createKeySet
    void clear() -> clear
    boolean containsKey(java.lang.Object) -> containsKey
    int size() -> size
    java.util.Map backingMap() -> backingMap
    java.util.Collection createCollection() -> createCollection
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    com.google.common.collect.Multiset keys() -> keys
    boolean putAll(com.google.common.collect.Multimap) -> putAll
    boolean putAll(java.lang.Object,java.lang.Iterable) -> putAll
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    boolean containsEntry(java.lang.Object,java.lang.Object) -> containsEntry
    boolean containsValue(java.lang.Object) -> containsValue
    boolean isEmpty() -> isEmpty
com.google.common.collect.UnmodifiableIterator -> cT:
    void <init>() -> <init>
    void remove() -> remove
com.google.common.collect.UnmodifiableListIterator -> cU:
    void <init>() -> <init>
    void add(java.lang.Object) -> add
    void set(java.lang.Object) -> set
com.google.common.collect.UsingToStringOrdering -> com.google.common.collect.UsingToStringOrdering:
    com.google.common.collect.UsingToStringOrdering INSTANCE -> INSTANCE
    long serialVersionUID -> serialVersionUID
    int compare(java.lang.Object,java.lang.Object) -> compare
    java.lang.Object readResolve() -> readResolve
    java.lang.String toString() -> toString
    void <init>() -> <init>
    void <clinit>() -> <clinit>
com.google.common.math.BigIntegerMath -> cV:
    java.math.BigInteger SQRT2_PRECOMPUTED_BITS -> a
    boolean isPowerOfTwo(java.math.BigInteger) -> a
    java.math.BigInteger sqrt(java.math.BigInteger,java.math.RoundingMode) -> a
    java.math.BigInteger sqrtFloor(java.math.BigInteger) -> a
    java.math.BigInteger sqrtApproxWithDoubles(java.math.BigInteger) -> b
    java.math.BigInteger factorial(int) -> a
    java.math.BigInteger listProduct(java.util.List,int,int) -> a
    java.math.BigInteger binomial(int,int) -> a
    void <clinit>() -> <clinit>
com.google.common.math.BigIntegerMath$1 -> cW:
    int[] $SwitchMap$java$math$RoundingMode -> a
    void <clinit>() -> <clinit>
com.google.common.math.DoubleMath -> cX:
    double roundIntermediate(double,java.math.RoundingMode) -> a
    int roundToInt(double,java.math.RoundingMode) -> a
    long roundToLong(double,java.math.RoundingMode) -> a
    java.math.BigInteger roundToBigInteger(double,java.math.RoundingMode) -> a
    boolean isMathematicalInteger(double) -> a
    void <clinit>() -> <clinit>
com.google.common.math.DoubleMath$1 -> cY:
    int[] $SwitchMap$java$math$RoundingMode -> a
    void <clinit>() -> <clinit>
com.google.common.math.DoubleUtils -> cZ:
    long getSignificand(double) -> a
    boolean isFinite(double) -> a
    double bigToDouble(java.math.BigInteger) -> a
    void <clinit>() -> <clinit>
com.google.common.math.IntMath -> da:
    int lessThanBranchFree(int,int) -> a
    int log2(int,java.math.RoundingMode) -> a
    int sqrt(int,java.math.RoundingMode) -> b
    int divide(int,int,java.math.RoundingMode) -> a
    void <clinit>() -> <clinit>
com.google.common.math.IntMath$1 -> db:
    int[] $SwitchMap$java$math$RoundingMode -> a
    void <clinit>() -> <clinit>
com.google.common.math.LongMath -> dc:
    long[] factorials -> a
    int[] biggestBinomials -> a
    int[] biggestSimpleBinomials -> b
    int lessThanBranchFree(long,long) -> a
    int log2(long,java.math.RoundingMode) -> a
    long sqrt(long,java.math.RoundingMode) -> a
    long binomial(int,int) -> a
    long multiplyFraction(long,long,long) -> a
    void <clinit>() -> <clinit>
com.google.common.math.LongMath$1 -> dd:
    int[] $SwitchMap$java$math$RoundingMode -> a
    void <clinit>() -> <clinit>
com.google.common.primitives.UnsignedInteger -> com.google.common.primitives.UnsignedInteger:
    com.google.common.primitives.UnsignedInteger ZERO -> ZERO
    com.google.common.primitives.UnsignedInteger ONE -> ONE
    com.google.common.primitives.UnsignedInteger MAX_VALUE -> MAX_VALUE
    int value -> value
    void <init>(int) -> <init>
    com.google.common.primitives.UnsignedInteger fromIntBits(int) -> fromIntBits
    com.google.common.primitives.UnsignedInteger valueOf(long) -> valueOf
    com.google.common.primitives.UnsignedInteger valueOf(java.math.BigInteger) -> valueOf
    com.google.common.primitives.UnsignedInteger valueOf(java.lang.String) -> valueOf
    com.google.common.primitives.UnsignedInteger valueOf(java.lang.String,int) -> valueOf
    com.google.common.primitives.UnsignedInteger plus(com.google.common.primitives.UnsignedInteger) -> plus
    com.google.common.primitives.UnsignedInteger minus(com.google.common.primitives.UnsignedInteger) -> minus
    com.google.common.primitives.UnsignedInteger times(com.google.common.primitives.UnsignedInteger) -> times
    com.google.common.primitives.UnsignedInteger dividedBy(com.google.common.primitives.UnsignedInteger) -> dividedBy
    com.google.common.primitives.UnsignedInteger mod(com.google.common.primitives.UnsignedInteger) -> mod
    int intValue() -> intValue
    long longValue() -> longValue
    float floatValue() -> floatValue
    double doubleValue() -> doubleValue
    java.math.BigInteger bigIntegerValue() -> bigIntegerValue
    int compareTo(com.google.common.primitives.UnsignedInteger) -> compareTo
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> toString
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
com.google.common.primitives.UnsignedLong -> com.google.common.primitives.UnsignedLong:
    com.google.common.primitives.UnsignedLong ZERO -> ZERO
    com.google.common.primitives.UnsignedLong ONE -> ONE
    com.google.common.primitives.UnsignedLong MAX_VALUE -> MAX_VALUE
    long value -> value
    void <init>(long) -> <init>
    com.google.common.primitives.UnsignedLong fromLongBits(long) -> fromLongBits
    com.google.common.primitives.UnsignedLong valueOf(long) -> valueOf
    com.google.common.primitives.UnsignedLong valueOf(java.math.BigInteger) -> valueOf
    com.google.common.primitives.UnsignedLong valueOf(java.lang.String) -> valueOf
    com.google.common.primitives.UnsignedLong valueOf(java.lang.String,int) -> valueOf
    com.google.common.primitives.UnsignedLong plus(com.google.common.primitives.UnsignedLong) -> plus
    com.google.common.primitives.UnsignedLong minus(com.google.common.primitives.UnsignedLong) -> minus
    com.google.common.primitives.UnsignedLong times(com.google.common.primitives.UnsignedLong) -> times
    com.google.common.primitives.UnsignedLong dividedBy(com.google.common.primitives.UnsignedLong) -> dividedBy
    com.google.common.primitives.UnsignedLong mod(com.google.common.primitives.UnsignedLong) -> mod
    int intValue() -> intValue
    long longValue() -> longValue
    float floatValue() -> floatValue
    double doubleValue() -> doubleValue
    java.math.BigInteger bigIntegerValue() -> bigIntegerValue
    int compareTo(com.google.common.primitives.UnsignedLong) -> compareTo
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> toString
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
com.google.common.primitives.UnsignedLongs -> de:
    long[] maxValueDivs -> a
    int[] maxValueMods -> a
    int[] maxSafeDigits -> b
    int compare(long,long) -> a
    long divide(long,long) -> a
    long remainder(long,long) -> b
    long parseUnsignedLong(java.lang.String,int) -> a
    java.lang.String toString(long) -> a
    java.lang.String toString(long,int) -> a
    void <clinit>() -> <clinit>
de.lab4inf.math.functions.AbstractFresnelIntegrals -> df:
    double[] F -> a
    double[] G -> b
    double gaux(double) -> a
    double faux(double) -> b
    void <clinit>() -> <clinit>
de.lab4inf.math.functions.AbstractSiCiIntegrals -> dg:
    double[] F -> a
    double[] G -> b
    double auxg(double) -> a
    double auxf(double) -> b
    void <clinit>() -> <clinit>
de.lab4inf.math.functions.CosineIntegral -> dh:
    double[] A -> a
    double ci(double) -> c
    void <clinit>() -> <clinit>
de.lab4inf.math.functions.FresnelC -> di:
    double[] A -> a
    double fresnelC(double) -> c
    void <clinit>() -> <clinit>
de.lab4inf.math.functions.FresnelS -> dj:
    double[] A -> a
    double fresnelS(double) -> c
    void <clinit>() -> <clinit>
de.lab4inf.math.functions.SineIntegral -> dk:
    double[] FACULTY -> a
    double[] A -> b
    double si(double) -> c
    void <clinit>() -> <clinit>
edu.jas.arith.BigComplex -> edu.jas.arith.BigComplex:
    edu.jas.arith.BigRational re -> re
    edu.jas.arith.BigRational im -> im
    java.util.Random random -> a
    org.apache.log4j.Logger logger -> a
    edu.jas.arith.BigComplex ZERO -> ZERO
    edu.jas.arith.BigComplex ONE -> ONE
    edu.jas.arith.BigComplex I -> I
    void <init>(edu.jas.arith.BigRational,edu.jas.arith.BigRational) -> <init>
    void <init>(edu.jas.arith.BigRational) -> <init>
    void <init>(long) -> <init>
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    edu.jas.arith.BigComplex factory() -> factory
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    edu.jas.arith.BigComplex copy() -> copy
    edu.jas.arith.BigComplex copy(edu.jas.arith.BigComplex) -> copy
    edu.jas.arith.BigComplex getZERO() -> getZERO
    edu.jas.arith.BigComplex getONE() -> getONE
    edu.jas.arith.BigComplex getIMAG() -> getIMAG
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.arith.BigComplex fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.arith.BigComplex fromInteger(long) -> fromInteger
    edu.jas.arith.BigRational getRe() -> getRe
    edu.jas.arith.BigRational getIm() -> getIm
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    boolean isCZERO(edu.jas.arith.BigComplex) -> isCZERO
    boolean isZERO() -> isZERO
    boolean isCONE(edu.jas.arith.BigComplex) -> isCONE
    boolean isONE() -> isONE
    boolean isIMAG() -> isIMAG
    boolean isUnit() -> isUnit
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.arith.BigComplex) -> compareTo
    int signum() -> signum
    edu.jas.arith.BigComplex sum(edu.jas.arith.BigComplex) -> sum
    edu.jas.arith.BigComplex CSUM(edu.jas.arith.BigComplex,edu.jas.arith.BigComplex) -> CSUM
    edu.jas.arith.BigComplex CDIF(edu.jas.arith.BigComplex,edu.jas.arith.BigComplex) -> CDIF
    edu.jas.arith.BigComplex subtract(edu.jas.arith.BigComplex) -> subtract
    edu.jas.arith.BigComplex CNEG(edu.jas.arith.BigComplex) -> CNEG
    edu.jas.arith.BigComplex negate() -> negate
    edu.jas.arith.BigComplex CCON(edu.jas.arith.BigComplex) -> CCON
    edu.jas.arith.BigComplex conjugate() -> conjugate
    edu.jas.arith.BigComplex norm() -> norm
    edu.jas.arith.BigComplex abs() -> abs
    edu.jas.arith.BigRational CABS(edu.jas.arith.BigComplex) -> CABS
    edu.jas.arith.BigComplex CPROD(edu.jas.arith.BigComplex,edu.jas.arith.BigComplex) -> CPROD
    edu.jas.arith.BigComplex multiply(edu.jas.arith.BigComplex) -> multiply
    edu.jas.arith.BigComplex CINV(edu.jas.arith.BigComplex) -> CINV
    edu.jas.arith.BigComplex inverse() -> inverse
    edu.jas.arith.BigComplex remainder(edu.jas.arith.BigComplex) -> remainder
    edu.jas.arith.BigComplex CQ(edu.jas.arith.BigComplex,edu.jas.arith.BigComplex) -> CQ
    edu.jas.arith.BigComplex divide(edu.jas.arith.BigComplex) -> divide
    edu.jas.arith.BigComplex[] quotientRemainder(edu.jas.arith.BigComplex) -> quotientRemainder
    edu.jas.arith.BigComplex random(int) -> random
    edu.jas.arith.BigComplex random(int,java.util.Random) -> random
    edu.jas.arith.BigComplex CRAND(int) -> CRAND
    edu.jas.arith.BigComplex parse(java.lang.String) -> parse
    edu.jas.arith.BigComplex parse(java.io.Reader) -> parse
    edu.jas.arith.BigComplex gcd(edu.jas.arith.BigComplex) -> gcd
    edu.jas.arith.BigComplex[] egcd(edu.jas.arith.BigComplex) -> egcd
    edu.jas.structure.StarRingElem norm() -> norm
    edu.jas.structure.StarRingElem conjugate() -> conjugate
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.arith.BigDecimal -> edu.jas.arith.BigDecimal:
    java.math.BigDecimal val -> val
    java.util.Random random -> a
    java.math.MathContext DEFAULT_CONTEXT -> DEFAULT_CONTEXT
    int DEFAULT_PRECISION -> DEFAULT_PRECISION
    java.math.MathContext context -> context
    boolean EXACT_EQUAL -> EXACT_EQUAL
    edu.jas.arith.BigDecimal ZERO -> ZERO
    edu.jas.arith.BigDecimal ONE -> ONE
    void <init>(java.math.BigDecimal) -> <init>
    void <init>(java.math.BigDecimal,java.math.MathContext) -> <init>
    void <init>(long) -> <init>
    void <init>(long,java.math.MathContext) -> <init>
    void <init>(double) -> <init>
    void <init>(double,java.math.MathContext) -> <init>
    void <init>(java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger,java.math.MathContext) -> <init>
    void <init>(edu.jas.arith.BigRational) -> <init>
    void <init>(edu.jas.arith.BigRational,java.math.MathContext) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.math.MathContext) -> <init>
    void <init>() -> <init>
    edu.jas.arith.BigDecimal factory() -> factory
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    edu.jas.arith.BigDecimal copy() -> copy
    edu.jas.arith.BigDecimal copy(edu.jas.arith.BigDecimal) -> copy
    edu.jas.arith.BigDecimal getZERO() -> getZERO
    edu.jas.arith.BigDecimal getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.arith.BigDecimal fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.arith.BigDecimal valueOf(java.math.BigDecimal) -> valueOf
    edu.jas.arith.BigDecimal fromInteger(long) -> fromInteger
    edu.jas.arith.BigDecimal valueOf(long) -> valueOf
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    java.lang.String toString() -> toString
    double doubleValue() -> doubleValue
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    int compareTo(edu.jas.arith.BigDecimal) -> compareTo
    int compareToAbsolute(edu.jas.arith.BigDecimal) -> compareToAbsolute
    int compareToRelative(edu.jas.arith.BigDecimal) -> compareToRelative
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.BigDecimal abs() -> abs
    edu.jas.arith.BigDecimal negate() -> negate
    int signum() -> signum
    edu.jas.arith.BigDecimal subtract(edu.jas.arith.BigDecimal) -> subtract
    edu.jas.arith.BigDecimal divide(edu.jas.arith.BigDecimal) -> divide
    edu.jas.arith.BigDecimal inverse() -> inverse
    edu.jas.arith.BigDecimal remainder(edu.jas.arith.BigDecimal) -> remainder
    edu.jas.arith.BigDecimal[] quotientRemainder(edu.jas.arith.BigDecimal) -> quotientRemainder
    edu.jas.arith.BigDecimal[] divideAndRemainder(edu.jas.arith.BigDecimal) -> divideAndRemainder
    edu.jas.arith.BigDecimal gcd(edu.jas.arith.BigDecimal) -> gcd
    edu.jas.arith.BigDecimal[] egcd(edu.jas.arith.BigDecimal) -> egcd
    edu.jas.arith.BigDecimal random(int) -> random
    edu.jas.arith.BigDecimal random(int,java.util.Random) -> random
    edu.jas.arith.BigDecimal random(int,int) -> random
    edu.jas.arith.BigDecimal random(int,int,java.util.Random) -> random
    edu.jas.arith.BigDecimal multiply(edu.jas.arith.BigDecimal) -> multiply
    edu.jas.arith.BigDecimal sum(edu.jas.arith.BigDecimal) -> sum
    edu.jas.arith.BigDecimal parse(java.lang.String) -> parse
    edu.jas.arith.BigDecimal parse(java.io.Reader) -> parse
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.arith.BigInteger -> edu.jas.arith.BigInteger:
    java.math.BigInteger val -> val
    java.util.Random random -> a
    edu.jas.arith.BigInteger ZERO -> ZERO
    edu.jas.arith.BigInteger ONE -> ONE
    boolean nonNegative -> nonNegative
    void <init>(java.math.BigInteger) -> <init>
    void <init>(long) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>() -> <init>
    java.math.BigInteger getVal() -> getVal
    long longValue() -> longValue
    edu.jas.arith.BigInteger factory() -> factory
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    edu.jas.arith.BigInteger copy() -> copy
    edu.jas.arith.BigInteger copy(edu.jas.arith.BigInteger) -> copy
    edu.jas.arith.BigInteger getZERO() -> getZERO
    edu.jas.arith.BigInteger getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.arith.BigInteger fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.arith.BigInteger valueOf(java.math.BigInteger) -> valueOf
    edu.jas.arith.BigInteger fromInteger(long) -> fromInteger
    edu.jas.arith.BigInteger valueOf(long) -> valueOf
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    int compareTo(edu.jas.arith.BigInteger) -> compareTo
    int ICOMP(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> ICOMP
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.BigInteger abs() -> abs
    edu.jas.arith.BigInteger IABS(edu.jas.arith.BigInteger) -> IABS
    edu.jas.arith.BigInteger negate() -> negate
    edu.jas.arith.BigInteger INEG(edu.jas.arith.BigInteger) -> INEG
    int signum() -> signum
    int ISIGN(edu.jas.arith.BigInteger) -> ISIGN
    edu.jas.arith.BigInteger subtract(edu.jas.arith.BigInteger) -> subtract
    edu.jas.arith.BigInteger IDIF(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> IDIF
    edu.jas.arith.BigInteger divide(edu.jas.arith.BigInteger) -> divide
    edu.jas.arith.BigInteger IQ(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> IQ
    edu.jas.arith.BigInteger inverse() -> inverse
    edu.jas.arith.BigInteger remainder(edu.jas.arith.BigInteger) -> remainder
    edu.jas.arith.BigInteger IREM(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> IREM
    edu.jas.arith.BigInteger[] quotientRemainder(edu.jas.arith.BigInteger) -> quotientRemainder
    edu.jas.arith.BigInteger[] divideAndRemainder(edu.jas.arith.BigInteger) -> divideAndRemainder
    edu.jas.arith.BigInteger[] IQR(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> IQR
    edu.jas.arith.BigInteger gcd(edu.jas.arith.BigInteger) -> gcd
    edu.jas.arith.BigInteger[] egcd(edu.jas.arith.BigInteger) -> egcd
    edu.jas.arith.BigInteger IGCD(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> IGCD
    edu.jas.arith.BigInteger random(int) -> random
    edu.jas.arith.BigInteger random(int,java.util.Random) -> random
    edu.jas.arith.BigInteger IRAND(int) -> IRAND
    edu.jas.arith.BigInteger multiply(edu.jas.arith.BigInteger) -> multiply
    edu.jas.arith.BigInteger shiftLeft(int) -> shiftLeft
    edu.jas.arith.BigInteger IPROD(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> IPROD
    edu.jas.arith.BigInteger sum(edu.jas.arith.BigInteger) -> sum
    edu.jas.arith.BigInteger ISUM(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> ISUM
    edu.jas.arith.BigInteger parse(java.lang.String) -> parse
    edu.jas.arith.BigInteger parse(java.io.Reader) -> parse
    edu.jas.arith.BigRational getRational() -> getRational
    void setAllIterator() -> setAllIterator
    void setNonNegativeIterator() -> setNonNegativeIterator
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.arith.BigIntegerIterator -> dl:
    java.math.BigInteger curr -> a
    boolean nonNegative -> a
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    boolean hasNext() -> hasNext
    edu.jas.arith.BigInteger next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.BigRational -> edu.jas.arith.BigRational:
    java.math.BigInteger num -> num
    java.math.BigInteger den -> den
    edu.jas.arith.BigRational ZERO -> ZERO
    edu.jas.arith.BigRational ONE -> ONE
    java.util.Random random -> a
    boolean nonNegative -> nonNegative
    boolean duplicates -> duplicates
    void <init>(java.math.BigInteger,java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger) -> <init>
    void <init>(edu.jas.arith.BigInteger) -> <init>
    void <init>(edu.jas.arith.BigInteger,edu.jas.arith.BigInteger) -> <init>
    void <init>(long,long) -> <init>
    void <init>(long) -> <init>
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    edu.jas.arith.BigRational factory() -> factory
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    edu.jas.arith.BigRational copy() -> copy
    edu.jas.arith.BigRational copy(edu.jas.arith.BigRational) -> copy
    edu.jas.arith.BigRational getRational() -> getRational
    java.math.BigInteger numerator() -> numerator
    java.math.BigInteger denominator() -> denominator
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> toString
    double doubleValue() -> doubleValue
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    edu.jas.arith.BigRational getZERO() -> getZERO
    edu.jas.arith.BigRational getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.arith.BigRational fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.arith.BigRational fromInteger(edu.jas.arith.BigInteger) -> fromInteger
    edu.jas.arith.BigRational valueOf(java.math.BigInteger) -> valueOf
    edu.jas.arith.BigRational fromInteger(long) -> fromInteger
    edu.jas.arith.BigRational valueOf(long) -> valueOf
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.BigRational RNRED(java.math.BigInteger,java.math.BigInteger) -> RNRED
    edu.jas.arith.BigRational reduction(java.math.BigInteger,java.math.BigInteger) -> reduction
    edu.jas.arith.BigRational abs() -> abs
    edu.jas.arith.BigRational RNABS(edu.jas.arith.BigRational) -> RNABS
    int compareTo(edu.jas.arith.BigRational) -> compareTo
    int RNCOMP(edu.jas.arith.BigRational,edu.jas.arith.BigRational) -> RNCOMP
    java.math.BigInteger RNDEN(edu.jas.arith.BigRational) -> RNDEN
    edu.jas.arith.BigRational subtract(edu.jas.arith.BigRational) -> subtract
    edu.jas.arith.BigRational RNDIF(edu.jas.arith.BigRational,edu.jas.arith.BigRational) -> RNDIF
    void RNDWR(edu.jas.arith.BigRational,int) -> RNDWR
    edu.jas.arith.BigRational RNINT(java.math.BigInteger) -> RNINT
    edu.jas.arith.BigRational inverse() -> inverse
    edu.jas.arith.BigRational RNINV(edu.jas.arith.BigRational) -> RNINV
    edu.jas.arith.BigRational negate() -> negate
    edu.jas.arith.BigRational RNNEG(edu.jas.arith.BigRational) -> RNNEG
    java.math.BigInteger RNNUM(edu.jas.arith.BigRational) -> RNNUM
    edu.jas.arith.BigRational multiply(edu.jas.arith.BigRational) -> multiply
    edu.jas.arith.BigRational RNPROD(edu.jas.arith.BigRational,edu.jas.arith.BigRational) -> RNPROD
    edu.jas.arith.BigRational divide(edu.jas.arith.BigRational) -> divide
    edu.jas.arith.BigRational RNQ(edu.jas.arith.BigRational,edu.jas.arith.BigRational) -> RNQ
    edu.jas.arith.BigRational remainder(edu.jas.arith.BigRational) -> remainder
    edu.jas.arith.BigRational[] quotientRemainder(edu.jas.arith.BigRational) -> quotientRemainder
    edu.jas.arith.BigRational random(int) -> random
    edu.jas.arith.BigRational random(int,java.util.Random) -> random
    edu.jas.arith.BigRational RNRAND(int) -> RNRAND
    int signum() -> signum
    int RNSIGN(edu.jas.arith.BigRational) -> RNSIGN
    edu.jas.arith.BigRational sum(edu.jas.arith.BigRational) -> sum
    edu.jas.arith.BigRational RNSUM(edu.jas.arith.BigRational,edu.jas.arith.BigRational) -> RNSUM
    edu.jas.arith.BigRational parse(java.lang.String) -> parse
    edu.jas.arith.BigRational parse(java.io.Reader) -> parse
    edu.jas.arith.BigRational gcd(edu.jas.arith.BigRational) -> gcd
    edu.jas.arith.BigRational[] egcd(edu.jas.arith.BigRational) -> egcd
    void setAllIterator() -> setAllIterator
    void setNonNegativeIterator() -> setNonNegativeIterator
    void setNoDuplicatesIterator() -> setNoDuplicatesIterator
    void setDuplicatesIterator() -> setDuplicatesIterator
    java.util.Iterator iterator() -> iterator
    java.util.Iterator uniqueIterator() -> uniqueIterator
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.arith.BigRational$1 -> dm:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.arith.BigRationalIterator -> dn:
    edu.jas.arith.BigRational curr -> a
    edu.jas.arith.BigInteger den -> a
    edu.jas.arith.BigInteger num -> b
    java.util.Iterator denit -> a
    java.util.Iterator numit -> b
    java.util.List denlist -> a
    java.util.List numlist -> b
    java.util.Iterator denlistit -> c
    java.util.Iterator numlistit -> d
    boolean nonNegative -> a
    long level -> a
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    boolean hasNext() -> hasNext
    edu.jas.arith.BigRational next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.BigRationalUniqueIterator -> do:
    java.util.Set unique -> a
    java.util.Iterator ratit -> a
    void <init>() -> <init>
    void <init>(java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    edu.jas.arith.BigRational next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModInteger -> edu.jas.arith.ModInteger:
    edu.jas.arith.ModIntegerRing ring -> ring
    java.math.BigInteger val -> val
    void <init>(edu.jas.arith.ModIntegerRing,java.math.BigInteger) -> <init>
    void <init>(edu.jas.arith.ModIntegerRing,long) -> <init>
    void <init>(edu.jas.arith.ModIntegerRing,java.lang.String) -> <init>
    void <init>(edu.jas.arith.ModIntegerRing) -> <init>
    java.math.BigInteger getVal() -> getVal
    java.math.BigInteger getModul() -> getModul
    edu.jas.arith.ModIntegerRing factory() -> factory
    java.math.BigInteger getSymmetricVal() -> getSymmetricVal
    edu.jas.arith.BigInteger getInteger() -> getInteger
    edu.jas.arith.BigInteger getSymmetricInteger() -> getSymmetricInteger
    edu.jas.arith.ModInteger copy() -> copy
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    int compareTo(edu.jas.arith.ModInteger) -> compareTo
    int MICOMP(edu.jas.arith.ModInteger,edu.jas.arith.ModInteger) -> MICOMP
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.ModInteger abs() -> abs
    edu.jas.arith.ModInteger MIABS(edu.jas.arith.ModInteger) -> MIABS
    edu.jas.arith.ModInteger negate() -> negate
    edu.jas.arith.ModInteger MINEG(edu.jas.arith.ModInteger) -> MINEG
    int signum() -> signum
    int MISIGN(edu.jas.arith.ModInteger) -> MISIGN
    edu.jas.arith.ModInteger subtract(edu.jas.arith.ModInteger) -> subtract
    edu.jas.arith.ModInteger MIDIF(edu.jas.arith.ModInteger,edu.jas.arith.ModInteger) -> MIDIF
    edu.jas.arith.ModInteger divide(edu.jas.arith.ModInteger) -> divide
    edu.jas.arith.ModInteger MIQ(edu.jas.arith.ModInteger,edu.jas.arith.ModInteger) -> MIQ
    edu.jas.arith.ModInteger inverse() -> inverse
    edu.jas.arith.ModInteger MIINV(edu.jas.arith.ModInteger) -> MIINV
    edu.jas.arith.ModInteger remainder(edu.jas.arith.ModInteger) -> remainder
    edu.jas.arith.ModInteger MIREM(edu.jas.arith.ModInteger,edu.jas.arith.ModInteger) -> MIREM
    edu.jas.arith.ModInteger[] quotientRemainder(edu.jas.arith.ModInteger) -> quotientRemainder
    edu.jas.arith.ModInteger multiply(edu.jas.arith.ModInteger) -> multiply
    edu.jas.arith.ModInteger MIPROD(edu.jas.arith.ModInteger,edu.jas.arith.ModInteger) -> MIPROD
    edu.jas.arith.ModInteger sum(edu.jas.arith.ModInteger) -> sum
    edu.jas.arith.ModInteger MISUM(edu.jas.arith.ModInteger,edu.jas.arith.ModInteger) -> MISUM
    edu.jas.arith.ModInteger gcd(edu.jas.arith.ModInteger) -> gcd
    edu.jas.arith.ModInteger[] hegcd(edu.jas.arith.ModInteger) -> hegcd
    edu.jas.arith.ModInteger[] egcd(edu.jas.arith.ModInteger) -> egcd
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
edu.jas.arith.ModIntegerIterator -> dp:
    java.math.BigInteger curr -> a
    edu.jas.arith.ModIntegerRing ring -> a
    void <init>(edu.jas.arith.ModIntegerRing) -> <init>
    boolean hasNext() -> hasNext
    edu.jas.arith.ModInteger next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModIntegerRing -> edu.jas.arith.ModIntegerRing:
    java.math.BigInteger modul -> modul
    java.util.Random random -> a
    int isField -> isField
    void <init>(java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger,boolean) -> <init>
    void <init>(long) -> <init>
    void <init>(long,boolean) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,boolean) -> <init>
    java.math.BigInteger getModul() -> getModul
    edu.jas.arith.BigInteger getIntegerModul() -> getIntegerModul
    edu.jas.arith.ModInteger create(java.math.BigInteger) -> create
    edu.jas.arith.ModInteger create(long) -> create
    edu.jas.arith.ModInteger create(java.lang.String) -> create
    edu.jas.arith.ModInteger copy(edu.jas.arith.ModInteger) -> copy
    edu.jas.arith.ModInteger getZERO() -> getZERO
    edu.jas.arith.ModInteger getONE() -> getONE
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.arith.ModInteger fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.arith.ModInteger fromInteger(long) -> fromInteger
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.ModInteger random(int) -> random
    edu.jas.arith.ModInteger random(int,java.util.Random) -> random
    edu.jas.arith.ModInteger parse(java.lang.String) -> parse
    edu.jas.arith.ModInteger parse(java.io.Reader) -> parse
    edu.jas.arith.ModInteger chineseRemainder(edu.jas.arith.ModInteger,edu.jas.arith.ModInteger,edu.jas.arith.ModInteger) -> chineseRemainder
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> chineseRemainder
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.arith.ModLong -> edu.jas.arith.ModLong:
    edu.jas.arith.ModLongRing ring -> ring
    long val -> val
    void <init>(edu.jas.arith.ModLongRing,java.math.BigInteger) -> <init>
    void <init>(edu.jas.arith.ModLongRing,long) -> <init>
    void <init>(edu.jas.arith.ModLongRing,java.lang.Long) -> <init>
    void <init>(edu.jas.arith.ModLongRing,java.lang.String) -> <init>
    void <init>(edu.jas.arith.ModLongRing) -> <init>
    long getVal() -> getVal
    long getModul() -> getModul
    edu.jas.arith.ModLongRing factory() -> factory
    long getSymmetricVal() -> getSymmetricVal
    edu.jas.arith.BigInteger getInteger() -> getInteger
    edu.jas.arith.BigInteger getSymmetricInteger() -> getSymmetricInteger
    edu.jas.arith.ModLong copy() -> copy
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    int compareTo(edu.jas.arith.ModLong) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.ModLong abs() -> abs
    edu.jas.arith.ModLong negate() -> negate
    int signum() -> signum
    edu.jas.arith.ModLong subtract(edu.jas.arith.ModLong) -> subtract
    edu.jas.arith.ModLong divide(edu.jas.arith.ModLong) -> divide
    edu.jas.arith.ModLong inverse() -> inverse
    edu.jas.arith.ModLong remainder(edu.jas.arith.ModLong) -> remainder
    edu.jas.arith.ModLong multiply(edu.jas.arith.ModLong) -> multiply
    edu.jas.arith.ModLong sum(edu.jas.arith.ModLong) -> sum
    edu.jas.arith.ModLong gcd(edu.jas.arith.ModLong) -> gcd
    edu.jas.arith.ModLong[] egcd(edu.jas.arith.ModLong) -> egcd
    long gcd(long,long) -> gcd
    long[] hegcd(long,long) -> hegcd
    long modInverse(long,long) -> modInverse
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
edu.jas.arith.ModLongIterator -> dq:
    long curr -> a
    edu.jas.arith.ModLongRing ring -> a
    void <init>(edu.jas.arith.ModLongRing) -> <init>
    boolean hasNext() -> hasNext
    edu.jas.arith.ModLong next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.ModLongRing -> edu.jas.arith.ModLongRing:
    long modul -> modul
    java.util.Random random -> a
    int isField -> isField
    java.math.BigInteger MAX_LONG -> MAX_LONG
    void <init>(long) -> <init>
    void <init>(long,boolean) -> <init>
    void <init>(java.lang.Long) -> <init>
    void <init>(java.lang.Long,boolean) -> <init>
    void <init>(java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger,boolean) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,boolean) -> <init>
    java.math.BigInteger getModul() -> getModul
    long getLongModul() -> getLongModul
    edu.jas.arith.BigInteger getIntegerModul() -> getIntegerModul
    edu.jas.arith.ModLong create(java.math.BigInteger) -> create
    edu.jas.arith.ModLong create(long) -> create
    edu.jas.arith.ModLong create(java.lang.String) -> create
    edu.jas.arith.ModLong copy(edu.jas.arith.ModLong) -> copy
    edu.jas.arith.ModLong getZERO() -> getZERO
    edu.jas.arith.ModLong getONE() -> getONE
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.arith.ModLong fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.arith.ModLong fromInteger(long) -> fromInteger
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.arith.ModLong random(int) -> random
    edu.jas.arith.ModLong random(int,java.util.Random) -> random
    edu.jas.arith.ModLong parse(java.lang.String) -> parse
    edu.jas.arith.ModLong parse(java.io.Reader) -> parse
    edu.jas.arith.ModLong chineseRemainder(edu.jas.arith.ModLong,edu.jas.arith.ModLong,edu.jas.arith.ModLong) -> chineseRemainder
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> chineseRemainder
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.arith.Modular -> dr:
    edu.jas.arith.BigInteger getSymmetricInteger() -> getSymmetricInteger
edu.jas.arith.ModularNotInvertibleException -> edu.jas.arith.ModularNotInvertibleException:
    edu.jas.structure.GcdRingElem f -> f
    edu.jas.structure.GcdRingElem f1 -> f1
    edu.jas.structure.GcdRingElem f2 -> f2
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
    void <init>(edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem) -> <init>
    void <init>(java.lang.String,edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem) -> <init>
    void <init>(java.lang.String,java.lang.Throwable,edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem) -> <init>
    void <init>(java.lang.Throwable,edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem) -> <init>
    java.lang.String toString() -> toString
edu.jas.arith.ModularRingFactory -> edu.jas.arith.ModularRingFactory:
    edu.jas.arith.BigInteger getIntegerModul() -> getIntegerModul
    edu.jas.structure.RingElem chineseRemainder(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> chineseRemainder
edu.jas.arith.PrimeList -> edu.jas.arith.PrimeList:
    java.util.List SMALL_LIST -> a
    java.util.List LOW_LIST -> b
    java.util.List MEDIUM_LIST -> c
    java.util.List LARGE_LIST -> d
    java.util.List MERSENNE_LIST -> e
    java.util.List val -> f
    java.math.BigInteger last -> a
    void <init>() -> <init>
    void <init>(edu.jas.arith.PrimeList$Range) -> <init>
    java.math.BigInteger getLongPrime(int,int) -> a
    java.math.BigInteger getMersennePrime(int) -> b
    java.lang.String toString() -> toString
    int size() -> a
    java.math.BigInteger get(int) -> a
    java.util.Iterator iterator() -> iterator
    void <clinit>() -> <clinit>
edu.jas.arith.PrimeList$1 -> ds:
    int index -> a
    edu.jas.arith.PrimeList this$0 -> a
    void <init>(edu.jas.arith.PrimeList) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.arith.PrimeList$2 -> dt:
    int[] $SwitchMap$edu$jas$arith$PrimeList$Range -> a
    void <clinit>() -> <clinit>
edu.jas.arith.PrimeList$Range -> edu.jas.arith.PrimeList$Range:
    edu.jas.arith.PrimeList$Range small -> small
    edu.jas.arith.PrimeList$Range low -> low
    edu.jas.arith.PrimeList$Range medium -> medium
    edu.jas.arith.PrimeList$Range large -> large
    edu.jas.arith.PrimeList$Range mersenne -> mersenne
    edu.jas.arith.PrimeList$Range[] $VALUES -> a
    edu.jas.arith.PrimeList$Range[] values() -> values
    edu.jas.arith.PrimeList$Range valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
edu.jas.arith.Rational -> du:
    edu.jas.arith.BigRational getRational() -> getRational
edu.jas.gb.AbstractPair -> edu.jas.gb.AbstractPair:
    edu.jas.poly.ExpVector e -> e
    edu.jas.poly.GenPolynomial pi -> pi
    edu.jas.poly.GenPolynomial pj -> pj
    int i -> i
    int j -> j
    int s -> s
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,int) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,int,int) -> <init>
    void <init>(edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,int) -> <init>
    void <init>(edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,int,int) -> <init>
    void maxIndex(int) -> maxIndex
    java.lang.String toString() -> toString
edu.jas.gb.ExtendedGB -> dv:
    java.util.List F -> a
    java.util.List G -> b
    java.util.List F2G -> c
    java.util.List G2F -> d
    edu.jas.poly.GenPolynomialRing ring -> a
    void <init>(java.util.List,java.util.List,java.util.List,java.util.List) -> <init>
    java.lang.String toString() -> toString
edu.jas.gb.GroebnerBase -> edu.jas.gb.GroebnerBase:
    boolean isGB(java.util.List) -> isGB
    boolean isGB(int,java.util.List) -> isGB
    java.util.List GB(java.util.List) -> GB
    java.util.List GB(int,java.util.List) -> GB
    edu.jas.gb.ExtendedGB extGB(java.util.List) -> extGB
    edu.jas.gb.ExtendedGB extGB(int,java.util.List) -> extGB
    java.util.List minimalGB(java.util.List) -> minimalGB
    boolean isReductionMatrix(edu.jas.gb.ExtendedGB) -> isReductionMatrix
    boolean isReductionMatrix(java.util.List,java.util.List,java.util.List,java.util.List) -> isReductionMatrix
edu.jas.gb.GroebnerBaseAbstract -> edu.jas.gb.GroebnerBaseAbstract:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.gb.Reduction red -> red
    edu.jas.gb.PairList strategy -> strategy
    edu.jas.vector.BasicLinAlg blas -> blas
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>() -> <init>
    void <init>(edu.jas.gb.Reduction) -> <init>
    void <init>(edu.jas.gb.PairList) -> <init>
    void <init>(edu.jas.gb.Reduction,edu.jas.gb.PairList) -> <init>
    java.lang.String toString() -> toString
    java.util.List normalizeZerosOnes(java.util.List) -> normalizeZerosOnes
    boolean isGB(java.util.List) -> isGB
    boolean isGB(int,java.util.List) -> isGB
    boolean isGB(java.util.List,boolean) -> isGB
    boolean isGB(int,java.util.List,boolean) -> isGB
    boolean isGBsimple(int,java.util.List) -> isGBsimple
    boolean criterion3(int,int,edu.jas.poly.ExpVector,java.util.List) -> criterion3
    boolean isGBidem(int,java.util.List) -> isGBidem
    int commonZeroTest(java.util.List) -> commonZeroTest
    java.util.List GB(java.util.List) -> GB
    edu.jas.gb.ExtendedGB extGB(java.util.List) -> extGB
    edu.jas.gb.ExtendedGB extGB(int,java.util.List) -> extGB
    java.util.List minimalGB(java.util.List) -> minimalGB
    boolean isMinimalGB(java.util.List) -> isMinimalGB
    boolean isReductionMatrix(edu.jas.gb.ExtendedGB) -> isReductionMatrix
    boolean isReductionMatrix(java.util.List,java.util.List,java.util.List,java.util.List) -> isReductionMatrix
    java.util.List normalizeMatrix(int,java.util.List) -> normalizeMatrix
    edu.jas.gb.ExtendedGB minimalExtendedGB(int,java.util.List,java.util.List) -> minimalExtendedGB
    java.util.List univariateDegrees(java.util.List) -> univariateDegrees
    edu.jas.poly.GenPolynomial constructUnivariate(int,java.util.List) -> constructUnivariate
    void terminate() -> terminate
    int cancel() -> cancel
    void <clinit>() -> <clinit>
edu.jas.gb.GroebnerBaseSeq -> edu.jas.gb.GroebnerBaseSeq:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    void <init>(edu.jas.gb.Reduction) -> <init>
    void <init>(edu.jas.gb.PairList) -> <init>
    void <init>(edu.jas.gb.Reduction,edu.jas.gb.PairList) -> <init>
    java.util.List GB(int,java.util.List) -> GB
    edu.jas.gb.ExtendedGB extGB(int,java.util.List) -> extGB
    void <clinit>() -> <clinit>
edu.jas.gb.OrderedPairlist -> edu.jas.gb.OrderedPairlist:
    java.util.List P -> P
    java.util.SortedMap pairlist -> pairlist
    java.util.List red -> red
    edu.jas.poly.GenPolynomialRing ring -> ring
    edu.jas.gb.Reduction reduction -> reduction
    boolean oneInGB -> oneInGB
    boolean useCriterion4 -> useCriterion4
    int putCount -> putCount
    int remCount -> remCount
    int moduleVars -> moduleVars
    org.apache.log4j.Logger logger -> a
    void <init>() -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    void <init>(int,edu.jas.poly.GenPolynomialRing) -> <init>
    edu.jas.gb.PairList create(edu.jas.poly.GenPolynomialRing) -> create
    edu.jas.gb.PairList create(int,edu.jas.poly.GenPolynomialRing) -> create
    java.lang.String toString() -> toString
    int put(edu.jas.poly.GenPolynomial) -> put
    int put(java.util.List) -> put
    edu.jas.gb.Pair removeNext() -> removeNext
    boolean hasNext() -> hasNext
    java.util.List getList() -> getList
    int size() -> size
    int putCount() -> putCount
    int remCount() -> remCount
    int putOne(edu.jas.poly.GenPolynomial) -> putOne
    int putOne() -> putOne
    boolean criterion3(int,int,edu.jas.poly.ExpVector) -> criterion3
    void <clinit>() -> <clinit>
edu.jas.gb.Pair -> edu.jas.gb.Pair:
    int n -> n
    boolean toZero -> toZero
    boolean useCriterion4 -> useCriterion4
    boolean useCriterion3 -> useCriterion3
    void <init>(java.lang.Object,edu.jas.poly.GenPolynomial,int,int) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,int) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,int,int) -> <init>
    void <init>(edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,int) -> <init>
    void <init>(edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,int,int) -> <init>
    java.lang.String toString() -> toString
    void pairNumber(int) -> pairNumber
    int getPairNumber() -> getPairNumber
    void setZero() -> setZero
    boolean isZero() -> isZero
    boolean equals(java.lang.Object) -> equals
    int compareTo(edu.jas.gb.Pair) -> compareTo
    int hashCode() -> hashCode
    void setUseCriterion4(boolean) -> setUseCriterion4
    boolean getUseCriterion4() -> getUseCriterion4
    void setUseCriterion3(boolean) -> setUseCriterion3
    boolean getUseCriterion3() -> getUseCriterion3
    int compareTo(java.lang.Object) -> compareTo
edu.jas.gb.PairList -> edu.jas.gb.PairList:
    edu.jas.gb.PairList create(edu.jas.poly.GenPolynomialRing) -> create
    edu.jas.gb.PairList create(int,edu.jas.poly.GenPolynomialRing) -> create
    java.lang.String toString() -> toString
    int put(edu.jas.poly.GenPolynomial) -> put
    int put(java.util.List) -> put
    int putOne() -> putOne
    edu.jas.gb.Pair removeNext() -> removeNext
    boolean hasNext() -> hasNext
    int size() -> size
    java.util.List getList() -> getList
    int putCount() -> putCount
    int remCount() -> remCount
    boolean criterion3(int,int,edu.jas.poly.ExpVector) -> criterion3
edu.jas.gb.Reduction -> edu.jas.gb.Reduction:
    edu.jas.poly.GenPolynomial SPolynomial(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> SPolynomial
    edu.jas.poly.GenPolynomial SPolynomial(java.util.List,int,edu.jas.poly.GenPolynomial,int,edu.jas.poly.GenPolynomial) -> SPolynomial
    boolean moduleCriterion(int,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> moduleCriterion
    boolean moduleCriterion(int,edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> moduleCriterion
    boolean criterion4(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> criterion4
    boolean criterion4(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> criterion4
    boolean criterion4(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> criterion4
    boolean isTopReducible(java.util.List,edu.jas.poly.GenPolynomial) -> isTopReducible
    boolean isReducible(java.util.List,edu.jas.poly.GenPolynomial) -> isReducible
    boolean isNormalform(java.util.List,edu.jas.poly.GenPolynomial) -> isNormalform
    boolean isNormalform(java.util.List) -> isNormalform
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> normalform
    java.util.List normalform(java.util.List,java.util.List) -> normalform
    edu.jas.poly.GenPolynomial normalform(java.util.List,java.util.List,edu.jas.poly.GenPolynomial) -> normalform
    java.util.List irreducibleSet(java.util.List) -> irreducibleSet
    boolean isReductionNF(java.util.List,java.util.List,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> isReductionNF
edu.jas.gb.ReductionAbstract -> edu.jas.gb.ReductionAbstract:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial SPolynomial(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> SPolynomial
    edu.jas.poly.GenPolynomial SPolynomial(java.util.List,int,edu.jas.poly.GenPolynomial,int,edu.jas.poly.GenPolynomial) -> SPolynomial
    boolean moduleCriterion(int,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> moduleCriterion
    boolean moduleCriterion(int,edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> moduleCriterion
    boolean criterion4(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> criterion4
    boolean criterion4(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> criterion4
    boolean criterion4(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> criterion4
    java.util.List normalform(java.util.List,java.util.List) -> normalform
    boolean isTopReducible(java.util.List,edu.jas.poly.GenPolynomial) -> isTopReducible
    boolean isReducible(java.util.List,edu.jas.poly.GenPolynomial) -> isReducible
    boolean isNormalform(java.util.List,edu.jas.poly.GenPolynomial) -> isNormalform
    boolean isNormalform(java.util.List) -> isNormalform
    java.util.List irreducibleSet(java.util.List) -> irreducibleSet
    boolean isReductionNF(java.util.List,java.util.List,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> isReductionNF
    void <clinit>() -> <clinit>
edu.jas.gb.ReductionSeq -> edu.jas.gb.ReductionSeq:
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> normalform
    edu.jas.poly.GenPolynomial normalform(java.util.List,java.util.List,edu.jas.poly.GenPolynomial) -> normalform
edu.jas.gbufd.GroebnerBasePartial -> edu.jas.gbufd.GroebnerBasePartial:
    org.apache.log4j.Logger logger -> a
    edu.jas.gb.GroebnerBaseAbstract bb -> bb
    edu.jas.gb.GroebnerBaseAbstract rbb -> rbb
    void <init>() -> <init>
    void <init>(edu.jas.structure.RingFactory) -> <init>
    void <init>(edu.jas.gb.GroebnerBaseAbstract,edu.jas.gb.GroebnerBaseAbstract) -> <init>
    java.util.List GB(int,java.util.List) -> GB
    boolean isGBrec(java.util.List) -> isGBrec
    boolean isGBrec(int,java.util.List) -> isGBrec
    java.util.List partialPermutation(java.lang.String[],java.lang.String[]) -> partialPermutation
    java.util.List getPermutation(java.lang.String[],java.lang.String[]) -> getPermutation
    int indexOf(java.lang.String,java.lang.String[]) -> indexOf
    java.util.List partialPermutation(java.lang.String[],java.lang.String[],java.lang.String[]) -> partialPermutation
    java.util.List partialPermutation(java.lang.String[],java.lang.String[],java.lang.String[],java.lang.String[]) -> partialPermutation
    java.lang.String[] remainingVars(java.lang.String[],java.lang.String[]) -> remainingVars
    edu.jas.poly.OptimizedPolynomialList partialGBrec(java.util.List,java.lang.String[]) -> partialGBrec
    edu.jas.poly.OptimizedPolynomialList partialGB(java.util.List,java.lang.String[]) -> partialGB
    edu.jas.poly.OptimizedPolynomialList elimPartialGB(java.util.List,java.lang.String[],java.lang.String[]) -> elimPartialGB
    void <clinit>() -> <clinit>
edu.jas.gbufd.GroebnerBasePseudoRecSeq -> edu.jas.gbufd.GroebnerBasePseudoRecSeq:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> engine
    edu.jas.gbufd.PseudoReduction redRec -> redRec
    edu.jas.gbufd.PseudoReduction red -> red
    edu.jas.structure.RingFactory cofac -> cofac
    edu.jas.structure.RingFactory baseCofac -> baseCofac
    void <init>(edu.jas.structure.RingFactory) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.gb.PairList) -> <init>
    void <init>(edu.jas.gbufd.PseudoReduction,edu.jas.structure.RingFactory,edu.jas.gb.PairList) -> <init>
    java.util.List GB(int,java.util.List) -> GB
    java.util.List minimalGB(java.util.List) -> minimalGB
    boolean isGBsimple(int,java.util.List) -> isGBsimple
    void <clinit>() -> <clinit>
edu.jas.gbufd.PseudoReduction -> edu.jas.gbufd.PseudoReduction:
    edu.jas.gbufd.PseudoReductionEntry normalformFactor(java.util.List,edu.jas.poly.GenPolynomial) -> normalformFactor
    edu.jas.poly.GenPolynomial normalformRecursive(java.util.List,edu.jas.poly.GenPolynomial) -> normalformRecursive
edu.jas.gbufd.PseudoReductionEntry -> dw:
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> <init>
edu.jas.gbufd.PseudoReductionSeq -> edu.jas.gbufd.PseudoReductionSeq:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial normalform(java.util.List,edu.jas.poly.GenPolynomial) -> normalform
    edu.jas.poly.GenPolynomial normalformRecursive(java.util.List,edu.jas.poly.GenPolynomial) -> normalformRecursive
    edu.jas.poly.GenPolynomial normalform(java.util.List,java.util.List,edu.jas.poly.GenPolynomial) -> normalform
    edu.jas.gbufd.PseudoReductionEntry normalformFactor(java.util.List,edu.jas.poly.GenPolynomial) -> normalformFactor
    void <clinit>() -> <clinit>
edu.jas.integrate.Integral -> edu.jas.integrate.Integral:
    edu.jas.poly.GenPolynomial num -> num
    edu.jas.poly.GenPolynomial den -> den
    edu.jas.poly.GenPolynomial pol -> pol
    java.util.List rational -> rational
    java.util.List logarithm -> logarithm
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,java.util.List) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,java.util.List,java.util.List) -> <init>
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
edu.jas.integrate.LogIntegral -> edu.jas.integrate.LogIntegral:
    edu.jas.poly.GenPolynomial num -> num
    edu.jas.poly.GenPolynomial den -> den
    java.util.List cfactors -> cfactors
    java.util.List cdenom -> cdenom
    java.util.List afactors -> afactors
    java.util.List adenom -> adenom
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,java.util.List,java.util.List,java.util.List,java.util.List) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toStringX() -> toStringX
    java.lang.String toScript() -> toScript
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
edu.jas.integrate.QuotIntegral -> edu.jas.integrate.QuotIntegral:
    edu.jas.ufd.Quotient quot -> quot
    java.util.List rational -> rational
    java.util.List logarithm -> logarithm
    void <init>(edu.jas.integrate.Integral) -> <init>
    void <init>(edu.jas.ufd.QuotientRing,edu.jas.integrate.Integral) -> <init>
    void <init>(edu.jas.ufd.Quotient,edu.jas.poly.GenPolynomial,java.util.List) -> <init>
    void <init>(edu.jas.ufd.Quotient,edu.jas.poly.GenPolynomial,java.util.List,java.util.List) -> <init>
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
edu.jas.kern.ComputerThreads -> dx:
    boolean NO_THREADS -> a
    int N_CPUS -> a
    java.util.concurrent.ExecutorService pool -> a
    void <init>() -> <init>
    java.util.concurrent.ExecutorService getPool() -> a
    void <clinit>() -> <clinit>
edu.jas.kern.PreemptStatus -> dy:
    boolean allowPreempt -> a
    boolean isAllowed() -> a
    void <clinit>() -> <clinit>
edu.jas.kern.PreemptingException -> edu.jas.kern.PreemptingException:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
edu.jas.kern.PrettyPrint -> dz:
    boolean toDo -> a
    boolean isTrue() -> a
    void <clinit>() -> <clinit>
edu.jas.kern.Scripting -> edu.jas.kern.Scripting:
    edu.jas.kern.Scripting$Lang script -> a
    edu.jas.kern.Scripting$Lang getLang() -> a
    void <clinit>() -> <clinit>
edu.jas.kern.Scripting$Lang -> edu.jas.kern.Scripting$Lang:
    edu.jas.kern.Scripting$Lang Python -> Python
    edu.jas.kern.Scripting$Lang Ruby -> Ruby
    edu.jas.kern.Scripting$Lang[] $VALUES -> a
    edu.jas.kern.Scripting$Lang[] values() -> values
    edu.jas.kern.Scripting$Lang valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
edu.jas.kern.TimeStatus -> dA:
    boolean allowTime -> a
    long limitTime -> a
    long startTime -> b
    java.util.concurrent.Callable callBack -> a
    void checkTime(java.lang.String) -> a
    void <clinit>() -> <clinit>
edu.jas.poly.AlgToPoly -> dB:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.AlgebToCompl -> dC:
    edu.jas.poly.ComplexRing cfac -> a
    void <init>(edu.jas.poly.ComplexRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.AlgebraicNotInvertibleException -> edu.jas.poly.AlgebraicNotInvertibleException:
    edu.jas.poly.GenPolynomial f -> f
    edu.jas.poly.GenPolynomial f1 -> f1
    edu.jas.poly.GenPolynomial f2 -> f2
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(java.lang.String,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(java.lang.String,java.lang.Throwable,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(java.lang.Throwable,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    java.lang.String toString() -> toString
edu.jas.poly.AlgebraicNumber -> edu.jas.poly.AlgebraicNumber:
    edu.jas.poly.AlgebraicNumberRing ring -> ring
    edu.jas.poly.GenPolynomial val -> val
    int isunit -> isunit
    void <init>(edu.jas.poly.AlgebraicNumberRing,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.poly.AlgebraicNumberRing) -> <init>
    edu.jas.poly.GenPolynomial getVal() -> getVal
    edu.jas.poly.AlgebraicNumberRing factory() -> factory
    edu.jas.poly.AlgebraicNumber copy() -> copy
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    int compareTo(edu.jas.poly.AlgebraicNumber) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.AlgebraicNumber abs() -> abs
    edu.jas.poly.AlgebraicNumber sum(edu.jas.poly.AlgebraicNumber) -> sum
    edu.jas.poly.AlgebraicNumber sum(edu.jas.poly.GenPolynomial) -> sum
    edu.jas.poly.AlgebraicNumber sum(edu.jas.structure.RingElem) -> sum
    edu.jas.poly.AlgebraicNumber negate() -> negate
    int signum() -> signum
    edu.jas.poly.AlgebraicNumber subtract(edu.jas.poly.AlgebraicNumber) -> subtract
    edu.jas.poly.AlgebraicNumber divide(edu.jas.poly.AlgebraicNumber) -> divide
    edu.jas.poly.AlgebraicNumber inverse() -> inverse
    edu.jas.poly.AlgebraicNumber remainder(edu.jas.poly.AlgebraicNumber) -> remainder
    edu.jas.poly.AlgebraicNumber[] quotientRemainder(edu.jas.poly.AlgebraicNumber) -> quotientRemainder
    edu.jas.poly.AlgebraicNumber multiply(edu.jas.poly.AlgebraicNumber) -> multiply
    edu.jas.poly.AlgebraicNumber multiply(edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.AlgebraicNumber multiply(edu.jas.poly.GenPolynomial) -> multiply
    edu.jas.poly.AlgebraicNumber monic() -> monic
    edu.jas.poly.AlgebraicNumber gcd(edu.jas.poly.AlgebraicNumber) -> gcd
    edu.jas.poly.AlgebraicNumber[] egcd(edu.jas.poly.AlgebraicNumber) -> egcd
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
edu.jas.poly.AlgebraicNumberIterator -> dD:
    java.util.Iterator iter -> a
    java.util.List powers -> a
    edu.jas.poly.AlgebraicNumberRing aring -> a
    org.apache.log4j.Logger logger -> a
    void <init>(edu.jas.poly.AlgebraicNumberRing) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
    void <clinit>() -> <clinit>
edu.jas.poly.AlgebraicNumberRing -> edu.jas.poly.AlgebraicNumberRing:
    edu.jas.poly.GenPolynomialRing ring -> ring
    edu.jas.poly.GenPolynomial modul -> modul
    int isField -> isField
    org.apache.log4j.Logger logger -> a
    void <init>(edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,boolean) -> <init>
    edu.jas.poly.GenPolynomial getModul() -> getModul
    edu.jas.poly.AlgebraicNumber copy(edu.jas.poly.AlgebraicNumber) -> copy
    edu.jas.poly.AlgebraicNumber getZERO() -> getZERO
    edu.jas.poly.AlgebraicNumber getONE() -> getONE
    edu.jas.poly.AlgebraicNumber getGenerator() -> getGenerator
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    void setField(boolean) -> setField
    int getField() -> getField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.poly.AlgebraicNumber fillFromInteger(java.math.BigInteger) -> fillFromInteger
    edu.jas.poly.AlgebraicNumber fillFromInteger(long) -> fillFromInteger
    edu.jas.poly.AlgebraicNumber fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.AlgebraicNumber fromInteger(long) -> fromInteger
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.AlgebraicNumber random(int) -> random
    edu.jas.poly.AlgebraicNumber random(int,java.util.Random) -> random
    edu.jas.poly.AlgebraicNumber parse(java.lang.String) -> parse
    edu.jas.poly.AlgebraicNumber parse(java.io.Reader) -> parse
    edu.jas.poly.AlgebraicNumber chineseRemainder(edu.jas.poly.AlgebraicNumber,edu.jas.poly.AlgebraicNumber,edu.jas.poly.AlgebraicNumber) -> chineseRemainder
    edu.jas.poly.AlgebraicNumber interpolate(edu.jas.poly.AlgebraicNumber,edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> interpolate
    int depth() -> depth
    long extensionDegree() -> extensionDegree
    long totalExtensionDegree() -> totalExtensionDegree
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.poly.AlgebraicNumberRing$1 -> dE:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.poly.AnyToComplex -> dF:
    edu.jas.poly.ComplexRing cfac -> a
    void <init>(edu.jas.poly.ComplexRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.CoeffToAlg -> dG:
    edu.jas.poly.AlgebraicNumberRing afac -> a
    edu.jas.poly.GenPolynomial zero -> a
    void <init>(edu.jas.poly.AlgebraicNumberRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.CoeffToRecAlg -> dH:
    java.util.List lfac -> a
    int depth -> a
    void <init>(int,edu.jas.poly.AlgebraicNumberRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.CompRatToDec -> dI:
    edu.jas.poly.ComplexRing ring -> a
    void <init>(edu.jas.structure.RingFactory) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.ComplToAlgeb -> dJ:
    edu.jas.poly.AlgebraicNumberRing afac -> a
    edu.jas.poly.AlgebraicNumber I -> a
    void <init>(edu.jas.poly.AlgebraicNumberRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.Complex -> edu.jas.poly.Complex:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.poly.ComplexRing ring -> ring
    edu.jas.structure.RingElem re -> re
    edu.jas.structure.RingElem im -> im
    void <init>(edu.jas.poly.ComplexRing,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> <init>
    void <init>(edu.jas.poly.ComplexRing,edu.jas.structure.RingElem) -> <init>
    void <init>(edu.jas.poly.ComplexRing,long) -> <init>
    void <init>(edu.jas.poly.ComplexRing) -> <init>
    void <init>(edu.jas.poly.ComplexRing,java.lang.String) -> <init>
    edu.jas.poly.ComplexRing factory() -> factory
    edu.jas.structure.RingElem getRe() -> getRe
    edu.jas.structure.RingElem getIm() -> getIm
    edu.jas.poly.Complex copy() -> copy
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isIMAG() -> isIMAG
    boolean isUnit() -> isUnit
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.poly.Complex) -> compareTo
    int signum() -> signum
    edu.jas.poly.Complex sum(edu.jas.poly.Complex) -> sum
    edu.jas.poly.Complex subtract(edu.jas.poly.Complex) -> subtract
    edu.jas.poly.Complex negate() -> negate
    edu.jas.poly.Complex conjugate() -> conjugate
    edu.jas.poly.Complex norm() -> norm
    edu.jas.poly.Complex abs() -> abs
    edu.jas.poly.Complex multiply(edu.jas.poly.Complex) -> multiply
    edu.jas.poly.Complex inverse() -> inverse
    edu.jas.poly.Complex remainder(edu.jas.poly.Complex) -> remainder
    edu.jas.poly.Complex divide(edu.jas.poly.Complex) -> divide
    edu.jas.poly.Complex[] quotientRemainder(edu.jas.poly.Complex) -> quotientRemainder
    edu.jas.poly.Complex[] divideAndRemainder(edu.jas.poly.Complex) -> divideAndRemainder
    edu.jas.poly.Complex gcd(edu.jas.poly.Complex) -> gcd
    edu.jas.poly.Complex[] egcd(edu.jas.poly.Complex) -> egcd
    edu.jas.structure.StarRingElem norm() -> norm
    edu.jas.structure.StarRingElem conjugate() -> conjugate
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    void <clinit>() -> <clinit>
edu.jas.poly.ComplexRing -> edu.jas.poly.ComplexRing:
    java.util.Random random -> a
    edu.jas.structure.RingFactory ring -> ring
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.util.List generators() -> generators
    edu.jas.poly.AlgebraicNumberRing algebraicRing() -> algebraicRing
    boolean isFinite() -> isFinite
    edu.jas.poly.Complex copy(edu.jas.poly.Complex) -> copy
    edu.jas.poly.Complex getZERO() -> getZERO
    edu.jas.poly.Complex getONE() -> getONE
    edu.jas.poly.Complex getIMAG() -> getIMAG
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.poly.Complex fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.Complex fromInteger(long) -> fromInteger
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.Complex random(int) -> random
    edu.jas.poly.Complex random(int,java.util.Random) -> random
    edu.jas.poly.Complex parse(java.lang.String) -> parse
    edu.jas.poly.Complex parse(java.io.Reader) -> parse
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.poly.DistToRec -> dK:
    edu.jas.poly.GenPolynomialRing fac -> a
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.EvalMain -> dL:
    edu.jas.structure.RingFactory cfac -> a
    edu.jas.structure.RingElem a -> a
    void <init>(edu.jas.structure.RingFactory,edu.jas.structure.RingElem) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.EvalMainPol -> dM:
    edu.jas.poly.GenPolynomialRing cfac -> a
    edu.jas.structure.RingElem a -> a
    void <init>(edu.jas.poly.GenPolynomialRing,edu.jas.structure.RingElem) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.ExpVector -> edu.jas.poly.ExpVector:
    int hash -> hash
    java.util.Random random -> a
    edu.jas.poly.ExpVector$StorUnit storunit -> storunit
    void <init>() -> <init>
    edu.jas.poly.ExpVector create(int) -> create
    edu.jas.poly.ExpVector create(int,int,long) -> create
    edu.jas.poly.ExpVector create(long[]) -> create
    edu.jas.poly.ExpVector create(java.lang.String) -> create
    edu.jas.poly.ExpVector create(java.util.Collection) -> create
    edu.jas.structure.AbelianGroupFactory factory() -> factory
    boolean isFinite() -> isFinite
    edu.jas.poly.ExpVector copy() -> copy
    long[] getVal() -> getVal
    long getVal(int) -> getVal
    long setVal(int,long) -> setVal
    int length() -> length
    edu.jas.poly.ExpVector extend(int,int,long) -> extend
    edu.jas.poly.ExpVector extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVector contract(int,int) -> contract
    edu.jas.poly.ExpVector reverse() -> reverse
    edu.jas.poly.ExpVector reverse(int) -> reverse
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVector permutation(java.util.List) -> permutation
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> toString
    java.lang.String varsToString(java.lang.String[]) -> varsToString
    java.lang.String toScript() -> toScript
    java.lang.String toScript(java.lang.String[]) -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    java.lang.String indexVarName(int,java.lang.String[]) -> indexVarName
    int varIndex(int) -> varIndex
    int indexVar(java.lang.String,java.lang.String[]) -> indexVar
    edu.jas.structure.RingElem evaluate(edu.jas.structure.RingFactory,java.util.List) -> evaluate
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isZERO() -> isZERO
    java.lang.String[] stdVars() -> stdVars
    java.lang.String[] stdVars(java.lang.String) -> stdVars
    java.lang.String[] STDVARS(int) -> STDVARS
    java.lang.String[] STDVARS(java.lang.String,int) -> STDVARS
    edu.jas.poly.ExpVector EVABS(edu.jas.poly.ExpVector) -> EVABS
    edu.jas.poly.ExpVector abs() -> abs
    edu.jas.poly.ExpVector EVNEG(edu.jas.poly.ExpVector) -> EVNEG
    edu.jas.poly.ExpVector negate() -> negate
    edu.jas.poly.ExpVector EVSUM(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVSUM
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVector EVDIF(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVDIF
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVector EVSU(edu.jas.poly.ExpVector,int,long) -> EVSU
    edu.jas.poly.ExpVector subst(int,long) -> subst
    edu.jas.poly.ExpVector EVRAND(int,long,float) -> EVRAND
    edu.jas.poly.ExpVector EVRAND(int,long,float,java.util.Random) -> EVRAND
    edu.jas.poly.ExpVector random(int,long,float) -> random
    edu.jas.poly.ExpVector random(int,long,float,java.util.Random) -> random
    int EVSIGN(edu.jas.poly.ExpVector) -> EVSIGN
    int signum() -> signum
    long EVTDEG(edu.jas.poly.ExpVector) -> EVTDEG
    long degree() -> degree
    long totalDeg() -> totalDeg
    long EVMDEG(edu.jas.poly.ExpVector) -> EVMDEG
    long maxDeg() -> maxDeg
    long EVWDEG(long[][],edu.jas.poly.ExpVector) -> EVWDEG
    long weightDeg(long[][]) -> weightDeg
    edu.jas.poly.ExpVector EVLCM(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVLCM
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVector EVGCD(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVGCD
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> gcd
    int[] EVDOV(edu.jas.poly.ExpVector) -> EVDOV
    int[] dependencyOnVariables() -> dependencyOnVariables
    boolean EVMT(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVMT
    boolean multipleOf(edu.jas.poly.ExpVector) -> multipleOf
    boolean divides(edu.jas.poly.ExpVector) -> divides
    int compareTo(edu.jas.poly.ExpVector) -> compareTo
    int EVILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVILCP
    int invLexCompareTo(edu.jas.poly.ExpVector) -> invLexCompareTo
    int EVILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> EVILCP
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> invLexCompareTo
    int EVIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVIGLC
    int invGradCompareTo(edu.jas.poly.ExpVector) -> invGradCompareTo
    int EVIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> EVIGLC
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> invGradCompareTo
    int EVRILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVRILCP
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> revInvLexCompareTo
    int EVRILCP(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> EVRILCP
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvLexCompareTo
    int EVRIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVRIGLC
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> revInvGradCompareTo
    int EVRIGLC(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> EVRIGLC
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvGradCompareTo
    int EVIWLC(long[][],edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> EVIWLC
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> invWeightCompareTo
    int EVIWLC(long[][],edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,int,int) -> EVIWLC
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector,int,int) -> invWeightCompareTo
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
edu.jas.poly.ExpVector$1 -> dN:
    int[] $SwitchMap$edu$jas$poly$ExpVector$StorUnit -> a
    void <clinit>() -> <clinit>
edu.jas.poly.ExpVector$StorUnit -> edu.jas.poly.ExpVector$StorUnit:
    edu.jas.poly.ExpVector$StorUnit LONG -> LONG
    edu.jas.poly.ExpVector$StorUnit INT -> INT
    edu.jas.poly.ExpVector$StorUnit SHORT -> SHORT
    edu.jas.poly.ExpVector$StorUnit BYTE -> BYTE
    edu.jas.poly.ExpVector$StorUnit[] $VALUES -> a
    edu.jas.poly.ExpVector$StorUnit[] values() -> values
    edu.jas.poly.ExpVector$StorUnit valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
edu.jas.poly.ExpVectorByte -> edu.jas.poly.ExpVectorByte:
    byte[] val -> val
    long maxByte -> maxByte
    long minByte -> minByte
    void <init>(int) -> <init>
    void <init>(int,int,byte) -> <init>
    void <init>(int,int,long) -> <init>
    void <init>(byte[]) -> <init>
    void <init>(long[]) -> <init>
    void <init>(java.lang.String) -> <init>
    edu.jas.poly.ExpVectorByte copy() -> copy
    long[] getVal() -> getVal
    long getVal(int) -> getVal
    long setVal(int,long) -> setVal
    byte setVal(int,byte) -> setVal
    int length() -> length
    edu.jas.poly.ExpVectorByte extend(int,int,long) -> extend
    edu.jas.poly.ExpVectorByte extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVectorByte contract(int,int) -> contract
    edu.jas.poly.ExpVectorByte reverse() -> reverse
    edu.jas.poly.ExpVectorByte reverse(int) -> reverse
    edu.jas.poly.ExpVectorByte combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVectorByte permutation(java.util.List) -> permutation
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorByte abs() -> abs
    edu.jas.poly.ExpVectorByte negate() -> negate
    edu.jas.poly.ExpVectorByte sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVectorByte subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVectorByte subst(int,byte) -> subst
    edu.jas.poly.ExpVectorByte subst(int,long) -> subst
    int signum() -> signum
    long totalDeg() -> totalDeg
    long maxDeg() -> maxDeg
    long weightDeg(long[][]) -> weightDeg
    edu.jas.poly.ExpVectorByte lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVectorByte gcd(edu.jas.poly.ExpVector) -> gcd
    int[] dependencyOnVariables() -> dependencyOnVariables
    boolean multipleOf(edu.jas.poly.ExpVector) -> multipleOf
    int compareTo(edu.jas.poly.ExpVector) -> compareTo
    int invLexCompareTo(edu.jas.poly.ExpVector) -> invLexCompareTo
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> invLexCompareTo
    int invGradCompareTo(edu.jas.poly.ExpVector) -> invGradCompareTo
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> invGradCompareTo
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> revInvLexCompareTo
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvLexCompareTo
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> revInvGradCompareTo
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvGradCompareTo
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> invWeightCompareTo
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector,int,int) -> invWeightCompareTo
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> gcd
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVector subst(int,long) -> subst
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVector negate() -> negate
    edu.jas.poly.ExpVector abs() -> abs
    edu.jas.poly.ExpVector permutation(java.util.List) -> permutation
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVector reverse(int) -> reverse
    edu.jas.poly.ExpVector reverse() -> reverse
    edu.jas.poly.ExpVector contract(int,int) -> contract
    edu.jas.poly.ExpVector extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVector extend(int,int,long) -> extend
    edu.jas.poly.ExpVector copy() -> copy
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorInteger -> edu.jas.poly.ExpVectorInteger:
    int[] val -> val
    long maxInt -> maxInt
    long minInt -> minInt
    void <init>(int) -> <init>
    void <init>(int,int,int) -> <init>
    void <init>(int,int,long) -> <init>
    void <init>(int[]) -> <init>
    void <init>(long[]) -> <init>
    void <init>(java.lang.String) -> <init>
    edu.jas.poly.ExpVectorInteger copy() -> copy
    long[] getVal() -> getVal
    long getVal(int) -> getVal
    long setVal(int,long) -> setVal
    int setVal(int,int) -> setVal
    int length() -> length
    edu.jas.poly.ExpVectorInteger extend(int,int,long) -> extend
    edu.jas.poly.ExpVectorInteger extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVectorInteger contract(int,int) -> contract
    edu.jas.poly.ExpVectorInteger reverse() -> reverse
    edu.jas.poly.ExpVectorInteger reverse(int) -> reverse
    edu.jas.poly.ExpVectorInteger combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVectorInteger permutation(java.util.List) -> permutation
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorInteger abs() -> abs
    edu.jas.poly.ExpVectorInteger negate() -> negate
    edu.jas.poly.ExpVectorInteger sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVectorInteger subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVectorInteger subst(int,long) -> subst
    edu.jas.poly.ExpVectorInteger subst(int,int) -> subst
    int signum() -> signum
    long totalDeg() -> totalDeg
    long maxDeg() -> maxDeg
    long weightDeg(long[][]) -> weightDeg
    edu.jas.poly.ExpVectorInteger lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVectorInteger gcd(edu.jas.poly.ExpVector) -> gcd
    int[] dependencyOnVariables() -> dependencyOnVariables
    boolean multipleOf(edu.jas.poly.ExpVector) -> multipleOf
    int compareTo(edu.jas.poly.ExpVector) -> compareTo
    int invLexCompareTo(edu.jas.poly.ExpVector) -> invLexCompareTo
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> invLexCompareTo
    int invGradCompareTo(edu.jas.poly.ExpVector) -> invGradCompareTo
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> invGradCompareTo
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> revInvLexCompareTo
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvLexCompareTo
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> revInvGradCompareTo
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvGradCompareTo
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> invWeightCompareTo
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector,int,int) -> invWeightCompareTo
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> gcd
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVector subst(int,long) -> subst
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVector negate() -> negate
    edu.jas.poly.ExpVector abs() -> abs
    edu.jas.poly.ExpVector permutation(java.util.List) -> permutation
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVector reverse(int) -> reverse
    edu.jas.poly.ExpVector reverse() -> reverse
    edu.jas.poly.ExpVector contract(int,int) -> contract
    edu.jas.poly.ExpVector extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVector extend(int,int,long) -> extend
    edu.jas.poly.ExpVector copy() -> copy
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorLong -> edu.jas.poly.ExpVectorLong:
    long[] val -> val
    void <init>(int) -> <init>
    void <init>(int,int,long) -> <init>
    void <init>(long[]) -> <init>
    void <init>(java.lang.String) -> <init>
    edu.jas.poly.ExpVectorLong copy() -> copy
    long[] getVal() -> getVal
    long getVal(int) -> getVal
    long setVal(int,long) -> setVal
    int length() -> length
    edu.jas.poly.ExpVectorLong extend(int,int,long) -> extend
    edu.jas.poly.ExpVectorLong extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVectorLong contract(int,int) -> contract
    edu.jas.poly.ExpVectorLong reverse() -> reverse
    edu.jas.poly.ExpVectorLong reverse(int) -> reverse
    edu.jas.poly.ExpVectorLong reverseUpper(int) -> reverseUpper
    edu.jas.poly.ExpVectorLong combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVectorLong permutation(java.util.List) -> permutation
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorLong abs() -> abs
    edu.jas.poly.ExpVectorLong negate() -> negate
    edu.jas.poly.ExpVectorLong sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVectorLong subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVectorLong subst(int,long) -> subst
    int signum() -> signum
    long totalDeg() -> totalDeg
    long maxDeg() -> maxDeg
    long weightDeg(long[][]) -> weightDeg
    edu.jas.poly.ExpVectorLong lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVectorLong gcd(edu.jas.poly.ExpVector) -> gcd
    int[] dependencyOnVariables() -> dependencyOnVariables
    boolean multipleOf(edu.jas.poly.ExpVector) -> multipleOf
    int compareTo(edu.jas.poly.ExpVector) -> compareTo
    int invLexCompareTo(edu.jas.poly.ExpVector) -> invLexCompareTo
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> invLexCompareTo
    int invGradCompareTo(edu.jas.poly.ExpVector) -> invGradCompareTo
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> invGradCompareTo
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> revInvLexCompareTo
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvLexCompareTo
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> revInvGradCompareTo
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvGradCompareTo
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> invWeightCompareTo
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector,int,int) -> invWeightCompareTo
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> gcd
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVector subst(int,long) -> subst
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVector negate() -> negate
    edu.jas.poly.ExpVector abs() -> abs
    edu.jas.poly.ExpVector permutation(java.util.List) -> permutation
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVector reverse(int) -> reverse
    edu.jas.poly.ExpVector reverse() -> reverse
    edu.jas.poly.ExpVector contract(int,int) -> contract
    edu.jas.poly.ExpVector extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVector extend(int,int,long) -> extend
    edu.jas.poly.ExpVector copy() -> copy
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.ExpVectorPair -> edu.jas.poly.ExpVectorPair:
    edu.jas.poly.ExpVector e1 -> e1
    edu.jas.poly.ExpVector e2 -> e2
    void <init>(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> <init>
    edu.jas.poly.ExpVector getFirst() -> getFirst
    edu.jas.poly.ExpVector getSecond() -> getSecond
    long totalDeg() -> totalDeg
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    boolean equals(edu.jas.poly.ExpVectorPair) -> equals
    int hashCode() -> hashCode
    boolean isMultiple(edu.jas.poly.ExpVectorPair) -> isMultiple
edu.jas.poly.ExpVectorShort -> edu.jas.poly.ExpVectorShort:
    short[] val -> val
    long maxShort -> maxShort
    long minShort -> minShort
    void <init>(int) -> <init>
    void <init>(int,int,short) -> <init>
    void <init>(int,int,long) -> <init>
    void <init>(short[]) -> <init>
    void <init>(long[]) -> <init>
    void <init>(java.lang.String) -> <init>
    edu.jas.poly.ExpVectorShort copy() -> copy
    long[] getVal() -> getVal
    long getVal(int) -> getVal
    long setVal(int,long) -> setVal
    short setVal(int,short) -> setVal
    int length() -> length
    edu.jas.poly.ExpVectorShort extend(int,int,long) -> extend
    edu.jas.poly.ExpVectorShort extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVectorShort contract(int,int) -> contract
    edu.jas.poly.ExpVectorShort reverse() -> reverse
    edu.jas.poly.ExpVectorShort reverse(int) -> reverse
    edu.jas.poly.ExpVectorShort combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVectorShort permutation(java.util.List) -> permutation
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.ExpVectorShort abs() -> abs
    edu.jas.poly.ExpVectorShort negate() -> negate
    edu.jas.poly.ExpVectorShort sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVectorShort subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVectorShort subst(int,short) -> subst
    edu.jas.poly.ExpVectorShort subst(int,long) -> subst
    int signum() -> signum
    long totalDeg() -> totalDeg
    long maxDeg() -> maxDeg
    long weightDeg(long[][]) -> weightDeg
    edu.jas.poly.ExpVectorShort lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVectorShort gcd(edu.jas.poly.ExpVector) -> gcd
    int[] dependencyOnVariables() -> dependencyOnVariables
    boolean multipleOf(edu.jas.poly.ExpVector) -> multipleOf
    int compareTo(edu.jas.poly.ExpVector) -> compareTo
    int invLexCompareTo(edu.jas.poly.ExpVector) -> invLexCompareTo
    int invLexCompareTo(edu.jas.poly.ExpVector,int,int) -> invLexCompareTo
    int invGradCompareTo(edu.jas.poly.ExpVector) -> invGradCompareTo
    int invGradCompareTo(edu.jas.poly.ExpVector,int,int) -> invGradCompareTo
    int revInvLexCompareTo(edu.jas.poly.ExpVector) -> revInvLexCompareTo
    int revInvLexCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvLexCompareTo
    int revInvGradCompareTo(edu.jas.poly.ExpVector) -> revInvGradCompareTo
    int revInvGradCompareTo(edu.jas.poly.ExpVector,int,int) -> revInvGradCompareTo
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector) -> invWeightCompareTo
    int invWeightCompareTo(long[][],edu.jas.poly.ExpVector,int,int) -> invWeightCompareTo
    edu.jas.poly.ExpVector gcd(edu.jas.poly.ExpVector) -> gcd
    edu.jas.poly.ExpVector lcm(edu.jas.poly.ExpVector) -> lcm
    edu.jas.poly.ExpVector subst(int,long) -> subst
    edu.jas.poly.ExpVector subtract(edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.ExpVector sum(edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.ExpVector negate() -> negate
    edu.jas.poly.ExpVector abs() -> abs
    edu.jas.poly.ExpVector permutation(java.util.List) -> permutation
    edu.jas.poly.ExpVector combine(edu.jas.poly.ExpVector) -> combine
    edu.jas.poly.ExpVector reverse(int) -> reverse
    edu.jas.poly.ExpVector reverse() -> reverse
    edu.jas.poly.ExpVector contract(int,int) -> contract
    edu.jas.poly.ExpVector extendLower(int,int,long) -> extendLower
    edu.jas.poly.ExpVector extend(int,int,long) -> extend
    edu.jas.poly.ExpVector copy() -> copy
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
edu.jas.poly.FromInteger -> dO:
    edu.jas.structure.RingFactory ring -> a
    void <init>(edu.jas.structure.RingFactory) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.FromIntegerPoly -> dP:
    edu.jas.poly.GenPolynomialRing ring -> a
    edu.jas.poly.FromInteger fi -> a
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.GenPolynomial -> edu.jas.poly.GenPolynomial:
    edu.jas.poly.GenPolynomialRing ring -> ring
    java.util.SortedMap val -> val
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(edu.jas.poly.GenPolynomialRing,java.util.TreeMap) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing,edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing,edu.jas.structure.RingElem) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing,edu.jas.poly.ExpVector) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing,java.util.SortedMap) -> <init>
    edu.jas.poly.GenPolynomialRing factory() -> factory
    edu.jas.poly.GenPolynomial copy() -> copy
    int length() -> length
    java.util.SortedMap getMap() -> getMap
    void doPutToMap(edu.jas.poly.ExpVector,edu.jas.structure.RingElem) -> doPutToMap
    void doRemoveFromMap(edu.jas.poly.ExpVector,edu.jas.structure.RingElem) -> doRemoveFromMap
    void doPutToMap(java.util.SortedMap) -> doPutToMap
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    boolean isConstant() -> isConstant
    boolean isHomogeneous() -> isHomogeneous
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.poly.GenPolynomial) -> compareTo
    int signum() -> signum
    int numberOfVariables() -> numberOfVariables
    java.util.Map$Entry leadingMonomial() -> leadingMonomial
    edu.jas.poly.ExpVector leadingExpVector() -> leadingExpVector
    edu.jas.poly.ExpVector trailingExpVector() -> trailingExpVector
    edu.jas.structure.RingElem leadingBaseCoefficient() -> leadingBaseCoefficient
    edu.jas.structure.RingElem trailingBaseCoefficient() -> trailingBaseCoefficient
    edu.jas.structure.RingElem coefficient(edu.jas.poly.ExpVector) -> coefficient
    edu.jas.poly.GenPolynomial reductum() -> reductum
    long degree(int) -> degree
    long degree() -> degree
    long totalDegree() -> totalDegree
    edu.jas.poly.ExpVector degreeVector() -> degreeVector
    edu.jas.structure.RingElem maxNorm() -> maxNorm
    edu.jas.structure.RingElem sumNorm() -> sumNorm
    edu.jas.poly.GenPolynomial sum(edu.jas.poly.GenPolynomial) -> sum
    edu.jas.poly.GenPolynomial sum(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> sum
    edu.jas.poly.GenPolynomial sum(edu.jas.structure.RingElem) -> sum
    void doAddTo(edu.jas.poly.GenPolynomial) -> doAddTo
    void doAddTo(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> doAddTo
    void doAddTo(edu.jas.structure.RingElem) -> doAddTo
    edu.jas.poly.GenPolynomial subtract(edu.jas.poly.GenPolynomial) -> subtract
    edu.jas.poly.GenPolynomial subtract(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> subtract
    edu.jas.poly.GenPolynomial subtract(edu.jas.structure.RingElem) -> subtract
    edu.jas.poly.GenPolynomial subtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial) -> subtractMultiple
    edu.jas.poly.GenPolynomial subtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> subtractMultiple
    edu.jas.poly.GenPolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial) -> scaleSubtractMultiple
    edu.jas.poly.GenPolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> scaleSubtractMultiple
    edu.jas.poly.GenPolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> scaleSubtractMultiple
    edu.jas.poly.GenPolynomial negate() -> negate
    edu.jas.poly.GenPolynomial abs() -> abs
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.GenPolynomial) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenPolynomial monic() -> monic
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenPolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.GenPolynomial divide(edu.jas.structure.RingElem) -> divide
    edu.jas.poly.GenPolynomial[] quotientRemainder(edu.jas.poly.GenPolynomial) -> quotientRemainder
    edu.jas.poly.GenPolynomial[] divideAndRemainder(edu.jas.poly.GenPolynomial) -> divideAndRemainder
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial) -> divide
    edu.jas.poly.GenPolynomial remainder(edu.jas.poly.GenPolynomial) -> remainder
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial) -> gcd
    edu.jas.poly.GenPolynomial[] egcd(edu.jas.poly.GenPolynomial) -> egcd
    edu.jas.poly.GenPolynomial[] hegcd(edu.jas.poly.GenPolynomial) -> hegcd
    edu.jas.poly.GenPolynomial inverse() -> inverse
    edu.jas.poly.GenPolynomial modInverse(edu.jas.poly.GenPolynomial) -> modInverse
    edu.jas.poly.GenPolynomial extend(edu.jas.poly.GenPolynomialRing,int,long) -> extend
    edu.jas.poly.GenPolynomial extendLower(edu.jas.poly.GenPolynomialRing,int,long) -> extendLower
    java.util.Map contract(edu.jas.poly.GenPolynomialRing) -> contract
    edu.jas.poly.GenPolynomial contractCoeff(edu.jas.poly.GenPolynomialRing) -> contractCoeff
    edu.jas.poly.GenPolynomial extendUnivariate(edu.jas.poly.GenPolynomialRing,int) -> extendUnivariate
    edu.jas.poly.GenPolynomial homogenize(edu.jas.poly.GenPolynomialRing) -> homogenize
    edu.jas.poly.GenPolynomial deHomogenize(edu.jas.poly.GenPolynomialRing) -> deHomogenize
    edu.jas.poly.GenPolynomial reverse(edu.jas.poly.GenPolynomialRing) -> reverse
    java.util.Iterator coefficientIterator() -> coefficientIterator
    java.util.Iterator exponentIterator() -> exponentIterator
    java.util.Iterator iterator() -> iterator
    edu.jas.poly.GenPolynomial map(edu.jas.structure.UnaryFunctor) -> map
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    void <clinit>() -> <clinit>
edu.jas.poly.GenPolynomialIterator -> dQ:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.Iterator eviter -> a
    java.util.List powers -> a
    java.util.List coeffiter -> b
    java.util.Iterator itercoeff -> b
    edu.jas.poly.GenPolynomial current -> a
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    boolean hasNext() -> hasNext
    edu.jas.poly.GenPolynomial next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.GenPolynomialMonomialIterator -> dR:
    edu.jas.poly.GenPolynomialRing ring -> a
    java.util.Iterator iter -> a
    edu.jas.poly.GenPolynomial current -> a
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    boolean hasNext() -> hasNext
    edu.jas.poly.GenPolynomial next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.GenPolynomialRing -> edu.jas.poly.GenPolynomialRing:
    edu.jas.structure.RingFactory coFac -> coFac
    int nvar -> nvar
    edu.jas.poly.TermOrder tord -> tord
    boolean partial -> partial
    java.lang.String[] vars -> vars
    java.util.Set knownVars -> a
    edu.jas.poly.GenPolynomial ZERO -> ZERO
    edu.jas.poly.GenPolynomial ONE -> ONE
    edu.jas.poly.ExpVector evzero -> evzero
    java.util.Random random -> random
    int isField -> isField
    org.apache.log4j.Logger logger -> a
    int creations -> creations
    boolean checkPreempt -> checkPreempt
    void <init>(edu.jas.structure.RingFactory,int) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder) -> <init>
    void <init>(edu.jas.structure.RingFactory,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.TermOrder,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,java.lang.String[],edu.jas.poly.TermOrder) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.GenPolynomialRing) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing,edu.jas.poly.TermOrder) -> <init>
    edu.jas.poly.GenPolynomialRing copy() -> copy
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScript(edu.jas.poly.ExpVector) -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int getCreations() -> getCreations
    java.lang.String[] getVars() -> getVars
    java.lang.String[] setVars(java.lang.String[]) -> setVars
    java.lang.String varsToString() -> varsToString
    edu.jas.structure.RingElem getZEROCoefficient() -> getZEROCoefficient
    edu.jas.structure.RingElem getONECoefficient() -> getONECoefficient
    edu.jas.poly.GenPolynomial getZERO() -> getZERO
    edu.jas.poly.GenPolynomial getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.poly.GenPolynomial valueOf(edu.jas.structure.RingElem) -> valueOf
    edu.jas.poly.GenPolynomial valueOf(edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenPolynomial valueOf(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenPolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenPolynomial random(int) -> random
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> random
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> random
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.GenPolynomial copy(edu.jas.poly.GenPolynomial) -> copy
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> parse
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.GenPolynomial univariate(int) -> univariate
    edu.jas.poly.GenPolynomial univariate(int,long) -> univariate
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> univariate
    java.util.List getGenerators() -> getGenerators
    java.util.List generators() -> generators
    java.util.List generators(int) -> generators
    boolean isFinite() -> isFinite
    java.util.List univariateList() -> univariateList
    java.util.List univariateList(int) -> univariateList
    java.util.List univariateList(int,long) -> univariateList
    edu.jas.poly.GenPolynomialRing extend(int) -> extend
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> extend
    edu.jas.poly.GenPolynomialRing extendLower(int) -> extendLower
    edu.jas.poly.GenPolynomialRing extendLower(java.lang.String[]) -> extendLower
    edu.jas.poly.GenPolynomialRing contract(int) -> contract
    edu.jas.poly.GenPolynomialRing recursive(int) -> recursive
    edu.jas.poly.GenPolynomialRing distribute() -> distribute
    edu.jas.poly.GenPolynomialRing reverse() -> reverse
    edu.jas.poly.GenPolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.PolynomialComparator getComparator() -> getComparator
    edu.jas.poly.PolynomialComparator getComparator(boolean) -> getComparator
    java.lang.String[] newVars(java.lang.String,int) -> newVars
    java.lang.String[] newVars(java.lang.String) -> newVars
    java.lang.String[] newVars(int) -> newVars
    java.lang.String[] newVars() -> newVars
    void addVars(java.lang.String[]) -> addVars
    java.lang.String[] permuteVars(java.util.List,java.lang.String[]) -> permuteVars
    edu.jas.poly.GenPolynomialRing permutation(java.util.List) -> permutation
    java.util.Iterator iterator() -> iterator
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.poly.GenPolynomialRing$1 -> dS:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.poly.GenPolynomialTokenizer -> edu.jas.poly.GenPolynomialTokenizer:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    java.lang.String[] vars -> a
    int nvars -> a
    edu.jas.poly.TermOrder tord -> a
    java.io.StreamTokenizer tok -> a
    java.io.Reader reader -> a
    edu.jas.structure.RingFactory fac -> a
    edu.jas.poly.GenPolynomialRing pfac -> a
    edu.jas.poly.GenSolvablePolynomialRing spfac -> a
    void <init>() -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing,java.io.Reader) -> <init>
    void <init>(java.io.Reader) -> <init>
    edu.jas.poly.GenPolynomial nextPolynomial() -> a
    long nextExponent() -> a
    edu.jas.poly.GenSolvablePolynomial nextSolvablePolynomial() -> a
    boolean digit(char) -> a
    java.lang.String[] variableList(java.lang.String) -> a
    void <clinit>() -> <clinit>
edu.jas.poly.GenPolynomialTokenizer$coeffType -> edu.jas.poly.GenPolynomialTokenizer$coeffType:
    edu.jas.poly.GenPolynomialTokenizer$coeffType BigRat -> BigRat
    edu.jas.poly.GenPolynomialTokenizer$coeffType BigInt -> BigInt
    edu.jas.poly.GenPolynomialTokenizer$coeffType ModInt -> ModInt
    edu.jas.poly.GenPolynomialTokenizer$coeffType BigC -> BigC
    edu.jas.poly.GenPolynomialTokenizer$coeffType BigQ -> BigQ
    edu.jas.poly.GenPolynomialTokenizer$coeffType BigD -> BigD
    edu.jas.poly.GenPolynomialTokenizer$coeffType ANrat -> ANrat
    edu.jas.poly.GenPolynomialTokenizer$coeffType ANmod -> ANmod
    edu.jas.poly.GenPolynomialTokenizer$coeffType IntFunc -> IntFunc
    edu.jas.poly.GenPolynomialTokenizer$coeffType[] $VALUES -> a
    edu.jas.poly.GenPolynomialTokenizer$coeffType[] values() -> values
    edu.jas.poly.GenPolynomialTokenizer$coeffType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
edu.jas.poly.GenPolynomialTokenizer$polyType -> edu.jas.poly.GenPolynomialTokenizer$polyType:
    edu.jas.poly.GenPolynomialTokenizer$polyType PolBigRat -> PolBigRat
    edu.jas.poly.GenPolynomialTokenizer$polyType PolBigInt -> PolBigInt
    edu.jas.poly.GenPolynomialTokenizer$polyType PolModInt -> PolModInt
    edu.jas.poly.GenPolynomialTokenizer$polyType PolBigC -> PolBigC
    edu.jas.poly.GenPolynomialTokenizer$polyType PolBigD -> PolBigD
    edu.jas.poly.GenPolynomialTokenizer$polyType PolBigQ -> PolBigQ
    edu.jas.poly.GenPolynomialTokenizer$polyType PolANrat -> PolANrat
    edu.jas.poly.GenPolynomialTokenizer$polyType PolANmod -> PolANmod
    edu.jas.poly.GenPolynomialTokenizer$polyType PolIntFunc -> PolIntFunc
    edu.jas.poly.GenPolynomialTokenizer$polyType[] $VALUES -> a
    edu.jas.poly.GenPolynomialTokenizer$polyType[] values() -> values
    edu.jas.poly.GenPolynomialTokenizer$polyType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
edu.jas.poly.GenSolvablePolynomial -> edu.jas.poly.GenSolvablePolynomial:
    edu.jas.poly.GenSolvablePolynomialRing ring -> ring
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(edu.jas.poly.GenSolvablePolynomialRing) -> <init>
    void <init>(edu.jas.poly.GenSolvablePolynomialRing,edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> <init>
    void <init>(edu.jas.poly.GenSolvablePolynomialRing,edu.jas.structure.RingElem) -> <init>
    void <init>(edu.jas.poly.GenSolvablePolynomialRing,java.util.SortedMap) -> <init>
    edu.jas.poly.GenSolvablePolynomialRing factory() -> factory
    edu.jas.poly.GenSolvablePolynomial copy() -> copy
    boolean equals(java.lang.Object) -> equals
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.GenSolvablePolynomial) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.GenSolvablePolynomial,edu.jas.poly.GenSolvablePolynomial) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(java.util.Map$Entry) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.GenSolvablePolynomial subtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.GenSolvablePolynomial) -> subtractMultiple
    edu.jas.poly.GenSolvablePolynomial subtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenSolvablePolynomial) -> subtractMultiple
    edu.jas.poly.GenSolvablePolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.poly.GenSolvablePolynomial) -> scaleSubtractMultiple
    edu.jas.poly.GenSolvablePolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenSolvablePolynomial) -> scaleSubtractMultiple
    edu.jas.poly.GenSolvablePolynomial scaleSubtractMultiple(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.poly.GenSolvablePolynomial) -> scaleSubtractMultiple
    edu.jas.poly.GenSolvablePolynomial monic() -> monic
    edu.jas.poly.GenSolvablePolynomial[] quotientRemainder(edu.jas.poly.GenSolvablePolynomial) -> quotientRemainder
    edu.jas.poly.GenSolvablePolynomial rightRecursivePolynomial() -> rightRecursivePolynomial
    edu.jas.poly.GenSolvablePolynomial evalAsRightRecursivePolynomial() -> evalAsRightRecursivePolynomial
    boolean isRightRecursivePolynomial(edu.jas.poly.GenSolvablePolynomial) -> isRightRecursivePolynomial
    edu.jas.poly.GenPolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenPolynomial monic() -> monic
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenPolynomial copy() -> copy
    edu.jas.poly.GenPolynomialRing factory() -> factory
    edu.jas.structure.ElemFactory factory() -> factory
    edu.jas.structure.Element copy() -> copy
    void <clinit>() -> <clinit>
edu.jas.poly.GenSolvablePolynomialRing -> edu.jas.poly.GenSolvablePolynomialRing:
    edu.jas.poly.RelationTable table -> table
    edu.jas.poly.GenSolvablePolynomial ZERO -> ZERO
    edu.jas.poly.GenSolvablePolynomial ONE -> ONE
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>(edu.jas.structure.RingFactory,int) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.RelationTable) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,edu.jas.poly.RelationTable) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.TermOrder,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,java.lang.String[],edu.jas.poly.RelationTable) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.GenPolynomialRing) -> <init>
    void addRelations(edu.jas.poly.RelationGenerator) -> addRelations
    void addRelations(java.util.List) -> addRelations
    void addSolvRelations(java.util.List) -> addSolvRelations
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.GenSolvablePolynomial getZERO() -> getZERO
    edu.jas.poly.GenSolvablePolynomial getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    edu.jas.poly.GenSolvablePolynomial valueOf(edu.jas.structure.RingElem) -> valueOf
    edu.jas.poly.GenSolvablePolynomial valueOf(edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenSolvablePolynomial valueOf(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenSolvablePolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.GenSolvablePolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenSolvablePolynomial random(int) -> random
    edu.jas.poly.GenSolvablePolynomial random(int,java.util.Random) -> random
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float) -> random
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.GenSolvablePolynomial copy(edu.jas.poly.GenSolvablePolynomial) -> copy
    edu.jas.poly.GenSolvablePolynomial parse(java.lang.String) -> parse
    edu.jas.poly.GenSolvablePolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.GenSolvablePolynomial univariate(int) -> univariate
    edu.jas.poly.GenSolvablePolynomial univariate(int,long) -> univariate
    edu.jas.poly.GenSolvablePolynomial univariate(int,int,long) -> univariate
    java.util.List univariateList() -> univariateList
    java.util.List univariateList(int) -> univariateList
    java.util.List univariateList(int,long) -> univariateList
    edu.jas.poly.GenSolvablePolynomialRing extend(int) -> extend
    edu.jas.poly.GenSolvablePolynomialRing extend(java.lang.String[]) -> extend
    edu.jas.poly.GenSolvablePolynomialRing contract(int) -> contract
    edu.jas.poly.GenSolvablePolynomialRing reverse() -> reverse
    edu.jas.poly.GenSolvablePolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.GenSolvablePolynomialRing recursive(int) -> recursive
    edu.jas.poly.GenSolvablePolynomialRing distribute() -> distribute
    edu.jas.poly.GenPolynomialRing permutation(java.util.List) -> permutation
    edu.jas.poly.GenPolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.GenPolynomialRing reverse() -> reverse
    edu.jas.poly.GenPolynomialRing distribute() -> distribute
    edu.jas.poly.GenPolynomialRing recursive(int) -> recursive
    edu.jas.poly.GenPolynomialRing contract(int) -> contract
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> extend
    edu.jas.poly.GenPolynomialRing extend(int) -> extend
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> univariate
    edu.jas.poly.GenPolynomial univariate(int,long) -> univariate
    edu.jas.poly.GenPolynomial univariate(int) -> univariate
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> parse
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> random
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> random
    edu.jas.poly.GenPolynomial random(int) -> random
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenPolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.GenPolynomial valueOf(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenPolynomial valueOf(edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenPolynomial valueOf(edu.jas.structure.RingElem) -> valueOf
    edu.jas.poly.GenPolynomial getONE() -> getONE
    edu.jas.poly.GenPolynomial getZERO() -> getZERO
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.poly.GenSolvablePolynomialRing$1 -> dT:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.poly.GenWordPolynomial -> edu.jas.poly.GenWordPolynomial:
    edu.jas.poly.GenWordPolynomialRing ring -> ring
    java.util.SortedMap val -> val
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(edu.jas.poly.GenWordPolynomialRing,java.util.TreeMap) -> <init>
    void <init>(edu.jas.poly.GenWordPolynomialRing) -> <init>
    void <init>(edu.jas.poly.GenWordPolynomialRing,edu.jas.structure.RingElem,edu.jas.poly.Word) -> <init>
    void <init>(edu.jas.poly.GenWordPolynomialRing,edu.jas.structure.RingElem) -> <init>
    void <init>(edu.jas.poly.GenWordPolynomialRing,edu.jas.poly.Word) -> <init>
    void <init>(edu.jas.poly.GenWordPolynomialRing,edu.jas.poly.ExpVector) -> <init>
    void <init>(edu.jas.poly.GenWordPolynomialRing,edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> <init>
    void <init>(edu.jas.poly.GenWordPolynomialRing,java.util.SortedMap) -> <init>
    edu.jas.poly.GenWordPolynomialRing factory() -> factory
    edu.jas.poly.GenWordPolynomial copy() -> copy
    int length() -> length
    java.util.SortedMap getMap() -> getMap
    void doPutToMap(edu.jas.poly.Word,edu.jas.structure.RingElem) -> doPutToMap
    void doRemoveFromMap(edu.jas.poly.Word,edu.jas.structure.RingElem) -> doRemoveFromMap
    void doPutToMap(java.util.SortedMap) -> doPutToMap
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    boolean isConstant() -> isConstant
    boolean isHomogeneous() -> isHomogeneous
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.poly.GenWordPolynomial) -> compareTo
    int signum() -> signum
    int numberOfVariables() -> numberOfVariables
    java.util.Map$Entry leadingMonomial() -> leadingMonomial
    edu.jas.poly.Word leadingWord() -> leadingWord
    edu.jas.poly.Word trailingWord() -> trailingWord
    edu.jas.structure.RingElem leadingBaseCoefficient() -> leadingBaseCoefficient
    edu.jas.structure.RingElem trailingBaseCoefficient() -> trailingBaseCoefficient
    edu.jas.structure.RingElem coefficient(edu.jas.poly.Word) -> coefficient
    edu.jas.poly.GenWordPolynomial reductum() -> reductum
    long degree() -> degree
    edu.jas.structure.RingElem maxNorm() -> maxNorm
    edu.jas.structure.RingElem sumNorm() -> sumNorm
    edu.jas.poly.GenWordPolynomial sum(edu.jas.poly.GenWordPolynomial) -> sum
    edu.jas.poly.GenWordPolynomial sum(edu.jas.structure.RingElem,edu.jas.poly.Word) -> sum
    edu.jas.poly.GenWordPolynomial sum(edu.jas.structure.RingElem) -> sum
    edu.jas.poly.GenWordPolynomial subtract(edu.jas.poly.GenWordPolynomial) -> subtract
    edu.jas.poly.GenWordPolynomial subtract(edu.jas.structure.RingElem,edu.jas.poly.Word) -> subtract
    edu.jas.poly.GenWordPolynomial subtract(edu.jas.structure.RingElem) -> subtract
    edu.jas.poly.GenWordPolynomial negate() -> negate
    edu.jas.poly.GenWordPolynomial abs() -> abs
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.poly.GenWordPolynomial) -> multiply
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.poly.GenWordPolynomial,edu.jas.poly.GenWordPolynomial) -> multiply
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenWordPolynomial monic() -> monic
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.Word) -> multiply
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.poly.Word,edu.jas.poly.Word) -> multiply
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.Word,edu.jas.poly.Word) -> multiply
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.Word,edu.jas.structure.RingElem,edu.jas.poly.Word) -> multiply
    edu.jas.poly.GenWordPolynomial multiply(edu.jas.poly.Word) -> multiply
    edu.jas.poly.GenWordPolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.GenWordPolynomial divide(edu.jas.structure.RingElem) -> divide
    edu.jas.poly.GenWordPolynomial[] quotientRemainder(edu.jas.poly.GenWordPolynomial) -> quotientRemainder
    edu.jas.poly.GenWordPolynomial divide(edu.jas.poly.GenWordPolynomial) -> divide
    edu.jas.poly.GenWordPolynomial remainder(edu.jas.poly.GenWordPolynomial) -> remainder
    edu.jas.poly.GenWordPolynomial gcd(edu.jas.poly.GenWordPolynomial) -> gcd
    edu.jas.poly.GenWordPolynomial[] egcd(edu.jas.poly.GenWordPolynomial) -> egcd
    edu.jas.poly.GenWordPolynomial[] hegcd(edu.jas.poly.GenWordPolynomial) -> hegcd
    edu.jas.poly.GenWordPolynomial inverse() -> inverse
    edu.jas.poly.GenWordPolynomial modInverse(edu.jas.poly.GenWordPolynomial) -> modInverse
    java.util.Iterator coefficientIterator() -> coefficientIterator
    java.util.Iterator wordIterator() -> wordIterator
    java.util.Iterator iterator() -> iterator
    edu.jas.poly.GenWordPolynomial map(edu.jas.structure.UnaryFunctor) -> map
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    void <clinit>() -> <clinit>
edu.jas.poly.GenWordPolynomialRing -> edu.jas.poly.GenWordPolynomialRing:
    edu.jas.structure.RingFactory coFac -> coFac
    edu.jas.poly.WordFactory alphabet -> alphabet
    edu.jas.poly.GenWordPolynomial ZERO -> ZERO
    edu.jas.poly.GenWordPolynomial ONE -> ONE
    edu.jas.poly.Word wone -> wone
    java.util.Random random -> random
    int isField -> isField
    org.apache.log4j.Logger logger -> a
    boolean checkPreempt -> checkPreempt
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.WordFactory) -> <init>
    void <init>(edu.jas.structure.RingFactory,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,java.lang.String) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.GenWordPolynomialRing) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    edu.jas.poly.GenWordPolynomialRing copy() -> copy
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String[] getVars() -> getVars
    edu.jas.structure.RingElem getZEROCoefficient() -> getZEROCoefficient
    edu.jas.structure.RingElem getONECoefficient() -> getONECoefficient
    edu.jas.poly.GenWordPolynomial getZERO() -> getZERO
    edu.jas.poly.GenWordPolynomial getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isFinite() -> isFinite
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.poly.GenWordPolynomial valueOf(edu.jas.structure.RingElem) -> valueOf
    edu.jas.poly.GenWordPolynomial valueOf(edu.jas.poly.Word) -> valueOf
    edu.jas.poly.GenWordPolynomial valueOf(edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenWordPolynomial valueOf(edu.jas.structure.RingElem,edu.jas.poly.Word) -> valueOf
    edu.jas.poly.GenWordPolynomial valueOf(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenWordPolynomial valueOf(edu.jas.poly.GenPolynomial) -> valueOf
    java.util.List valueOf(java.util.List) -> valueOf
    edu.jas.poly.GenWordPolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.GenWordPolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenWordPolynomial random(int) -> random
    edu.jas.poly.GenWordPolynomial random(int,java.util.Random) -> random
    edu.jas.poly.GenWordPolynomial random(int,int,int) -> random
    edu.jas.poly.GenWordPolynomial random(int,int,int,java.util.Random) -> random
    edu.jas.poly.GenWordPolynomial copy(edu.jas.poly.GenWordPolynomial) -> copy
    edu.jas.poly.GenWordPolynomial parse(java.lang.String) -> parse
    edu.jas.poly.GenWordPolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.GenWordPolynomial univariate(int) -> univariate
    edu.jas.poly.GenWordPolynomial commute(int,int) -> commute
    java.util.List commute(int) -> commute
    java.util.List commute() -> commute
    java.util.List univariateList() -> univariateList
    java.util.List getGenerators() -> getGenerators
    java.util.List generators() -> generators
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.poly.GenWordPolynomialRing$1 -> dU:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.poly.ImagPartComplex -> dV:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.InvalidExpressionException -> edu.jas.poly.InvalidExpressionException:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
edu.jas.poly.ModSymToInt -> dW:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.ModuleList -> edu.jas.poly.ModuleList:
    edu.jas.poly.GenPolynomialRing ring -> ring
    java.util.List list -> list
    int rows -> rows
    int cols -> cols
    org.apache.log4j.Logger logger -> a
    void <init>(edu.jas.poly.GenPolynomialRing,java.util.List) -> <init>
    void <init>(edu.jas.poly.GenSolvablePolynomialRing,java.util.List) -> <init>
    void <init>(edu.jas.vector.GenVectorModul,java.util.List) -> <init>
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.util.List padCols(edu.jas.poly.GenPolynomialRing,java.util.List) -> padCols
    edu.jas.poly.PolynomialList getPolynomialList() -> getPolynomialList
    java.util.List castToSolvableList() -> castToSolvableList
    java.util.List castToList(java.util.List) -> castToList
    java.util.List vecToList(java.util.List) -> vecToList
    void <clinit>() -> <clinit>
edu.jas.poly.ModuleList$1 -> dX:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.poly.Monomial -> dY:
    edu.jas.poly.ExpVector e -> a
    edu.jas.structure.RingElem c -> a
    void <init>(java.util.Map$Entry) -> <init>
    void <init>(edu.jas.poly.ExpVector,edu.jas.structure.RingElem) -> <init>
    java.lang.String toString() -> toString
edu.jas.poly.OptimizedPolynomialList -> edu.jas.poly.OptimizedPolynomialList:
    java.util.List perm -> perm
    void <init>(java.util.List,edu.jas.poly.GenPolynomialRing,java.util.List) -> <init>
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
edu.jas.poly.OrderedModuleList -> edu.jas.poly.OrderedModuleList:
    void <init>(edu.jas.poly.GenPolynomialRing,java.util.List) -> <init>
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.List sort(edu.jas.poly.GenPolynomialRing,java.util.List) -> sort
edu.jas.poly.OrderedModuleList$1 -> dZ:
    java.util.Comparator val$evc -> a
    void <init>(java.util.Comparator) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.OrderedPolynomialList -> edu.jas.poly.OrderedPolynomialList:
    void <init>(edu.jas.poly.GenPolynomialRing,java.util.List) -> <init>
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.List sort(java.util.List) -> sort
    java.util.List sort(edu.jas.poly.GenPolynomialRing,java.util.List) -> sort
edu.jas.poly.OrderedPolynomialList$1 -> ea:
    java.util.Comparator val$evc -> a
    void <init>(java.util.Comparator) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.Overlap -> edu.jas.poly.Overlap:
    edu.jas.poly.Word l1 -> l1
    edu.jas.poly.Word r1 -> r1
    edu.jas.poly.Word l2 -> l2
    edu.jas.poly.Word r2 -> r2
    void <init>(edu.jas.poly.Word,edu.jas.poly.Word,edu.jas.poly.Word,edu.jas.poly.Word) -> <init>
    boolean isOverlap(edu.jas.poly.Word,edu.jas.poly.Word) -> isOverlap
    java.lang.String toString() -> toString
edu.jas.poly.OverlapList -> edu.jas.poly.OverlapList:
    java.util.List ols -> ols
    void <init>() -> <init>
    void add(edu.jas.poly.Overlap) -> add
    java.lang.String toString() -> toString
    boolean isOverlap(edu.jas.poly.Word,edu.jas.poly.Word) -> isOverlap
edu.jas.poly.PolyIterator -> eb:
    java.util.Iterator ms -> a
    void <init>(java.util.SortedMap) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.poly.PolyUtil -> ec:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial recursive(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial distribute(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> b
    java.util.List recursive(edu.jas.poly.GenPolynomialRing,java.util.List) -> a
    java.util.List distribute(edu.jas.poly.GenPolynomialRing,java.util.List) -> b
    edu.jas.poly.GenPolynomial integerFromModularCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> c
    java.util.List integerFromModularCoefficients(edu.jas.poly.GenPolynomialRing,java.util.List) -> c
    edu.jas.poly.GenPolynomial integerFromRationalCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> d
    java.lang.Object[] integerFromRationalCoefficientsFactor(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial fromIntegerCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> e
    java.util.List fromIntegerCoefficients(edu.jas.poly.GenPolynomialRing,java.util.List) -> d
    edu.jas.poly.GenPolynomial complexDecimalFromRational(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial realPartFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> g
    edu.jas.poly.GenPolynomial imaginaryPartFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> h
    edu.jas.poly.GenPolynomial complexFromAny(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> i
    edu.jas.poly.GenPolynomial fromAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> j
    edu.jas.poly.GenPolynomial convertToAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> k
    edu.jas.poly.GenPolynomial convertToRecAlgebraicCoefficients(int,edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial complexFromAlgebraic(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> l
    edu.jas.poly.GenPolynomial algebraicFromComplex(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> m
    edu.jas.poly.GenPolynomial chineseRemainder(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial monic(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenSolvablePolynomial monic(edu.jas.poly.GenSolvablePolynomial) -> a
    java.util.List monic(java.util.List) -> a
    java.util.List leadingExpVector(java.util.List) -> b
    edu.jas.poly.GenPolynomial extendCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,int,long) -> a
    edu.jas.poly.GenPolynomial toRecursive(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> n
    edu.jas.poly.GenPolynomial baseSparsePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial baseDensePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial basePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> c
    edu.jas.poly.GenPolynomial[] basePseudoQuotientRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial recursiveDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> d
    edu.jas.poly.GenPolynomial baseRecursiveDivide(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial recursivePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial recursiveSparsePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> f
    edu.jas.poly.GenPolynomial recursiveDensePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> g
    edu.jas.poly.GenPolynomial recursivePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> h
    edu.jas.poly.GenPolynomial coefficientPseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> i
    edu.jas.poly.GenPolynomial coefficientBasePseudoDivide(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> c
    edu.jas.poly.GenPolynomial baseDeriviative(edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial recursiveDeriviative(edu.jas.poly.GenPolynomial) -> c
    edu.jas.arith.BigInteger factorBound(edu.jas.poly.ExpVector) -> a
    edu.jas.poly.GenPolynomial evaluateMainRecursive(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial evaluateMain(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> b
    java.util.List evaluateMain(edu.jas.poly.GenPolynomialRing,java.util.List,edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem evaluateMain(edu.jas.structure.RingFactory,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    java.util.List evaluateMain(edu.jas.structure.RingFactory,java.util.List,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial evaluateFirstRec(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial substituteMain(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> j
    edu.jas.poly.GenPolynomial substituteUnivariate(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> k
    edu.jas.poly.GenPolynomial seriesOfTaylor(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> b
    edu.jas.poly.GenPolynomial interpolate(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial interpolate(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.poly.GenPolynomial switchVariables(edu.jas.poly.GenPolynomial) -> d
    long coeffMaxDegree(edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial map(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.structure.UnaryFunctor) -> a
    edu.jas.poly.GenPolynomial removeUnusedUpperVariables(edu.jas.poly.GenPolynomial) -> e
    edu.jas.poly.GenPolynomial removeUnusedLowerVariables(edu.jas.poly.GenPolynomial) -> f
    void <clinit>() -> <clinit>
edu.jas.poly.PolyUtil$1 -> ed:
    edu.jas.poly.GenPolynomialRing val$fac -> a
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolyUtil$2 -> ee:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolyUtil$5 -> ef:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.PolynomialComparator -> edu.jas.poly.PolynomialComparator:
    edu.jas.poly.TermOrder tord -> tord
    boolean reverse -> reverse
    void <init>(edu.jas.poly.TermOrder,boolean) -> <init>
    int compare(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> compare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.PolynomialList -> edu.jas.poly.PolynomialList:
    edu.jas.poly.GenPolynomialRing ring -> ring
    java.util.List list -> list
    org.apache.log4j.Logger logger -> a
    void <init>(edu.jas.poly.GenPolynomialRing,java.util.List) -> <init>
    void <init>(edu.jas.poly.GenSolvablePolynomialRing,java.util.List) -> <init>
    edu.jas.poly.PolynomialList copy() -> copy
    boolean equals(java.lang.Object) -> equals
    int compareTo(edu.jas.poly.PolynomialList) -> compareTo
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    edu.jas.poly.ModuleList getModuleList(int) -> getModuleList
    java.util.List getList() -> getList
    java.util.List castToSolvableList() -> castToSolvableList
    java.util.List getSolvableList() -> getSolvableList
    edu.jas.poly.GenSolvablePolynomialRing getSolvableRing() -> getSolvableRing
    java.util.List castToSolvableList(java.util.List) -> castToSolvableList
    java.util.List castToSolvableMatrix(java.util.List) -> castToSolvableMatrix
    java.util.List castToList(java.util.List) -> castToList
    java.util.List castToMatrix(java.util.List) -> castToMatrix
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    edu.jas.poly.PolynomialList homogenize() -> homogenize
    edu.jas.poly.PolynomialList deHomogenize() -> deHomogenize
    boolean isHomogeneous() -> isHomogeneous
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
edu.jas.poly.PolynomialList$1 -> eg:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.poly.QLRSolvablePolynomial -> edu.jas.poly.QLRSolvablePolynomial:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.poly.QLRSolvablePolynomialRing ring -> ring
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(edu.jas.poly.QLRSolvablePolynomialRing) -> <init>
    void <init>(edu.jas.poly.QLRSolvablePolynomialRing,edu.jas.structure.GcdRingElem,edu.jas.poly.ExpVector) -> <init>
    void <init>(edu.jas.poly.QLRSolvablePolynomialRing,edu.jas.structure.GcdRingElem) -> <init>
    void <init>(edu.jas.poly.QLRSolvablePolynomialRing,edu.jas.poly.GenSolvablePolynomial) -> <init>
    void <init>(edu.jas.poly.QLRSolvablePolynomialRing,java.util.SortedMap) -> <init>
    edu.jas.poly.QLRSolvablePolynomialRing factory() -> factory
    edu.jas.poly.QLRSolvablePolynomial copy() -> copy
    boolean equals(java.lang.Object) -> equals
    edu.jas.poly.QLRSolvablePolynomial multiply(edu.jas.poly.QLRSolvablePolynomial) -> multiply
    edu.jas.poly.QLRSolvablePolynomial multiply(edu.jas.poly.QLRSolvablePolynomial,edu.jas.poly.QLRSolvablePolynomial) -> multiply
    edu.jas.poly.QLRSolvablePolynomial multiply(edu.jas.structure.GcdRingElem) -> multiply
    edu.jas.poly.QLRSolvablePolynomial multiply(edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem) -> multiply
    edu.jas.poly.QLRSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.QLRSolvablePolynomial multiply(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.QLRSolvablePolynomial multiply(edu.jas.structure.GcdRingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.QLRSolvablePolynomial multiply(edu.jas.structure.GcdRingElem,edu.jas.poly.ExpVector,edu.jas.structure.GcdRingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.QLRSolvablePolynomial multiplyLeft(edu.jas.structure.GcdRingElem,edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.QLRSolvablePolynomial multiplyLeft(edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.QLRSolvablePolynomial multiplyLeft(edu.jas.structure.GcdRingElem) -> multiplyLeft
    edu.jas.poly.QLRSolvablePolynomial multiplyLeft(java.util.Map$Entry) -> multiplyLeft
    edu.jas.poly.QLRSolvablePolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.QLRSolvablePolynomial shift(edu.jas.poly.QLRSolvablePolynomial,edu.jas.poly.ExpVector) -> shift
    edu.jas.poly.GenSolvablePolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(java.util.Map$Entry) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenSolvablePolynomial copy() -> copy
    edu.jas.poly.GenSolvablePolynomialRing factory() -> factory
    edu.jas.poly.GenPolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenPolynomial copy() -> copy
    edu.jas.poly.GenPolynomialRing factory() -> factory
    edu.jas.structure.ElemFactory factory() -> factory
    edu.jas.structure.Element copy() -> copy
    void <clinit>() -> <clinit>
edu.jas.poly.QLRSolvablePolynomialRing -> edu.jas.poly.QLRSolvablePolynomialRing:
    org.apache.log4j.Logger logger -> a
    edu.jas.poly.RecSolvablePolynomialRing polCoeff -> polCoeff
    edu.jas.poly.QLRSolvablePolynomial ZERO -> ZERO
    edu.jas.poly.QLRSolvablePolynomial ONE -> ONE
    edu.jas.structure.QuotPairFactory qpfac -> qpfac
    void <init>(edu.jas.structure.RingFactory,int) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.RelationTable) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,edu.jas.poly.RelationTable) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.TermOrder,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.GenSolvablePolynomialRing) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.QLRSolvablePolynomialRing) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,java.lang.String[],edu.jas.poly.RelationTable) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.QLRSolvablePolynomial getZERO() -> getZERO
    edu.jas.poly.QLRSolvablePolynomial getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    edu.jas.poly.QLRSolvablePolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.QLRSolvablePolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.QLRSolvablePolynomial random(int) -> random
    edu.jas.poly.QLRSolvablePolynomial random(int,java.util.Random) -> random
    edu.jas.poly.QLRSolvablePolynomial random(int,int,int,float) -> random
    edu.jas.poly.QLRSolvablePolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.QLRSolvablePolynomial copy(edu.jas.poly.QLRSolvablePolynomial) -> copy
    edu.jas.poly.QLRSolvablePolynomial parse(java.lang.String) -> parse
    edu.jas.poly.QLRSolvablePolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.QLRSolvablePolynomial univariate(int) -> univariate
    edu.jas.poly.QLRSolvablePolynomial univariate(int,long) -> univariate
    edu.jas.poly.QLRSolvablePolynomial univariate(int,int,long) -> univariate
    java.util.List recUnivariateList() -> recUnivariateList
    java.util.List recUnivariateList(int) -> recUnivariateList
    java.util.List recUnivariateList(int,long) -> recUnivariateList
    edu.jas.poly.QLRSolvablePolynomialRing extend(int) -> extend
    edu.jas.poly.QLRSolvablePolynomialRing contract(int) -> contract
    edu.jas.poly.QLRSolvablePolynomialRing reverse() -> reverse
    edu.jas.poly.QLRSolvablePolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.QLRSolvablePolynomial fromPolyCoefficients(edu.jas.poly.GenSolvablePolynomial) -> fromPolyCoefficients
    edu.jas.poly.RecSolvablePolynomial toPolyCoefficients(edu.jas.poly.QLRSolvablePolynomial) -> toPolyCoefficients
    edu.jas.poly.RecSolvablePolynomial toPolyCoefficients(edu.jas.poly.GenPolynomial) -> toPolyCoefficients
    edu.jas.poly.GenSolvablePolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.GenSolvablePolynomialRing reverse() -> reverse
    edu.jas.poly.GenSolvablePolynomialRing contract(int) -> contract
    edu.jas.poly.GenSolvablePolynomialRing extend(int) -> extend
    edu.jas.poly.GenSolvablePolynomial univariate(int,int,long) -> univariate
    edu.jas.poly.GenSolvablePolynomial univariate(int,long) -> univariate
    edu.jas.poly.GenSolvablePolynomial univariate(int) -> univariate
    edu.jas.poly.GenSolvablePolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.GenSolvablePolynomial parse(java.lang.String) -> parse
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float) -> random
    edu.jas.poly.GenSolvablePolynomial random(int,java.util.Random) -> random
    edu.jas.poly.GenSolvablePolynomial random(int) -> random
    edu.jas.poly.GenSolvablePolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenSolvablePolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.GenSolvablePolynomial getONE() -> getONE
    edu.jas.poly.GenSolvablePolynomial getZERO() -> getZERO
    edu.jas.poly.GenPolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.GenPolynomialRing reverse() -> reverse
    edu.jas.poly.GenPolynomialRing contract(int) -> contract
    edu.jas.poly.GenPolynomialRing extend(int) -> extend
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> univariate
    edu.jas.poly.GenPolynomial univariate(int,long) -> univariate
    edu.jas.poly.GenPolynomial univariate(int) -> univariate
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> parse
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> random
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> random
    edu.jas.poly.GenPolynomial random(int) -> random
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenPolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.GenPolynomial getONE() -> getONE
    edu.jas.poly.GenPolynomial getZERO() -> getZERO
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.poly.QLRSolvablePolynomialRing$1 -> eh:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.poly.RatToInt -> ei:
    java.math.BigInteger lcm -> a
    void <init>(java.math.BigInteger) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RatToIntFactor -> ej:
    java.math.BigInteger lcm -> a
    java.math.BigInteger gcd -> b
    void <init>(java.math.BigInteger,java.math.BigInteger) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RealPartComplex -> ek:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RecSolvablePolynomial -> edu.jas.poly.RecSolvablePolynomial:
    edu.jas.poly.RecSolvablePolynomialRing ring -> ring
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(edu.jas.poly.RecSolvablePolynomialRing) -> <init>
    void <init>(edu.jas.poly.RecSolvablePolynomialRing,edu.jas.poly.ExpVector) -> <init>
    void <init>(edu.jas.poly.RecSolvablePolynomialRing,edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> <init>
    void <init>(edu.jas.poly.RecSolvablePolynomialRing,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.poly.RecSolvablePolynomialRing,edu.jas.poly.GenSolvablePolynomial) -> <init>
    void <init>(edu.jas.poly.RecSolvablePolynomialRing,java.util.SortedMap) -> <init>
    edu.jas.poly.RecSolvablePolynomialRing factory() -> factory
    edu.jas.poly.RecSolvablePolynomial copy() -> copy
    boolean equals(java.lang.Object) -> equals
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.RecSolvablePolynomial) -> multiply
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.RecSolvablePolynomial,edu.jas.poly.RecSolvablePolynomial) -> multiply
    edu.jas.poly.RecSolvablePolynomial recMultiply(edu.jas.poly.GenPolynomial) -> recMultiply
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> multiply
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.RecSolvablePolynomial multiply(edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.RecSolvablePolynomial multiplyLeft(edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.RecSolvablePolynomial multiplyLeft(edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.RecSolvablePolynomial multiplyLeft(edu.jas.poly.GenPolynomial) -> multiplyLeft
    edu.jas.poly.RecSolvablePolynomial multiplyLeft(java.util.Map$Entry) -> multiplyLeft
    edu.jas.poly.RecSolvablePolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.RecSolvablePolynomial shift(edu.jas.poly.RecSolvablePolynomial,edu.jas.poly.ExpVector) -> shift
    edu.jas.poly.GenSolvablePolynomial rightRecursivePolynomial() -> rightRecursivePolynomial
    edu.jas.poly.GenSolvablePolynomial evalAsRightRecursivePolynomial() -> evalAsRightRecursivePolynomial
    boolean isRightRecursivePolynomial(edu.jas.poly.GenSolvablePolynomial) -> isRightRecursivePolynomial
    edu.jas.poly.GenSolvablePolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(java.util.Map$Entry) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiplyLeft(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiplyLeft
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector,edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenSolvablePolynomial multiply(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> multiply
    edu.jas.poly.GenSolvablePolynomial copy() -> copy
    edu.jas.poly.GenSolvablePolynomialRing factory() -> factory
    edu.jas.poly.GenPolynomial multiply(java.util.Map$Entry) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenPolynomial multiply(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> multiply
    edu.jas.poly.GenPolynomial copy() -> copy
    edu.jas.poly.GenPolynomialRing factory() -> factory
    edu.jas.structure.ElemFactory factory() -> factory
    edu.jas.structure.Element copy() -> copy
    void <clinit>() -> <clinit>
edu.jas.poly.RecSolvablePolynomialRing -> edu.jas.poly.RecSolvablePolynomialRing:
    edu.jas.poly.RelationTable coeffTable -> coeffTable
    edu.jas.poly.RecSolvablePolynomial ZERO -> ZERO
    edu.jas.poly.RecSolvablePolynomial ONE -> ONE
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>(edu.jas.structure.RingFactory,int) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.RelationTable) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,edu.jas.poly.RelationTable) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.TermOrder,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,java.lang.String[]) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,edu.jas.poly.TermOrder,java.lang.String[],edu.jas.poly.RelationTable) -> <init>
    void <init>(edu.jas.structure.RingFactory,edu.jas.poly.RecSolvablePolynomialRing) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.RecSolvablePolynomial getZERO() -> getZERO
    edu.jas.poly.RecSolvablePolynomial getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    edu.jas.poly.RecSolvablePolynomial valueOf(edu.jas.poly.GenPolynomial) -> valueOf
    edu.jas.poly.RecSolvablePolynomial valueOf(edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.RecSolvablePolynomial valueOf(edu.jas.poly.GenPolynomial,edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.RecSolvablePolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.RecSolvablePolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.RecSolvablePolynomial random(int) -> random
    edu.jas.poly.RecSolvablePolynomial random(int,java.util.Random) -> random
    edu.jas.poly.RecSolvablePolynomial random(int,int,int,float) -> random
    edu.jas.poly.RecSolvablePolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.RecSolvablePolynomial copy(edu.jas.poly.RecSolvablePolynomial) -> copy
    edu.jas.poly.RecSolvablePolynomial parse(java.lang.String) -> parse
    edu.jas.poly.RecSolvablePolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.RecSolvablePolynomial univariate(int) -> univariate
    edu.jas.poly.RecSolvablePolynomial univariate(int,long) -> univariate
    edu.jas.poly.RecSolvablePolynomial univariate(int,int,long) -> univariate
    java.util.List recUnivariateList() -> recUnivariateList
    java.util.List recUnivariateList(int) -> recUnivariateList
    java.util.List recUnivariateList(int,long) -> recUnivariateList
    edu.jas.poly.RecSolvablePolynomialRing extend(int) -> extend
    edu.jas.poly.RecSolvablePolynomialRing extend(java.lang.String[]) -> extend
    edu.jas.poly.RecSolvablePolynomialRing contract(int) -> contract
    edu.jas.poly.RecSolvablePolynomialRing reverse() -> reverse
    edu.jas.poly.RecSolvablePolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.GenSolvablePolynomialRing distribute(edu.jas.poly.RecSolvablePolynomialRing) -> distribute
    edu.jas.poly.GenSolvablePolynomialRing permutation(java.util.List) -> permutation
    edu.jas.poly.GenPolynomialRing permutation(java.util.List) -> permutation
    edu.jas.poly.GenSolvablePolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.GenSolvablePolynomialRing reverse() -> reverse
    edu.jas.poly.GenSolvablePolynomialRing contract(int) -> contract
    edu.jas.poly.GenSolvablePolynomialRing extend(java.lang.String[]) -> extend
    edu.jas.poly.GenSolvablePolynomialRing extend(int) -> extend
    edu.jas.poly.GenSolvablePolynomial univariate(int,int,long) -> univariate
    edu.jas.poly.GenSolvablePolynomial univariate(int,long) -> univariate
    edu.jas.poly.GenSolvablePolynomial univariate(int) -> univariate
    edu.jas.poly.GenSolvablePolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.GenSolvablePolynomial parse(java.lang.String) -> parse
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.GenSolvablePolynomial random(int,int,int,float) -> random
    edu.jas.poly.GenSolvablePolynomial random(int,java.util.Random) -> random
    edu.jas.poly.GenSolvablePolynomial random(int) -> random
    edu.jas.poly.GenSolvablePolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenSolvablePolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.GenSolvablePolynomial valueOf(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenSolvablePolynomial valueOf(edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenSolvablePolynomial valueOf(edu.jas.structure.RingElem) -> valueOf
    edu.jas.poly.GenSolvablePolynomial getONE() -> getONE
    edu.jas.poly.GenSolvablePolynomial getZERO() -> getZERO
    edu.jas.poly.GenPolynomialRing reverse(boolean) -> reverse
    edu.jas.poly.GenPolynomialRing reverse() -> reverse
    edu.jas.poly.GenPolynomialRing contract(int) -> contract
    edu.jas.poly.GenPolynomialRing extend(java.lang.String[]) -> extend
    edu.jas.poly.GenPolynomialRing extend(int) -> extend
    edu.jas.poly.GenPolynomial univariate(int,int,long) -> univariate
    edu.jas.poly.GenPolynomial univariate(int,long) -> univariate
    edu.jas.poly.GenPolynomial univariate(int) -> univariate
    edu.jas.poly.GenPolynomial parse(java.io.Reader) -> parse
    edu.jas.poly.GenPolynomial parse(java.lang.String) -> parse
    edu.jas.poly.GenPolynomial random(int,int,int,float,java.util.Random) -> random
    edu.jas.poly.GenPolynomial random(int,int,int,float) -> random
    edu.jas.poly.GenPolynomial random(int,java.util.Random) -> random
    edu.jas.poly.GenPolynomial random(int) -> random
    edu.jas.poly.GenPolynomial fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenPolynomial fromInteger(long) -> fromInteger
    edu.jas.poly.GenPolynomial valueOf(edu.jas.structure.RingElem,edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenPolynomial valueOf(edu.jas.poly.ExpVector) -> valueOf
    edu.jas.poly.GenPolynomial valueOf(edu.jas.structure.RingElem) -> valueOf
    edu.jas.poly.GenPolynomial getONE() -> getONE
    edu.jas.poly.GenPolynomial getZERO() -> getZERO
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.poly.RecSolvablePolynomialRing$1 -> el:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
edu.jas.poly.RecToDist -> em:
    edu.jas.poly.GenPolynomialRing fac -> a
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.poly.RelationGenerator -> en:
    boolean select$619b419f() -> a
    org.apache.commons.math3.linear.RealVector validate$6943c45f() -> a
    org.apache.commons.math3.FieldElement visit$3480e502() -> a
    org.apache.commons.math3.FieldElement end() -> b
    double visit$255dfbe() -> a
    double end() -> b
    boolean converged$51f99816() -> b
    org.matheclipse.core.interfaces.IExpr visit$5c7435c8() -> a
    org.matheclipse.core.interfaces.IExpr end() -> b
edu.jas.poly.RelationTable -> edu.jas.poly.RelationTable:
    java.util.Map table -> table
    edu.jas.poly.GenSolvablePolynomialRing ring -> ring
    boolean coeffTable -> coeffTable
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>(edu.jas.poly.GenSolvablePolynomialRing) -> <init>
    void <init>(edu.jas.poly.GenSolvablePolynomialRing,boolean) -> <init>
    boolean equals(java.lang.Object) -> equals
    java.util.Map fromListDeg2(java.util.List) -> fromListDeg2
    int fromListDeg2HashCode(java.util.List) -> fromListDeg2HashCode
    boolean equalMaps(java.util.Map,java.util.Map) -> equalMaps
    int hashCode() -> hashCode
    boolean isEmpty() -> isEmpty
    java.lang.String toString() -> toString
    java.lang.String toString(java.lang.String[]) -> toString
    java.lang.String toScript() -> toScript
    void update(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,edu.jas.poly.GenSolvablePolynomial) -> update
    void update(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenSolvablePolynomial) -> update
    void update(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> update
    void update(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,edu.jas.poly.GenPolynomial) -> update
    edu.jas.poly.TableRelation lookup(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> lookup
    java.util.List makeKey(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> makeKey
    int size() -> size
    void extend(edu.jas.poly.RelationTable) -> extend
    void contract(edu.jas.poly.RelationTable) -> contract
    void recursive(edu.jas.poly.RelationTable) -> recursive
    void reverse(edu.jas.poly.RelationTable) -> reverse
    java.util.List relationList() -> relationList
    void addSolvRelations(java.util.List) -> addSolvRelations
    void addRelations(java.util.List) -> addRelations
    void <clinit>() -> <clinit>
edu.jas.poly.TableRelation -> edu.jas.poly.TableRelation:
    edu.jas.poly.ExpVector e -> e
    edu.jas.poly.ExpVector f -> f
    edu.jas.poly.GenSolvablePolynomial p -> p
    void <init>(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector,edu.jas.poly.GenSolvablePolynomial) -> <init>
    java.lang.String toString() -> toString
edu.jas.poly.TermOrder -> edu.jas.poly.TermOrder:
    int LEX -> LEX
    int INVLEX -> INVLEX
    int GRLEX -> GRLEX
    int IGRLEX -> IGRLEX
    int REVLEX -> REVLEX
    int REVILEX -> REVILEX
    int REVTDEG -> REVTDEG
    int REVITDG -> REVITDG
    int DEFAULT_EVORD -> DEFAULT_EVORD
    int evord -> evord
    int evord2 -> evord2
    int evbeg1 -> evbeg1
    int evend1 -> evend1
    int evbeg2 -> evbeg2
    int evend2 -> evend2
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    long[][] weight -> weight
    edu.jas.poly.TermOrder$EVComparator horder -> horder
    edu.jas.poly.TermOrder$EVComparator lorder -> lorder
    edu.jas.poly.TermOrder$EVComparator sugar -> sugar
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(long[]) -> <init>
    void <init>(long[][]) -> <init>
    void <init>(int,int) -> <init>
    void <init>(int,int,int,int) -> <init>
    int getEvord() -> getEvord
    int getEvord2() -> getEvord2
    int getSplit() -> getSplit
    long[][] getWeight() -> getWeight
    edu.jas.poly.TermOrder$EVComparator getDescendComparator() -> getDescendComparator
    edu.jas.poly.TermOrder$EVComparator getAscendComparator() -> getAscendComparator
    edu.jas.poly.TermOrder$EVComparator getSugarComparator() -> getSugarComparator
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String weightToString() -> weightToString
    java.lang.String toString() -> toString
    edu.jas.poly.TermOrder extend(int,int) -> extend
    edu.jas.poly.TermOrder extendLower(int,int) -> extendLower
    edu.jas.poly.TermOrder contract(int,int) -> contract
    edu.jas.poly.TermOrder reverse() -> reverse
    edu.jas.poly.TermOrder reverse(boolean) -> reverse
    int revert(int) -> revert
    long[] longArrayPermutation(java.util.List,long[]) -> longArrayPermutation
    edu.jas.poly.TermOrder permutation(java.util.List) -> permutation
    edu.jas.poly.TermOrder$EVComparator access$000(edu.jas.poly.TermOrder) -> access$000
    long[][] access$100(edu.jas.poly.TermOrder) -> access$100
    int access$200(edu.jas.poly.TermOrder) -> access$200
    int access$300(edu.jas.poly.TermOrder) -> access$300
    int access$400(edu.jas.poly.TermOrder) -> access$400
    int access$500(edu.jas.poly.TermOrder) -> access$500
    void <clinit>() -> <clinit>
edu.jas.poly.TermOrder$1 -> edu.jas.poly.TermOrder$1:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$10 -> edu.jas.poly.TermOrder$10:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$11 -> edu.jas.poly.TermOrder$11:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$12 -> edu.jas.poly.TermOrder$12:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$13 -> edu.jas.poly.TermOrder$13:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$14 -> edu.jas.poly.TermOrder$14:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$15 -> edu.jas.poly.TermOrder$15:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$16 -> edu.jas.poly.TermOrder$16:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$17 -> edu.jas.poly.TermOrder$17:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$18 -> edu.jas.poly.TermOrder$18:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$19 -> edu.jas.poly.TermOrder$19:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$2 -> edu.jas.poly.TermOrder$2:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$20 -> edu.jas.poly.TermOrder$20:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$21 -> edu.jas.poly.TermOrder$21:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$22 -> edu.jas.poly.TermOrder$22:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$23 -> edu.jas.poly.TermOrder$23:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$24 -> edu.jas.poly.TermOrder$24:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$25 -> edu.jas.poly.TermOrder$25:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$26 -> edu.jas.poly.TermOrder$26:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$27 -> edu.jas.poly.TermOrder$27:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$28 -> edu.jas.poly.TermOrder$28:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$29 -> edu.jas.poly.TermOrder$29:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$3 -> edu.jas.poly.TermOrder$3:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$30 -> edu.jas.poly.TermOrder$30:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$31 -> edu.jas.poly.TermOrder$31:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$32 -> edu.jas.poly.TermOrder$32:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$33 -> edu.jas.poly.TermOrder$33:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$34 -> edu.jas.poly.TermOrder$34:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$35 -> edu.jas.poly.TermOrder$35:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$36 -> edu.jas.poly.TermOrder$36:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$37 -> edu.jas.poly.TermOrder$37:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$38 -> edu.jas.poly.TermOrder$38:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$39 -> edu.jas.poly.TermOrder$39:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$4 -> edu.jas.poly.TermOrder$4:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$40 -> edu.jas.poly.TermOrder$40:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$41 -> edu.jas.poly.TermOrder$41:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$42 -> edu.jas.poly.TermOrder$42:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$43 -> edu.jas.poly.TermOrder$43:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$44 -> edu.jas.poly.TermOrder$44:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$45 -> edu.jas.poly.TermOrder$45:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$46 -> edu.jas.poly.TermOrder$46:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$47 -> edu.jas.poly.TermOrder$47:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$48 -> edu.jas.poly.TermOrder$48:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$49 -> edu.jas.poly.TermOrder$49:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$5 -> edu.jas.poly.TermOrder$5:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$50 -> edu.jas.poly.TermOrder$50:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$51 -> edu.jas.poly.TermOrder$51:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$52 -> edu.jas.poly.TermOrder$52:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$53 -> edu.jas.poly.TermOrder$53:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$54 -> edu.jas.poly.TermOrder$54:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$55 -> edu.jas.poly.TermOrder$55:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$56 -> edu.jas.poly.TermOrder$56:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$57 -> edu.jas.poly.TermOrder$57:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$58 -> edu.jas.poly.TermOrder$58:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$59 -> edu.jas.poly.TermOrder$59:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$6 -> edu.jas.poly.TermOrder$6:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$60 -> edu.jas.poly.TermOrder$60:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$61 -> edu.jas.poly.TermOrder$61:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$62 -> edu.jas.poly.TermOrder$62:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$63 -> edu.jas.poly.TermOrder$63:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$64 -> edu.jas.poly.TermOrder$64:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$65 -> edu.jas.poly.TermOrder$65:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$66 -> edu.jas.poly.TermOrder$66:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$67 -> edu.jas.poly.TermOrder$67:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$68 -> edu.jas.poly.TermOrder$68:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$69 -> edu.jas.poly.TermOrder$69:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$7 -> edu.jas.poly.TermOrder$7:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$70 -> edu.jas.poly.TermOrder$70:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$8 -> edu.jas.poly.TermOrder$8:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$9 -> edu.jas.poly.TermOrder$9:
    edu.jas.poly.TermOrder this$0 -> this$0
    void <init>(edu.jas.poly.TermOrder) -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrder$EVComparator -> edu.jas.poly.TermOrder$EVComparator:
    void <init>() -> <init>
    int compare(edu.jas.poly.ExpVector,edu.jas.poly.ExpVector) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.TermOrderOptimization -> eo:
    org.apache.log4j.Logger logger -> a
    void <init>() -> <init>
    java.util.List expVectorAdd(java.util.List,edu.jas.poly.ExpVector) -> a
    java.util.List degreeMatrix(java.util.Collection) -> a
    java.util.List optimalPermutation(java.util.List) -> b
    java.util.List inversePermutation(java.util.List) -> a
    edu.jas.poly.GenPolynomial permutation(java.util.List,edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    java.util.List permutation(java.util.List,edu.jas.poly.GenPolynomialRing,java.util.List) -> a
    edu.jas.poly.GenPolynomialRing permutation(java.util.List,edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.poly.OptimizedPolynomialList optimizeTermOrder(edu.jas.poly.GenPolynomialRing,java.util.List) -> a
    void <clinit>() -> <clinit>
edu.jas.poly.Word -> edu.jas.poly.Word:
    edu.jas.poly.WordFactory mono -> mono
    java.lang.String val -> val
    int hash -> hash
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(edu.jas.poly.WordFactory) -> <init>
    void <init>(edu.jas.poly.WordFactory,java.lang.String) -> <init>
    void <init>(edu.jas.poly.WordFactory,java.lang.String,boolean) -> <init>
    edu.jas.structure.MonoidFactory factory() -> factory
    edu.jas.poly.Word copy() -> copy
    java.lang.String getVal() -> getVal
    char getVal(int) -> getVal
    int length() -> length
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    edu.jas.poly.Word multiply(edu.jas.poly.Word) -> multiply
    edu.jas.poly.Word divide(edu.jas.poly.Word) -> divide
    edu.jas.poly.Word[] divideWord(edu.jas.poly.Word) -> divideWord
    edu.jas.poly.Word remainder(edu.jas.poly.Word) -> remainder
    edu.jas.poly.Word[] quotientRemainder(edu.jas.poly.Word) -> quotientRemainder
    edu.jas.poly.Word inverse() -> inverse
    int signum() -> signum
    long degree() -> degree
    java.util.SortedMap dependencyOnVariables() -> dependencyOnVariables
    edu.jas.poly.ExpVector leadingExpVector() -> leadingExpVector
    edu.jas.poly.Word reductum() -> reductum
    boolean multipleOf(edu.jas.poly.Word) -> multipleOf
    boolean divides(edu.jas.poly.Word) -> divides
    int compareTo(edu.jas.poly.Word) -> compareTo
    int gradCompareTo(edu.jas.poly.Word) -> gradCompareTo
    int gradInvlexCompareTo(edu.jas.poly.Word) -> gradInvlexCompareTo
    boolean isOverlap(edu.jas.poly.Overlap,edu.jas.poly.Word) -> isOverlap
    edu.jas.poly.OverlapList overlap(edu.jas.poly.Word) -> overlap
    edu.jas.poly.Word lcm(edu.jas.poly.Word) -> lcm
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
edu.jas.poly.WordFactory -> edu.jas.poly.WordFactory:
    java.lang.String alphabet -> alphabet
    edu.jas.poly.Word ONE -> ONE
    java.lang.String transRef -> transRef
    java.lang.String[] translation -> translation
    java.util.Random random -> a
    org.apache.log4j.Logger logger -> a
    edu.jas.poly.WordFactory$WordComparator horder -> a
    edu.jas.poly.WordFactory$WordComparator lorder -> b
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String[]) -> <init>
    boolean isFinite() -> isFinite
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    edu.jas.poly.Word getONE() -> getONE
    edu.jas.poly.Word copy(edu.jas.poly.Word) -> copy
    int length() -> length
    java.lang.String getVal() -> getVal
    java.lang.String[] getTrans() -> getTrans
    char getVal(int) -> getVal
    java.lang.String[] getVars() -> getVars
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.List generators() -> generators
    edu.jas.poly.Word fromInteger(long) -> fromInteger
    edu.jas.poly.Word fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.Word valueOf(edu.jas.poly.ExpVector) -> valueOf
    int indexOf(char) -> indexOf
    edu.jas.poly.Word random(int) -> random
    edu.jas.poly.Word random(int,java.util.Random) -> random
    edu.jas.poly.Word parse(java.lang.String) -> parse
    edu.jas.poly.Word parse(java.io.Reader) -> parse
    edu.jas.poly.WordFactory$WordComparator getDescendComparator() -> getDescendComparator
    edu.jas.poly.WordFactory$WordComparator getAscendComparator() -> getAscendComparator
    java.lang.String cleanSpace(java.lang.String) -> cleanSpace
    java.lang.String clean(java.lang.String) -> clean
    java.lang.String[] cleanAll(java.lang.String[]) -> cleanAll
    java.lang.String concat(java.lang.String[]) -> concat
    java.lang.String[] trimAll(java.lang.String[]) -> trimAll
    int indexOf(java.lang.String[],java.lang.String) -> indexOf
    boolean isSingleLetters(java.lang.String[]) -> isSingleLetters
    java.lang.String translate(java.lang.String[]) -> translate
    java.lang.String transVar(char) -> transVar
    edu.jas.structure.MonoidElem getONE() -> getONE
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    void <clinit>() -> <clinit>
edu.jas.poly.WordFactory$1 -> edu.jas.poly.WordFactory$1:
    void <init>() -> <init>
    int compare(edu.jas.poly.Word,edu.jas.poly.Word) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.WordFactory$2 -> edu.jas.poly.WordFactory$2:
    void <init>() -> <init>
    int compare(edu.jas.poly.Word,edu.jas.poly.Word) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.WordFactory$WordComparator -> edu.jas.poly.WordFactory$WordComparator:
    void <init>() -> <init>
    int compare(edu.jas.poly.Word,edu.jas.poly.Word) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.jas.poly.WordMonomial -> ep:
    edu.jas.poly.Word e -> a
    edu.jas.structure.RingElem c -> a
    void <init>(java.util.Map$Entry) -> <init>
    void <init>(edu.jas.poly.Word,edu.jas.structure.RingElem) -> <init>
    java.lang.String toString() -> toString
edu.jas.poly.WordPolyIterator -> eq:
    java.util.Iterator ms -> a
    void <init>(java.util.SortedMap) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.ps.Coefficients -> edu.jas.ps.Coefficients:
    java.util.HashMap coeffCache -> coeffCache
    void <init>() -> <init>
    void <init>(java.util.HashMap) -> <init>
    edu.jas.structure.RingElem get(int) -> get
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.Multiply -> er:
    edu.jas.structure.RingElem x -> a
    void <init>(edu.jas.structure.RingElem) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ps.Negate -> es:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ps.PolynomialTaylorFunction -> et:
    edu.jas.poly.GenPolynomial pol -> a
    void <init>(edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,long) -> <init>
    java.lang.String toString() -> toString
    edu.jas.ps.TaylorFunction deriviative() -> a
    edu.jas.structure.RingElem evaluate(edu.jas.structure.RingElem) -> a
edu.jas.ps.Subtract -> eu:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.ps.Sum -> ev:
    void <init>() -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.ps.TaylorFunction -> ew:
    edu.jas.ps.TaylorFunction deriviative() -> a
    edu.jas.structure.RingElem evaluate(edu.jas.structure.RingElem) -> a
edu.jas.ps.UnivPowerSeries -> edu.jas.ps.UnivPowerSeries:
    edu.jas.ps.UnivPowerSeriesRing ring -> ring
    edu.jas.ps.Coefficients lazyCoeffs -> lazyCoeffs
    int truncate -> truncate
    int order -> order
    void <init>() -> <init>
    void <init>(edu.jas.ps.UnivPowerSeriesRing) -> <init>
    void <init>(edu.jas.ps.UnivPowerSeriesRing,edu.jas.ps.Coefficients) -> <init>
    edu.jas.ps.UnivPowerSeriesRing factory() -> factory
    edu.jas.ps.UnivPowerSeries copy() -> copy
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    edu.jas.structure.RingElem coefficient(int) -> coefficient
    edu.jas.poly.GenPolynomial asPolynomial() -> asPolynomial
    edu.jas.structure.RingElem leadingCoefficient() -> leadingCoefficient
    edu.jas.ps.UnivPowerSeries reductum() -> reductum
    edu.jas.ps.UnivPowerSeries prepend(edu.jas.structure.RingElem) -> prepend
    edu.jas.ps.UnivPowerSeries shift(int) -> shift
    edu.jas.ps.UnivPowerSeries select$1b83eb32(edu.jas.poly.RelationGenerator) -> select$1b83eb32
    edu.jas.ps.UnivPowerSeries shiftSelect$1b83eb32(edu.jas.poly.RelationGenerator) -> shiftSelect$1b83eb32
    edu.jas.ps.UnivPowerSeries map(edu.jas.structure.UnaryFunctor) -> map
    edu.jas.ps.UnivPowerSeries zip(edu.jas.structure.BinaryFunctor,edu.jas.ps.UnivPowerSeries) -> zip
    edu.jas.ps.UnivPowerSeries sum(edu.jas.ps.UnivPowerSeries) -> sum
    edu.jas.ps.UnivPowerSeries subtract(edu.jas.ps.UnivPowerSeries) -> subtract
    edu.jas.ps.UnivPowerSeries multiply(edu.jas.structure.RingElem) -> multiply
    edu.jas.ps.UnivPowerSeries monic() -> monic
    edu.jas.ps.UnivPowerSeries negate() -> negate
    edu.jas.ps.UnivPowerSeries abs() -> abs
    edu.jas.structure.RingElem evaluate(edu.jas.structure.RingElem) -> evaluate
    int order() -> order
    int truncate() -> truncate
    int setTruncate(int) -> setTruncate
    int signum() -> signum
    int compareTo(edu.jas.ps.UnivPowerSeries) -> compareTo
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isUnit() -> isUnit
    edu.jas.ps.UnivPowerSeries multiply(edu.jas.ps.UnivPowerSeries) -> multiply
    edu.jas.ps.UnivPowerSeries inverse() -> inverse
    edu.jas.ps.UnivPowerSeries divide(edu.jas.ps.UnivPowerSeries) -> divide
    edu.jas.ps.UnivPowerSeries remainder(edu.jas.ps.UnivPowerSeries) -> remainder
    edu.jas.ps.UnivPowerSeries[] quotientRemainder(edu.jas.ps.UnivPowerSeries) -> quotientRemainder
    edu.jas.ps.UnivPowerSeries differentiate() -> differentiate
    edu.jas.ps.UnivPowerSeries integrate(edu.jas.structure.RingElem) -> integrate
    edu.jas.ps.UnivPowerSeries gcd(edu.jas.ps.UnivPowerSeries) -> gcd
    edu.jas.ps.UnivPowerSeries[] egcd(edu.jas.ps.UnivPowerSeries) -> egcd
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
edu.jas.ps.UnivPowerSeries$1 -> edu.jas.ps.UnivPowerSeries$1:
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$10 -> edu.jas.ps.UnivPowerSeries$10:
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$11 -> edu.jas.ps.UnivPowerSeries$11:
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$12 -> edu.jas.ps.UnivPowerSeries$12:
    edu.jas.structure.RingElem val$c -> val$c
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries,edu.jas.structure.RingElem) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$2 -> edu.jas.ps.UnivPowerSeries$2:
    edu.jas.structure.RingElem val$h -> val$h
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries,edu.jas.structure.RingElem) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$3 -> edu.jas.ps.UnivPowerSeries$3:
    int val$k -> val$k
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries,int) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$4 -> edu.jas.ps.UnivPowerSeries$4:
    edu.jas.poly.RelationGenerator val$sel$c1826e8 -> val$sel$c1826e8
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries,edu.jas.poly.RelationGenerator) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$5 -> edu.jas.ps.UnivPowerSeries$5:
    int pos -> pos
    edu.jas.poly.RelationGenerator val$sel$c1826e8 -> val$sel$c1826e8
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries,edu.jas.poly.RelationGenerator) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$6 -> edu.jas.ps.UnivPowerSeries$6:
    edu.jas.structure.UnaryFunctor val$f -> val$f
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries,edu.jas.structure.UnaryFunctor) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$7 -> edu.jas.ps.UnivPowerSeries$7:
    edu.jas.structure.BinaryFunctor val$f -> val$f
    edu.jas.ps.UnivPowerSeries val$ps -> val$ps
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries,edu.jas.structure.BinaryFunctor,edu.jas.ps.UnivPowerSeries) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeries$8 -> ex:
    edu.jas.structure.RingElem val$b -> a
    void <init>(edu.jas.ps.UnivPowerSeries,edu.jas.structure.RingElem) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ps.UnivPowerSeries$9 -> edu.jas.ps.UnivPowerSeries$9:
    edu.jas.ps.UnivPowerSeries val$ps -> val$ps
    edu.jas.ps.UnivPowerSeries this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeries,edu.jas.ps.UnivPowerSeries) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeriesMap -> ey:
    edu.jas.ps.UnivPowerSeries map(edu.jas.ps.UnivPowerSeries) -> a
edu.jas.ps.UnivPowerSeriesRing -> edu.jas.ps.UnivPowerSeriesRing:
    java.util.Random random -> random
    int DEFAULT_TRUNCATE -> DEFAULT_TRUNCATE
    int truncate -> truncate
    java.lang.String DEFAULT_NAME -> DEFAULT_NAME
    java.lang.String var -> var
    edu.jas.structure.RingFactory coFac -> coFac
    edu.jas.ps.UnivPowerSeries ONE -> ONE
    edu.jas.ps.UnivPowerSeries ZERO -> ZERO
    void <init>() -> <init>
    void <init>(edu.jas.structure.RingFactory) -> <init>
    void <init>(edu.jas.structure.RingFactory,int) -> <init>
    void <init>(edu.jas.structure.RingFactory,java.lang.String) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    void <init>(edu.jas.structure.RingFactory,int,java.lang.String) -> <init>
    edu.jas.ps.UnivPowerSeries fixPoint(edu.jas.ps.UnivPowerSeriesMap) -> fixPoint
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.ps.UnivPowerSeries getZERO() -> getZERO
    edu.jas.ps.UnivPowerSeries getONE() -> getONE
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    edu.jas.ps.UnivPowerSeries getEXP() -> getEXP
    edu.jas.ps.UnivPowerSeries getSIN() -> getSIN
    edu.jas.ps.UnivPowerSeries getCOS() -> getCOS
    edu.jas.ps.UnivPowerSeries getTAN() -> getTAN
    edu.jas.ps.UnivPowerSeries solveODE(edu.jas.ps.UnivPowerSeries,edu.jas.structure.RingElem) -> solveODE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.ps.UnivPowerSeries fromInteger(long) -> fromInteger
    edu.jas.ps.UnivPowerSeries fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.poly.GenPolynomialRing polyRing() -> polyRing
    edu.jas.ps.UnivPowerSeries fromPolynomial(edu.jas.poly.GenPolynomial) -> fromPolynomial
    edu.jas.ps.UnivPowerSeries random() -> random
    edu.jas.ps.UnivPowerSeries random(int) -> random
    edu.jas.ps.UnivPowerSeries random(int,java.util.Random) -> random
    edu.jas.ps.UnivPowerSeries random(int,float) -> random
    edu.jas.ps.UnivPowerSeries random(int,float,java.util.Random) -> random
    edu.jas.ps.UnivPowerSeries copy(edu.jas.ps.UnivPowerSeries) -> copy
    edu.jas.ps.UnivPowerSeries parse(java.lang.String) -> parse
    edu.jas.ps.UnivPowerSeries parse(java.io.Reader) -> parse
    edu.jas.ps.UnivPowerSeries seriesOfTaylor(edu.jas.ps.TaylorFunction,edu.jas.structure.RingElem) -> seriesOfTaylor
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
edu.jas.ps.UnivPowerSeriesRing$1 -> edu.jas.ps.UnivPowerSeriesRing$1:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeriesRing) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeriesRing$10 -> edu.jas.ps.UnivPowerSeriesRing$10:
    edu.jas.ps.TaylorFunction der -> der
    long k -> k
    long n -> n
    edu.jas.ps.TaylorFunction val$f -> val$f
    edu.jas.structure.RingElem val$a -> val$a
    edu.jas.ps.UnivPowerSeriesRing this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeriesRing,edu.jas.ps.TaylorFunction,edu.jas.structure.RingElem) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeriesRing$2 -> edu.jas.ps.UnivPowerSeriesRing$2:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeriesRing) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeriesRing$3 -> edu.jas.ps.UnivPowerSeriesRing$3:
    edu.jas.structure.RingElem val$cg -> val$cg
    edu.jas.ps.UnivPowerSeriesRing this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeriesRing,edu.jas.structure.RingElem) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeriesRing$4 -> ez:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    void <init>(edu.jas.ps.UnivPowerSeriesRing) -> <init>
    edu.jas.ps.UnivPowerSeries map(edu.jas.ps.UnivPowerSeries) -> a
edu.jas.ps.UnivPowerSeriesRing$5 -> eA:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    void <init>(edu.jas.ps.UnivPowerSeriesRing) -> <init>
    edu.jas.ps.UnivPowerSeries map(edu.jas.ps.UnivPowerSeries) -> a
edu.jas.ps.UnivPowerSeriesRing$6 -> eB:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    void <init>(edu.jas.ps.UnivPowerSeriesRing) -> <init>
    edu.jas.ps.UnivPowerSeries map(edu.jas.ps.UnivPowerSeries) -> a
edu.jas.ps.UnivPowerSeriesRing$7 -> eC:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> a
    void <init>(edu.jas.ps.UnivPowerSeriesRing) -> <init>
    edu.jas.ps.UnivPowerSeries map(edu.jas.ps.UnivPowerSeries) -> a
edu.jas.ps.UnivPowerSeriesRing$8 -> edu.jas.ps.UnivPowerSeriesRing$8:
    edu.jas.ps.UnivPowerSeriesRing this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeriesRing,java.util.HashMap) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.ps.UnivPowerSeriesRing$9 -> edu.jas.ps.UnivPowerSeriesRing$9:
    java.util.Random val$rnd -> val$rnd
    float val$d -> val$d
    int val$k -> val$k
    edu.jas.ps.UnivPowerSeriesRing this$0 -> this$0
    void <init>(edu.jas.ps.UnivPowerSeriesRing,java.util.Random,float,int) -> <init>
    edu.jas.structure.RingElem generate(int) -> generate
edu.jas.root.Boundary -> edu.jas.root.Boundary:
    edu.jas.root.Rectangle rect -> rect
    edu.jas.poly.GenPolynomial A -> A
    edu.jas.poly.GenPolynomial[] polys -> polys
    edu.jas.poly.GenPolynomialRing rfac -> rfac
    void <init>(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial[]) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    edu.jas.poly.GenPolynomial getRealPart(int) -> getRealPart
    edu.jas.poly.GenPolynomial getImagPart(int) -> getImagPart
    edu.jas.root.Boundary copy() -> copy
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
edu.jas.root.ComplexRoots -> edu.jas.root.ComplexRoots:
edu.jas.root.ComplexRootsAbstract -> edu.jas.root.ComplexRootsAbstract:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.Squarefree engine -> engine
    void <init>(edu.jas.structure.RingFactory) -> <init>
    edu.jas.poly.Complex rootBound(edu.jas.poly.GenPolynomial) -> rootBound
    edu.jas.structure.RingElem magnitudeBound(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> magnitudeBound
    long complexRootCount(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> complexRootCount
    java.util.List complexRoots(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> complexRoots
    java.util.List complexRoots(edu.jas.poly.GenPolynomial) -> complexRoots
    edu.jas.root.Rectangle complexRootRefinement(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.arith.BigRational) -> complexRootRefinement
    java.util.List complexRoots(edu.jas.poly.GenPolynomial,edu.jas.arith.BigRational) -> complexRoots
    edu.jas.root.Rectangle invariantRectangle(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> invariantRectangle
    java.lang.String toDecimal(edu.jas.poly.Complex) -> toDecimal
    edu.jas.poly.Complex approximateRoot(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> approximateRoot
    java.util.List approximateRoots(edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> approximateRoots
    edu.jas.poly.Complex[] copyOfComplex(edu.jas.poly.Complex[],int) -> copyOfComplex
    edu.jas.root.Rectangle invariantMagnitudeRectangle(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> invariantMagnitudeRectangle
    edu.jas.poly.Complex complexRectangleMagnitude(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> complexRectangleMagnitude
    edu.jas.poly.Complex complexMagnitude(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.structure.RingElem) -> complexMagnitude
    void <clinit>() -> <clinit>
edu.jas.root.ComplexRootsAbstract$1 -> eD:
    void <init>(edu.jas.root.ComplexRootsAbstract) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.root.ComplexRootsSturm -> edu.jas.root.ComplexRootsSturm:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>(edu.jas.structure.RingFactory) -> <init>
    long indexOfCauchy(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> indexOfCauchy
    long[] indexOfRouth(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> indexOfRouth
    java.util.List sturmSequence(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> sturmSequence
    long complexRootCount(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> complexRootCount
    long windingNumber(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> windingNumber
    java.util.List complexRoots(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial) -> complexRoots
    edu.jas.root.Rectangle invariantRectangle(edu.jas.root.Rectangle,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> invariantRectangle
    void <clinit>() -> <clinit>
edu.jas.root.InvalidBoundaryException -> edu.jas.root.InvalidBoundaryException:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
edu.jas.root.NoConvergenceException -> edu.jas.root.NoConvergenceException:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
edu.jas.root.Rectangle -> edu.jas.root.Rectangle:
    edu.jas.poly.Complex[] corners -> corners
    void <init>(edu.jas.poly.Complex[]) -> <init>
    void <init>(edu.jas.poly.Complex) -> <init>
    void <init>(edu.jas.poly.Complex,edu.jas.poly.Complex) -> <init>
    void <init>(edu.jas.poly.Complex,edu.jas.poly.Complex,edu.jas.poly.Complex,edu.jas.poly.Complex) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    edu.jas.poly.Complex getNW() -> getNW
    edu.jas.poly.Complex getSW() -> getSW
    edu.jas.poly.Complex getSE() -> getSE
    edu.jas.poly.Complex getNE() -> getNE
    edu.jas.root.Rectangle exchangeNW(edu.jas.poly.Complex) -> exchangeNW
    edu.jas.root.Rectangle exchangeSW(edu.jas.poly.Complex) -> exchangeSW
    edu.jas.root.Rectangle exchangeSE(edu.jas.poly.Complex) -> exchangeSE
    edu.jas.root.Rectangle exchangeNE(edu.jas.poly.Complex) -> exchangeNE
    boolean contains(edu.jas.poly.Complex) -> contains
    boolean contains(edu.jas.root.Rectangle) -> contains
    edu.jas.poly.Complex randomPoint() -> randomPoint
    edu.jas.root.Rectangle copy() -> copy
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.poly.Complex getCenter() -> getCenter
    edu.jas.poly.Complex getRationalCenter() -> getRationalCenter
    edu.jas.poly.Complex getDecimalCenter() -> getDecimalCenter
    java.lang.String centerApprox() -> centerApprox
    edu.jas.structure.RingElem length() -> length
    edu.jas.arith.BigRational rationalLength() -> rationalLength
    edu.jas.structure.RingElem lengthReal() -> lengthReal
    edu.jas.structure.RingElem lengthImag() -> lengthImag
edu.jas.root.RootUtil -> eE:
    org.apache.log4j.Logger logger -> a
    void <init>() -> <init>
    long signVar(java.util.List) -> a
    void <clinit>() -> <clinit>
edu.jas.structure.AbelianGroupElem -> edu.jas.structure.AbelianGroupElem:
    boolean isZERO() -> isZERO
    int signum() -> signum
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem abs() -> abs
edu.jas.structure.AbelianGroupFactory -> edu.jas.structure.AbelianGroupFactory:
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
edu.jas.structure.BinaryFunctor -> eF:
    edu.jas.structure.Element eval(edu.jas.structure.Element,edu.jas.structure.Element) -> a
edu.jas.structure.ElemFactory -> edu.jas.structure.ElemFactory:
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    java.lang.String toScript() -> toScript
edu.jas.structure.Element -> edu.jas.structure.Element:
    edu.jas.structure.Element copy() -> copy
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.ElemFactory factory() -> factory
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
edu.jas.structure.GcdRingElem -> edu.jas.structure.GcdRingElem:
edu.jas.structure.ModulElem -> edu.jas.structure.ModulElem:
    edu.jas.structure.ModulElem scalarMultiply(edu.jas.structure.RingElem) -> scalarMultiply
    edu.jas.structure.ModulElem linearCombination(edu.jas.structure.RingElem,edu.jas.structure.ModulElem,edu.jas.structure.RingElem) -> linearCombination
    edu.jas.structure.ModulElem linearCombination(edu.jas.structure.ModulElem,edu.jas.structure.RingElem) -> linearCombination
    edu.jas.structure.RingElem scalarProduct(edu.jas.structure.ModulElem) -> scalarProduct
    edu.jas.structure.ModulElem scalarProduct(java.util.List) -> scalarProduct
edu.jas.structure.ModulFactory -> edu.jas.structure.ModulFactory:
edu.jas.structure.MonoidElem -> edu.jas.structure.MonoidElem:
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem inverse() -> inverse
edu.jas.structure.MonoidFactory -> edu.jas.structure.MonoidFactory:
    edu.jas.structure.MonoidElem getONE() -> getONE
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
edu.jas.structure.NotInvertibleException -> edu.jas.structure.NotInvertibleException:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
edu.jas.structure.Power -> eG:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    edu.jas.structure.RingFactory fac -> a
    void <init>() -> <init>
    void <init>(edu.jas.structure.RingFactory) -> <init>
    edu.jas.structure.RingElem positivePower(edu.jas.structure.RingElem,long) -> a
    edu.jas.structure.RingElem positivePower(edu.jas.structure.RingElem,java.math.BigInteger) -> a
    edu.jas.structure.RingElem power(edu.jas.structure.RingFactory,edu.jas.structure.RingElem,long) -> a
    edu.jas.structure.RingElem modPower(edu.jas.structure.RingElem,java.math.BigInteger,edu.jas.structure.RingElem) -> a
    long logarithm(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> a
    edu.jas.structure.RingElem multiply(edu.jas.structure.RingFactory,java.util.List) -> a
    void <clinit>() -> <clinit>
edu.jas.structure.QuotPair -> eH:
    edu.jas.structure.RingElem numerator() -> numerator
    edu.jas.structure.RingElem denominator() -> denominator
    boolean isConstant() -> isConstant
edu.jas.structure.QuotPairFactory -> eI:
    edu.jas.structure.RingElem create(edu.jas.structure.RingElem) -> create
    edu.jas.structure.RingElem create(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> create
    edu.jas.structure.RingFactory pairFactory() -> pairFactory
edu.jas.structure.RingElem -> edu.jas.structure.RingElem:
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
edu.jas.structure.RingFactory -> edu.jas.structure.RingFactory:
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
edu.jas.structure.StarRingElem -> edu.jas.structure.StarRingElem:
    edu.jas.structure.StarRingElem conjugate() -> conjugate
    edu.jas.structure.StarRingElem norm() -> norm
edu.jas.structure.UnaryFunctor -> eJ:
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
edu.jas.ufd.FactorAbsolute -> edu.jas.ufd.FactorAbsolute:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.lang.String toString() -> toString
    boolean isAbsoluteIrreducible(edu.jas.poly.GenPolynomial) -> isAbsoluteIrreducible
    edu.jas.ufd.FactorsMap baseFactorsAbsolute(edu.jas.poly.GenPolynomial) -> baseFactorsAbsolute
    edu.jas.ufd.FactorsList baseFactorsAbsoluteSquarefree(edu.jas.poly.GenPolynomial) -> baseFactorsAbsoluteSquarefree
    edu.jas.ufd.Factors baseFactorsAbsoluteIrreducible(edu.jas.poly.GenPolynomial) -> baseFactorsAbsoluteIrreducible
    edu.jas.ufd.PartialFraction baseAlgebraicPartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseAlgebraicPartialFraction
    edu.jas.ufd.PartialFraction baseAlgebraicPartialFractionIrreducible(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseAlgebraicPartialFractionIrreducible
    edu.jas.ufd.PartialFraction baseAlgebraicPartialFractionIrreducibleAbsolute(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseAlgebraicPartialFractionIrreducibleAbsolute
    edu.jas.ufd.FactorsMap factorsAbsolute(edu.jas.poly.GenPolynomial) -> factorsAbsolute
    edu.jas.ufd.FactorsList factorsAbsoluteSquarefree(edu.jas.poly.GenPolynomial) -> factorsAbsoluteSquarefree
    edu.jas.ufd.Factors factorsAbsoluteIrreducible(edu.jas.poly.GenPolynomial) -> factorsAbsoluteIrreducible
    boolean isAbsoluteFactorization(edu.jas.ufd.Factors) -> isAbsoluteFactorization
    boolean isAbsoluteFactorization(edu.jas.ufd.FactorsList) -> isAbsoluteFactorization
    boolean isAbsoluteFactorization(edu.jas.ufd.FactorsMap) -> isAbsoluteFactorization
    void <clinit>() -> <clinit>
edu.jas.ufd.FactorAbstract -> edu.jas.ufd.FactorAbstract:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> engine
    edu.jas.ufd.SquarefreeAbstract sengine -> sengine
    void <init>() -> <init>
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.lang.String toString() -> toString
    boolean isIrreducible(edu.jas.poly.GenPolynomial) -> isIrreducible
    boolean isReducible(edu.jas.poly.GenPolynomial) -> isReducible
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> isSquarefree
    java.util.List factorsSquarefreeOptimize(edu.jas.poly.GenPolynomial) -> factorsSquarefreeOptimize
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> factorsSquarefree
    java.util.List factorsSquarefreeKronecker(edu.jas.poly.GenPolynomial) -> factorsSquarefreeKronecker
    java.util.List removeOnce(java.util.List,java.util.List) -> removeOnce
    java.util.List baseFactorsRadical(edu.jas.poly.GenPolynomial) -> baseFactorsRadical
    java.util.SortedMap baseFactors(edu.jas.poly.GenPolynomial) -> baseFactors
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> baseFactorsSquarefree
    java.util.List factorsRadical(edu.jas.poly.GenPolynomial) -> factorsRadical
    java.util.List factorsRadical(java.util.List) -> factorsRadical
    java.util.SortedMap factors(edu.jas.poly.GenPolynomial) -> factors
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> squarefreePart
    edu.jas.poly.GenPolynomial primitivePart(edu.jas.poly.GenPolynomial) -> primitivePart
    edu.jas.poly.GenPolynomial basePrimitivePart(edu.jas.poly.GenPolynomial) -> basePrimitivePart
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> squarefreeFactors
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.List) -> isFactorization
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> isFactorization
    long factorsDegree(java.util.SortedMap) -> factorsDegree
    boolean isRecursiveFactorization(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> isRecursiveFactorization
    java.util.List recursiveFactorsSquarefree(edu.jas.poly.GenPolynomial) -> recursiveFactorsSquarefree
    java.util.SortedMap recursiveFactors(edu.jas.poly.GenPolynomial) -> recursiveFactors
    java.util.List normalizeFactorization(java.util.List) -> normalizeFactorization
    void <clinit>() -> <clinit>
edu.jas.ufd.FactorAlgebraic -> edu.jas.ufd.FactorAlgebraic:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.FactorAbstract factorCoeff -> factorCoeff
    void <init>() -> <init>
    void <init>(edu.jas.poly.AlgebraicNumberRing) -> <init>
    void <init>(edu.jas.poly.AlgebraicNumberRing,edu.jas.ufd.FactorAbstract) -> <init>
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> baseFactorsSquarefree
    void <clinit>() -> <clinit>
edu.jas.ufd.FactorComplex -> edu.jas.ufd.FactorComplex:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.FactorAbstract factorAlgeb -> factorAlgeb
    edu.jas.poly.AlgebraicNumberRing afac -> afac
    void <init>() -> <init>
    void <init>(edu.jas.structure.RingFactory) -> <init>
    void <init>(edu.jas.poly.ComplexRing) -> <init>
    void <init>(edu.jas.poly.ComplexRing,edu.jas.ufd.FactorAbstract) -> <init>
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> baseFactorsSquarefree
    void <clinit>() -> <clinit>
edu.jas.ufd.FactorFactory -> eK:
    org.apache.log4j.Logger logger -> a
    void <init>() -> <init>
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.arith.ModIntegerRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.arith.ModLongRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation$146bcd55() -> a
    edu.jas.ufd.FactorAbstract getImplementation$17dd3501() -> b
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.poly.AlgebraicNumberRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.ufd.FactorAbstract getImplementation(edu.jas.structure.RingFactory) -> a
    void <clinit>() -> <clinit>
edu.jas.ufd.FactorInteger -> edu.jas.ufd.FactorInteger:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.FactorAbstract mfactor -> mfactor
    edu.jas.ufd.GreatestCommonDivisorAbstract mengine -> mengine
    void <init>() -> <init>
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> baseFactorsSquarefree
    java.util.BitSet factorDegrees(java.util.List,int) -> factorDegrees
    long degreeSum(java.util.List) -> degreeSum
    java.util.List searchFactorsMonic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,java.util.List,java.util.BitSet) -> searchFactorsMonic
    java.util.List searchFactorsNonMonic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,java.util.List,java.util.BitSet) -> searchFactorsNonMonic
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> factorsSquarefree
    java.util.List factorsSquarefreeHensel(edu.jas.poly.GenPolynomial) -> factorsSquarefreeHensel
    boolean testSeparate(java.util.List,edu.jas.arith.BigInteger) -> testSeparate
    boolean isNearlySquarefree(edu.jas.poly.GenPolynomial) -> isNearlySquarefree
    void <clinit>() -> <clinit>
edu.jas.ufd.FactorModular -> edu.jas.ufd.FactorModular:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.util.SortedMap baseDistinctDegreeFactors(edu.jas.poly.GenPolynomial) -> baseDistinctDegreeFactors
    java.util.List baseEqualDegreeFactors(edu.jas.poly.GenPolynomial,long) -> baseEqualDegreeFactors
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> baseFactorsSquarefree
    void <clinit>() -> <clinit>
edu.jas.ufd.FactorQuotient -> edu.jas.ufd.FactorQuotient:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.FactorAbstract nengine -> nengine
    void <init>() -> <init>
    void <init>(edu.jas.ufd.QuotientRing) -> <init>
    void <init>(edu.jas.ufd.QuotientRing,edu.jas.ufd.FactorAbstract) -> <init>
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> baseFactorsSquarefree
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> factorsSquarefree
    void <clinit>() -> <clinit>
edu.jas.ufd.FactorRational -> edu.jas.ufd.FactorRational:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.FactorAbstract iengine -> iengine
    void <init>() -> <init>
    java.util.List baseFactorsSquarefree(edu.jas.poly.GenPolynomial) -> baseFactorsSquarefree
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> factorsSquarefree
    void <clinit>() -> <clinit>
edu.jas.ufd.Factorization -> edu.jas.ufd.Factorization:
    boolean isIrreducible(edu.jas.poly.GenPolynomial) -> isIrreducible
    boolean isReducible(edu.jas.poly.GenPolynomial) -> isReducible
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> isSquarefree
    java.util.List factorsSquarefree(edu.jas.poly.GenPolynomial) -> factorsSquarefree
    java.util.SortedMap factors(edu.jas.poly.GenPolynomial) -> factors
    java.util.List factorsRadical(edu.jas.poly.GenPolynomial) -> factorsRadical
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> squarefreePart
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> squarefreeFactors
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.List) -> isFactorization
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> isFactorization
edu.jas.ufd.Factors -> edu.jas.ufd.Factors:
    edu.jas.poly.GenPolynomial poly -> poly
    edu.jas.poly.AlgebraicNumberRing afac -> afac
    edu.jas.poly.GenPolynomial apoly -> apoly
    java.util.List afactors -> afactors
    java.util.List arfactors -> arfactors
    void <init>(edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.AlgebraicNumberRing,edu.jas.poly.GenPolynomial,java.util.List) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.AlgebraicNumberRing,edu.jas.poly.GenPolynomial,java.util.List,java.util.List) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    int length() -> length
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    int compareTo(edu.jas.ufd.Factors) -> compareTo
    edu.jas.poly.AlgebraicNumberRing findExtensionField() -> findExtensionField
    java.util.List getFactors() -> getFactors
    edu.jas.ufd.Factors getFactor(edu.jas.poly.GenPolynomial) -> getFactor
    int compareTo(java.lang.Object) -> compareTo
edu.jas.ufd.FactorsList -> edu.jas.ufd.FactorsList:
    edu.jas.poly.GenPolynomial poly -> poly
    java.util.List factors -> factors
    java.util.List afactors -> afactors
    void <init>(edu.jas.poly.GenPolynomial,java.util.List) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,java.util.List,java.util.List) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    edu.jas.poly.AlgebraicNumberRing findExtensionField() -> findExtensionField
edu.jas.ufd.FactorsMap -> edu.jas.ufd.FactorsMap:
    edu.jas.poly.GenPolynomial poly -> poly
    java.util.SortedMap factors -> factors
    java.util.SortedMap afactors -> afactors
    void <init>(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> <init>
    void <init>(edu.jas.poly.GenPolynomial,java.util.SortedMap,java.util.SortedMap) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    int length() -> length
    edu.jas.poly.AlgebraicNumberRing findExtensionField() -> findExtensionField
edu.jas.ufd.GCDFactory -> eL:
    org.apache.log4j.Logger logger -> a
    void <init>() -> <init>
    edu.jas.ufd.GreatestCommonDivisorAbstract getImplementation(edu.jas.arith.ModLongRing) -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getImplementation$7645a7b4() -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getImplementation(edu.jas.structure.RingFactory) -> a
    edu.jas.ufd.GreatestCommonDivisorAbstract getProxy(edu.jas.structure.RingFactory) -> b
    void <clinit>() -> <clinit>
edu.jas.ufd.GCDProxy -> edu.jas.ufd.GCDProxy:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.GreatestCommonDivisorAbstract e1 -> e1
    edu.jas.ufd.GreatestCommonDivisorAbstract e2 -> e2
    java.util.concurrent.ExecutorService pool -> pool
    void <init>(edu.jas.ufd.GreatestCommonDivisorAbstract,edu.jas.ufd.GreatestCommonDivisorAbstract) -> <init>
    java.lang.String toString() -> toString
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseGcd
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateGcd
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> gcd
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseResultant
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateResultant
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> resultant
    boolean access$000(edu.jas.ufd.GCDProxy) -> access$000
    org.apache.log4j.Logger access$100() -> access$100
    void <clinit>() -> <clinit>
edu.jas.ufd.GCDProxy$1 -> eM:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$10 -> eN:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$11 -> eO:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$12 -> eP:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$2 -> eQ:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$3 -> eR:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$4 -> eS:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$5 -> eT:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$6 -> eU:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$7 -> eV:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$8 -> eW:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GCDProxy$9 -> eX:
    edu.jas.poly.GenPolynomial val$P -> a
    edu.jas.poly.GenPolynomial val$S -> b
    edu.jas.ufd.GCDProxy this$0 -> a
    void <init>(edu.jas.ufd.GCDProxy,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    edu.jas.poly.GenPolynomial call() -> a
    java.lang.Object call() -> call
edu.jas.ufd.GreatestCommonDivisor -> edu.jas.ufd.GreatestCommonDivisor:
    edu.jas.poly.GenPolynomial content(edu.jas.poly.GenPolynomial) -> content
    edu.jas.poly.GenPolynomial primitivePart(edu.jas.poly.GenPolynomial) -> primitivePart
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> gcd
    edu.jas.poly.GenPolynomial lcm(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> lcm
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> resultant
    java.util.List coPrime(java.util.List) -> coPrime
    boolean isCoPrime(java.util.List) -> isCoPrime
edu.jas.ufd.GreatestCommonDivisorAbstract -> edu.jas.ufd.GreatestCommonDivisorAbstract:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    java.lang.String toString() -> toString
    edu.jas.structure.GcdRingElem baseContent(edu.jas.poly.GenPolynomial) -> baseContent
    edu.jas.poly.GenPolynomial basePrimitivePart(edu.jas.poly.GenPolynomial) -> basePrimitivePart
    java.util.List basePrimitivePart(java.util.List) -> basePrimitivePart
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseGcd
    edu.jas.poly.GenPolynomial recursiveContent(edu.jas.poly.GenPolynomial) -> recursiveContent
    edu.jas.poly.GenPolynomial recursivePrimitivePart(edu.jas.poly.GenPolynomial) -> recursivePrimitivePart
    java.util.List recursivePrimitivePart(java.util.List) -> recursivePrimitivePart
    edu.jas.structure.GcdRingElem baseRecursiveContent(edu.jas.poly.GenPolynomial) -> baseRecursiveContent
    edu.jas.poly.GenPolynomial baseRecursivePrimitivePart(edu.jas.poly.GenPolynomial) -> baseRecursivePrimitivePart
    edu.jas.poly.GenPolynomial recursiveGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveGcd
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateGcd
    edu.jas.poly.GenPolynomial content(edu.jas.poly.GenPolynomial) -> content
    edu.jas.poly.GenPolynomial primitivePart(edu.jas.poly.GenPolynomial) -> primitivePart
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial,edu.jas.structure.GcdRingElem) -> divide
    edu.jas.structure.GcdRingElem gcd(edu.jas.structure.GcdRingElem,edu.jas.structure.GcdRingElem) -> gcd
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> gcd
    edu.jas.poly.GenPolynomial lcm(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> lcm
    edu.jas.poly.GenPolynomial gcd(java.util.List) -> gcd
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseResultant
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateResultant
    edu.jas.poly.GenPolynomial recursiveResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveResultant
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> resultant
    java.util.List coPrime(java.util.List) -> coPrime
    java.util.List coPrimeRec(java.util.List) -> coPrimeRec
    java.util.List coPrime(edu.jas.poly.GenPolynomial,java.util.List) -> coPrime
    boolean isCoPrime(java.util.List) -> isCoPrime
    boolean isCoPrime(java.util.List,java.util.List) -> isCoPrime
    edu.jas.poly.GenPolynomial[] baseExtendedGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseExtendedGcd
    edu.jas.poly.GenPolynomial[] baseHalfExtendedGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseHalfExtendedGcd
    edu.jas.poly.GenPolynomial[] baseGcdDiophant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseGcdDiophant
    edu.jas.poly.GenPolynomial[] basePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> basePartialFraction
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> basePartialFraction
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,java.util.List) -> basePartialFraction
    boolean isBasePartialFraction(edu.jas.poly.GenPolynomial,java.util.List,java.util.List) -> isBasePartialFraction
    boolean isBasePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int,java.util.List) -> isBasePartialFraction
    edu.jas.poly.GenPolynomial basePartialFractionValue(edu.jas.poly.GenPolynomial,int,java.util.List) -> basePartialFractionValue
    void <clinit>() -> <clinit>
edu.jas.ufd.GreatestCommonDivisorModEval -> edu.jas.ufd.GreatestCommonDivisorModEval:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.GreatestCommonDivisorAbstract mufd -> mufd
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseGcd
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateGcd
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> gcd
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseResultant
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateResultant
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> resultant
    void <clinit>() -> <clinit>
edu.jas.ufd.GreatestCommonDivisorModular -> edu.jas.ufd.GreatestCommonDivisorModular:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.GreatestCommonDivisorAbstract mufd -> mufd
    edu.jas.ufd.GreatestCommonDivisorAbstract iufd -> iufd
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseGcd
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateGcd
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> gcd
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseResultant
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateResultant
    edu.jas.poly.GenPolynomial resultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> resultant
    void <clinit>() -> <clinit>
edu.jas.ufd.GreatestCommonDivisorPrimitive -> edu.jas.ufd.GreatestCommonDivisorPrimitive:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseGcd
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateGcd
    void <clinit>() -> <clinit>
edu.jas.ufd.GreatestCommonDivisorSimple -> edu.jas.ufd.GreatestCommonDivisorSimple:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseGcd
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateGcd
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseResultant
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateResultant
    void <clinit>() -> <clinit>
edu.jas.ufd.GreatestCommonDivisorSubres -> edu.jas.ufd.GreatestCommonDivisorSubres:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial basePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> basePseudoRemainder
    edu.jas.poly.GenPolynomial recursivePseudoRemainder(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursivePseudoRemainder
    edu.jas.poly.GenPolynomial baseGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseGcd
    edu.jas.poly.GenPolynomial recursiveUnivariateGcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateGcd
    edu.jas.poly.GenPolynomial baseResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> baseResultant
    edu.jas.poly.GenPolynomial recursiveUnivariateResultant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> recursiveUnivariateResultant
    edu.jas.poly.GenPolynomial baseDiscriminant(edu.jas.poly.GenPolynomial) -> baseDiscriminant
    edu.jas.structure.GcdRingElem power(edu.jas.structure.RingFactory,edu.jas.structure.GcdRingElem,long) -> power
    edu.jas.poly.GenPolynomial power(edu.jas.structure.RingFactory,edu.jas.poly.GenPolynomial,long) -> power
    void <clinit>() -> <clinit>
edu.jas.ufd.HenselApprox -> edu.jas.ufd.HenselApprox:
    edu.jas.poly.GenPolynomial A -> A
    edu.jas.poly.GenPolynomial B -> B
    edu.jas.poly.GenPolynomial Am -> Am
    edu.jas.poly.GenPolynomial Bm -> Bm
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    edu.jas.arith.BigInteger approximationSize() -> approximationSize
edu.jas.ufd.HenselMultUtil -> eY:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    void <init>() -> <init>
    java.util.List liftDiophant(java.util.List,edu.jas.poly.GenPolynomial,java.util.List,long,long) -> a
    java.util.List liftHensel(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,java.util.List,java.util.List,long,java.util.List) -> a
    void <clinit>() -> <clinit>
edu.jas.ufd.HenselUtil -> eZ:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    void <init>() -> <init>
    edu.jas.ufd.HenselApprox liftHenselQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.ufd.HenselApprox liftHenselQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial[] liftExtendedEuclidean(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftExtendedEuclidean(java.util.List,long) -> a
    java.util.List liftDiophant(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftDiophant(java.util.List,edu.jas.poly.GenPolynomial,long) -> a
    java.util.List liftDiophant(java.util.List,long,long) -> a
    boolean isExtendedEuclideanLift(java.util.List,java.util.List) -> a
    boolean isDiophantLift(java.util.List,java.util.List,edu.jas.poly.GenPolynomial) -> a
    java.util.List liftHenselMonic(edu.jas.poly.GenPolynomial,java.util.List,long) -> a
    void <clinit>() -> <clinit>
edu.jas.ufd.NoLiftingException -> edu.jas.ufd.NoLiftingException:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
edu.jas.ufd.PartialFraction -> edu.jas.ufd.PartialFraction:
    edu.jas.poly.GenPolynomial num -> num
    edu.jas.poly.GenPolynomial den -> den
    java.util.List cfactors -> cfactors
    java.util.List cdenom -> cdenom
    java.util.List afactors -> afactors
    java.util.List adenom -> adenom
    void <init>(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,java.util.List,java.util.List,java.util.List,java.util.List) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toStringX() -> toStringX
    java.lang.String toScript() -> toScript
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
edu.jas.ufd.PolyUfdUtil -> fa:
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    void <init>() -> <init>
    edu.jas.poly.GenPolynomial integralFromQuotientCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> a
    edu.jas.poly.GenPolynomial quotientFromIntegralCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> c
    java.util.List quotientFromIntegralCoefficients(edu.jas.poly.GenPolynomialRing,java.util.Collection) -> a
    edu.jas.poly.GenPolynomial introduceLowerVariable(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> b
    edu.jas.poly.GenPolynomial substituteConvertToAlgebraicCoefficients(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,long) -> a
    edu.jas.poly.GenPolynomial norm(edu.jas.poly.GenPolynomial,long) -> a
    void ensureFieldProperty(edu.jas.poly.AlgebraicNumberRing) -> a
    edu.jas.poly.GenPolynomial substituteKronecker(edu.jas.poly.GenPolynomial,long) -> b
    edu.jas.poly.GenPolynomial backSubstituteKronecker(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial,long) -> b
    void <clinit>() -> <clinit>
edu.jas.ufd.Quotient -> edu.jas.ufd.Quotient:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.ufd.QuotientRing ring -> ring
    edu.jas.poly.GenPolynomial num -> num
    edu.jas.poly.GenPolynomial den -> den
    void <init>(edu.jas.ufd.QuotientRing) -> <init>
    void <init>(edu.jas.ufd.QuotientRing,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.ufd.QuotientRing,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> <init>
    void <init>(edu.jas.ufd.QuotientRing,edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,boolean) -> <init>
    edu.jas.ufd.QuotientRing factory() -> factory
    edu.jas.poly.GenPolynomial numerator() -> numerator
    edu.jas.poly.GenPolynomial denominator() -> denominator
    edu.jas.ufd.Quotient copy() -> copy
    boolean isZERO() -> isZERO
    boolean isONE() -> isONE
    boolean isUnit() -> isUnit
    boolean isConstant() -> isConstant
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    int compareTo(edu.jas.ufd.Quotient) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.ufd.Quotient abs() -> abs
    edu.jas.ufd.Quotient sum(edu.jas.ufd.Quotient) -> sum
    edu.jas.ufd.Quotient negate() -> negate
    int signum() -> signum
    edu.jas.ufd.Quotient subtract(edu.jas.ufd.Quotient) -> subtract
    edu.jas.ufd.Quotient divide(edu.jas.ufd.Quotient) -> divide
    edu.jas.ufd.Quotient inverse() -> inverse
    edu.jas.ufd.Quotient remainder(edu.jas.ufd.Quotient) -> remainder
    edu.jas.ufd.Quotient[] quotientRemainder(edu.jas.ufd.Quotient) -> quotientRemainder
    edu.jas.ufd.Quotient multiply(edu.jas.ufd.Quotient) -> multiply
    edu.jas.ufd.Quotient multiply(edu.jas.poly.GenPolynomial) -> multiply
    edu.jas.ufd.Quotient multiply(edu.jas.structure.GcdRingElem) -> multiply
    edu.jas.ufd.Quotient monic() -> monic
    edu.jas.ufd.Quotient gcd(edu.jas.ufd.Quotient) -> gcd
    edu.jas.ufd.Quotient[] egcd(edu.jas.ufd.Quotient) -> egcd
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
    edu.jas.structure.RingElem denominator() -> denominator
    edu.jas.structure.RingElem numerator() -> numerator
    void <clinit>() -> <clinit>
edu.jas.ufd.QuotientRing -> edu.jas.ufd.QuotientRing:
    org.apache.log4j.Logger logger -> a
    edu.jas.poly.GenPolynomialRing ring -> ring
    edu.jas.ufd.GreatestCommonDivisor engine -> engine
    boolean ufdGCD -> ufdGCD
    void <init>(edu.jas.poly.GenPolynomialRing) -> <init>
    void <init>(edu.jas.poly.GenPolynomialRing,boolean) -> <init>
    edu.jas.poly.GenPolynomialRing pairFactory() -> pairFactory
    edu.jas.ufd.Quotient create(edu.jas.poly.GenPolynomial) -> create
    edu.jas.ufd.Quotient create(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> create
    edu.jas.poly.GenPolynomial divide(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> divide
    edu.jas.poly.GenPolynomial gcd(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> gcd
    boolean isFinite() -> isFinite
    edu.jas.ufd.Quotient copy(edu.jas.ufd.Quotient) -> copy
    edu.jas.ufd.Quotient getZERO() -> getZERO
    edu.jas.ufd.Quotient getONE() -> getONE
    java.util.List generators() -> generators
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    edu.jas.ufd.Quotient fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.ufd.Quotient fromInteger(long) -> fromInteger
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.ufd.Quotient random(int) -> random
    edu.jas.ufd.Quotient random(int,int,int,float) -> random
    edu.jas.ufd.Quotient random(int,java.util.Random) -> random
    edu.jas.ufd.Quotient parse(java.lang.String) -> parse
    edu.jas.ufd.Quotient parse(java.io.Reader) -> parse
    long extensionDegree() -> extensionDegree
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    edu.jas.structure.RingFactory pairFactory() -> pairFactory
    edu.jas.structure.RingElem create(edu.jas.structure.RingElem,edu.jas.structure.RingElem) -> create
    edu.jas.structure.RingElem create(edu.jas.structure.RingElem) -> create
    void <clinit>() -> <clinit>
edu.jas.ufd.Squarefree -> edu.jas.ufd.Squarefree:
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> squarefreePart
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> isSquarefree
    boolean isSquarefree(java.util.List) -> isSquarefree
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> squarefreeFactors
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.List) -> isFactorization
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> isFactorization
    java.util.List coPrimeSquarefree(java.util.List) -> coPrimeSquarefree
    java.util.List coPrimeSquarefree(edu.jas.poly.GenPolynomial,java.util.List) -> coPrimeSquarefree
    boolean isCoPrimeSquarefree(java.util.List) -> isCoPrimeSquarefree
edu.jas.ufd.SquarefreeAbstract -> edu.jas.ufd.SquarefreeAbstract:
    edu.jas.ufd.GreatestCommonDivisorAbstract engine -> engine
    void <init>(edu.jas.ufd.GreatestCommonDivisorAbstract) -> <init>
    edu.jas.poly.GenPolynomial baseSquarefreePart(edu.jas.poly.GenPolynomial) -> baseSquarefreePart
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> baseSquarefreeFactors
    edu.jas.poly.GenPolynomial recursiveUnivariateSquarefreePart(edu.jas.poly.GenPolynomial) -> recursiveUnivariateSquarefreePart
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> recursiveUnivariateSquarefreeFactors
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> squarefreePart
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> isSquarefree
    boolean isSquarefree(java.util.List) -> isSquarefree
    boolean isRecursiveSquarefree(edu.jas.poly.GenPolynomial) -> isRecursiveSquarefree
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> squarefreeFactors
    java.util.List coPrimeSquarefree(java.util.List) -> coPrimeSquarefree
    java.util.List coPrimeSquarefree(edu.jas.poly.GenPolynomial,java.util.List) -> coPrimeSquarefree
    boolean isCoPrimeSquarefree(java.util.List) -> isCoPrimeSquarefree
    java.util.SortedMap normalizeFactorization(java.util.SortedMap) -> normalizeFactorization
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.List) -> isFactorization
    long factorCount(java.util.SortedMap) -> factorCount
    boolean isFactorization(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> isFactorization
    boolean isRecursiveFactorization(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> isRecursiveFactorization
    edu.jas.poly.GenPolynomial recursiveSquarefreePart(edu.jas.poly.GenPolynomial) -> recursiveSquarefreePart
    java.util.SortedMap recursiveSquarefreeFactors(edu.jas.poly.GenPolynomial) -> recursiveSquarefreeFactors
    java.util.List basePartialFraction(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> basePartialFraction
    boolean isBasePartialFraction(edu.jas.poly.GenPolynomial,java.util.SortedMap,java.util.List) -> isBasePartialFraction
    edu.jas.structure.GcdRingElem squarefreePart(edu.jas.structure.GcdRingElem) -> squarefreePart
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> squarefreeFactors
edu.jas.ufd.SquarefreeFactory -> fb:
    org.apache.log4j.Logger logger -> a
    void <init>() -> <init>
    edu.jas.ufd.SquarefreeAbstract getImplementation(edu.jas.arith.BigInteger) -> a
    edu.jas.ufd.SquarefreeAbstract getImplementation(edu.jas.arith.BigRational) -> a
    edu.jas.ufd.SquarefreeAbstract getImplementation(edu.jas.poly.GenPolynomialRing) -> a
    edu.jas.ufd.SquarefreeAbstract getImplementationPoly(edu.jas.poly.GenPolynomialRing) -> b
    edu.jas.ufd.SquarefreeAbstract getImplementation(edu.jas.structure.RingFactory) -> a
    void <clinit>() -> <clinit>
edu.jas.ufd.SquarefreeFieldChar0 -> edu.jas.ufd.SquarefreeFieldChar0:
    org.apache.log4j.Logger logger -> a
    edu.jas.structure.RingFactory coFac -> coFac
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.lang.String toString() -> toString
    edu.jas.poly.GenPolynomial baseSquarefreePart(edu.jas.poly.GenPolynomial) -> baseSquarefreePart
    boolean isBaseSquarefree(edu.jas.poly.GenPolynomial) -> isBaseSquarefree
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> baseSquarefreeFactors
    edu.jas.poly.GenPolynomial recursiveUnivariateSquarefreePart(edu.jas.poly.GenPolynomial) -> recursiveUnivariateSquarefreePart
    boolean isRecursiveUnivariateSquarefree(edu.jas.poly.GenPolynomial) -> isRecursiveUnivariateSquarefree
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> recursiveUnivariateSquarefreeFactors
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> squarefreePart
    boolean isSquarefree(edu.jas.poly.GenPolynomial) -> isSquarefree
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> squarefreeFactors
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> squarefreeFactors
    void <clinit>() -> <clinit>
edu.jas.ufd.SquarefreeFieldCharP -> edu.jas.ufd.SquarefreeFieldCharP:
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    edu.jas.structure.RingFactory coFac -> coFac
    edu.jas.poly.AlgebraicNumberRing aCoFac -> aCoFac
    edu.jas.ufd.QuotientRing qCoFac -> qCoFac
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.lang.String toString() -> toString
    edu.jas.poly.GenPolynomial baseSquarefreePart(edu.jas.poly.GenPolynomial) -> baseSquarefreePart
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> baseSquarefreeFactors
    edu.jas.poly.GenPolynomial recursiveUnivariateSquarefreePart(edu.jas.poly.GenPolynomial) -> recursiveUnivariateSquarefreePart
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> recursiveUnivariateSquarefreeFactors
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> squarefreePart
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> squarefreeFactors
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> squarefreeFactors
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> baseRootCharacteristic
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> recursiveUnivariateRootCharacteristic
    boolean isCharRoot(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> isCharRoot
    boolean isRecursiveCharRoot(edu.jas.poly.GenPolynomial,java.util.SortedMap) -> isRecursiveCharRoot
    boolean isRecursiveCharRoot(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial) -> isRecursiveCharRoot
    void <clinit>() -> <clinit>
edu.jas.ufd.SquarefreeFiniteFieldCharP -> edu.jas.ufd.SquarefreeFiniteFieldCharP:
    org.apache.log4j.Logger logger -> a
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.util.SortedMap rootCharacteristic(edu.jas.structure.GcdRingElem) -> rootCharacteristic
    edu.jas.structure.GcdRingElem coeffRootCharacteristic(edu.jas.structure.GcdRingElem) -> coeffRootCharacteristic
    java.util.SortedMap rootCharacteristic(edu.jas.poly.GenPolynomial) -> rootCharacteristic
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> baseRootCharacteristic
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> recursiveUnivariateRootCharacteristic
    void <clinit>() -> <clinit>
edu.jas.ufd.SquarefreeInfiniteAlgebraicFieldCharP -> edu.jas.ufd.SquarefreeInfiniteAlgebraicFieldCharP:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.SquarefreeAbstract aengine -> aengine
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.util.SortedMap squarefreeFactors(edu.jas.poly.AlgebraicNumber) -> squarefreeFactors
    java.util.SortedMap rootCharacteristic(edu.jas.poly.AlgebraicNumber) -> rootCharacteristic
    edu.jas.poly.GenPolynomial rootCharacteristic(edu.jas.poly.GenPolynomial) -> rootCharacteristic
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> baseRootCharacteristic
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> recursiveUnivariateRootCharacteristic
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> squarefreeFactors
    void <clinit>() -> <clinit>
edu.jas.ufd.SquarefreeInfiniteFieldCharP -> edu.jas.ufd.SquarefreeInfiniteFieldCharP:
    org.apache.log4j.Logger logger -> a
    edu.jas.ufd.SquarefreeAbstract qengine -> qengine
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.util.SortedMap squarefreeFactors(edu.jas.ufd.Quotient) -> squarefreeFactors
    java.util.SortedMap rootCharacteristic(edu.jas.ufd.Quotient) -> rootCharacteristic
    edu.jas.poly.GenPolynomial rootCharacteristic(edu.jas.poly.GenPolynomial) -> rootCharacteristic
    edu.jas.poly.GenPolynomial baseRootCharacteristic(edu.jas.poly.GenPolynomial) -> baseRootCharacteristic
    edu.jas.poly.GenPolynomial recursiveUnivariateRootCharacteristic(edu.jas.poly.GenPolynomial) -> recursiveUnivariateRootCharacteristic
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> squarefreeFactors
    void <clinit>() -> <clinit>
edu.jas.ufd.SquarefreeRingChar0 -> edu.jas.ufd.SquarefreeRingChar0:
    org.apache.log4j.Logger logger -> a
    edu.jas.structure.RingFactory coFac -> coFac
    void <init>(edu.jas.structure.RingFactory) -> <init>
    java.lang.String toString() -> toString
    edu.jas.poly.GenPolynomial baseSquarefreePart(edu.jas.poly.GenPolynomial) -> baseSquarefreePart
    java.util.SortedMap baseSquarefreeFactors(edu.jas.poly.GenPolynomial) -> baseSquarefreeFactors
    edu.jas.poly.GenPolynomial recursiveUnivariateSquarefreePart(edu.jas.poly.GenPolynomial) -> recursiveUnivariateSquarefreePart
    java.util.SortedMap recursiveUnivariateSquarefreeFactors(edu.jas.poly.GenPolynomial) -> recursiveUnivariateSquarefreeFactors
    edu.jas.poly.GenPolynomial squarefreePart(edu.jas.poly.GenPolynomial) -> squarefreePart
    java.util.SortedMap squarefreeFactors(edu.jas.poly.GenPolynomial) -> squarefreeFactors
    java.util.SortedMap squarefreeFactors(edu.jas.structure.GcdRingElem) -> squarefreeFactors
    void <clinit>() -> <clinit>
edu.jas.ufd.TrialParts -> fc:
    java.util.List evalPoints -> a
    edu.jas.poly.GenPolynomial univPoly -> a
    java.util.List univFactors -> b
    java.util.List ldcfFactors -> c
    java.util.List ldcfEval -> d
    void <init>(java.util.List,edu.jas.poly.GenPolynomial,java.util.List,java.util.List,java.util.List) -> <init>
    java.lang.String toString() -> toString
edu.jas.util.CartesianOneProductInfiniteIterator -> fd:
    java.util.Iterator compit -> a
    void <init>(java.lang.Iterable) -> <init>
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.CartesianProduct -> fe:
    java.util.List comps -> a
    void <init>(java.util.List) -> <init>
    java.util.Iterator iterator() -> iterator
edu.jas.util.CartesianProductInfinite -> ff:
    java.util.List comps -> a
    void <init>(java.util.List) -> <init>
    java.util.Iterator iterator() -> iterator
edu.jas.util.CartesianProductIterator -> fg:
    java.util.List comps -> a
    java.util.List compit -> b
    java.util.List current -> c
    boolean empty -> a
    void <init>(java.util.List) -> <init>
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.CartesianTwoProductInfiniteIteratorList -> fh:
    java.util.Iterator compit0 -> a
    java.util.Iterator compit1 -> b
    java.util.List fincomps0 -> a
    java.util.List fincomps1 -> b
    java.util.Iterator fincompit0 -> c
    java.util.Iterator fincompit1 -> d
    java.util.List current -> c
    boolean empty -> a
    long level -> a
    void <init>(java.lang.Iterable,java.lang.Iterable) -> <init>
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.KsubSet -> fi:
    java.util.List set -> a
    int k -> a
    void <init>(java.util.List,int) -> <init>
    java.util.Iterator iterator() -> iterator
edu.jas.util.KsubSetIterator -> fj:
    java.util.List set -> a
    int k -> a
    java.util.List rest -> b
    java.lang.Object current -> a
    java.util.Iterator recIter -> a
    java.util.Iterator iter -> b
    void <init>(java.util.List,int) -> <init>
    boolean hasNext() -> hasNext
    java.util.List next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.LongIterable -> fk:
    boolean nonNegative -> a
    long upperBound -> a
    void <init>() -> <init>
    java.util.Iterator iterator() -> iterator
edu.jas.util.LongIterator -> fl:
    long current -> a
    boolean empty -> a
    boolean nonNegative -> b
    long upperBound -> b
    void <init>() -> <init>
    void <init>(boolean,long) -> <init>
    boolean hasNext() -> hasNext
    java.lang.Long next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.OneSubSetIterator -> fm:
    java.util.List set -> a
    java.util.Iterator iter -> a
    void <init>(java.util.List) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.util.ZeroSubSetIterator -> fn:
    boolean hasNext -> a
    void <init>() -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
edu.jas.vector.BasicLinAlg -> edu.jas.vector.BasicLinAlg:
    org.apache.log4j.Logger logger -> a
    void <init>() -> <init>
    edu.jas.structure.RingElem scalarProduct(java.util.List,java.util.List) -> scalarProduct
    java.util.List leftScalarProduct(java.util.List,java.util.List) -> leftScalarProduct
    java.util.List rightScalarProduct(java.util.List,java.util.List) -> rightScalarProduct
    java.util.List vectorAdd(java.util.List,java.util.List) -> vectorAdd
    boolean isZero(java.util.List) -> isZero
    java.util.List scalarProduct(edu.jas.structure.RingElem,java.util.List) -> scalarProduct
    java.util.List scalarProduct(java.util.List,edu.jas.structure.RingElem) -> scalarProduct
    void <clinit>() -> <clinit>
edu.jas.vector.GenVector -> edu.jas.vector.GenVector:
    org.apache.log4j.Logger logger -> a
    edu.jas.vector.GenVectorModul modul -> modul
    java.util.List val -> val
    void <init>(edu.jas.vector.GenVectorModul) -> <init>
    void <init>(edu.jas.vector.GenVectorModul,java.util.List) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    edu.jas.vector.GenVectorModul factory() -> factory
    edu.jas.vector.GenVector copy() -> copy
    boolean isZERO() -> isZERO
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(edu.jas.vector.GenVector) -> compareTo
    int signum() -> signum
    edu.jas.vector.GenVector sum(edu.jas.vector.GenVector) -> sum
    edu.jas.vector.GenVector subtract(edu.jas.vector.GenVector) -> subtract
    edu.jas.vector.GenVector negate() -> negate
    edu.jas.vector.GenVector abs() -> abs
    edu.jas.vector.GenVector scalarMultiply(edu.jas.structure.RingElem) -> scalarMultiply
    edu.jas.vector.GenVector leftScalarMultiply(edu.jas.structure.RingElem) -> leftScalarMultiply
    edu.jas.vector.GenVector linearCombination(edu.jas.structure.RingElem,edu.jas.vector.GenVector,edu.jas.structure.RingElem) -> linearCombination
    edu.jas.vector.GenVector linearCombination(edu.jas.vector.GenVector,edu.jas.structure.RingElem) -> linearCombination
    edu.jas.vector.GenVector linearCombination(edu.jas.structure.RingElem,edu.jas.vector.GenVector) -> linearCombination
    edu.jas.vector.GenVector leftLinearCombination(edu.jas.structure.RingElem,edu.jas.structure.RingElem,edu.jas.vector.GenVector) -> leftLinearCombination
    edu.jas.structure.RingElem scalarProduct(edu.jas.vector.GenVector) -> scalarProduct
    edu.jas.vector.GenVector scalarProduct(java.util.List) -> scalarProduct
    edu.jas.vector.GenVector rightScalarProduct(java.util.List) -> rightScalarProduct
    edu.jas.structure.ModulElem scalarProduct(java.util.List) -> scalarProduct
    edu.jas.structure.RingElem scalarProduct(edu.jas.structure.ModulElem) -> scalarProduct
    edu.jas.structure.ModulElem linearCombination(edu.jas.structure.ModulElem,edu.jas.structure.RingElem) -> linearCombination
    edu.jas.structure.ModulElem linearCombination(edu.jas.structure.RingElem,edu.jas.structure.ModulElem,edu.jas.structure.RingElem) -> linearCombination
    edu.jas.structure.ModulElem scalarMultiply(edu.jas.structure.RingElem) -> scalarMultiply
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    edu.jas.structure.ElemFactory factory() -> factory
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
edu.jas.vector.GenVectorModul -> edu.jas.vector.GenVectorModul:
    org.apache.log4j.Logger logger -> a
    edu.jas.structure.RingFactory coFac -> coFac
    int cols -> cols
    edu.jas.vector.GenVector ZERO -> ZERO
    java.util.List BASIS -> BASIS
    java.util.Random random -> a
    float DEFAULT_DENSITY -> DEFAULT_DENSITY
    float density -> density
    void <init>(edu.jas.structure.RingFactory,int) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    edu.jas.vector.GenVector getZERO() -> getZERO
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    edu.jas.vector.GenVector fromInteger(long) -> fromInteger
    edu.jas.vector.GenVector fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.vector.GenVector fromList(java.util.List) -> fromList
    edu.jas.vector.GenVector random(int) -> random
    edu.jas.vector.GenVector random(int,float) -> random
    edu.jas.vector.GenVector random(int,java.util.Random) -> random
    edu.jas.vector.GenVector random(int,float,java.util.Random) -> random
    edu.jas.vector.GenVector copy(edu.jas.vector.GenVector) -> copy
    edu.jas.vector.GenVector parse(java.lang.String) -> parse
    edu.jas.vector.GenVector parse(java.io.Reader) -> parse
    edu.jas.structure.ModulElem random(int,float) -> random
    edu.jas.structure.ModulElem fromList(java.util.List) -> fromList
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    void <clinit>() -> <clinit>
org.apache.commons.math3.Field -> org.apache.commons.math3.Field:
    java.lang.Object getZero() -> getZero
    java.lang.Object getOne() -> getOne
    java.lang.Class getRuntimeClass() -> getRuntimeClass
org.apache.commons.math3.FieldElement -> org.apache.commons.math3.FieldElement:
    java.lang.Object add(java.lang.Object) -> add
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object negate() -> negate
    java.lang.Object multiply(int) -> multiply
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object reciprocal() -> reciprocal
    org.apache.commons.math3.Field getField() -> getField
org.apache.commons.math3.RealFieldElement -> org.apache.commons.math3.RealFieldElement:
    double getReal() -> getReal
    java.lang.Object add(double) -> add
    java.lang.Object subtract(double) -> subtract
    java.lang.Object multiply(double) -> multiply
    java.lang.Object divide(double) -> divide
    java.lang.Object remainder(double) -> remainder
    java.lang.Object remainder(java.lang.Object) -> remainder
    java.lang.Object abs() -> abs
    java.lang.Object ceil() -> ceil
    java.lang.Object floor() -> floor
    java.lang.Object rint() -> rint
    long round() -> round
    java.lang.Object signum() -> signum
    java.lang.Object copySign(java.lang.Object) -> copySign
    java.lang.Object copySign(double) -> copySign
    java.lang.Object scalb(int) -> scalb
    java.lang.Object hypot(java.lang.Object) -> hypot
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object sqrt() -> sqrt
    java.lang.Object cbrt() -> cbrt
    java.lang.Object rootN(int) -> rootN
    java.lang.Object pow(double) -> pow
    java.lang.Object pow(int) -> pow
    java.lang.Object pow(java.lang.Object) -> pow
    java.lang.Object exp() -> exp
    java.lang.Object expm1() -> expm1
    java.lang.Object log() -> log
    java.lang.Object log1p() -> log1p
    java.lang.Object cos() -> cos
    java.lang.Object sin() -> sin
    java.lang.Object tan() -> tan
    java.lang.Object acos() -> acos
    java.lang.Object asin() -> asin
    java.lang.Object atan() -> atan
    java.lang.Object atan2(java.lang.Object) -> atan2
    java.lang.Object cosh() -> cosh
    java.lang.Object sinh() -> sinh
    java.lang.Object tanh() -> tanh
    java.lang.Object acosh() -> acosh
    java.lang.Object asinh() -> asinh
    java.lang.Object atanh() -> atanh
    java.lang.Object linearCombination(java.lang.Object[],java.lang.Object[]) -> linearCombination
    java.lang.Object linearCombination(double[],java.lang.Object[]) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
org.apache.commons.math3.analysis.BivariateFunction -> fo:
    double value(double,double) -> a
org.apache.commons.math3.analysis.DifferentiableUnivariateFunction -> fp:
org.apache.commons.math3.analysis.FunctionUtils$13 -> fq:
    org.apache.commons.math3.analysis.BivariateFunction val$f -> a
    double val$fixed -> a
    void <init>(org.apache.commons.math3.analysis.BivariateFunction,double) -> <init>
    double value(double) -> value
org.apache.commons.math3.analysis.MultivariateMatrixFunction -> fr:
    double[][] value(double[]) -> a
org.apache.commons.math3.analysis.MultivariateVectorFunction -> fs:
    double[] value(double[]) -> a
org.apache.commons.math3.analysis.ParametricUnivariateFunction -> ft:
    double value(double,double[]) -> a
    double[] gradient(double,double[]) -> a
    void <init>() -> <init>
org.apache.commons.math3.analysis.UnivariateFunction -> fu:
    double value(double) -> value
org.apache.commons.math3.analysis.differentiation.DSCompiler -> fv:
    java.util.concurrent.atomic.AtomicReference compilers -> a
    int parameters -> a
    int order -> b
    int[][] sizes -> a
    int[][] derivativesIndirection -> b
    int[] lowerIndirection -> a
    int[][][] multIndirection -> a
    int[][][] compIndirection -> b
    void <init>(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> <init>
    org.apache.commons.math3.analysis.differentiation.DSCompiler getCompiler(int,int) -> a
    int[][] compileSizes(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[][] compileDerivativesIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[] compileLowerIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    int[][][] compileMultiplicationIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler,int[]) -> a
    int[][][] compileCompositionIndirection(int,int,org.apache.commons.math3.analysis.differentiation.DSCompiler,org.apache.commons.math3.analysis.differentiation.DSCompiler,int[][],int[][]) -> a
    int getPartialDerivativeIndex(int,int,int[][],int[]) -> a
    int convertIndex(int,int,int[][],int,int,int[][]) -> a
    int getSize() -> a
    void add(double[],int,double[],int,double[],int) -> a
    void subtract(double[],int,double[],int,double[],int) -> b
    void multiply(double[],int,double[],int,double[],int) -> c
    void divide$380619bb(double[],int,double[],double[],int) -> a
    void pow(double[],int,int,double[],int) -> a
    void rootN(double[],int,int,double[],int) -> b
    void exp(double[],int,double[],int) -> a
    void log(double[],int,double[],int) -> b
    void atan(double[],int,double[],int) -> c
    void compose(double[],int,double[],double[],int) -> b
    double taylor(double[],int,double[]) -> a
    void checkCompatibility(org.apache.commons.math3.analysis.differentiation.DSCompiler) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.analysis.differentiation.DerivativeStructure -> org.apache.commons.math3.analysis.differentiation.DerivativeStructure:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.analysis.differentiation.DSCompiler compiler -> a
    double[] data -> data
    void <init>(org.apache.commons.math3.analysis.differentiation.DSCompiler) -> <init>
    void <init>(int,int) -> <init>
    void <init>(int,int,double) -> <init>
    void <init>(int,int,int,double) -> <init>
    void <init>(double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> <init>
    void <init>(double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> <init>
    void <init>(double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> <init>
    void <init>(int,int,double[]) -> <init>
    void <init>(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> <init>
    int getFreeParameters() -> getFreeParameters
    int getOrder() -> getOrder
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure createConstant(double) -> createConstant
    double getReal() -> getReal
    double getValue() -> getValue
    double getPartialDerivative(int[]) -> getPartialDerivative
    double[] getAllDerivatives() -> getAllDerivatives
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure add(double) -> add
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure add(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> add
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure subtract(double) -> subtract
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure subtract(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> subtract
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure multiply(int) -> multiply
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure multiply(double) -> multiply
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure multiply(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> multiply
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure divide(double) -> divide
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure divide(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> divide
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure remainder(double) -> remainder
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure remainder(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> remainder
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure negate() -> negate
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure abs() -> abs
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure ceil() -> ceil
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure floor() -> floor
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure rint() -> rint
    long round() -> round
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure signum() -> signum
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure copySign(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> copySign
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure copySign(double) -> copySign
    int getExponent() -> getExponent
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure scalb(int) -> scalb
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure hypot(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> hypot
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure hypot(org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> hypot
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure compose(double[]) -> compose
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure reciprocal() -> reciprocal
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure sqrt() -> sqrt
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure cbrt() -> cbrt
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure rootN(int) -> rootN
    org.apache.commons.math3.Field getField() -> getField
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure pow(double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> pow
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure pow(double) -> pow
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure pow(int) -> pow
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure pow(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> pow
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure exp() -> exp
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure expm1() -> expm1
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure log() -> log
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure log1p() -> log1p
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure log10() -> log10
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure cos() -> cos
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure sin() -> sin
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure tan() -> tan
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure acos() -> acos
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure asin() -> asin
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure atan() -> atan
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure atan2(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> atan2
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure atan2(org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> atan2
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure cosh() -> cosh
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure sinh() -> sinh
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure tanh() -> tanh
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure acosh() -> acosh
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure asinh() -> asinh
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure atanh() -> atanh
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure toDegrees() -> toDegrees
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure toRadians() -> toRadians
    double taylor(double[]) -> taylor
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure linearCombination(org.apache.commons.math3.analysis.differentiation.DerivativeStructure[],org.apache.commons.math3.analysis.differentiation.DerivativeStructure[]) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure linearCombination(double[],org.apache.commons.math3.analysis.differentiation.DerivativeStructure[]) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure linearCombination(org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure linearCombination(double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure linearCombination(org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure linearCombination(double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure linearCombination(org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure linearCombination(double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure,double,org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> linearCombination
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object writeReplace() -> writeReplace
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double[],java.lang.Object[]) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object[],java.lang.Object[]) -> linearCombination
    java.lang.Object atanh() -> atanh
    java.lang.Object asinh() -> asinh
    java.lang.Object acosh() -> acosh
    java.lang.Object tanh() -> tanh
    java.lang.Object sinh() -> sinh
    java.lang.Object cosh() -> cosh
    java.lang.Object atan2(java.lang.Object) -> atan2
    java.lang.Object atan() -> atan
    java.lang.Object asin() -> asin
    java.lang.Object acos() -> acos
    java.lang.Object tan() -> tan
    java.lang.Object sin() -> sin
    java.lang.Object cos() -> cos
    java.lang.Object log1p() -> log1p
    java.lang.Object log() -> log
    java.lang.Object expm1() -> expm1
    java.lang.Object exp() -> exp
    java.lang.Object pow(java.lang.Object) -> pow
    java.lang.Object pow(int) -> pow
    java.lang.Object pow(double) -> pow
    java.lang.Object rootN(int) -> rootN
    java.lang.Object cbrt() -> cbrt
    java.lang.Object sqrt() -> sqrt
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object hypot(java.lang.Object) -> hypot
    java.lang.Object scalb(int) -> scalb
    java.lang.Object copySign(double) -> copySign
    java.lang.Object copySign(java.lang.Object) -> copySign
    java.lang.Object signum() -> signum
    java.lang.Object rint() -> rint
    java.lang.Object floor() -> floor
    java.lang.Object ceil() -> ceil
    java.lang.Object abs() -> abs
    java.lang.Object remainder(java.lang.Object) -> remainder
    java.lang.Object remainder(double) -> remainder
    java.lang.Object divide(double) -> divide
    java.lang.Object multiply(double) -> multiply
    java.lang.Object subtract(double) -> subtract
    java.lang.Object add(double) -> add
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    org.apache.commons.math3.analysis.differentiation.DSCompiler access$000(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> access$000
org.apache.commons.math3.analysis.differentiation.DerivativeStructure$1 -> fw:
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure this$0 -> a
    void <init>(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> <init>
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
org.apache.commons.math3.analysis.differentiation.DerivativeStructure$DataTransferObject -> org.apache.commons.math3.analysis.differentiation.DerivativeStructure$DataTransferObject:
    long serialVersionUID -> serialVersionUID
    int variables -> variables
    int order -> order
    double[] data -> data
    void <init>(int,int,double[]) -> <init>
    java.lang.Object readResolve() -> readResolve
org.apache.commons.math3.analysis.differentiation.SparseGradient -> org.apache.commons.math3.analysis.differentiation.SparseGradient:
    long serialVersionUID -> serialVersionUID
    double value -> value
    java.util.Map derivatives -> derivatives
    void <init>(double,java.util.Map) -> <init>
    void <init>(double,double,java.util.Map) -> <init>
    org.apache.commons.math3.analysis.differentiation.SparseGradient createConstant(double) -> createConstant
    org.apache.commons.math3.analysis.differentiation.SparseGradient createVariable(int,double) -> createVariable
    int numVars() -> numVars
    double getDerivative(int) -> getDerivative
    double getValue() -> getValue
    double getReal() -> getReal
    org.apache.commons.math3.analysis.differentiation.SparseGradient add(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> add
    void addInPlace(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> addInPlace
    org.apache.commons.math3.analysis.differentiation.SparseGradient add(double) -> add
    org.apache.commons.math3.analysis.differentiation.SparseGradient subtract(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> subtract
    org.apache.commons.math3.analysis.differentiation.SparseGradient subtract(double) -> subtract
    org.apache.commons.math3.analysis.differentiation.SparseGradient multiply(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> multiply
    void multiplyInPlace(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> multiplyInPlace
    org.apache.commons.math3.analysis.differentiation.SparseGradient multiply(double) -> multiply
    org.apache.commons.math3.analysis.differentiation.SparseGradient multiply(int) -> multiply
    org.apache.commons.math3.analysis.differentiation.SparseGradient divide(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> divide
    org.apache.commons.math3.analysis.differentiation.SparseGradient divide(double) -> divide
    org.apache.commons.math3.analysis.differentiation.SparseGradient negate() -> negate
    org.apache.commons.math3.Field getField() -> getField
    org.apache.commons.math3.analysis.differentiation.SparseGradient remainder(double) -> remainder
    org.apache.commons.math3.analysis.differentiation.SparseGradient remainder(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> remainder
    org.apache.commons.math3.analysis.differentiation.SparseGradient abs() -> abs
    org.apache.commons.math3.analysis.differentiation.SparseGradient ceil() -> ceil
    org.apache.commons.math3.analysis.differentiation.SparseGradient floor() -> floor
    org.apache.commons.math3.analysis.differentiation.SparseGradient rint() -> rint
    long round() -> round
    org.apache.commons.math3.analysis.differentiation.SparseGradient signum() -> signum
    org.apache.commons.math3.analysis.differentiation.SparseGradient copySign(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> copySign
    org.apache.commons.math3.analysis.differentiation.SparseGradient copySign(double) -> copySign
    org.apache.commons.math3.analysis.differentiation.SparseGradient scalb(int) -> scalb
    org.apache.commons.math3.analysis.differentiation.SparseGradient hypot(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> hypot
    org.apache.commons.math3.analysis.differentiation.SparseGradient hypot(org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> hypot
    org.apache.commons.math3.analysis.differentiation.SparseGradient reciprocal() -> reciprocal
    org.apache.commons.math3.analysis.differentiation.SparseGradient sqrt() -> sqrt
    org.apache.commons.math3.analysis.differentiation.SparseGradient cbrt() -> cbrt
    org.apache.commons.math3.analysis.differentiation.SparseGradient rootN(int) -> rootN
    org.apache.commons.math3.analysis.differentiation.SparseGradient pow(double) -> pow
    org.apache.commons.math3.analysis.differentiation.SparseGradient pow(int) -> pow
    org.apache.commons.math3.analysis.differentiation.SparseGradient pow(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> pow
    org.apache.commons.math3.analysis.differentiation.SparseGradient pow(double,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> pow
    org.apache.commons.math3.analysis.differentiation.SparseGradient exp() -> exp
    org.apache.commons.math3.analysis.differentiation.SparseGradient expm1() -> expm1
    org.apache.commons.math3.analysis.differentiation.SparseGradient log() -> log
    org.apache.commons.math3.analysis.differentiation.SparseGradient log10() -> log10
    org.apache.commons.math3.analysis.differentiation.SparseGradient log1p() -> log1p
    org.apache.commons.math3.analysis.differentiation.SparseGradient cos() -> cos
    org.apache.commons.math3.analysis.differentiation.SparseGradient sin() -> sin
    org.apache.commons.math3.analysis.differentiation.SparseGradient tan() -> tan
    org.apache.commons.math3.analysis.differentiation.SparseGradient acos() -> acos
    org.apache.commons.math3.analysis.differentiation.SparseGradient asin() -> asin
    org.apache.commons.math3.analysis.differentiation.SparseGradient atan() -> atan
    org.apache.commons.math3.analysis.differentiation.SparseGradient atan2(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> atan2
    org.apache.commons.math3.analysis.differentiation.SparseGradient atan2(org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> atan2
    org.apache.commons.math3.analysis.differentiation.SparseGradient cosh() -> cosh
    org.apache.commons.math3.analysis.differentiation.SparseGradient sinh() -> sinh
    org.apache.commons.math3.analysis.differentiation.SparseGradient tanh() -> tanh
    org.apache.commons.math3.analysis.differentiation.SparseGradient acosh() -> acosh
    org.apache.commons.math3.analysis.differentiation.SparseGradient asinh() -> asinh
    org.apache.commons.math3.analysis.differentiation.SparseGradient atanh() -> atanh
    org.apache.commons.math3.analysis.differentiation.SparseGradient toDegrees() -> toDegrees
    org.apache.commons.math3.analysis.differentiation.SparseGradient toRadians() -> toRadians
    double taylor(double[]) -> taylor
    org.apache.commons.math3.analysis.differentiation.SparseGradient compose(double,double) -> compose
    org.apache.commons.math3.analysis.differentiation.SparseGradient linearCombination(org.apache.commons.math3.analysis.differentiation.SparseGradient[],org.apache.commons.math3.analysis.differentiation.SparseGradient[]) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.SparseGradient linearCombination(double[],org.apache.commons.math3.analysis.differentiation.SparseGradient[]) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.SparseGradient linearCombination(org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.SparseGradient linearCombination(double,org.apache.commons.math3.analysis.differentiation.SparseGradient,double,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.SparseGradient linearCombination(org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.SparseGradient linearCombination(double,org.apache.commons.math3.analysis.differentiation.SparseGradient,double,org.apache.commons.math3.analysis.differentiation.SparseGradient,double,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.SparseGradient linearCombination(org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> linearCombination
    org.apache.commons.math3.analysis.differentiation.SparseGradient linearCombination(double,org.apache.commons.math3.analysis.differentiation.SparseGradient,double,org.apache.commons.math3.analysis.differentiation.SparseGradient,double,org.apache.commons.math3.analysis.differentiation.SparseGradient,double,org.apache.commons.math3.analysis.differentiation.SparseGradient) -> linearCombination
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double[],java.lang.Object[]) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object[],java.lang.Object[]) -> linearCombination
    java.lang.Object atanh() -> atanh
    java.lang.Object asinh() -> asinh
    java.lang.Object acosh() -> acosh
    java.lang.Object tanh() -> tanh
    java.lang.Object sinh() -> sinh
    java.lang.Object cosh() -> cosh
    java.lang.Object atan2(java.lang.Object) -> atan2
    java.lang.Object atan() -> atan
    java.lang.Object asin() -> asin
    java.lang.Object acos() -> acos
    java.lang.Object tan() -> tan
    java.lang.Object sin() -> sin
    java.lang.Object cos() -> cos
    java.lang.Object log1p() -> log1p
    java.lang.Object log() -> log
    java.lang.Object expm1() -> expm1
    java.lang.Object exp() -> exp
    java.lang.Object pow(java.lang.Object) -> pow
    java.lang.Object pow(int) -> pow
    java.lang.Object pow(double) -> pow
    java.lang.Object rootN(int) -> rootN
    java.lang.Object cbrt() -> cbrt
    java.lang.Object sqrt() -> sqrt
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object hypot(java.lang.Object) -> hypot
    java.lang.Object scalb(int) -> scalb
    java.lang.Object copySign(double) -> copySign
    java.lang.Object copySign(java.lang.Object) -> copySign
    java.lang.Object signum() -> signum
    java.lang.Object rint() -> rint
    java.lang.Object floor() -> floor
    java.lang.Object ceil() -> ceil
    java.lang.Object abs() -> abs
    java.lang.Object remainder(java.lang.Object) -> remainder
    java.lang.Object remainder(double) -> remainder
    java.lang.Object divide(double) -> divide
    java.lang.Object multiply(double) -> multiply
    java.lang.Object subtract(double) -> subtract
    java.lang.Object add(double) -> add
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
org.apache.commons.math3.analysis.differentiation.SparseGradient$1 -> fx:
    void <init>(org.apache.commons.math3.analysis.differentiation.SparseGradient) -> <init>
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
org.apache.commons.math3.analysis.function.Add -> fy:
    void <init>() -> <init>
    double value(double,double) -> a
org.apache.commons.math3.analysis.function.Divide -> fz:
    void <init>() -> <init>
    double value(double,double) -> a
org.apache.commons.math3.analysis.function.Multiply -> fA:
    void <init>() -> <init>
    double value(double,double) -> a
org.apache.commons.math3.analysis.integration.BaseAbstractUnivariateIntegrator -> fB:
    org.apache.commons.math3.util.Incrementor iterations -> a
    double absoluteAccuracy -> a
    double relativeAccuracy -> b
    int minimalIterationCount -> a
    org.apache.commons.math3.util.Incrementor evaluations -> b
    org.apache.commons.math3.analysis.UnivariateFunction function -> a
    double min -> c
    double max -> d
    void <init>(double,double,int,int) -> <init>
    void <init>(int,int) -> <init>
    double computeObjectiveValue(double) -> a
    double integrate(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.RombergIntegrator -> fC:
    void <init>() -> <init>
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.SimpsonIntegrator -> fD:
    void <init>() -> <init>
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.TrapezoidIntegrator -> fE:
    double s -> e
    void <init>() -> <init>
    double stage(org.apache.commons.math3.analysis.integration.BaseAbstractUnivariateIntegrator,int) -> a
    double doIntegrate() -> a
org.apache.commons.math3.analysis.integration.UnivariateIntegrator -> fF:
    double integrate(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
org.apache.commons.math3.analysis.integration.gauss.BaseRuleFactory -> fG:
    java.util.Map pointsAndWeights -> a
    java.util.Map pointsAndWeightsDouble -> b
    void <init>() -> <init>
    org.apache.commons.math3.util.Pair getRule(int) -> a
    org.apache.commons.math3.util.Pair getRuleInternal(int) -> b
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.GaussIntegrator -> fH:
    double[] points -> a
    double[] weights -> b
    void <init>(double[],double[]) -> <init>
    void <init>(org.apache.commons.math3.util.Pair) -> <init>
org.apache.commons.math3.analysis.integration.gauss.GaussIntegratorFactory -> fI:
    org.apache.commons.math3.analysis.integration.gauss.BaseRuleFactory legendre -> a
    void <init>() -> <init>
    org.apache.commons.math3.util.Pair transform(org.apache.commons.math3.util.Pair,double,double) -> a
org.apache.commons.math3.analysis.integration.gauss.HermiteRuleFactory -> fJ:
    void <init>() -> <init>
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.LegendreHighPrecisionRuleFactory -> fK:
    java.math.MathContext mContext -> a
    java.math.BigDecimal two -> a
    java.math.BigDecimal minusOne -> b
    java.math.BigDecimal oneHalf -> c
    void <init>() -> <init>
    void <init>(java.math.MathContext) -> <init>
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.integration.gauss.LegendreRuleFactory -> fL:
    void <init>() -> <init>
    org.apache.commons.math3.util.Pair computeRule(int) -> c
org.apache.commons.math3.analysis.interpolation.SplineInterpolator -> fM:
    void <init>() -> <init>
    org.apache.commons.math3.analysis.UnivariateFunction interpolate(double[],double[]) -> a
org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator -> fN:
    org.apache.commons.math3.analysis.UnivariateFunction interpolate(double[],double[]) -> a
org.apache.commons.math3.analysis.polynomials.PolynomialFunction -> org.apache.commons.math3.analysis.polynomials.PolynomialFunction:
    long serialVersionUID -> serialVersionUID
    double[] coefficients -> coefficients
    void <init>(double[]) -> <init>
    double value(double) -> value
    int degree() -> degree
    double[] getCoefficients() -> getCoefficients
    double evaluate(double[],double) -> evaluate
    org.apache.commons.math3.analysis.differentiation.DerivativeStructure value(org.apache.commons.math3.analysis.differentiation.DerivativeStructure) -> value
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction add(org.apache.commons.math3.analysis.polynomials.PolynomialFunction) -> add
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction subtract(org.apache.commons.math3.analysis.polynomials.PolynomialFunction) -> subtract
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction negate() -> negate
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction multiply(org.apache.commons.math3.analysis.polynomials.PolynomialFunction) -> multiply
    double[] differentiate(double[]) -> differentiate
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction polynomialDerivative() -> polynomialDerivative
    org.apache.commons.math3.analysis.UnivariateFunction derivative() -> derivative
    java.lang.String toString() -> toString
    java.lang.String toString(double) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction -> fO:
    double[] knots -> a
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction[] polynomials -> a
    int n -> a
    void <init>(double[],org.apache.commons.math3.analysis.polynomials.PolynomialFunction[]) -> <init>
    double value(double) -> value
org.apache.commons.math3.analysis.solvers.AbstractPolynomialSolver -> fP:
    org.apache.commons.math3.analysis.polynomials.PolynomialFunction polynomialFunction -> a
    void <init>(double) -> <init>
    void setup(int,org.apache.commons.math3.analysis.polynomials.PolynomialFunction,double,double,double) -> a
    void setup(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver -> fQ:
    void <init>(double) -> <init>
org.apache.commons.math3.analysis.solvers.AllowedSolution -> org.apache.commons.math3.analysis.solvers.AllowedSolution:
    org.apache.commons.math3.analysis.solvers.AllowedSolution ANY_SIDE -> ANY_SIDE
    org.apache.commons.math3.analysis.solvers.AllowedSolution LEFT_SIDE -> LEFT_SIDE
    org.apache.commons.math3.analysis.solvers.AllowedSolution RIGHT_SIDE -> RIGHT_SIDE
    org.apache.commons.math3.analysis.solvers.AllowedSolution BELOW_SIDE -> BELOW_SIDE
    org.apache.commons.math3.analysis.solvers.AllowedSolution ABOVE_SIDE -> ABOVE_SIDE
    org.apache.commons.math3.analysis.solvers.AllowedSolution[] $VALUES -> a
    org.apache.commons.math3.analysis.solvers.AllowedSolution[] values() -> values
    org.apache.commons.math3.analysis.solvers.AllowedSolution valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver -> fR:
    double functionValueAccuracy -> a
    double absoluteAccuracy -> b
    double relativeAccuracy -> c
    org.apache.commons.math3.util.Incrementor evaluations -> a
    double searchMin -> d
    double searchMax -> e
    double searchStart -> f
    org.apache.commons.math3.analysis.UnivariateFunction function -> a
    void <init>(double) -> <init>
    void <init>(double,double,double) -> <init>
    double computeObjectiveValue(double) -> a
    void setup(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double) -> a
    double doSolve() -> a
    boolean isSequence(double,double,double) -> a
    void verifySequence(double,double,double) -> a
    void verifyBracketing(double,double) -> a
    void incrementEvaluationCount() -> a
org.apache.commons.math3.analysis.solvers.BaseSecantSolver -> org.apache.commons.math3.analysis.solvers.BaseSecantSolver:
    org.apache.commons.math3.analysis.solvers.AllowedSolution allowed -> a
    org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method method -> a
    void <init>(double,org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method) -> <init>
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.BaseSecantSolver$1 -> fS:
    int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$BaseSecantSolver$Method -> a
    int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$AllowedSolution -> b
    void <clinit>() -> <clinit>
org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method -> org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method:
    org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method REGULA_FALSI -> REGULA_FALSI
    org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method ILLINOIS -> ILLINOIS
    org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method PEGASUS -> PEGASUS
    org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method[] $VALUES -> a
    org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method[] values() -> values
    org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver -> fT:
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
org.apache.commons.math3.analysis.solvers.BisectionSolver -> fU:
    void <init>() -> <init>
    void <init>(double) -> <init>
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.BrentSolver -> fV:
    void <init>() -> <init>
    void <init>(double) -> <init>
    double doSolve() -> a
    double brent(double,double,double,double) -> a
org.apache.commons.math3.analysis.solvers.IllinoisSolver -> fW:
    void <init>() -> <init>
org.apache.commons.math3.analysis.solvers.LaguerreSolver -> fX:
    org.apache.commons.math3.analysis.solvers.LaguerreSolver$ComplexSolver complexSolver -> a
    void <init>() -> <init>
    void <init>(double) -> <init>
    double doSolve() -> a
    double laguerre$441f079d(double,double) -> a
    org.apache.commons.math3.complex.Complex[] solveAllComplex(double[],double) -> a
org.apache.commons.math3.analysis.solvers.LaguerreSolver$ComplexSolver -> fY:
    org.apache.commons.math3.analysis.solvers.LaguerreSolver this$0 -> a
    void <init>(org.apache.commons.math3.analysis.solvers.LaguerreSolver) -> <init>
    boolean isRoot(double,double,org.apache.commons.math3.complex.Complex) -> a
    org.apache.commons.math3.complex.Complex[] solveAll(org.apache.commons.math3.complex.Complex[],org.apache.commons.math3.complex.Complex) -> a
    org.apache.commons.math3.complex.Complex solve(org.apache.commons.math3.complex.Complex[],org.apache.commons.math3.complex.Complex) -> a
    void <init>(org.apache.commons.math3.analysis.solvers.LaguerreSolver,byte) -> <init>
org.apache.commons.math3.analysis.solvers.MullerSolver -> fZ:
    void <init>() -> <init>
    void <init>(double) -> <init>
    double doSolve() -> a
    double solve(double,double,double,double) -> a
org.apache.commons.math3.analysis.solvers.PegasusSolver -> ga:
    void <init>() -> <init>
org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver -> gb:
    void <init>() -> <init>
org.apache.commons.math3.analysis.solvers.RiddersSolver -> gc:
    void <init>() -> <init>
    void <init>(double) -> <init>
    double doSolve() -> a
org.apache.commons.math3.analysis.solvers.SecantSolver -> gd:
    void <init>() -> <init>
    double doSolve() -> a
org.apache.commons.math3.complex.Complex -> org.apache.commons.math3.complex.Complex:
    org.apache.commons.math3.complex.Complex I -> I
    org.apache.commons.math3.complex.Complex NaN -> NaN
    org.apache.commons.math3.complex.Complex INF -> INF
    org.apache.commons.math3.complex.Complex ONE -> ONE
    org.apache.commons.math3.complex.Complex ZERO -> ZERO
    long serialVersionUID -> serialVersionUID
    double imaginary -> imaginary
    double real -> real
    boolean isNaN -> a
    boolean isInfinite -> b
    void <init>(double) -> <init>
    void <init>(double,double) -> <init>
    double abs() -> abs
    org.apache.commons.math3.complex.Complex add(org.apache.commons.math3.complex.Complex) -> add
    org.apache.commons.math3.complex.Complex add(double) -> add
    org.apache.commons.math3.complex.Complex conjugate() -> conjugate
    org.apache.commons.math3.complex.Complex divide(org.apache.commons.math3.complex.Complex) -> divide
    org.apache.commons.math3.complex.Complex divide(double) -> divide
    org.apache.commons.math3.complex.Complex reciprocal() -> reciprocal
    boolean equals(java.lang.Object) -> equals
    boolean equals(org.apache.commons.math3.complex.Complex,org.apache.commons.math3.complex.Complex,int) -> equals
    boolean equals(org.apache.commons.math3.complex.Complex,org.apache.commons.math3.complex.Complex) -> equals
    boolean equals(org.apache.commons.math3.complex.Complex,org.apache.commons.math3.complex.Complex,double) -> equals
    boolean equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex,org.apache.commons.math3.complex.Complex,double) -> equalsWithRelativeTolerance
    int hashCode() -> hashCode
    double getImaginary() -> getImaginary
    double getReal() -> getReal
    boolean isNaN() -> isNaN
    boolean isInfinite() -> isInfinite
    org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex) -> multiply
    org.apache.commons.math3.complex.Complex multiply(int) -> multiply
    org.apache.commons.math3.complex.Complex multiply(double) -> multiply
    org.apache.commons.math3.complex.Complex negate() -> negate
    org.apache.commons.math3.complex.Complex subtract(org.apache.commons.math3.complex.Complex) -> subtract
    org.apache.commons.math3.complex.Complex subtract(double) -> subtract
    org.apache.commons.math3.complex.Complex acos() -> acos
    org.apache.commons.math3.complex.Complex asin() -> asin
    org.apache.commons.math3.complex.Complex atan() -> atan
    org.apache.commons.math3.complex.Complex cos() -> cos
    org.apache.commons.math3.complex.Complex cosh() -> cosh
    org.apache.commons.math3.complex.Complex exp() -> exp
    org.apache.commons.math3.complex.Complex log() -> log
    org.apache.commons.math3.complex.Complex pow(org.apache.commons.math3.complex.Complex) -> pow
    org.apache.commons.math3.complex.Complex pow(double) -> pow
    org.apache.commons.math3.complex.Complex sin() -> sin
    org.apache.commons.math3.complex.Complex sinh() -> sinh
    org.apache.commons.math3.complex.Complex sqrt() -> sqrt
    org.apache.commons.math3.complex.Complex sqrt1z() -> sqrt1z
    org.apache.commons.math3.complex.Complex tan() -> tan
    org.apache.commons.math3.complex.Complex tanh() -> tanh
    double getArgument() -> getArgument
    java.util.List nthRoot(int) -> nthRoot
    org.apache.commons.math3.complex.Complex createComplex(double,double) -> createComplex
    org.apache.commons.math3.complex.Complex valueOf(double,double) -> valueOf
    org.apache.commons.math3.complex.Complex valueOf(double) -> valueOf
    java.lang.Object readResolve() -> readResolve
    org.apache.commons.math3.complex.ComplexField getField() -> getField
    java.lang.String toString() -> toString
    org.apache.commons.math3.Field getField() -> getField
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    void <clinit>() -> <clinit>
org.apache.commons.math3.complex.ComplexField -> org.apache.commons.math3.complex.ComplexField:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    org.apache.commons.math3.complex.ComplexField getInstance() -> getInstance
    org.apache.commons.math3.complex.Complex getOne() -> getOne
    org.apache.commons.math3.complex.Complex getZero() -> getZero
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    java.lang.Object readResolve() -> readResolve
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
    void <init>(cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
org.apache.commons.math3.complex.ComplexField$LazyHolder -> ge:
    org.apache.commons.math3.complex.ComplexField INSTANCE -> a
    org.apache.commons.math3.complex.ComplexField access$000() -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.dfp.Dfp -> org.apache.commons.math3.dfp.Dfp:
    int RADIX -> RADIX
    int MIN_EXP -> MIN_EXP
    int MAX_EXP -> MAX_EXP
    int ERR_SCALE -> ERR_SCALE
    byte FINITE -> FINITE
    byte INFINITE -> INFINITE
    byte SNAN -> SNAN
    byte QNAN -> QNAN
    int[] mant -> mant
    byte sign -> sign
    int exp -> exp
    byte nans -> nans
    org.apache.commons.math3.dfp.DfpField field -> a
    void <init>(org.apache.commons.math3.dfp.DfpField) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,byte) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,int) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,long) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,double) -> <init>
    void <init>(org.apache.commons.math3.dfp.Dfp) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,java.lang.String) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,byte,byte) -> <init>
    org.apache.commons.math3.dfp.Dfp newInstance() -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(byte) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(int) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(long) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(double) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(org.apache.commons.math3.dfp.Dfp) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(java.lang.String) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(byte,byte) -> newInstance
    org.apache.commons.math3.dfp.DfpField getField() -> getField
    int getRadixDigits() -> getRadixDigits
    org.apache.commons.math3.dfp.Dfp getZero() -> getZero
    org.apache.commons.math3.dfp.Dfp getOne() -> getOne
    org.apache.commons.math3.dfp.Dfp getTwo() -> getTwo
    void shiftLeft() -> shiftLeft
    void shiftRight() -> shiftRight
    int align(int) -> align
    boolean lessThan(org.apache.commons.math3.dfp.Dfp) -> lessThan
    boolean greaterThan(org.apache.commons.math3.dfp.Dfp) -> greaterThan
    boolean negativeOrNull() -> negativeOrNull
    boolean strictlyNegative() -> strictlyNegative
    boolean positiveOrNull() -> positiveOrNull
    boolean strictlyPositive() -> strictlyPositive
    org.apache.commons.math3.dfp.Dfp abs() -> abs
    boolean isInfinite() -> isInfinite
    boolean isNaN() -> isNaN
    boolean isZero() -> isZero
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean unequal(org.apache.commons.math3.dfp.Dfp) -> unequal
    int compare(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> a
    org.apache.commons.math3.dfp.Dfp rint() -> rint
    org.apache.commons.math3.dfp.Dfp floor() -> floor
    org.apache.commons.math3.dfp.Dfp ceil() -> ceil
    org.apache.commons.math3.dfp.Dfp remainder(org.apache.commons.math3.dfp.Dfp) -> remainder
    org.apache.commons.math3.dfp.Dfp trunc(org.apache.commons.math3.dfp.DfpField$RoundingMode) -> trunc
    int intValue() -> intValue
    int log10K() -> log10K
    org.apache.commons.math3.dfp.Dfp power10K(int) -> power10K
    int intLog10() -> intLog10
    org.apache.commons.math3.dfp.Dfp power10(int) -> power10
    int complement(int) -> complement
    org.apache.commons.math3.dfp.Dfp add(org.apache.commons.math3.dfp.Dfp) -> add
    org.apache.commons.math3.dfp.Dfp negate() -> negate
    org.apache.commons.math3.dfp.Dfp subtract(org.apache.commons.math3.dfp.Dfp) -> subtract
    int round(int) -> round
    org.apache.commons.math3.dfp.Dfp multiply(org.apache.commons.math3.dfp.Dfp) -> multiply
    org.apache.commons.math3.dfp.Dfp multiply(int) -> multiply
    org.apache.commons.math3.dfp.Dfp divide(org.apache.commons.math3.dfp.Dfp) -> divide
    org.apache.commons.math3.dfp.Dfp divide(int) -> divide
    org.apache.commons.math3.dfp.Dfp reciprocal() -> reciprocal
    org.apache.commons.math3.dfp.Dfp sqrt() -> sqrt
    java.lang.String toString() -> toString
    java.lang.String dfp2sci() -> dfp2sci
    java.lang.String dfp2string() -> dfp2string
    org.apache.commons.math3.dfp.Dfp dotrap(int,java.lang.String,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> dotrap
    org.apache.commons.math3.dfp.Dfp trap(int,java.lang.String,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> trap
    int classify() -> classify
    org.apache.commons.math3.dfp.Dfp copysign(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> copysign
    org.apache.commons.math3.dfp.Dfp nextAfter(org.apache.commons.math3.dfp.Dfp) -> nextAfter
    double toDouble() -> toDouble
    double[] toSplitDouble() -> toSplitDouble
    double getReal() -> getReal
    org.apache.commons.math3.dfp.Dfp add(double) -> add
    org.apache.commons.math3.dfp.Dfp subtract(double) -> subtract
    org.apache.commons.math3.dfp.Dfp multiply(double) -> multiply
    org.apache.commons.math3.dfp.Dfp divide(double) -> divide
    org.apache.commons.math3.dfp.Dfp remainder(double) -> remainder
    long round() -> round
    org.apache.commons.math3.dfp.Dfp signum() -> signum
    org.apache.commons.math3.dfp.Dfp copySign(org.apache.commons.math3.dfp.Dfp) -> copySign
    org.apache.commons.math3.dfp.Dfp copySign(double) -> copySign
    org.apache.commons.math3.dfp.Dfp scalb(int) -> scalb
    org.apache.commons.math3.dfp.Dfp hypot(org.apache.commons.math3.dfp.Dfp) -> hypot
    org.apache.commons.math3.dfp.Dfp cbrt() -> cbrt
    org.apache.commons.math3.dfp.Dfp rootN(int) -> rootN
    org.apache.commons.math3.dfp.Dfp pow(double) -> pow
    org.apache.commons.math3.dfp.Dfp pow(int) -> pow
    org.apache.commons.math3.dfp.Dfp pow(org.apache.commons.math3.dfp.Dfp) -> pow
    org.apache.commons.math3.dfp.Dfp exp() -> exp
    org.apache.commons.math3.dfp.Dfp expm1() -> expm1
    org.apache.commons.math3.dfp.Dfp log() -> log
    org.apache.commons.math3.dfp.Dfp log1p() -> log1p
    int log10() -> log10
    org.apache.commons.math3.dfp.Dfp cos() -> cos
    org.apache.commons.math3.dfp.Dfp sin() -> sin
    org.apache.commons.math3.dfp.Dfp tan() -> tan
    org.apache.commons.math3.dfp.Dfp acos() -> acos
    org.apache.commons.math3.dfp.Dfp asin() -> asin
    org.apache.commons.math3.dfp.Dfp atan() -> atan
    org.apache.commons.math3.dfp.Dfp atan2(org.apache.commons.math3.dfp.Dfp) -> atan2
    org.apache.commons.math3.dfp.Dfp cosh() -> cosh
    org.apache.commons.math3.dfp.Dfp sinh() -> sinh
    org.apache.commons.math3.dfp.Dfp tanh() -> tanh
    org.apache.commons.math3.dfp.Dfp acosh() -> acosh
    org.apache.commons.math3.dfp.Dfp asinh() -> asinh
    org.apache.commons.math3.dfp.Dfp atanh() -> atanh
    org.apache.commons.math3.dfp.Dfp linearCombination(org.apache.commons.math3.dfp.Dfp[],org.apache.commons.math3.dfp.Dfp[]) -> linearCombination
    org.apache.commons.math3.dfp.Dfp linearCombination(double[],org.apache.commons.math3.dfp.Dfp[]) -> linearCombination
    org.apache.commons.math3.dfp.Dfp linearCombination(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> linearCombination
    org.apache.commons.math3.dfp.Dfp linearCombination(double,org.apache.commons.math3.dfp.Dfp,double,org.apache.commons.math3.dfp.Dfp) -> linearCombination
    org.apache.commons.math3.dfp.Dfp linearCombination(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> linearCombination
    org.apache.commons.math3.dfp.Dfp linearCombination(double,org.apache.commons.math3.dfp.Dfp,double,org.apache.commons.math3.dfp.Dfp,double,org.apache.commons.math3.dfp.Dfp) -> linearCombination
    org.apache.commons.math3.dfp.Dfp linearCombination(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> linearCombination
    org.apache.commons.math3.dfp.Dfp linearCombination(double,org.apache.commons.math3.dfp.Dfp,double,org.apache.commons.math3.dfp.Dfp,double,org.apache.commons.math3.dfp.Dfp,double,org.apache.commons.math3.dfp.Dfp) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double[],java.lang.Object[]) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object[],java.lang.Object[]) -> linearCombination
    java.lang.Object atanh() -> atanh
    java.lang.Object asinh() -> asinh
    java.lang.Object acosh() -> acosh
    java.lang.Object tanh() -> tanh
    java.lang.Object sinh() -> sinh
    java.lang.Object cosh() -> cosh
    java.lang.Object atan2(java.lang.Object) -> atan2
    java.lang.Object atan() -> atan
    java.lang.Object asin() -> asin
    java.lang.Object acos() -> acos
    java.lang.Object tan() -> tan
    java.lang.Object sin() -> sin
    java.lang.Object cos() -> cos
    java.lang.Object log1p() -> log1p
    java.lang.Object log() -> log
    java.lang.Object expm1() -> expm1
    java.lang.Object exp() -> exp
    java.lang.Object pow(java.lang.Object) -> pow
    java.lang.Object pow(int) -> pow
    java.lang.Object pow(double) -> pow
    java.lang.Object rootN(int) -> rootN
    java.lang.Object cbrt() -> cbrt
    java.lang.Object sqrt() -> sqrt
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object hypot(java.lang.Object) -> hypot
    java.lang.Object scalb(int) -> scalb
    java.lang.Object copySign(double) -> copySign
    java.lang.Object copySign(java.lang.Object) -> copySign
    java.lang.Object signum() -> signum
    java.lang.Object rint() -> rint
    java.lang.Object floor() -> floor
    java.lang.Object ceil() -> ceil
    java.lang.Object abs() -> abs
    java.lang.Object remainder(java.lang.Object) -> remainder
    java.lang.Object remainder(double) -> remainder
    java.lang.Object divide(double) -> divide
    java.lang.Object multiply(double) -> multiply
    java.lang.Object subtract(double) -> subtract
    java.lang.Object add(double) -> add
    org.apache.commons.math3.Field getField() -> getField
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
org.apache.commons.math3.dfp.Dfp$1 -> gf:
    int[] $SwitchMap$org$apache$commons$math3$dfp$DfpField$RoundingMode -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.dfp.DfpDec -> org.apache.commons.math3.dfp.DfpDec:
    void <init>(org.apache.commons.math3.dfp.DfpField) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,byte) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,int) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,long) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,double) -> <init>
    void <init>(org.apache.commons.math3.dfp.Dfp) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,java.lang.String) -> <init>
    void <init>(org.apache.commons.math3.dfp.DfpField,byte,byte) -> <init>
    org.apache.commons.math3.dfp.Dfp newInstance() -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(byte) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(int) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(long) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(double) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(org.apache.commons.math3.dfp.Dfp) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(java.lang.String) -> newInstance
    org.apache.commons.math3.dfp.Dfp newInstance(byte,byte) -> newInstance
    int getDecimalDigits() -> getDecimalDigits
    int round(int) -> round
    org.apache.commons.math3.dfp.Dfp nextAfter(org.apache.commons.math3.dfp.Dfp) -> nextAfter
org.apache.commons.math3.dfp.DfpDec$1 -> gg:
    int[] $SwitchMap$org$apache$commons$math3$dfp$DfpField$RoundingMode -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.dfp.DfpField -> org.apache.commons.math3.dfp.DfpField:
    int FLAG_INVALID -> FLAG_INVALID
    int FLAG_DIV_ZERO -> FLAG_DIV_ZERO
    int FLAG_OVERFLOW -> FLAG_OVERFLOW
    int FLAG_UNDERFLOW -> FLAG_UNDERFLOW
    int FLAG_INEXACT -> FLAG_INEXACT
    java.lang.String sqr2String -> a
    java.lang.String sqr2ReciprocalString -> b
    java.lang.String sqr3String -> c
    java.lang.String sqr3ReciprocalString -> d
    java.lang.String piString -> e
    java.lang.String eString -> f
    java.lang.String ln2String -> g
    java.lang.String ln5String -> h
    java.lang.String ln10String -> i
    int radixDigits -> a
    org.apache.commons.math3.dfp.Dfp zero -> a
    org.apache.commons.math3.dfp.Dfp one -> b
    org.apache.commons.math3.dfp.Dfp two -> c
    org.apache.commons.math3.dfp.Dfp sqr2 -> d
    org.apache.commons.math3.dfp.Dfp[] sqr2Split -> a
    org.apache.commons.math3.dfp.Dfp sqr2Reciprocal -> e
    org.apache.commons.math3.dfp.Dfp sqr3 -> f
    org.apache.commons.math3.dfp.Dfp sqr3Reciprocal -> g
    org.apache.commons.math3.dfp.Dfp pi -> h
    org.apache.commons.math3.dfp.Dfp[] piSplit -> b
    org.apache.commons.math3.dfp.Dfp e -> i
    org.apache.commons.math3.dfp.Dfp[] eSplit -> c
    org.apache.commons.math3.dfp.Dfp ln2 -> j
    org.apache.commons.math3.dfp.Dfp[] ln2Split -> d
    org.apache.commons.math3.dfp.Dfp ln5 -> k
    org.apache.commons.math3.dfp.Dfp[] ln5Split -> e
    org.apache.commons.math3.dfp.Dfp ln10 -> l
    org.apache.commons.math3.dfp.DfpField$RoundingMode rMode -> a
    int ieeeFlags -> b
    void <init>(int) -> <init>
    void <init>(int,boolean) -> <init>
    int getRadixDigits() -> getRadixDigits
    void setRoundingMode(org.apache.commons.math3.dfp.DfpField$RoundingMode) -> setRoundingMode
    org.apache.commons.math3.dfp.DfpField$RoundingMode getRoundingMode() -> getRoundingMode
    int getIEEEFlags() -> getIEEEFlags
    void clearIEEEFlags() -> clearIEEEFlags
    void setIEEEFlags(int) -> setIEEEFlags
    void setIEEEFlagsBits(int) -> setIEEEFlagsBits
    org.apache.commons.math3.dfp.Dfp newDfp() -> newDfp
    org.apache.commons.math3.dfp.Dfp newDfp(byte) -> newDfp
    org.apache.commons.math3.dfp.Dfp newDfp(int) -> newDfp
    org.apache.commons.math3.dfp.Dfp newDfp(long) -> newDfp
    org.apache.commons.math3.dfp.Dfp newDfp(double) -> newDfp
    org.apache.commons.math3.dfp.Dfp newDfp(org.apache.commons.math3.dfp.Dfp) -> newDfp
    org.apache.commons.math3.dfp.Dfp newDfp(java.lang.String) -> newDfp
    org.apache.commons.math3.dfp.Dfp newDfp(byte,byte) -> newDfp
    org.apache.commons.math3.dfp.Dfp getZero() -> getZero
    org.apache.commons.math3.dfp.Dfp getOne() -> getOne
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    org.apache.commons.math3.dfp.Dfp getTwo() -> getTwo
    org.apache.commons.math3.dfp.Dfp getSqr2() -> getSqr2
    org.apache.commons.math3.dfp.Dfp[] getSqr2Split() -> getSqr2Split
    org.apache.commons.math3.dfp.Dfp getSqr2Reciprocal() -> getSqr2Reciprocal
    org.apache.commons.math3.dfp.Dfp getSqr3() -> getSqr3
    org.apache.commons.math3.dfp.Dfp getSqr3Reciprocal() -> getSqr3Reciprocal
    org.apache.commons.math3.dfp.Dfp getPi() -> getPi
    org.apache.commons.math3.dfp.Dfp[] getPiSplit() -> getPiSplit
    org.apache.commons.math3.dfp.Dfp getE() -> getE
    org.apache.commons.math3.dfp.Dfp[] getESplit() -> getESplit
    org.apache.commons.math3.dfp.Dfp getLn2() -> getLn2
    org.apache.commons.math3.dfp.Dfp[] getLn2Split() -> getLn2Split
    org.apache.commons.math3.dfp.Dfp getLn5() -> getLn5
    org.apache.commons.math3.dfp.Dfp[] getLn5Split() -> getLn5Split
    org.apache.commons.math3.dfp.Dfp getLn10() -> getLn10
    org.apache.commons.math3.dfp.Dfp[] split(java.lang.String) -> a
    org.apache.commons.math3.dfp.Dfp computePi(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> a
    org.apache.commons.math3.dfp.Dfp computeExp(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> computeExp
    org.apache.commons.math3.dfp.Dfp computeLn(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> computeLn
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
org.apache.commons.math3.dfp.DfpField$RoundingMode -> org.apache.commons.math3.dfp.DfpField$RoundingMode:
    org.apache.commons.math3.dfp.DfpField$RoundingMode ROUND_DOWN -> ROUND_DOWN
    org.apache.commons.math3.dfp.DfpField$RoundingMode ROUND_UP -> ROUND_UP
    org.apache.commons.math3.dfp.DfpField$RoundingMode ROUND_HALF_UP -> ROUND_HALF_UP
    org.apache.commons.math3.dfp.DfpField$RoundingMode ROUND_HALF_DOWN -> ROUND_HALF_DOWN
    org.apache.commons.math3.dfp.DfpField$RoundingMode ROUND_HALF_EVEN -> ROUND_HALF_EVEN
    org.apache.commons.math3.dfp.DfpField$RoundingMode ROUND_HALF_ODD -> ROUND_HALF_ODD
    org.apache.commons.math3.dfp.DfpField$RoundingMode ROUND_CEIL -> ROUND_CEIL
    org.apache.commons.math3.dfp.DfpField$RoundingMode ROUND_FLOOR -> ROUND_FLOOR
    org.apache.commons.math3.dfp.DfpField$RoundingMode[] $VALUES -> a
    org.apache.commons.math3.dfp.DfpField$RoundingMode[] values() -> values
    org.apache.commons.math3.dfp.DfpField$RoundingMode valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.distribution.AbstractIntegerDistribution -> org.apache.commons.math3.distribution.AbstractIntegerDistribution:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.random.RandomDataImpl randomData -> randomData
    org.apache.commons.math3.random.RandomGenerator random -> random
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator) -> <init>
    double cumulativeProbability(int,int) -> cumulativeProbability
    int inverseCumulativeProbability(double) -> inverseCumulativeProbability
    int solveInverseCumulativeProbability(double,int,int) -> solveInverseCumulativeProbability
    void reseedRandomGenerator(long) -> reseedRandomGenerator
    int sample() -> sample
    int[] sample(int) -> sample
    double checkedCumulativeProbability(int) -> a
    double logProbability(int) -> logProbability
org.apache.commons.math3.distribution.AbstractRealDistribution -> org.apache.commons.math3.distribution.AbstractRealDistribution:
    double SOLVER_DEFAULT_ABSOLUTE_ACCURACY -> SOLVER_DEFAULT_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.random.RandomDataImpl randomData -> randomData
    org.apache.commons.math3.random.RandomGenerator random -> random
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator) -> <init>
    double cumulativeProbability(double,double) -> cumulativeProbability
    double probability(double,double) -> probability
    double inverseCumulativeProbability(double) -> inverseCumulativeProbability
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    void reseedRandomGenerator(long) -> reseedRandomGenerator
    double sample() -> sample
    double[] sample(int) -> sample
    double probability(double) -> probability
    double logDensity(double) -> logDensity
org.apache.commons.math3.distribution.AbstractRealDistribution$1 -> gh:
    double val$p -> a
    org.apache.commons.math3.distribution.AbstractRealDistribution this$0 -> a
    void <init>(org.apache.commons.math3.distribution.AbstractRealDistribution,double) -> <init>
    double value(double) -> value
org.apache.commons.math3.distribution.BetaDistribution -> org.apache.commons.math3.distribution.BetaDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    double alpha -> alpha
    double beta -> beta
    double z -> z
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    void <init>(double,double) -> <init>
    void <init>(double,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double,double) -> <init>
    double getAlpha() -> getAlpha
    double getBeta() -> getBeta
    double density(double) -> density
    double logDensity(double) -> logDensity
    double cumulativeProbability(double) -> cumulativeProbability
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.BinomialDistribution -> org.apache.commons.math3.distribution.BinomialDistribution:
    long serialVersionUID -> serialVersionUID
    int numberOfTrials -> numberOfTrials
    double probabilityOfSuccess -> probabilityOfSuccess
    void <init>(int,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,int,double) -> <init>
    int getNumberOfTrials() -> getNumberOfTrials
    double getProbabilityOfSuccess() -> getProbabilityOfSuccess
    double probability(int) -> probability
    double logProbability(int) -> logProbability
    double cumulativeProbability(int) -> cumulativeProbability
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    int getSupportLowerBound() -> getSupportLowerBound
    int getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.CauchyDistribution -> org.apache.commons.math3.distribution.CauchyDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    double median -> median
    double scale -> scale
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    void <init>() -> <init>
    void <init>(double,double) -> <init>
    void <init>(double,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double,double) -> <init>
    double cumulativeProbability(double) -> cumulativeProbability
    double getMedian() -> getMedian
    double getScale() -> getScale
    double density(double) -> density
    double inverseCumulativeProbability(double) -> inverseCumulativeProbability
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.ChiSquaredDistribution -> org.apache.commons.math3.distribution.ChiSquaredDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.distribution.GammaDistribution gamma -> gamma
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    void <init>(double) -> <init>
    void <init>(double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    double getDegreesOfFreedom() -> getDegreesOfFreedom
    double density(double) -> density
    double logDensity(double) -> logDensity
    double cumulativeProbability(double) -> cumulativeProbability
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.ExponentialDistribution -> org.apache.commons.math3.distribution.ExponentialDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    double[] EXPONENTIAL_SA_QI -> a
    double mean -> mean
    double logMean -> logMean
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    void <init>(double) -> <init>
    void <init>(double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    double getMean() -> getMean
    double density(double) -> density
    double logDensity(double) -> logDensity
    double cumulativeProbability(double) -> cumulativeProbability
    double inverseCumulativeProbability(double) -> inverseCumulativeProbability
    double sample() -> sample
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
    void <clinit>() -> <clinit>
org.apache.commons.math3.distribution.FDistribution -> org.apache.commons.math3.distribution.FDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    double numeratorDegreesOfFreedom -> numeratorDegreesOfFreedom
    double denominatorDegreesOfFreedom -> denominatorDegreesOfFreedom
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    double numericalVariance -> numericalVariance
    boolean numericalVarianceIsCalculated -> numericalVarianceIsCalculated
    void <init>(double,double) -> <init>
    void <init>(double,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double,double) -> <init>
    double density(double) -> density
    double logDensity(double) -> logDensity
    double cumulativeProbability(double) -> cumulativeProbability
    double getNumeratorDegreesOfFreedom() -> getNumeratorDegreesOfFreedom
    double getDenominatorDegreesOfFreedom() -> getDenominatorDegreesOfFreedom
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double calculateNumericalVariance() -> calculateNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.GammaDistribution -> org.apache.commons.math3.distribution.GammaDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    double shape -> shape
    double scale -> scale
    double shiftedShape -> shiftedShape
    double densityPrefactor1 -> densityPrefactor1
    double logDensityPrefactor1 -> logDensityPrefactor1
    double densityPrefactor2 -> densityPrefactor2
    double logDensityPrefactor2 -> logDensityPrefactor2
    double minY -> minY
    double maxLogY -> maxLogY
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    void <init>(double,double) -> <init>
    void <init>(double,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double,double) -> <init>
    double getAlpha() -> getAlpha
    double getShape() -> getShape
    double getBeta() -> getBeta
    double getScale() -> getScale
    double density(double) -> density
    double logDensity(double) -> logDensity
    double cumulativeProbability(double) -> cumulativeProbability
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
    double sample() -> sample
org.apache.commons.math3.distribution.HypergeometricDistribution -> org.apache.commons.math3.distribution.HypergeometricDistribution:
    long serialVersionUID -> serialVersionUID
    int numberOfSuccesses -> numberOfSuccesses
    int populationSize -> populationSize
    int sampleSize -> sampleSize
    double numericalVariance -> numericalVariance
    boolean numericalVarianceIsCalculated -> numericalVarianceIsCalculated
    void <init>(int,int,int) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,int,int,int) -> <init>
    double cumulativeProbability(int) -> cumulativeProbability
    int[] getDomain(int,int,int) -> a
    int getNumberOfSuccesses() -> getNumberOfSuccesses
    int getPopulationSize() -> getPopulationSize
    int getSampleSize() -> getSampleSize
    double probability(int) -> probability
    double logProbability(int) -> logProbability
    double upperCumulativeProbability(int) -> upperCumulativeProbability
    double innerCumulativeProbability(int,int,int) -> a
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double calculateNumericalVariance() -> calculateNumericalVariance
    int getSupportLowerBound() -> getSupportLowerBound
    int getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.IntegerDistribution -> gi:
    double probability(int) -> probability
    double cumulativeProbability(int) -> cumulativeProbability
    int inverseCumulativeProbability(double) -> inverseCumulativeProbability
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    int getSupportLowerBound() -> getSupportLowerBound
    int getSupportUpperBound() -> getSupportUpperBound
org.apache.commons.math3.distribution.NormalDistribution -> org.apache.commons.math3.distribution.NormalDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    double SQRT2 -> a
    double mean -> mean
    double standardDeviation -> standardDeviation
    double logStandardDeviationPlusHalfLog2Pi -> logStandardDeviationPlusHalfLog2Pi
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    void <init>() -> <init>
    void <init>(double,double) -> <init>
    void <init>(double,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double,double) -> <init>
    double getMean() -> getMean
    double getStandardDeviation() -> getStandardDeviation
    double density(double) -> density
    double logDensity(double) -> logDensity
    double cumulativeProbability(double) -> cumulativeProbability
    double inverseCumulativeProbability(double) -> inverseCumulativeProbability
    double cumulativeProbability(double,double) -> cumulativeProbability
    double probability(double,double) -> probability
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
    double sample() -> sample
    void <clinit>() -> <clinit>
org.apache.commons.math3.distribution.PascalDistribution -> org.apache.commons.math3.distribution.PascalDistribution:
    long serialVersionUID -> serialVersionUID
    int numberOfSuccesses -> numberOfSuccesses
    double probabilityOfSuccess -> probabilityOfSuccess
    double logProbabilityOfSuccess -> logProbabilityOfSuccess
    double log1mProbabilityOfSuccess -> log1mProbabilityOfSuccess
    void <init>(int,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,int,double) -> <init>
    int getNumberOfSuccesses() -> getNumberOfSuccesses
    double getProbabilityOfSuccess() -> getProbabilityOfSuccess
    double probability(int) -> probability
    double logProbability(int) -> logProbability
    double cumulativeProbability(int) -> cumulativeProbability
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    int getSupportLowerBound() -> getSupportLowerBound
    int getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.PoissonDistribution -> org.apache.commons.math3.distribution.PoissonDistribution:
    int DEFAULT_MAX_ITERATIONS -> DEFAULT_MAX_ITERATIONS
    double DEFAULT_EPSILON -> DEFAULT_EPSILON
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.distribution.NormalDistribution normal -> normal
    org.apache.commons.math3.distribution.ExponentialDistribution exponential -> exponential
    double mean -> mean
    int maxIterations -> maxIterations
    double epsilon -> epsilon
    void <init>(double) -> <init>
    void <init>(double,double,int) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double,int) -> <init>
    void <init>(double,double) -> <init>
    void <init>(double,int) -> <init>
    double getMean() -> getMean
    double probability(int) -> probability
    double logProbability(int) -> logProbability
    double cumulativeProbability(int) -> cumulativeProbability
    double normalApproximateProbability(int) -> normalApproximateProbability
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    int getSupportLowerBound() -> getSupportLowerBound
    int getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportConnected() -> isSupportConnected
    int sample() -> sample
    long nextPoisson(double) -> a
org.apache.commons.math3.distribution.RealDistribution -> gj:
    double density(double) -> density
    double cumulativeProbability(double) -> cumulativeProbability
    double inverseCumulativeProbability(double) -> inverseCumulativeProbability
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.SaddlePointExpansion -> gk:
    double HALF_LOG_2_PI -> a
    double[] EXACT_STIRLING_ERRORS -> a
    double getStirlingError(double) -> a
    double getDeviancePart(double,double) -> a
    double logBinomialProbability(int,int,double,double) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.distribution.TDistribution -> org.apache.commons.math3.distribution.TDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    double degreesOfFreedom -> degreesOfFreedom
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    double factor -> factor
    void <init>(double) -> <init>
    void <init>(double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    double getDegreesOfFreedom() -> getDegreesOfFreedom
    double density(double) -> density
    double logDensity(double) -> logDensity
    double cumulativeProbability(double) -> cumulativeProbability
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.UniformIntegerDistribution -> org.apache.commons.math3.distribution.UniformIntegerDistribution:
    long serialVersionUID -> serialVersionUID
    int lower -> lower
    int upper -> upper
    void <init>(int,int) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,int,int) -> <init>
    double probability(int) -> probability
    double cumulativeProbability(int) -> cumulativeProbability
    double getNumericalMean() -> getNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    int getSupportLowerBound() -> getSupportLowerBound
    int getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportConnected() -> isSupportConnected
    int sample() -> sample
org.apache.commons.math3.distribution.WeibullDistribution -> org.apache.commons.math3.distribution.WeibullDistribution:
    double DEFAULT_INVERSE_ABSOLUTE_ACCURACY -> DEFAULT_INVERSE_ABSOLUTE_ACCURACY
    long serialVersionUID -> serialVersionUID
    double shape -> shape
    double scale -> scale
    double solverAbsoluteAccuracy -> solverAbsoluteAccuracy
    double numericalMean -> numericalMean
    boolean numericalMeanIsCalculated -> numericalMeanIsCalculated
    double numericalVariance -> numericalVariance
    boolean numericalVarianceIsCalculated -> numericalVarianceIsCalculated
    void <init>(double,double) -> <init>
    void <init>(double,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,double,double,double) -> <init>
    double getShape() -> getShape
    double getScale() -> getScale
    double density(double) -> density
    double logDensity(double) -> logDensity
    double cumulativeProbability(double) -> cumulativeProbability
    double inverseCumulativeProbability(double) -> inverseCumulativeProbability
    double getSolverAbsoluteAccuracy() -> getSolverAbsoluteAccuracy
    double getNumericalMean() -> getNumericalMean
    double calculateNumericalMean() -> calculateNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double calculateNumericalVariance() -> calculateNumericalVariance
    double getSupportLowerBound() -> getSupportLowerBound
    double getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportLowerBoundInclusive() -> isSupportLowerBoundInclusive
    boolean isSupportUpperBoundInclusive() -> isSupportUpperBoundInclusive
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.distribution.ZipfDistribution -> org.apache.commons.math3.distribution.ZipfDistribution:
    long serialVersionUID -> serialVersionUID
    int numberOfElements -> numberOfElements
    double exponent -> exponent
    double numericalMean -> numericalMean
    boolean numericalMeanIsCalculated -> numericalMeanIsCalculated
    double numericalVariance -> numericalVariance
    boolean numericalVarianceIsCalculated -> numericalVarianceIsCalculated
    void <init>(int,double) -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator,int,double) -> <init>
    int getNumberOfElements() -> getNumberOfElements
    double getExponent() -> getExponent
    double probability(int) -> probability
    double logProbability(int) -> logProbability
    double cumulativeProbability(int) -> cumulativeProbability
    double getNumericalMean() -> getNumericalMean
    double calculateNumericalMean() -> calculateNumericalMean
    double getNumericalVariance() -> getNumericalVariance
    double calculateNumericalVariance() -> calculateNumericalVariance
    double generalizedHarmonic(int,double) -> a
    int getSupportLowerBound() -> getSupportLowerBound
    int getSupportUpperBound() -> getSupportUpperBound
    boolean isSupportConnected() -> isSupportConnected
org.apache.commons.math3.exception.ConvergenceException -> org.apache.commons.math3.exception.ConvergenceException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
org.apache.commons.math3.exception.DimensionMismatchException -> org.apache.commons.math3.exception.DimensionMismatchException:
    long serialVersionUID -> serialVersionUID
    int dimension -> dimension
    void <init>(org.apache.commons.math3.exception.util.Localizable,int,int) -> <init>
    void <init>(int,int) -> <init>
    int getDimension() -> getDimension
org.apache.commons.math3.exception.MathArithmeticException -> org.apache.commons.math3.exception.MathArithmeticException:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.exception.util.ExceptionContext context -> context
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
    org.apache.commons.math3.exception.util.ExceptionContext getContext() -> getContext
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathIllegalArgumentException -> org.apache.commons.math3.exception.MathIllegalArgumentException:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.exception.util.ExceptionContext context -> context
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
    org.apache.commons.math3.exception.util.ExceptionContext getContext() -> getContext
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathIllegalNumberException -> org.apache.commons.math3.exception.MathIllegalNumberException:
    java.lang.Integer INTEGER_ZERO -> INTEGER_ZERO
    long serialVersionUID -> serialVersionUID
    java.lang.Number argument -> argument
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Number,java.lang.Object[]) -> <init>
    java.lang.Number getArgument() -> getArgument
    void <clinit>() -> <clinit>
org.apache.commons.math3.exception.MathIllegalStateException -> org.apache.commons.math3.exception.MathIllegalStateException:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.exception.util.ExceptionContext context -> context
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
    void <init>(java.lang.Throwable,org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
    void <init>() -> <init>
    org.apache.commons.math3.exception.util.ExceptionContext getContext() -> getContext
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MathInternalError -> org.apache.commons.math3.exception.MathInternalError:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.Throwable) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
org.apache.commons.math3.exception.MathUnsupportedOperationException -> org.apache.commons.math3.exception.MathUnsupportedOperationException:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.exception.util.ExceptionContext context -> context
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
    org.apache.commons.math3.exception.util.ExceptionContext getContext() -> getContext
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math3.exception.MaxCountExceededException -> org.apache.commons.math3.exception.MaxCountExceededException:
    long serialVersionUID -> serialVersionUID
    java.lang.Number max -> max
    void <init>(java.lang.Number) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Number,java.lang.Object[]) -> <init>
    java.lang.Number getMax() -> getMax
org.apache.commons.math3.exception.MultiDimensionMismatchException -> org.apache.commons.math3.exception.MultiDimensionMismatchException:
    long serialVersionUID -> serialVersionUID
    java.lang.Integer[] wrong -> wrong
    java.lang.Integer[] expected -> expected
    void <init>(java.lang.Integer[],java.lang.Integer[]) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Integer[],java.lang.Integer[]) -> <init>
    java.lang.Integer[] getWrongDimensions() -> getWrongDimensions
    java.lang.Integer[] getExpectedDimensions() -> getExpectedDimensions
    int getWrongDimension(int) -> getWrongDimension
    int getExpectedDimension(int) -> getExpectedDimension
org.apache.commons.math3.exception.NoBracketingException -> org.apache.commons.math3.exception.NoBracketingException:
    long serialVersionUID -> serialVersionUID
    double lo -> lo
    double hi -> hi
    double fLo -> fLo
    double fHi -> fHi
    void <init>(double,double,double,double) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,double,double,double,double,java.lang.Object[]) -> <init>
    double getLo() -> getLo
    double getHi() -> getHi
    double getFLo() -> getFLo
    double getFHi() -> getFHi
org.apache.commons.math3.exception.NoDataException -> org.apache.commons.math3.exception.NoDataException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable) -> <init>
org.apache.commons.math3.exception.NonMonotonicSequenceException -> org.apache.commons.math3.exception.NonMonotonicSequenceException:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.util.MathArrays$OrderDirection direction -> direction
    boolean strict -> strict
    int index -> index
    java.lang.Number previous -> previous
    void <init>(java.lang.Number,java.lang.Number,int) -> <init>
    void <init>(java.lang.Number,java.lang.Number,int,org.apache.commons.math3.util.MathArrays$OrderDirection,boolean) -> <init>
    org.apache.commons.math3.util.MathArrays$OrderDirection getDirection() -> getDirection
    boolean getStrict() -> getStrict
    int getIndex() -> getIndex
    java.lang.Number getPrevious() -> getPrevious
org.apache.commons.math3.exception.NotANumberException -> org.apache.commons.math3.exception.NotANumberException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.apache.commons.math3.exception.NotFiniteNumberException -> org.apache.commons.math3.exception.NotFiniteNumberException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Number,java.lang.Object[]) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Number,java.lang.Object[]) -> <init>
org.apache.commons.math3.exception.NotPositiveException -> org.apache.commons.math3.exception.NotPositiveException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Number) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Number) -> <init>
org.apache.commons.math3.exception.NotStrictlyPositiveException -> org.apache.commons.math3.exception.NotStrictlyPositiveException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Number) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Number) -> <init>
org.apache.commons.math3.exception.NullArgumentException -> org.apache.commons.math3.exception.NullArgumentException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
org.apache.commons.math3.exception.NumberIsTooLargeException -> org.apache.commons.math3.exception.NumberIsTooLargeException:
    long serialVersionUID -> serialVersionUID
    java.lang.Number max -> max
    boolean boundIsAllowed -> boundIsAllowed
    void <init>(java.lang.Number,java.lang.Number,boolean) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Number,java.lang.Number,boolean) -> <init>
    boolean getBoundIsAllowed() -> getBoundIsAllowed
    java.lang.Number getMax() -> getMax
org.apache.commons.math3.exception.NumberIsTooSmallException -> org.apache.commons.math3.exception.NumberIsTooSmallException:
    long serialVersionUID -> serialVersionUID
    java.lang.Number min -> min
    boolean boundIsAllowed -> boundIsAllowed
    void <init>(java.lang.Number,java.lang.Number,boolean) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Number,java.lang.Number,boolean) -> <init>
    boolean getBoundIsAllowed() -> getBoundIsAllowed
    java.lang.Number getMin() -> getMin
org.apache.commons.math3.exception.OutOfRangeException -> org.apache.commons.math3.exception.OutOfRangeException:
    long serialVersionUID -> serialVersionUID
    java.lang.Number lo -> lo
    java.lang.Number hi -> hi
    void <init>(java.lang.Number,java.lang.Number,java.lang.Number) -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Number,java.lang.Number,java.lang.Number) -> <init>
    java.lang.Number getLo() -> getLo
    java.lang.Number getHi() -> getHi
org.apache.commons.math3.exception.TooManyEvaluationsException -> org.apache.commons.math3.exception.TooManyEvaluationsException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Number) -> <init>
org.apache.commons.math3.exception.TooManyIterationsException -> org.apache.commons.math3.exception.TooManyIterationsException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.Number) -> <init>
org.apache.commons.math3.exception.ZeroException -> org.apache.commons.math3.exception.ZeroException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> <init>
org.apache.commons.math3.exception.util.ExceptionContext -> org.apache.commons.math3.exception.util.ExceptionContext:
    long serialVersionUID -> serialVersionUID
    java.lang.Throwable throwable -> throwable
    java.util.List msgPatterns -> msgPatterns
    java.util.List msgArguments -> msgArguments
    java.util.Map context -> context
    void <init>(java.lang.Throwable) -> <init>
    java.lang.Throwable getThrowable() -> getThrowable
    void addMessage(org.apache.commons.math3.exception.util.Localizable,java.lang.Object[]) -> addMessage
    void setValue(java.lang.String,java.lang.Object) -> setValue
    java.lang.Object getValue(java.lang.String) -> getValue
    java.util.Set getKeys() -> getKeys
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
    java.lang.String getMessage(java.util.Locale) -> getMessage
    java.lang.String getMessage(java.util.Locale,java.lang.String) -> getMessage
    java.lang.String buildMessage(java.util.Locale,java.lang.String) -> a
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
    void deSerializeContext(java.io.ObjectInputStream) -> a
    java.lang.String nonSerializableReplacement(java.lang.Object) -> a
org.apache.commons.math3.exception.util.Localizable -> org.apache.commons.math3.exception.util.Localizable:
    java.lang.String getSourceString() -> getSourceString
    java.lang.String getLocalizedString(java.util.Locale) -> getLocalizedString
org.apache.commons.math3.exception.util.LocalizedFormats -> org.apache.commons.math3.exception.util.LocalizedFormats:
    org.apache.commons.math3.exception.util.LocalizedFormats ARGUMENT_OUTSIDE_DOMAIN -> ARGUMENT_OUTSIDE_DOMAIN
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SIZE_EXCEEDS_MAX_VARIABLES -> ARRAY_SIZE_EXCEEDS_MAX_VARIABLES
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1 -> ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_SUMS_TO_ZERO -> ARRAY_SUMS_TO_ZERO
    org.apache.commons.math3.exception.util.LocalizedFormats ASSYMETRIC_EIGEN_NOT_SUPPORTED -> ASSYMETRIC_EIGEN_NOT_SUPPORTED
    org.apache.commons.math3.exception.util.LocalizedFormats AT_LEAST_ONE_COLUMN -> AT_LEAST_ONE_COLUMN
    org.apache.commons.math3.exception.util.LocalizedFormats AT_LEAST_ONE_ROW -> AT_LEAST_ONE_ROW
    org.apache.commons.math3.exception.util.LocalizedFormats BANDWIDTH -> BANDWIDTH
    org.apache.commons.math3.exception.util.LocalizedFormats BESSEL_FUNCTION_BAD_ARGUMENT -> BESSEL_FUNCTION_BAD_ARGUMENT
    org.apache.commons.math3.exception.util.LocalizedFormats BESSEL_FUNCTION_FAILED_CONVERGENCE -> BESSEL_FUNCTION_FAILED_CONVERGENCE
    org.apache.commons.math3.exception.util.LocalizedFormats BINOMIAL_INVALID_PARAMETERS_ORDER -> BINOMIAL_INVALID_PARAMETERS_ORDER
    org.apache.commons.math3.exception.util.LocalizedFormats BINOMIAL_NEGATIVE_PARAMETER -> BINOMIAL_NEGATIVE_PARAMETER
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_0TH_ROOT_OF_UNITY -> CANNOT_COMPUTE_0TH_ROOT_OF_UNITY
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA -> CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA -> CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N -> CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS -> CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR -> CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_COMPLEX -> CANNOT_FORMAT_INSTANCE_AS_COMPLEX
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR -> CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_FORMAT_OBJECT_TO_FRACTION -> CANNOT_FORMAT_OBJECT_TO_FRACTION
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR -> CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_RETRIEVE_AT_NEGATIVE_INDEX -> CANNOT_RETRIEVE_AT_NEGATIVE_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_SET_AT_NEGATIVE_INDEX -> CANNOT_SET_AT_NEGATIVE_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY -> CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_TRANSFORM_TO_DOUBLE -> CANNOT_TRANSFORM_TO_DOUBLE
    org.apache.commons.math3.exception.util.LocalizedFormats CARDAN_ANGLES_SINGULARITY -> CARDAN_ANGLES_SINGULARITY
    org.apache.commons.math3.exception.util.LocalizedFormats CLASS_DOESNT_IMPLEMENT_COMPARABLE -> CLASS_DOESNT_IMPLEMENT_COMPARABLE
    org.apache.commons.math3.exception.util.LocalizedFormats CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT -> CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT
    org.apache.commons.math3.exception.util.LocalizedFormats COLUMN_INDEX_OUT_OF_RANGE -> COLUMN_INDEX_OUT_OF_RANGE
    org.apache.commons.math3.exception.util.LocalizedFormats COLUMN_INDEX -> COLUMN_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats CONSTRAINT -> CONSTRAINT
    org.apache.commons.math3.exception.util.LocalizedFormats CONTINUED_FRACTION_INFINITY_DIVERGENCE -> CONTINUED_FRACTION_INFINITY_DIVERGENCE
    org.apache.commons.math3.exception.util.LocalizedFormats CONTINUED_FRACTION_NAN_DIVERGENCE -> CONTINUED_FRACTION_NAN_DIVERGENCE
    org.apache.commons.math3.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR -> CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR
    org.apache.commons.math3.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_ONE -> CONTRACTION_CRITERIA_SMALLER_THAN_ONE
    org.apache.commons.math3.exception.util.LocalizedFormats CONVERGENCE_FAILED -> CONVERGENCE_FAILED
    org.apache.commons.math3.exception.util.LocalizedFormats CROSSING_BOUNDARY_LOOPS -> CROSSING_BOUNDARY_LOOPS
    org.apache.commons.math3.exception.util.LocalizedFormats CROSSOVER_RATE -> CROSSOVER_RATE
    org.apache.commons.math3.exception.util.LocalizedFormats CUMULATIVE_PROBABILITY_RETURNED_NAN -> CUMULATIVE_PROBABILITY_RETURNED_NAN
    org.apache.commons.math3.exception.util.LocalizedFormats DIFFERENT_ROWS_LENGTHS -> DIFFERENT_ROWS_LENGTHS
    org.apache.commons.math3.exception.util.LocalizedFormats DIFFERENT_ORIG_AND_PERMUTED_DATA -> DIFFERENT_ORIG_AND_PERMUTED_DATA
    org.apache.commons.math3.exception.util.LocalizedFormats DIGEST_NOT_INITIALIZED -> DIGEST_NOT_INITIALIZED
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_2x2 -> DIMENSIONS_MISMATCH_2x2
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_SIMPLE -> DIMENSIONS_MISMATCH_SIMPLE
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSIONS_MISMATCH -> DIMENSIONS_MISMATCH
    org.apache.commons.math3.exception.util.LocalizedFormats DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN -> DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN
    org.apache.commons.math3.exception.util.LocalizedFormats DISTRIBUTION_NOT_LOADED -> DISTRIBUTION_NOT_LOADED
    org.apache.commons.math3.exception.util.LocalizedFormats DUPLICATED_ABSCISSA_DIVISION_BY_ZERO -> DUPLICATED_ABSCISSA_DIVISION_BY_ZERO
    org.apache.commons.math3.exception.util.LocalizedFormats ELITISM_RATE -> ELITISM_RATE
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_CLUSTER_IN_K_MEANS -> EMPTY_CLUSTER_IN_K_MEANS
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_INTERPOLATION_SAMPLE -> EMPTY_INTERPOLATION_SAMPLE
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY -> EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_SELECTED_COLUMN_INDEX_ARRAY -> EMPTY_SELECTED_COLUMN_INDEX_ARRAY
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_SELECTED_ROW_INDEX_ARRAY -> EMPTY_SELECTED_ROW_INDEX_ARRAY
    org.apache.commons.math3.exception.util.LocalizedFormats EMPTY_STRING_FOR_IMAGINARY_CHARACTER -> EMPTY_STRING_FOR_IMAGINARY_CHARACTER
    org.apache.commons.math3.exception.util.LocalizedFormats ENDPOINTS_NOT_AN_INTERVAL -> ENDPOINTS_NOT_AN_INTERVAL
    org.apache.commons.math3.exception.util.LocalizedFormats EQUAL_VERTICES_IN_SIMPLEX -> EQUAL_VERTICES_IN_SIMPLEX
    org.apache.commons.math3.exception.util.LocalizedFormats EULER_ANGLES_SINGULARITY -> EULER_ANGLES_SINGULARITY
    org.apache.commons.math3.exception.util.LocalizedFormats EVALUATION -> EVALUATION
    org.apache.commons.math3.exception.util.LocalizedFormats EXPANSION_FACTOR_SMALLER_THAN_ONE -> EXPANSION_FACTOR_SMALLER_THAN_ONE
    org.apache.commons.math3.exception.util.LocalizedFormats FACTORIAL_NEGATIVE_PARAMETER -> FACTORIAL_NEGATIVE_PARAMETER
    org.apache.commons.math3.exception.util.LocalizedFormats FAILED_BRACKETING -> FAILED_BRACKETING
    org.apache.commons.math3.exception.util.LocalizedFormats FAILED_FRACTION_CONVERSION -> FAILED_FRACTION_CONVERSION
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_COLUMNS_NOT_INITIALIZED_YET -> FIRST_COLUMNS_NOT_INITIALIZED_YET
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_ELEMENT_NOT_ZERO -> FIRST_ELEMENT_NOT_ZERO
    org.apache.commons.math3.exception.util.LocalizedFormats FIRST_ROWS_NOT_INITIALIZED_YET -> FIRST_ROWS_NOT_INITIALIZED_YET
    org.apache.commons.math3.exception.util.LocalizedFormats FRACTION_CONVERSION_OVERFLOW -> FRACTION_CONVERSION_OVERFLOW
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION_NOT_DIFFERENTIABLE -> FUNCTION_NOT_DIFFERENTIABLE
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION_NOT_POLYNOMIAL -> FUNCTION_NOT_POLYNOMIAL
    org.apache.commons.math3.exception.util.LocalizedFormats GCD_OVERFLOW_32_BITS -> GCD_OVERFLOW_32_BITS
    org.apache.commons.math3.exception.util.LocalizedFormats GCD_OVERFLOW_64_BITS -> GCD_OVERFLOW_64_BITS
    org.apache.commons.math3.exception.util.LocalizedFormats HOLE_BETWEEN_MODELS_TIME_RANGES -> HOLE_BETWEEN_MODELS_TIME_RANGES
    org.apache.commons.math3.exception.util.LocalizedFormats ILL_CONDITIONED_OPERATOR -> ILL_CONDITIONED_OPERATOR
    org.apache.commons.math3.exception.util.LocalizedFormats INCONSISTENT_STATE_AT_2_PI_WRAPPING -> INCONSISTENT_STATE_AT_2_PI_WRAPPING
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_LARGER_THAN_MAX -> INDEX_LARGER_THAN_MAX
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_NOT_POSITIVE -> INDEX_NOT_POSITIVE
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX_OUT_OF_RANGE -> INDEX_OUT_OF_RANGE
    org.apache.commons.math3.exception.util.LocalizedFormats INDEX -> INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_FINITE_NUMBER -> NOT_FINITE_NUMBER
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_BOUND -> INFINITE_BOUND
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_ELEMENT -> ARRAY_ELEMENT
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_ARRAY_ELEMENT -> INFINITE_ARRAY_ELEMENT
    org.apache.commons.math3.exception.util.LocalizedFormats INFINITE_VALUE_CONVERSION -> INFINITE_VALUE_CONVERSION
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_CAPACITY_NOT_POSITIVE -> INITIAL_CAPACITY_NOT_POSITIVE
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_COLUMN_AFTER_FINAL_COLUMN -> INITIAL_COLUMN_AFTER_FINAL_COLUMN
    org.apache.commons.math3.exception.util.LocalizedFormats INITIAL_ROW_AFTER_FINAL_ROW -> INITIAL_ROW_AFTER_FINAL_ROW
    org.apache.commons.math3.exception.util.LocalizedFormats INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE -> INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE
    org.apache.commons.math3.exception.util.LocalizedFormats INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES -> INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DATA -> INSUFFICIENT_DATA
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DATA_FOR_T_STATISTIC -> INSUFFICIENT_DATA_FOR_T_STATISTIC
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_DIMENSION -> INSUFFICIENT_DIMENSION
    org.apache.commons.math3.exception.util.LocalizedFormats DIMENSION -> DIMENSION
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE -> INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE
    org.apache.commons.math3.exception.util.LocalizedFormats INSUFFICIENT_ROWS_AND_COLUMNS -> INSUFFICIENT_ROWS_AND_COLUMNS
    org.apache.commons.math3.exception.util.LocalizedFormats INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS -> INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS
    org.apache.commons.math3.exception.util.LocalizedFormats INTERNAL_ERROR -> INTERNAL_ERROR
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BINARY_DIGIT -> INVALID_BINARY_DIGIT
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BINARY_CHROMOSOME -> INVALID_BINARY_CHROMOSOME
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_BRACKETING_PARAMETERS -> INVALID_BRACKETING_PARAMETERS
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_FIXED_LENGTH_CHROMOSOME -> INVALID_FIXED_LENGTH_CHROMOSOME
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_IMPLEMENTATION -> INVALID_IMPLEMENTATION
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS -> INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_ITERATIONS_LIMITS -> INVALID_ITERATIONS_LIMITS
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_MAX_ITERATIONS -> INVALID_MAX_ITERATIONS
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_DATA_REGRESSION -> NOT_ENOUGH_DATA_REGRESSION
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_REGRESSION_ARRAY -> INVALID_REGRESSION_ARRAY
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_REGRESSION_OBSERVATION -> INVALID_REGRESSION_OBSERVATION
    org.apache.commons.math3.exception.util.LocalizedFormats INVALID_ROUNDING_METHOD -> INVALID_ROUNDING_METHOD
    org.apache.commons.math3.exception.util.LocalizedFormats ITERATOR_EXHAUSTED -> ITERATOR_EXHAUSTED
    org.apache.commons.math3.exception.util.LocalizedFormats ITERATIONS -> ITERATIONS
    org.apache.commons.math3.exception.util.LocalizedFormats LCM_OVERFLOW_32_BITS -> LCM_OVERFLOW_32_BITS
    org.apache.commons.math3.exception.util.LocalizedFormats LCM_OVERFLOW_64_BITS -> LCM_OVERFLOW_64_BITS
    org.apache.commons.math3.exception.util.LocalizedFormats LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE -> LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats LOESS_EXPECTS_AT_LEAST_ONE_POINT -> LOESS_EXPECTS_AT_LEAST_ONE_POINT
    org.apache.commons.math3.exception.util.LocalizedFormats LOWER_BOUND_NOT_BELOW_UPPER_BOUND -> LOWER_BOUND_NOT_BELOW_UPPER_BOUND
    org.apache.commons.math3.exception.util.LocalizedFormats LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT -> LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT
    org.apache.commons.math3.exception.util.LocalizedFormats MAP_MODIFIED_WHILE_ITERATING -> MAP_MODIFIED_WHILE_ITERATING
    org.apache.commons.math3.exception.util.LocalizedFormats EVALUATIONS -> EVALUATIONS
    org.apache.commons.math3.exception.util.LocalizedFormats MAX_COUNT_EXCEEDED -> MAX_COUNT_EXCEEDED
    org.apache.commons.math3.exception.util.LocalizedFormats MAX_ITERATIONS_EXCEEDED -> MAX_ITERATIONS_EXCEEDED
    org.apache.commons.math3.exception.util.LocalizedFormats MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION -> MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION
    org.apache.commons.math3.exception.util.LocalizedFormats MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS -> MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS
    org.apache.commons.math3.exception.util.LocalizedFormats MUTATION_RATE -> MUTATION_RATE
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_ELEMENT_AT_INDEX -> NAN_ELEMENT_AT_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_VALUE_CONVERSION -> NAN_VALUE_CONVERSION
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_BRIGHTNESS_EXPONENT -> NEGATIVE_BRIGHTNESS_EXPONENT
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_COMPLEX_MODULE -> NEGATIVE_COMPLEX_MODULE
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_2D_INDEX -> NEGATIVE_ELEMENT_AT_2D_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_INDEX -> NEGATIVE_ELEMENT_AT_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_SUCCESSES -> NEGATIVE_NUMBER_OF_SUCCESSES
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SUCCESSES -> NUMBER_OF_SUCCESSES
    org.apache.commons.math3.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_TRIALS -> NEGATIVE_NUMBER_OF_TRIALS
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_INTERPOLATION_POINTS -> NUMBER_OF_INTERPOLATION_POINTS
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_TRIALS -> NUMBER_OF_TRIALS
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_CONVEX -> NOT_CONVEX
    org.apache.commons.math3.exception.util.LocalizedFormats ROBUSTNESS_ITERATIONS -> ROBUSTNESS_ITERATIONS
    org.apache.commons.math3.exception.util.LocalizedFormats START_POSITION -> START_POSITION
    org.apache.commons.math3.exception.util.LocalizedFormats NON_CONVERGENT_CONTINUED_FRACTION -> NON_CONVERGENT_CONTINUED_FRACTION
    org.apache.commons.math3.exception.util.LocalizedFormats NON_INVERTIBLE_TRANSFORM -> NON_INVERTIBLE_TRANSFORM
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_MICROSPHERE_ELEMENTS -> NON_POSITIVE_MICROSPHERE_ELEMENTS
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_POLYNOMIAL_DEGREE -> NON_POSITIVE_POLYNOMIAL_DEGREE
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_ABSCISSA -> NON_REAL_FINITE_ABSCISSA
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_ORDINATE -> NON_REAL_FINITE_ORDINATE
    org.apache.commons.math3.exception.util.LocalizedFormats NON_REAL_FINITE_WEIGHT -> NON_REAL_FINITE_WEIGHT
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SQUARE_MATRIX -> NON_SQUARE_MATRIX
    org.apache.commons.math3.exception.util.LocalizedFormats NORM -> NORM
    org.apache.commons.math3.exception.util.LocalizedFormats NORMALIZE_INFINITE -> NORMALIZE_INFINITE
    org.apache.commons.math3.exception.util.LocalizedFormats NORMALIZE_NAN -> NORMALIZE_NAN
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ADDITION_COMPATIBLE_MATRICES -> NOT_ADDITION_COMPATIBLE_MATRICES
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_DECREASING_NUMBER_OF_POINTS -> NOT_DECREASING_NUMBER_OF_POINTS
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_DECREASING_SEQUENCE -> NOT_DECREASING_SEQUENCE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS -> NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION -> NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_INCREASING_NUMBER_OF_POINTS -> NOT_INCREASING_NUMBER_OF_POINTS
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_INCREASING_SEQUENCE -> NOT_INCREASING_SEQUENCE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_MULTIPLICATION_COMPATIBLE_MATRICES -> NOT_MULTIPLICATION_COMPATIBLE_MATRICES
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_DEFINITE_MATRIX -> NOT_POSITIVE_DEFINITE_MATRIX
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_DEFINITE_MATRIX -> NON_POSITIVE_DEFINITE_MATRIX
    org.apache.commons.math3.exception.util.LocalizedFormats NON_POSITIVE_DEFINITE_OPERATOR -> NON_POSITIVE_DEFINITE_OPERATOR
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SELF_ADJOINT_OPERATOR -> NON_SELF_ADJOINT_OPERATOR
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SQUARE_OPERATOR -> NON_SQUARE_OPERATOR
    org.apache.commons.math3.exception.util.LocalizedFormats DEGREES_OF_FREEDOM -> DEGREES_OF_FREEDOM
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_DEGREES_OF_FREEDOM -> NOT_POSITIVE_DEGREES_OF_FREEDOM
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_ELEMENT_AT_INDEX -> NOT_POSITIVE_ELEMENT_AT_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_EXPONENT -> NOT_POSITIVE_EXPONENT
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE -> NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE
    org.apache.commons.math3.exception.util.LocalizedFormats BASE -> BASE
    org.apache.commons.math3.exception.util.LocalizedFormats EXPONENT -> EXPONENT
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_LENGTH -> NOT_POSITIVE_LENGTH
    org.apache.commons.math3.exception.util.LocalizedFormats LENGTH -> LENGTH
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_MEAN -> NOT_POSITIVE_MEAN
    org.apache.commons.math3.exception.util.LocalizedFormats MEAN -> MEAN
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_NUMBER_OF_SAMPLES -> NOT_POSITIVE_NUMBER_OF_SAMPLES
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SAMPLES -> NUMBER_OF_SAMPLES
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_PERMUTATION -> NOT_POSITIVE_PERMUTATION
    org.apache.commons.math3.exception.util.LocalizedFormats PERMUTATION_SIZE -> PERMUTATION_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_POISSON_MEAN -> NOT_POSITIVE_POISSON_MEAN
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_POPULATION_SIZE -> NOT_POSITIVE_POPULATION_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats POPULATION_SIZE -> POPULATION_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_ROW_DIMENSION -> NOT_POSITIVE_ROW_DIMENSION
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SAMPLE_SIZE -> NOT_POSITIVE_SAMPLE_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SCALE -> NOT_POSITIVE_SCALE
    org.apache.commons.math3.exception.util.LocalizedFormats SCALE -> SCALE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_SHAPE -> NOT_POSITIVE_SHAPE
    org.apache.commons.math3.exception.util.LocalizedFormats SHAPE -> SHAPE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_STANDARD_DEVIATION -> NOT_POSITIVE_STANDARD_DEVIATION
    org.apache.commons.math3.exception.util.LocalizedFormats STANDARD_DEVIATION -> STANDARD_DEVIATION
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_UPPER_BOUND -> NOT_POSITIVE_UPPER_BOUND
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POSITIVE_WINDOW_SIZE -> NOT_POSITIVE_WINDOW_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO -> NOT_POWER_OF_TWO
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO_CONSIDER_PADDING -> NOT_POWER_OF_TWO_CONSIDER_PADDING
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_POWER_OF_TWO_PLUS_ONE -> NOT_POWER_OF_TWO_PLUS_ONE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS -> NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_SEQUENCE -> NOT_STRICTLY_DECREASING_SEQUENCE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_KNOT_VALUES -> NOT_STRICTLY_INCREASING_KNOT_VALUES
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS -> NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_SEQUENCE -> NOT_STRICTLY_INCREASING_SEQUENCE
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SUBTRACTION_COMPATIBLE_MATRICES -> NOT_SUBTRACTION_COMPATIBLE_MATRICES
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SUPPORTED_IN_DIMENSION_N -> NOT_SUPPORTED_IN_DIMENSION_N
    org.apache.commons.math3.exception.util.LocalizedFormats NOT_SYMMETRIC_MATRIX -> NOT_SYMMETRIC_MATRIX
    org.apache.commons.math3.exception.util.LocalizedFormats NON_SYMMETRIC_MATRIX -> NON_SYMMETRIC_MATRIX
    org.apache.commons.math3.exception.util.LocalizedFormats NO_BIN_SELECTED -> NO_BIN_SELECTED
    org.apache.commons.math3.exception.util.LocalizedFormats NO_CONVERGENCE_WITH_ANY_START_POINT -> NO_CONVERGENCE_WITH_ANY_START_POINT
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DATA -> NO_DATA
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DEGREES_OF_FREEDOM -> NO_DEGREES_OF_FREEDOM
    org.apache.commons.math3.exception.util.LocalizedFormats NO_DENSITY_FOR_THIS_DISTRIBUTION -> NO_DENSITY_FOR_THIS_DISTRIBUTION
    org.apache.commons.math3.exception.util.LocalizedFormats NO_FEASIBLE_SOLUTION -> NO_FEASIBLE_SOLUTION
    org.apache.commons.math3.exception.util.LocalizedFormats NO_OPTIMUM_COMPUTED_YET -> NO_OPTIMUM_COMPUTED_YET
    org.apache.commons.math3.exception.util.LocalizedFormats NO_REGRESSORS -> NO_REGRESSORS
    org.apache.commons.math3.exception.util.LocalizedFormats NO_RESULT_AVAILABLE -> NO_RESULT_AVAILABLE
    org.apache.commons.math3.exception.util.LocalizedFormats NO_SUCH_MATRIX_ENTRY -> NO_SUCH_MATRIX_ENTRY
    org.apache.commons.math3.exception.util.LocalizedFormats NAN_NOT_ALLOWED -> NAN_NOT_ALLOWED
    org.apache.commons.math3.exception.util.LocalizedFormats NULL_NOT_ALLOWED -> NULL_NOT_ALLOWED
    org.apache.commons.math3.exception.util.LocalizedFormats ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED -> ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED
    org.apache.commons.math3.exception.util.LocalizedFormats COVARIANCE_MATRIX -> COVARIANCE_MATRIX
    org.apache.commons.math3.exception.util.LocalizedFormats DENOMINATOR -> DENOMINATOR
    org.apache.commons.math3.exception.util.LocalizedFormats DENOMINATOR_FORMAT -> DENOMINATOR_FORMAT
    org.apache.commons.math3.exception.util.LocalizedFormats FRACTION -> FRACTION
    org.apache.commons.math3.exception.util.LocalizedFormats FUNCTION -> FUNCTION
    org.apache.commons.math3.exception.util.LocalizedFormats IMAGINARY_FORMAT -> IMAGINARY_FORMAT
    org.apache.commons.math3.exception.util.LocalizedFormats INPUT_ARRAY -> INPUT_ARRAY
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR -> NUMERATOR
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR_FORMAT -> NUMERATOR_FORMAT
    org.apache.commons.math3.exception.util.LocalizedFormats OBJECT_TRANSFORMATION -> OBJECT_TRANSFORMATION
    org.apache.commons.math3.exception.util.LocalizedFormats REAL_FORMAT -> REAL_FORMAT
    org.apache.commons.math3.exception.util.LocalizedFormats WHOLE_FORMAT -> WHOLE_FORMAT
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_LARGE -> NUMBER_TOO_LARGE
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_SMALL -> NUMBER_TOO_SMALL
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_LARGE_BOUND_EXCLUDED -> NUMBER_TOO_LARGE_BOUND_EXCLUDED
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_TOO_SMALL_BOUND_EXCLUDED -> NUMBER_TOO_SMALL_BOUND_EXCLUDED
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE -> NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats NUMERATOR_OVERFLOW_AFTER_MULTIPLY -> NUMERATOR_OVERFLOW_AFTER_MULTIPLY
    org.apache.commons.math3.exception.util.LocalizedFormats N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED -> N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED
    org.apache.commons.math3.exception.util.LocalizedFormats OBSERVED_COUNTS_ALL_ZERO -> OBSERVED_COUNTS_ALL_ZERO
    org.apache.commons.math3.exception.util.LocalizedFormats OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY -> OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY
    org.apache.commons.math3.exception.util.LocalizedFormats BOBYQA_BOUND_DIFFERENCE_CONDITION -> BOBYQA_BOUND_DIFFERENCE_CONDITION
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUNDS_QUANTILE_VALUE -> OUT_OF_BOUNDS_QUANTILE_VALUE
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUNDS_CONFIDENCE_LEVEL -> OUT_OF_BOUNDS_CONFIDENCE_LEVEL
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_BOUND_SIGNIFICANCE_LEVEL -> OUT_OF_BOUND_SIGNIFICANCE_LEVEL
    org.apache.commons.math3.exception.util.LocalizedFormats SIGNIFICANCE_LEVEL -> SIGNIFICANCE_LEVEL
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_ORDER_ABSCISSA_ARRAY -> OUT_OF_ORDER_ABSCISSA_ARRAY
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_ROOT_OF_UNITY_INDEX -> OUT_OF_RANGE_ROOT_OF_UNITY_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE -> OUT_OF_RANGE
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_SIMPLE -> OUT_OF_RANGE_SIMPLE
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_LEFT -> OUT_OF_RANGE_LEFT
    org.apache.commons.math3.exception.util.LocalizedFormats OUT_OF_RANGE_RIGHT -> OUT_OF_RANGE_RIGHT
    org.apache.commons.math3.exception.util.LocalizedFormats OUTLINE_BOUNDARY_LOOP_OPEN -> OUTLINE_BOUNDARY_LOOP_OPEN
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW -> OVERFLOW
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_FRACTION -> OVERFLOW_IN_FRACTION
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_ADDITION -> OVERFLOW_IN_ADDITION
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_SUBTRACTION -> OVERFLOW_IN_SUBTRACTION
    org.apache.commons.math3.exception.util.LocalizedFormats OVERFLOW_IN_MULTIPLICATION -> OVERFLOW_IN_MULTIPLICATION
    org.apache.commons.math3.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD -> PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD
    org.apache.commons.math3.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD -> PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD
    org.apache.commons.math3.exception.util.LocalizedFormats PERMUTATION_EXCEEDS_N -> PERMUTATION_EXCEEDS_N
    org.apache.commons.math3.exception.util.LocalizedFormats POLYNOMIAL -> POLYNOMIAL
    org.apache.commons.math3.exception.util.LocalizedFormats POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS -> POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS
    org.apache.commons.math3.exception.util.LocalizedFormats POPULATION_LIMIT_NOT_POSITIVE -> POPULATION_LIMIT_NOT_POSITIVE
    org.apache.commons.math3.exception.util.LocalizedFormats POWER_NEGATIVE_PARAMETERS -> POWER_NEGATIVE_PARAMETERS
    org.apache.commons.math3.exception.util.LocalizedFormats PROPAGATION_DIRECTION_MISMATCH -> PROPAGATION_DIRECTION_MISMATCH
    org.apache.commons.math3.exception.util.LocalizedFormats RANDOMKEY_MUTATION_WRONG_CLASS -> RANDOMKEY_MUTATION_WRONG_CLASS
    org.apache.commons.math3.exception.util.LocalizedFormats ROOTS_OF_UNITY_NOT_COMPUTED_YET -> ROOTS_OF_UNITY_NOT_COMPUTED_YET
    org.apache.commons.math3.exception.util.LocalizedFormats ROTATION_MATRIX_DIMENSIONS -> ROTATION_MATRIX_DIMENSIONS
    org.apache.commons.math3.exception.util.LocalizedFormats ROW_INDEX_OUT_OF_RANGE -> ROW_INDEX_OUT_OF_RANGE
    org.apache.commons.math3.exception.util.LocalizedFormats ROW_INDEX -> ROW_INDEX
    org.apache.commons.math3.exception.util.LocalizedFormats SAME_SIGN_AT_ENDPOINTS -> SAME_SIGN_AT_ENDPOINTS
    org.apache.commons.math3.exception.util.LocalizedFormats SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE -> SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE -> SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE
    org.apache.commons.math3.exception.util.LocalizedFormats SIMPLEX_NEED_ONE_POINT -> SIMPLEX_NEED_ONE_POINT
    org.apache.commons.math3.exception.util.LocalizedFormats SIMPLE_MESSAGE -> SIMPLE_MESSAGE
    org.apache.commons.math3.exception.util.LocalizedFormats SINGULAR_MATRIX -> SINGULAR_MATRIX
    org.apache.commons.math3.exception.util.LocalizedFormats SINGULAR_OPERATOR -> SINGULAR_OPERATOR
    org.apache.commons.math3.exception.util.LocalizedFormats SUBARRAY_ENDS_AFTER_ARRAY_END -> SUBARRAY_ENDS_AFTER_ARRAY_END
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_LARGE_CUTOFF_SINGULAR_VALUE -> TOO_LARGE_CUTOFF_SINGULAR_VALUE
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_LARGE_TOURNAMENT_ARITY -> TOO_LARGE_TOURNAMENT_ARITY
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY -> TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_MANY_REGRESSORS -> TOO_MANY_REGRESSORS
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_COST_RELATIVE_TOLERANCE -> TOO_SMALL_COST_RELATIVE_TOLERANCE
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_INTEGRATION_INTERVAL -> TOO_SMALL_INTEGRATION_INTERVAL
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_ORTHOGONALITY_TOLERANCE -> TOO_SMALL_ORTHOGONALITY_TOLERANCE
    org.apache.commons.math3.exception.util.LocalizedFormats TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE -> TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE
    org.apache.commons.math3.exception.util.LocalizedFormats TRUST_REGION_STEP_FAILED -> TRUST_REGION_STEP_FAILED
    org.apache.commons.math3.exception.util.LocalizedFormats TWO_OR_MORE_CATEGORIES_REQUIRED -> TWO_OR_MORE_CATEGORIES_REQUIRED
    org.apache.commons.math3.exception.util.LocalizedFormats TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED -> TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH -> UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM -> UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS -> UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_ORTHOGONOLIZE_MATRIX -> UNABLE_TO_ORTHOGONOLIZE_MATRIX
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN -> UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN
    org.apache.commons.math3.exception.util.LocalizedFormats UNABLE_TO_SOLVE_SINGULAR_PROBLEM -> UNABLE_TO_SOLVE_SINGULAR_PROBLEM
    org.apache.commons.math3.exception.util.LocalizedFormats UNBOUNDED_SOLUTION -> UNBOUNDED_SOLUTION
    org.apache.commons.math3.exception.util.LocalizedFormats UNKNOWN_MODE -> UNKNOWN_MODE
    org.apache.commons.math3.exception.util.LocalizedFormats UNKNOWN_PARAMETER -> UNKNOWN_PARAMETER
    org.apache.commons.math3.exception.util.LocalizedFormats UNMATCHED_ODE_IN_EXPANDED_SET -> UNMATCHED_ODE_IN_EXPANDED_SET
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_PARSE_AS_TYPE -> CANNOT_PARSE_AS_TYPE
    org.apache.commons.math3.exception.util.LocalizedFormats CANNOT_PARSE -> CANNOT_PARSE
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_3D_VECTOR -> UNPARSEABLE_3D_VECTOR
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_COMPLEX_NUMBER -> UNPARSEABLE_COMPLEX_NUMBER
    org.apache.commons.math3.exception.util.LocalizedFormats UNPARSEABLE_REAL_VECTOR -> UNPARSEABLE_REAL_VECTOR
    org.apache.commons.math3.exception.util.LocalizedFormats UNSUPPORTED_EXPANSION_MODE -> UNSUPPORTED_EXPANSION_MODE
    org.apache.commons.math3.exception.util.LocalizedFormats UNSUPPORTED_OPERATION -> UNSUPPORTED_OPERATION
    org.apache.commons.math3.exception.util.LocalizedFormats ARITHMETIC_EXCEPTION -> ARITHMETIC_EXCEPTION
    org.apache.commons.math3.exception.util.LocalizedFormats ILLEGAL_STATE -> ILLEGAL_STATE
    org.apache.commons.math3.exception.util.LocalizedFormats USER_EXCEPTION -> USER_EXCEPTION
    org.apache.commons.math3.exception.util.LocalizedFormats URL_CONTAINS_NO_DATA -> URL_CONTAINS_NO_DATA
    org.apache.commons.math3.exception.util.LocalizedFormats VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC -> VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC
    org.apache.commons.math3.exception.util.LocalizedFormats VECTOR_LENGTH_MISMATCH -> VECTOR_LENGTH_MISMATCH
    org.apache.commons.math3.exception.util.LocalizedFormats VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT -> VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT
    org.apache.commons.math3.exception.util.LocalizedFormats WEIGHT_AT_LEAST_ONE_NON_ZERO -> WEIGHT_AT_LEAST_ONE_NON_ZERO
    org.apache.commons.math3.exception.util.LocalizedFormats WRONG_BLOCK_LENGTH -> WRONG_BLOCK_LENGTH
    org.apache.commons.math3.exception.util.LocalizedFormats WRONG_NUMBER_OF_POINTS -> WRONG_NUMBER_OF_POINTS
    org.apache.commons.math3.exception.util.LocalizedFormats NUMBER_OF_POINTS -> NUMBER_OF_POINTS
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_DENOMINATOR -> ZERO_DENOMINATOR
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_DENOMINATOR_IN_FRACTION -> ZERO_DENOMINATOR_IN_FRACTION
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_FRACTION_TO_DIVIDE_BY -> ZERO_FRACTION_TO_DIVIDE_BY
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM -> ZERO_NORM
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_AXIS -> ZERO_NORM_FOR_ROTATION_AXIS
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR -> ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR
    org.apache.commons.math3.exception.util.LocalizedFormats ZERO_NOT_ALLOWED -> ZERO_NOT_ALLOWED
    java.lang.String sourceFormat -> sourceFormat
    org.apache.commons.math3.exception.util.LocalizedFormats[] $VALUES -> a
    org.apache.commons.math3.exception.util.LocalizedFormats[] values() -> values
    org.apache.commons.math3.exception.util.LocalizedFormats valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    java.lang.String getSourceString() -> getSourceString
    java.lang.String getLocalizedString(java.util.Locale) -> getLocalizedString
    void <clinit>() -> <clinit>
org.apache.commons.math3.fitting.AbstractCurveFitter -> gl:
    void <init>() -> <init>
    double[] fit(java.util.Collection) -> a
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem getProblem(java.util.Collection) -> a
org.apache.commons.math3.fitting.AbstractCurveFitter$TheoreticalValuesFunction -> gm:
    org.apache.commons.math3.analysis.ParametricUnivariateFunction f -> a
    double[] points -> a
    void <init>(org.apache.commons.math3.analysis.ParametricUnivariateFunction,java.util.Collection) -> <init>
org.apache.commons.math3.fitting.AbstractCurveFitter$TheoreticalValuesFunction$1 -> gn:
    org.apache.commons.math3.fitting.AbstractCurveFitter$TheoreticalValuesFunction this$0 -> a
    void <init>(org.apache.commons.math3.fitting.AbstractCurveFitter$TheoreticalValuesFunction) -> <init>
    double[] value(double[]) -> a
org.apache.commons.math3.fitting.AbstractCurveFitter$TheoreticalValuesFunction$2 -> go:
    org.apache.commons.math3.fitting.AbstractCurveFitter$TheoreticalValuesFunction this$0 -> a
    void <init>(org.apache.commons.math3.fitting.AbstractCurveFitter$TheoreticalValuesFunction) -> <init>
    double[][] value(double[]) -> a
org.apache.commons.math3.fitting.PolynomialCurveFitter -> gp:
    org.apache.commons.math3.analysis.ParametricUnivariateFunction FUNCTION$50469f21 -> a
    double[] initialGuess -> a
    int maxIter -> a
    void <init>(double[],int) -> <init>
    org.apache.commons.math3.fitting.PolynomialCurveFitter create(int) -> a
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem getProblem(java.util.Collection) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.fitting.WeightedObservedPoint -> org.apache.commons.math3.fitting.WeightedObservedPoint:
    long serialVersionUID -> serialVersionUID
    double weight -> weight
    double x -> x
    double y -> y
    void <init>(double,double,double) -> <init>
    double getWeight() -> getWeight
    double getX() -> getX
    double getY() -> getY
org.apache.commons.math3.fitting.WeightedObservedPoints -> org.apache.commons.math3.fitting.WeightedObservedPoints:
    long serialVersionUID -> serialVersionUID
    java.util.List observations -> observations
    void <init>() -> <init>
    void add(double,double) -> add
    void add(double,double,double) -> add
    void add(org.apache.commons.math3.fitting.WeightedObservedPoint) -> add
    java.util.List toList() -> toList
    void clear() -> clear
org.apache.commons.math3.fitting.leastsquares.AbstractEvaluation -> gq:
    void <init>(int) -> <init>
    double getCost() -> a
org.apache.commons.math3.fitting.leastsquares.DenseWeightedEvaluation -> gr:
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation unweighted -> a
    org.apache.commons.math3.linear.RealMatrix weightSqrt -> a
    void <init>(org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation,org.apache.commons.math3.linear.RealMatrix) -> <init>
    org.apache.commons.math3.linear.RealMatrix getJacobian() -> a
    org.apache.commons.math3.linear.RealVector getResiduals() -> a
    org.apache.commons.math3.linear.RealVector getPoint() -> b
org.apache.commons.math3.fitting.leastsquares.LeastSquaresAdapter -> gs:
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem problem -> a
    void <init>(org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem) -> <init>
    org.apache.commons.math3.linear.RealVector getStart() -> a
    int getObservationSize() -> a
    int getParameterSize() -> b
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation evaluate(org.apache.commons.math3.linear.RealVector) -> a
    org.apache.commons.math3.util.Incrementor getEvaluationCounter() -> a
    org.apache.commons.math3.util.Incrementor getIterationCounter() -> b
    edu.jas.poly.RelationGenerator getConvergenceChecker$45ee8af7() -> a
org.apache.commons.math3.fitting.leastsquares.LeastSquaresBuilder -> gt:
    int maxEvaluations -> a
    int maxIterations -> b
    org.apache.commons.math3.fitting.leastsquares.MultivariateJacobianFunction model -> a
    org.apache.commons.math3.linear.RealVector target -> a
    org.apache.commons.math3.linear.RealVector start -> b
    org.apache.commons.math3.linear.RealMatrix weight -> a
    void <init>() -> <init>
org.apache.commons.math3.fitting.leastsquares.LeastSquaresFactory$1 -> gu:
    org.apache.commons.math3.linear.RealMatrix val$weightSquareRoot -> a
    void <init>(org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem,org.apache.commons.math3.linear.RealMatrix) -> <init>
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation evaluate(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.fitting.leastsquares.LeastSquaresFactory$LocalLeastSquaresProblem -> gv:
    org.apache.commons.math3.linear.RealVector target -> a
    org.apache.commons.math3.fitting.leastsquares.MultivariateJacobianFunction model -> a
    org.apache.commons.math3.linear.RealVector start -> b
    boolean lazyEvaluation -> a
    edu.jas.poly.RelationGenerator paramValidator$493031eb -> a
    void <init>(org.apache.commons.math3.fitting.leastsquares.MultivariateJacobianFunction,org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.RealVector,edu.jas.poly.RelationGenerator,int,int,boolean,edu.jas.poly.RelationGenerator) -> <init>
    int getObservationSize() -> a
    int getParameterSize() -> b
    org.apache.commons.math3.linear.RealVector getStart() -> a
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation evaluate(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.fitting.leastsquares.LeastSquaresFactory$LocalLeastSquaresProblem$LazyUnweightedEvaluation -> gw:
    org.apache.commons.math3.linear.RealVector point -> a
    org.apache.commons.math3.fitting.leastsquares.ValueAndJacobianFunction model -> a
    org.apache.commons.math3.linear.RealVector target -> b
    void <init>(org.apache.commons.math3.fitting.leastsquares.ValueAndJacobianFunction,org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.RealVector) -> <init>
    org.apache.commons.math3.linear.RealMatrix getJacobian() -> a
    org.apache.commons.math3.linear.RealVector getPoint() -> b
    org.apache.commons.math3.linear.RealVector getResiduals() -> a
    void <init>(org.apache.commons.math3.fitting.leastsquares.ValueAndJacobianFunction,org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.RealVector,byte) -> <init>
org.apache.commons.math3.fitting.leastsquares.LeastSquaresFactory$LocalLeastSquaresProblem$UnweightedEvaluation -> gx:
    org.apache.commons.math3.linear.RealVector point -> a
    org.apache.commons.math3.linear.RealMatrix jacobian -> a
    org.apache.commons.math3.linear.RealVector residuals -> b
    void <init>(org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.RealMatrix,org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.RealVector) -> <init>
    org.apache.commons.math3.linear.RealMatrix getJacobian() -> a
    org.apache.commons.math3.linear.RealVector getPoint() -> b
    org.apache.commons.math3.linear.RealVector getResiduals() -> a
    void <init>(org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.RealMatrix,org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.RealVector,byte) -> <init>
org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer -> gy:
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer$Optimum optimize(org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem) -> a
org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer$Optimum -> gz:
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation value -> a
    void <init>(org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation,int,int) -> <init>
    org.apache.commons.math3.linear.RealMatrix getJacobian() -> a
    double getCost() -> a
    org.apache.commons.math3.linear.RealVector getResiduals() -> a
    org.apache.commons.math3.linear.RealVector getPoint() -> b
org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem -> gA:
    org.apache.commons.math3.linear.RealVector getStart() -> a
    int getObservationSize() -> a
    int getParameterSize() -> b
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation evaluate(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem$Evaluation -> gB:
    org.apache.commons.math3.linear.RealMatrix getJacobian() -> a
    double getCost() -> a
    org.apache.commons.math3.linear.RealVector getResiduals() -> a
    org.apache.commons.math3.linear.RealVector getPoint() -> b
org.apache.commons.math3.fitting.leastsquares.LevenbergMarquardtOptimizer -> gC:
    double TWO_EPS -> a
    double initialStepBoundFactor -> b
    double costRelativeTolerance -> c
    double parRelativeTolerance -> d
    double orthoTolerance -> e
    double qrRankingThreshold -> f
    void <init>() -> <init>
    void <init>(double,double,double,double,double) -> <init>
    org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer$Optimum optimize(org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.fitting.leastsquares.LevenbergMarquardtOptimizer$InternalData -> gD:
    double[][] weightedJacobian -> a
    int[] permutation -> a
    int rank -> a
    double[] diagR -> a
    double[] jacNorm -> b
    double[] beta -> c
    void <init>(double[][],int[],int,double[],double[],double[]) -> <init>
org.apache.commons.math3.fitting.leastsquares.MultivariateJacobianFunction -> gE:
    org.apache.commons.math3.util.Pair value(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.fitting.leastsquares.ValueAndJacobianFunction -> gF:
    org.apache.commons.math3.analysis.MultivariateVectorFunction value -> a
    org.apache.commons.math3.analysis.MultivariateMatrixFunction jacobian -> a
    org.apache.commons.math3.linear.RealVector computeValue(double[]) -> a
    org.apache.commons.math3.linear.RealMatrix computeJacobian(double[]) -> a
    void <init>(org.apache.commons.math3.analysis.MultivariateVectorFunction,org.apache.commons.math3.analysis.MultivariateMatrixFunction) -> <init>
    org.apache.commons.math3.util.Pair value(org.apache.commons.math3.linear.RealVector) -> a
org.apache.commons.math3.fraction.BigFraction -> org.apache.commons.math3.fraction.BigFraction:
    org.apache.commons.math3.fraction.BigFraction TWO -> TWO
    org.apache.commons.math3.fraction.BigFraction ONE -> ONE
    org.apache.commons.math3.fraction.BigFraction ZERO -> ZERO
    org.apache.commons.math3.fraction.BigFraction MINUS_ONE -> MINUS_ONE
    org.apache.commons.math3.fraction.BigFraction FOUR_FIFTHS -> FOUR_FIFTHS
    org.apache.commons.math3.fraction.BigFraction ONE_FIFTH -> ONE_FIFTH
    org.apache.commons.math3.fraction.BigFraction ONE_HALF -> ONE_HALF
    org.apache.commons.math3.fraction.BigFraction ONE_QUARTER -> ONE_QUARTER
    org.apache.commons.math3.fraction.BigFraction ONE_THIRD -> ONE_THIRD
    org.apache.commons.math3.fraction.BigFraction THREE_FIFTHS -> THREE_FIFTHS
    org.apache.commons.math3.fraction.BigFraction THREE_QUARTERS -> THREE_QUARTERS
    org.apache.commons.math3.fraction.BigFraction TWO_FIFTHS -> TWO_FIFTHS
    org.apache.commons.math3.fraction.BigFraction TWO_QUARTERS -> TWO_QUARTERS
    org.apache.commons.math3.fraction.BigFraction TWO_THIRDS -> TWO_THIRDS
    long serialVersionUID -> serialVersionUID
    java.math.BigInteger ONE_HUNDRED -> a
    java.math.BigInteger numerator -> numerator
    java.math.BigInteger denominator -> denominator
    void <init>(java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger,java.math.BigInteger) -> <init>
    void <init>(double) -> <init>
    void <init>(double,double,int) -> <init>
    void <init>(double,double,int,int) -> <init>
    void <init>(double,int) -> <init>
    void <init>(int) -> <init>
    void <init>(int,int) -> <init>
    void <init>(long) -> <init>
    void <init>(long,long) -> <init>
    org.apache.commons.math3.fraction.BigFraction getReducedFraction(int,int) -> getReducedFraction
    org.apache.commons.math3.fraction.BigFraction abs() -> abs
    org.apache.commons.math3.fraction.BigFraction add(java.math.BigInteger) -> add
    org.apache.commons.math3.fraction.BigFraction add(int) -> add
    org.apache.commons.math3.fraction.BigFraction add(long) -> add
    org.apache.commons.math3.fraction.BigFraction add(org.apache.commons.math3.fraction.BigFraction) -> add
    java.math.BigDecimal bigDecimalValue() -> bigDecimalValue
    java.math.BigDecimal bigDecimalValue(int) -> bigDecimalValue
    java.math.BigDecimal bigDecimalValue(int,int) -> bigDecimalValue
    int compareTo(org.apache.commons.math3.fraction.BigFraction) -> compareTo
    org.apache.commons.math3.fraction.BigFraction divide(java.math.BigInteger) -> divide
    org.apache.commons.math3.fraction.BigFraction divide(int) -> divide
    org.apache.commons.math3.fraction.BigFraction divide(long) -> divide
    org.apache.commons.math3.fraction.BigFraction divide(org.apache.commons.math3.fraction.BigFraction) -> divide
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    float floatValue() -> floatValue
    java.math.BigInteger getDenominator() -> getDenominator
    int getDenominatorAsInt() -> getDenominatorAsInt
    long getDenominatorAsLong() -> getDenominatorAsLong
    java.math.BigInteger getNumerator() -> getNumerator
    int getNumeratorAsInt() -> getNumeratorAsInt
    long getNumeratorAsLong() -> getNumeratorAsLong
    int hashCode() -> hashCode
    int intValue() -> intValue
    long longValue() -> longValue
    org.apache.commons.math3.fraction.BigFraction multiply(java.math.BigInteger) -> multiply
    org.apache.commons.math3.fraction.BigFraction multiply(int) -> multiply
    org.apache.commons.math3.fraction.BigFraction multiply(long) -> multiply
    org.apache.commons.math3.fraction.BigFraction multiply(org.apache.commons.math3.fraction.BigFraction) -> multiply
    org.apache.commons.math3.fraction.BigFraction negate() -> negate
    double percentageValue() -> percentageValue
    org.apache.commons.math3.fraction.BigFraction pow(int) -> pow
    org.apache.commons.math3.fraction.BigFraction pow(long) -> pow
    org.apache.commons.math3.fraction.BigFraction pow(java.math.BigInteger) -> pow
    double pow(double) -> pow
    org.apache.commons.math3.fraction.BigFraction reciprocal() -> reciprocal
    org.apache.commons.math3.fraction.BigFraction reduce() -> reduce
    org.apache.commons.math3.fraction.BigFraction subtract(java.math.BigInteger) -> subtract
    org.apache.commons.math3.fraction.BigFraction subtract(int) -> subtract
    org.apache.commons.math3.fraction.BigFraction subtract(long) -> subtract
    org.apache.commons.math3.fraction.BigFraction subtract(org.apache.commons.math3.fraction.BigFraction) -> subtract
    java.lang.String toString() -> toString
    org.apache.commons.math3.fraction.BigFractionField getField() -> getField
    org.apache.commons.math3.Field getField() -> getField
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
org.apache.commons.math3.fraction.BigFractionField -> org.apache.commons.math3.fraction.BigFractionField:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    org.apache.commons.math3.fraction.BigFractionField getInstance() -> getInstance
    org.apache.commons.math3.fraction.BigFraction getOne() -> getOne
    org.apache.commons.math3.fraction.BigFraction getZero() -> getZero
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    java.lang.Object readResolve() -> readResolve
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
    void <init>(cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
org.apache.commons.math3.fraction.BigFractionField$LazyHolder -> gG:
    org.apache.commons.math3.fraction.BigFractionField INSTANCE -> a
    org.apache.commons.math3.fraction.BigFractionField access$000() -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.fraction.Fraction -> org.apache.commons.math3.fraction.Fraction:
    org.apache.commons.math3.fraction.Fraction TWO -> TWO
    org.apache.commons.math3.fraction.Fraction ONE -> ONE
    org.apache.commons.math3.fraction.Fraction ZERO -> ZERO
    org.apache.commons.math3.fraction.Fraction FOUR_FIFTHS -> FOUR_FIFTHS
    org.apache.commons.math3.fraction.Fraction ONE_FIFTH -> ONE_FIFTH
    org.apache.commons.math3.fraction.Fraction ONE_HALF -> ONE_HALF
    org.apache.commons.math3.fraction.Fraction ONE_QUARTER -> ONE_QUARTER
    org.apache.commons.math3.fraction.Fraction ONE_THIRD -> ONE_THIRD
    org.apache.commons.math3.fraction.Fraction THREE_FIFTHS -> THREE_FIFTHS
    org.apache.commons.math3.fraction.Fraction THREE_QUARTERS -> THREE_QUARTERS
    org.apache.commons.math3.fraction.Fraction TWO_FIFTHS -> TWO_FIFTHS
    org.apache.commons.math3.fraction.Fraction TWO_QUARTERS -> TWO_QUARTERS
    org.apache.commons.math3.fraction.Fraction TWO_THIRDS -> TWO_THIRDS
    org.apache.commons.math3.fraction.Fraction MINUS_ONE -> MINUS_ONE
    long serialVersionUID -> serialVersionUID
    int denominator -> denominator
    int numerator -> numerator
    void <init>(double) -> <init>
    void <init>(double,double,int) -> <init>
    void <init>(double,int) -> <init>
    void <init>(double,double,int,int) -> <init>
    void <init>(int) -> <init>
    void <init>(int,int) -> <init>
    org.apache.commons.math3.fraction.Fraction abs() -> abs
    int compareTo(org.apache.commons.math3.fraction.Fraction) -> compareTo
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    float floatValue() -> floatValue
    int getDenominator() -> getDenominator
    int getNumerator() -> getNumerator
    int hashCode() -> hashCode
    int intValue() -> intValue
    long longValue() -> longValue
    org.apache.commons.math3.fraction.Fraction negate() -> negate
    org.apache.commons.math3.fraction.Fraction reciprocal() -> reciprocal
    org.apache.commons.math3.fraction.Fraction add(org.apache.commons.math3.fraction.Fraction) -> add
    org.apache.commons.math3.fraction.Fraction add(int) -> add
    org.apache.commons.math3.fraction.Fraction subtract(org.apache.commons.math3.fraction.Fraction) -> subtract
    org.apache.commons.math3.fraction.Fraction subtract(int) -> subtract
    org.apache.commons.math3.fraction.Fraction addSub(org.apache.commons.math3.fraction.Fraction,boolean) -> a
    org.apache.commons.math3.fraction.Fraction multiply(org.apache.commons.math3.fraction.Fraction) -> multiply
    org.apache.commons.math3.fraction.Fraction multiply(int) -> multiply
    org.apache.commons.math3.fraction.Fraction divide(org.apache.commons.math3.fraction.Fraction) -> divide
    org.apache.commons.math3.fraction.Fraction divide(int) -> divide
    double percentageValue() -> percentageValue
    org.apache.commons.math3.fraction.Fraction getReducedFraction(int,int) -> getReducedFraction
    java.lang.String toString() -> toString
    org.apache.commons.math3.fraction.FractionField getField() -> getField
    org.apache.commons.math3.Field getField() -> getField
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
org.apache.commons.math3.fraction.FractionConversionException -> org.apache.commons.math3.fraction.FractionConversionException:
    long serialVersionUID -> serialVersionUID
    void <init>(double,int) -> <init>
    void <init>(double,long,long) -> <init>
org.apache.commons.math3.fraction.FractionField -> org.apache.commons.math3.fraction.FractionField:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    org.apache.commons.math3.fraction.FractionField getInstance() -> getInstance
    org.apache.commons.math3.fraction.Fraction getOne() -> getOne
    org.apache.commons.math3.fraction.Fraction getZero() -> getZero
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    java.lang.Object readResolve() -> readResolve
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
    void <init>(cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
org.apache.commons.math3.fraction.FractionField$LazyHolder -> gH:
    org.apache.commons.math3.fraction.FractionField INSTANCE -> a
    org.apache.commons.math3.fraction.FractionField access$000() -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.linear.AbstractFieldMatrix -> gI:
    org.apache.commons.math3.Field field -> field
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.Field) -> <init>
    void <init>(org.apache.commons.math3.Field,int,int) -> <init>
    org.apache.commons.math3.Field extractField(org.apache.commons.math3.FieldElement[][]) -> extractField
    org.apache.commons.math3.Field extractField(org.apache.commons.math3.FieldElement[]) -> extractField
    org.apache.commons.math3.FieldElement[][] buildArray(org.apache.commons.math3.Field,int,int) -> buildArray
    org.apache.commons.math3.FieldElement[] buildArray(org.apache.commons.math3.Field,int) -> buildArray
    org.apache.commons.math3.Field getField() -> getField
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.FieldMatrix copy() -> copy
    org.apache.commons.math3.linear.FieldMatrix add(org.apache.commons.math3.linear.FieldMatrix) -> add
    org.apache.commons.math3.linear.FieldMatrix subtract(org.apache.commons.math3.linear.FieldMatrix) -> subtract
    org.apache.commons.math3.linear.FieldMatrix scalarAdd(org.apache.commons.math3.FieldElement) -> scalarAdd
    org.apache.commons.math3.linear.FieldMatrix scalarMultiply(org.apache.commons.math3.FieldElement) -> scalarMultiply
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> multiply
    org.apache.commons.math3.linear.FieldMatrix preMultiply(org.apache.commons.math3.linear.FieldMatrix) -> preMultiply
    org.apache.commons.math3.linear.FieldMatrix power(int) -> power
    org.apache.commons.math3.FieldElement[][] getData() -> getData
    org.apache.commons.math3.linear.FieldMatrix getSubMatrix(int,int,int,int) -> getSubMatrix
    org.apache.commons.math3.linear.FieldMatrix getSubMatrix(int[],int[]) -> getSubMatrix
    void copySubMatrix(int,int,int,int,org.apache.commons.math3.FieldElement[][]) -> copySubMatrix
    void copySubMatrix(int[],int[],org.apache.commons.math3.FieldElement[][]) -> copySubMatrix
    void setSubMatrix(org.apache.commons.math3.FieldElement[][],int,int) -> setSubMatrix
    org.apache.commons.math3.linear.FieldMatrix getRowMatrix(int) -> getRowMatrix
    void setRowMatrix(int,org.apache.commons.math3.linear.FieldMatrix) -> setRowMatrix
    org.apache.commons.math3.linear.FieldMatrix getColumnMatrix(int) -> getColumnMatrix
    void setColumnMatrix(int,org.apache.commons.math3.linear.FieldMatrix) -> setColumnMatrix
    org.apache.commons.math3.linear.FieldVector getRowVector(int) -> getRowVector
    void setRowVector(int,org.apache.commons.math3.linear.FieldVector) -> setRowVector
    org.apache.commons.math3.linear.FieldVector getColumnVector(int) -> getColumnVector
    void setColumnVector(int,org.apache.commons.math3.linear.FieldVector) -> setColumnVector
    org.apache.commons.math3.FieldElement[] getRow(int) -> getRow
    void setRow(int,org.apache.commons.math3.FieldElement[]) -> setRow
    org.apache.commons.math3.FieldElement[] getColumn(int) -> getColumn
    void setColumn(int,org.apache.commons.math3.FieldElement[]) -> setColumn
    org.apache.commons.math3.FieldElement getEntry(int,int) -> getEntry
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> setEntry
    void addToEntry(int,int,org.apache.commons.math3.FieldElement) -> addToEntry
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> multiplyEntry
    org.apache.commons.math3.linear.FieldMatrix transpose() -> transpose
    boolean isSquare() -> isSquare
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    org.apache.commons.math3.FieldElement getTrace() -> getTrace
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> operate
    org.apache.commons.math3.linear.FieldVector operate(org.apache.commons.math3.linear.FieldVector) -> operate
    org.apache.commons.math3.FieldElement[] preMultiply(org.apache.commons.math3.FieldElement[]) -> preMultiply
    org.apache.commons.math3.linear.FieldVector preMultiply(org.apache.commons.math3.linear.FieldVector) -> preMultiply
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInColumnOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor) -> walkInColumnOrder
    org.apache.commons.math3.FieldElement walkInColumnOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor) -> walkInColumnOrder
    org.apache.commons.math3.FieldElement walkInColumnOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInColumnOrder
    org.apache.commons.math3.FieldElement walkInColumnOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInColumnOrder
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor) -> walkInOptimizedOrder
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor) -> walkInOptimizedOrder
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInOptimizedOrder
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInOptimizedOrder
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void checkRowIndex(int) -> checkRowIndex
    void checkColumnIndex(int) -> checkColumnIndex
    void checkSubMatrixIndex(int,int,int,int) -> checkSubMatrixIndex
    void checkSubMatrixIndex(int[],int[]) -> checkSubMatrixIndex
    void checkAdditionCompatible(org.apache.commons.math3.linear.FieldMatrix) -> checkAdditionCompatible
    void checkSubtractionCompatible(org.apache.commons.math3.linear.FieldMatrix) -> checkSubtractionCompatible
    void checkMultiplicationCompatible(org.apache.commons.math3.linear.FieldMatrix) -> checkMultiplicationCompatible
org.apache.commons.math3.linear.AbstractFieldMatrix$1 -> gJ:
    int[] val$selectedRows -> a
    int[] val$selectedColumns -> b
    org.apache.commons.math3.linear.AbstractFieldMatrix this$0 -> a
    void <init>(org.apache.commons.math3.linear.AbstractFieldMatrix,org.apache.commons.math3.FieldElement,int[],int[]) -> <init>
    org.apache.commons.math3.FieldElement visit(int,int,org.apache.commons.math3.FieldElement) -> a
org.apache.commons.math3.linear.AbstractFieldMatrix$2 -> gK:
    int startRow -> a
    int startColumn -> b
    org.apache.commons.math3.FieldElement[][] val$destination -> a
    void <init>(org.apache.commons.math3.linear.AbstractFieldMatrix,org.apache.commons.math3.FieldElement,org.apache.commons.math3.FieldElement[][]) -> <init>
    void start$6046c8d5(int,int) -> a
    void visit(int,int,org.apache.commons.math3.FieldElement) -> a
org.apache.commons.math3.linear.AbstractFieldMatrix$3 -> gL:
    org.apache.commons.math3.linear.FieldMatrix val$out -> a
    void <init>(org.apache.commons.math3.linear.AbstractFieldMatrix,org.apache.commons.math3.FieldElement,org.apache.commons.math3.linear.FieldMatrix) -> <init>
    void visit(int,int,org.apache.commons.math3.FieldElement) -> a
org.apache.commons.math3.linear.AbstractRealMatrix -> gM:
    org.apache.commons.math3.linear.RealMatrixFormat DEFAULT_FORMAT -> a
    void <init>() -> <init>
    void <init>(int,int) -> <init>
    org.apache.commons.math3.linear.RealMatrix add(org.apache.commons.math3.linear.RealMatrix) -> add
    org.apache.commons.math3.linear.RealMatrix subtract(org.apache.commons.math3.linear.RealMatrix) -> subtract
    org.apache.commons.math3.linear.RealMatrix scalarAdd(double) -> scalarAdd
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> scalarMultiply
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> multiply
    org.apache.commons.math3.linear.RealMatrix preMultiply(org.apache.commons.math3.linear.RealMatrix) -> preMultiply
    org.apache.commons.math3.linear.RealMatrix power(int) -> power
    double[][] getData() -> getData
    double getNorm() -> getNorm
    double getFrobeniusNorm() -> getFrobeniusNorm
    org.apache.commons.math3.linear.RealMatrix getSubMatrix(int,int,int,int) -> getSubMatrix
    org.apache.commons.math3.linear.RealMatrix getSubMatrix(int[],int[]) -> getSubMatrix
    void copySubMatrix(int,int,int,int,double[][]) -> copySubMatrix
    void copySubMatrix(int[],int[],double[][]) -> copySubMatrix
    void setSubMatrix(double[][],int,int) -> setSubMatrix
    org.apache.commons.math3.linear.RealMatrix getRowMatrix(int) -> getRowMatrix
    void setRowMatrix(int,org.apache.commons.math3.linear.RealMatrix) -> setRowMatrix
    org.apache.commons.math3.linear.RealMatrix getColumnMatrix(int) -> getColumnMatrix
    void setColumnMatrix(int,org.apache.commons.math3.linear.RealMatrix) -> setColumnMatrix
    org.apache.commons.math3.linear.RealVector getRowVector(int) -> getRowVector
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> setRowVector
    org.apache.commons.math3.linear.RealVector getColumnVector(int) -> getColumnVector
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> setColumnVector
    double[] getRow(int) -> getRow
    void setRow(int,double[]) -> setRow
    double[] getColumn(int) -> getColumn
    void setColumn(int,double[]) -> setColumn
    void addToEntry(int,int,double) -> addToEntry
    void multiplyEntry(int,int,double) -> multiplyEntry
    org.apache.commons.math3.linear.RealMatrix transpose() -> transpose
    boolean isSquare() -> isSquare
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    double getTrace() -> getTrace
    double[] operate(double[]) -> operate
    org.apache.commons.math3.linear.RealVector operate(org.apache.commons.math3.linear.RealVector) -> operate
    double[] preMultiply(double[]) -> preMultiply
    org.apache.commons.math3.linear.RealVector preMultiply(org.apache.commons.math3.linear.RealVector) -> preMultiply
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    double walkInColumnOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor) -> walkInColumnOrder
    double walkInColumnOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> walkInColumnOrder
    double walkInColumnOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor,int,int,int,int) -> walkInColumnOrder
    double walkInColumnOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor,int,int,int,int) -> walkInColumnOrder
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor) -> walkInOptimizedOrder
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> walkInOptimizedOrder
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor,int,int,int,int) -> walkInOptimizedOrder
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor,int,int,int,int) -> walkInOptimizedOrder
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.RealMatrix copy() -> copy
    double getEntry(int,int) -> getEntry
    void setEntry(int,int,double) -> setEntry
    void <clinit>() -> <clinit>
org.apache.commons.math3.linear.AbstractRealMatrix$1 -> gN:
    double endRow -> a
    double columnSum -> b
    double maxColSum -> c
    void <init>(org.apache.commons.math3.linear.AbstractRealMatrix) -> <init>
    void start$6046c8d5(int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math3.linear.AbstractRealMatrix$2 -> gO:
    double sum -> a
    void <init>(org.apache.commons.math3.linear.AbstractRealMatrix) -> <init>
    void start$6046c8d5(int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math3.linear.AbstractRealMatrix$3 -> gP:
    int[] val$selectedRows -> a
    int[] val$selectedColumns -> b
    org.apache.commons.math3.linear.AbstractRealMatrix this$0 -> a
    void <init>(org.apache.commons.math3.linear.AbstractRealMatrix,int[],int[]) -> <init>
    double visit(int,int,double) -> a
org.apache.commons.math3.linear.AbstractRealMatrix$4 -> gQ:
    int startRow -> a
    int startColumn -> b
    double[][] val$destination -> a
    void <init>(org.apache.commons.math3.linear.AbstractRealMatrix,double[][]) -> <init>
    void start$6046c8d5(int,int,int) -> a
    void visit(int,int,double) -> a
org.apache.commons.math3.linear.AbstractRealMatrix$5 -> gR:
    org.apache.commons.math3.linear.RealMatrix val$out -> a
    void <init>(org.apache.commons.math3.linear.AbstractRealMatrix,org.apache.commons.math3.linear.RealMatrix) -> <init>
    void visit(int,int,double) -> a
org.apache.commons.math3.linear.AnyMatrix -> gS:
    boolean isSquare() -> isSquare
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
org.apache.commons.math3.linear.Array2DRowFieldMatrix -> org.apache.commons.math3.linear.Array2DRowFieldMatrix:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.FieldElement[][] data -> data
    void <init>(org.apache.commons.math3.Field) -> <init>
    void <init>(org.apache.commons.math3.Field,int,int) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[][]) -> <init>
    void <init>(org.apache.commons.math3.Field,org.apache.commons.math3.FieldElement[][]) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[][],boolean) -> <init>
    void <init>(org.apache.commons.math3.Field,org.apache.commons.math3.FieldElement[][],boolean) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[]) -> <init>
    void <init>(org.apache.commons.math3.Field,org.apache.commons.math3.FieldElement[]) -> <init>
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.FieldMatrix copy() -> copy
    org.apache.commons.math3.linear.Array2DRowFieldMatrix add(org.apache.commons.math3.linear.Array2DRowFieldMatrix) -> add
    org.apache.commons.math3.linear.Array2DRowFieldMatrix subtract(org.apache.commons.math3.linear.Array2DRowFieldMatrix) -> subtract
    org.apache.commons.math3.linear.Array2DRowFieldMatrix multiply(org.apache.commons.math3.linear.Array2DRowFieldMatrix) -> multiply
    org.apache.commons.math3.FieldElement[][] getData() -> getData
    org.apache.commons.math3.FieldElement[][] getDataRef() -> getDataRef
    void setSubMatrix(org.apache.commons.math3.FieldElement[][],int,int) -> setSubMatrix
    org.apache.commons.math3.FieldElement getEntry(int,int) -> getEntry
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> setEntry
    void addToEntry(int,int,org.apache.commons.math3.FieldElement) -> addToEntry
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> multiplyEntry
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> operate
    org.apache.commons.math3.FieldElement[] preMultiply(org.apache.commons.math3.FieldElement[]) -> preMultiply
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInColumnOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor) -> walkInColumnOrder
    org.apache.commons.math3.FieldElement walkInColumnOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor) -> walkInColumnOrder
    org.apache.commons.math3.FieldElement walkInColumnOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInColumnOrder
    org.apache.commons.math3.FieldElement walkInColumnOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInColumnOrder
    org.apache.commons.math3.FieldElement[][] copyOut() -> a
org.apache.commons.math3.linear.Array2DRowRealMatrix -> org.apache.commons.math3.linear.Array2DRowRealMatrix:
    long serialVersionUID -> serialVersionUID
    double[][] data -> data
    void <init>() -> <init>
    void <init>(int,int) -> <init>
    void <init>(double[][]) -> <init>
    void <init>(double[][],boolean) -> <init>
    void <init>(double[]) -> <init>
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.RealMatrix copy() -> copy
    org.apache.commons.math3.linear.Array2DRowRealMatrix add(org.apache.commons.math3.linear.Array2DRowRealMatrix) -> add
    org.apache.commons.math3.linear.Array2DRowRealMatrix subtract(org.apache.commons.math3.linear.Array2DRowRealMatrix) -> subtract
    org.apache.commons.math3.linear.Array2DRowRealMatrix multiply(org.apache.commons.math3.linear.Array2DRowRealMatrix) -> multiply
    double[][] getData() -> getData
    double[][] getDataRef() -> getDataRef
    void setSubMatrix(double[][],int,int) -> setSubMatrix
    double getEntry(int,int) -> getEntry
    void setEntry(int,int,double) -> setEntry
    void addToEntry(int,int,double) -> addToEntry
    void multiplyEntry(int,int,double) -> multiplyEntry
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    double[] operate(double[]) -> operate
    double[] preMultiply(double[]) -> preMultiply
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    double walkInColumnOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor) -> walkInColumnOrder
    double walkInColumnOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> walkInColumnOrder
    double walkInColumnOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor,int,int,int,int) -> walkInColumnOrder
    double walkInColumnOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor,int,int,int,int) -> walkInColumnOrder
    double[][] copyOut() -> a
org.apache.commons.math3.linear.ArrayFieldVector -> org.apache.commons.math3.linear.ArrayFieldVector:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.FieldElement[] data -> data
    org.apache.commons.math3.Field field -> field
    void <init>(org.apache.commons.math3.Field) -> <init>
    void <init>(org.apache.commons.math3.Field,int) -> <init>
    void <init>(int,org.apache.commons.math3.FieldElement) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[]) -> <init>
    void <init>(org.apache.commons.math3.Field,org.apache.commons.math3.FieldElement[]) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[],boolean) -> <init>
    void <init>(org.apache.commons.math3.Field,org.apache.commons.math3.FieldElement[],boolean) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[],int,int) -> <init>
    void <init>(org.apache.commons.math3.Field,org.apache.commons.math3.FieldElement[],int,int) -> <init>
    void <init>(org.apache.commons.math3.linear.FieldVector) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayFieldVector) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayFieldVector,boolean) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayFieldVector,org.apache.commons.math3.linear.ArrayFieldVector) -> <init>
    void <init>(org.apache.commons.math3.linear.FieldVector,org.apache.commons.math3.linear.FieldVector) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayFieldVector,org.apache.commons.math3.FieldElement[]) -> <init>
    void <init>(org.apache.commons.math3.linear.FieldVector,org.apache.commons.math3.FieldElement[]) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[],org.apache.commons.math3.linear.ArrayFieldVector) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[],org.apache.commons.math3.linear.FieldVector) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[],org.apache.commons.math3.FieldElement[]) -> <init>
    void <init>(org.apache.commons.math3.Field,org.apache.commons.math3.FieldElement[],org.apache.commons.math3.FieldElement[]) -> <init>
    org.apache.commons.math3.Field getField() -> getField
    org.apache.commons.math3.linear.FieldVector copy() -> copy
    org.apache.commons.math3.linear.FieldVector add(org.apache.commons.math3.linear.FieldVector) -> add
    org.apache.commons.math3.linear.ArrayFieldVector add(org.apache.commons.math3.linear.ArrayFieldVector) -> add
    org.apache.commons.math3.linear.FieldVector subtract(org.apache.commons.math3.linear.FieldVector) -> subtract
    org.apache.commons.math3.linear.ArrayFieldVector subtract(org.apache.commons.math3.linear.ArrayFieldVector) -> subtract
    org.apache.commons.math3.linear.FieldVector mapAdd(org.apache.commons.math3.FieldElement) -> mapAdd
    org.apache.commons.math3.linear.FieldVector mapAddToSelf(org.apache.commons.math3.FieldElement) -> mapAddToSelf
    org.apache.commons.math3.linear.FieldVector mapSubtract(org.apache.commons.math3.FieldElement) -> mapSubtract
    org.apache.commons.math3.linear.FieldVector mapSubtractToSelf(org.apache.commons.math3.FieldElement) -> mapSubtractToSelf
    org.apache.commons.math3.linear.FieldVector mapMultiply(org.apache.commons.math3.FieldElement) -> mapMultiply
    org.apache.commons.math3.linear.FieldVector mapMultiplyToSelf(org.apache.commons.math3.FieldElement) -> mapMultiplyToSelf
    org.apache.commons.math3.linear.FieldVector mapDivide(org.apache.commons.math3.FieldElement) -> mapDivide
    org.apache.commons.math3.linear.FieldVector mapDivideToSelf(org.apache.commons.math3.FieldElement) -> mapDivideToSelf
    org.apache.commons.math3.linear.FieldVector mapInv() -> mapInv
    org.apache.commons.math3.linear.FieldVector mapInvToSelf() -> mapInvToSelf
    org.apache.commons.math3.linear.FieldVector ebeMultiply(org.apache.commons.math3.linear.FieldVector) -> ebeMultiply
    org.apache.commons.math3.linear.ArrayFieldVector ebeMultiply(org.apache.commons.math3.linear.ArrayFieldVector) -> ebeMultiply
    org.apache.commons.math3.linear.FieldVector ebeDivide(org.apache.commons.math3.linear.FieldVector) -> ebeDivide
    org.apache.commons.math3.linear.ArrayFieldVector ebeDivide(org.apache.commons.math3.linear.ArrayFieldVector) -> ebeDivide
    org.apache.commons.math3.FieldElement[] getData() -> getData
    org.apache.commons.math3.FieldElement[] getDataRef() -> getDataRef
    org.apache.commons.math3.FieldElement dotProduct(org.apache.commons.math3.linear.FieldVector) -> dotProduct
    org.apache.commons.math3.FieldElement dotProduct(org.apache.commons.math3.linear.ArrayFieldVector) -> dotProduct
    org.apache.commons.math3.linear.FieldVector projection(org.apache.commons.math3.linear.FieldVector) -> projection
    org.apache.commons.math3.linear.ArrayFieldVector projection(org.apache.commons.math3.linear.ArrayFieldVector) -> projection
    org.apache.commons.math3.linear.FieldMatrix outerProduct(org.apache.commons.math3.linear.FieldVector) -> outerProduct
    org.apache.commons.math3.linear.FieldMatrix outerProduct(org.apache.commons.math3.linear.ArrayFieldVector) -> outerProduct
    org.apache.commons.math3.FieldElement getEntry(int) -> getEntry
    int getDimension() -> getDimension
    org.apache.commons.math3.linear.FieldVector append(org.apache.commons.math3.linear.FieldVector) -> append
    org.apache.commons.math3.linear.ArrayFieldVector append(org.apache.commons.math3.linear.ArrayFieldVector) -> append
    org.apache.commons.math3.linear.FieldVector append(org.apache.commons.math3.FieldElement) -> append
    org.apache.commons.math3.linear.FieldVector getSubVector(int,int) -> getSubVector
    void setEntry(int,org.apache.commons.math3.FieldElement) -> setEntry
    void setSubVector(int,org.apache.commons.math3.linear.FieldVector) -> setSubVector
    void set(int,org.apache.commons.math3.linear.ArrayFieldVector) -> set
    void set(org.apache.commons.math3.FieldElement) -> set
    org.apache.commons.math3.FieldElement[] toArray() -> toArray
    void checkVectorDimensions(org.apache.commons.math3.linear.FieldVector) -> checkVectorDimensions
    void checkVectorDimensions(int) -> checkVectorDimensions
    org.apache.commons.math3.FieldElement walkInDefaultOrder$709d5821(edu.jas.poly.RelationGenerator) -> walkInDefaultOrder$709d5821
    org.apache.commons.math3.FieldElement walkInDefaultOrder$71c2f03f(edu.jas.poly.RelationGenerator,int,int) -> walkInDefaultOrder$71c2f03f
    org.apache.commons.math3.FieldElement walkInOptimizedOrder$709d5821(edu.jas.poly.RelationGenerator) -> walkInOptimizedOrder$709d5821
    org.apache.commons.math3.FieldElement walkInOptimizedOrder$71c2f03f(edu.jas.poly.RelationGenerator,int,int) -> walkInOptimizedOrder$71c2f03f
    org.apache.commons.math3.FieldElement walkInDefaultOrder$3b1c077b(edu.jas.poly.RelationGenerator) -> walkInDefaultOrder$3b1c077b
    org.apache.commons.math3.FieldElement walkInDefaultOrder$14a2d8db(edu.jas.poly.RelationGenerator,int,int) -> walkInDefaultOrder$14a2d8db
    org.apache.commons.math3.FieldElement walkInOptimizedOrder$3b1c077b(edu.jas.poly.RelationGenerator) -> walkInOptimizedOrder$3b1c077b
    org.apache.commons.math3.FieldElement walkInOptimizedOrder$14a2d8db(edu.jas.poly.RelationGenerator,int,int) -> walkInOptimizedOrder$14a2d8db
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void checkIndex(int) -> a
    void checkIndices(int,int) -> a
org.apache.commons.math3.linear.ArrayRealVector -> org.apache.commons.math3.linear.ArrayRealVector:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.linear.RealVectorFormat DEFAULT_FORMAT -> a
    double[] data -> data
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(int,double) -> <init>
    void <init>(double[]) -> <init>
    void <init>(double[],boolean) -> <init>
    void <init>(double[],int,int) -> <init>
    void <init>(java.lang.Double[]) -> <init>
    void <init>(java.lang.Double[],int,int) -> <init>
    void <init>(org.apache.commons.math3.linear.RealVector) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayRealVector) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayRealVector,boolean) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayRealVector,org.apache.commons.math3.linear.ArrayRealVector) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayRealVector,org.apache.commons.math3.linear.RealVector) -> <init>
    void <init>(org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.linear.ArrayRealVector) -> <init>
    void <init>(org.apache.commons.math3.linear.ArrayRealVector,double[]) -> <init>
    void <init>(double[],org.apache.commons.math3.linear.ArrayRealVector) -> <init>
    void <init>(double[],double[]) -> <init>
    org.apache.commons.math3.linear.ArrayRealVector copy() -> copy
    org.apache.commons.math3.linear.ArrayRealVector add(org.apache.commons.math3.linear.RealVector) -> add
    org.apache.commons.math3.linear.ArrayRealVector subtract(org.apache.commons.math3.linear.RealVector) -> subtract
    org.apache.commons.math3.linear.ArrayRealVector map(org.apache.commons.math3.analysis.UnivariateFunction) -> map
    org.apache.commons.math3.linear.ArrayRealVector mapToSelf(org.apache.commons.math3.analysis.UnivariateFunction) -> mapToSelf
    org.apache.commons.math3.linear.RealVector mapAddToSelf(double) -> mapAddToSelf
    org.apache.commons.math3.linear.RealVector mapSubtractToSelf(double) -> mapSubtractToSelf
    org.apache.commons.math3.linear.RealVector mapMultiplyToSelf(double) -> mapMultiplyToSelf
    org.apache.commons.math3.linear.RealVector mapDivideToSelf(double) -> mapDivideToSelf
    org.apache.commons.math3.linear.ArrayRealVector ebeMultiply(org.apache.commons.math3.linear.RealVector) -> ebeMultiply
    org.apache.commons.math3.linear.ArrayRealVector ebeDivide(org.apache.commons.math3.linear.RealVector) -> ebeDivide
    double[] getDataRef() -> getDataRef
    double dotProduct(org.apache.commons.math3.linear.RealVector) -> dotProduct
    double getNorm() -> getNorm
    double getL1Norm() -> getL1Norm
    double getLInfNorm() -> getLInfNorm
    double getDistance(org.apache.commons.math3.linear.RealVector) -> getDistance
    double getL1Distance(org.apache.commons.math3.linear.RealVector) -> getL1Distance
    double getLInfDistance(org.apache.commons.math3.linear.RealVector) -> getLInfDistance
    org.apache.commons.math3.linear.RealMatrix outerProduct(org.apache.commons.math3.linear.RealVector) -> outerProduct
    double getEntry(int) -> getEntry
    int getDimension() -> getDimension
    org.apache.commons.math3.linear.RealVector append(org.apache.commons.math3.linear.RealVector) -> append
    org.apache.commons.math3.linear.ArrayRealVector append(org.apache.commons.math3.linear.ArrayRealVector) -> append
    org.apache.commons.math3.linear.RealVector append(double) -> append
    org.apache.commons.math3.linear.RealVector getSubVector(int,int) -> getSubVector
    void setEntry(int,double) -> setEntry
    void addToEntry(int,double) -> addToEntry
    void setSubVector(int,org.apache.commons.math3.linear.RealVector) -> setSubVector
    void setSubVector(int,double[]) -> setSubVector
    void set(double) -> set
    double[] toArray() -> toArray
    java.lang.String toString() -> toString
    void checkVectorDimensions(org.apache.commons.math3.linear.RealVector) -> checkVectorDimensions
    void checkVectorDimensions(int) -> checkVectorDimensions
    boolean isNaN() -> isNaN
    boolean isInfinite() -> isInfinite
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.linear.ArrayRealVector combine(double,double,org.apache.commons.math3.linear.RealVector) -> combine
    org.apache.commons.math3.linear.ArrayRealVector combineToSelf(double,double,org.apache.commons.math3.linear.RealVector) -> combineToSelf
    double walkInDefaultOrder$5d3267c1(edu.jas.poly.RelationGenerator) -> walkInDefaultOrder$5d3267c1
    double walkInDefaultOrder$25d7285f(edu.jas.poly.RelationGenerator,int,int) -> walkInDefaultOrder$25d7285f
    double walkInOptimizedOrder$5d3267c1(edu.jas.poly.RelationGenerator) -> walkInOptimizedOrder$5d3267c1
    double walkInOptimizedOrder$25d7285f(edu.jas.poly.RelationGenerator,int,int) -> walkInOptimizedOrder$25d7285f
    double walkInDefaultOrder$27435cdd(edu.jas.poly.RelationGenerator) -> walkInDefaultOrder$27435cdd
    double walkInDefaultOrder$63d0f5bd(edu.jas.poly.RelationGenerator,int,int) -> walkInDefaultOrder$63d0f5bd
    double walkInOptimizedOrder$27435cdd(edu.jas.poly.RelationGenerator) -> walkInOptimizedOrder$27435cdd
    double walkInOptimizedOrder$63d0f5bd(edu.jas.poly.RelationGenerator,int,int) -> walkInOptimizedOrder$63d0f5bd
    org.apache.commons.math3.linear.RealVector combineToSelf(double,double,org.apache.commons.math3.linear.RealVector) -> combineToSelf
    org.apache.commons.math3.linear.RealVector combine(double,double,org.apache.commons.math3.linear.RealVector) -> combine
    org.apache.commons.math3.linear.RealVector mapToSelf(org.apache.commons.math3.analysis.UnivariateFunction) -> mapToSelf
    org.apache.commons.math3.linear.RealVector map(org.apache.commons.math3.analysis.UnivariateFunction) -> map
    org.apache.commons.math3.linear.RealVector ebeMultiply(org.apache.commons.math3.linear.RealVector) -> ebeMultiply
    org.apache.commons.math3.linear.RealVector ebeDivide(org.apache.commons.math3.linear.RealVector) -> ebeDivide
    org.apache.commons.math3.linear.RealVector copy() -> copy
    org.apache.commons.math3.linear.RealVector subtract(org.apache.commons.math3.linear.RealVector) -> subtract
    org.apache.commons.math3.linear.RealVector add(org.apache.commons.math3.linear.RealVector) -> add
    void <clinit>() -> <clinit>
org.apache.commons.math3.linear.BlockFieldMatrix -> org.apache.commons.math3.linear.BlockFieldMatrix:
    int BLOCK_SIZE -> BLOCK_SIZE
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.FieldElement[][] blocks -> blocks
    int rows -> rows
    int columns -> columns
    int blockRows -> blockRows
    int blockColumns -> blockColumns
    void <init>(org.apache.commons.math3.Field,int,int) -> <init>
    void <init>(org.apache.commons.math3.FieldElement[][]) -> <init>
    void <init>(int,int,org.apache.commons.math3.FieldElement[][],boolean) -> <init>
    org.apache.commons.math3.FieldElement[][] toBlocksLayout(org.apache.commons.math3.FieldElement[][]) -> toBlocksLayout
    org.apache.commons.math3.FieldElement[][] createBlocksLayout(org.apache.commons.math3.Field,int,int) -> createBlocksLayout
    org.apache.commons.math3.linear.FieldMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.FieldMatrix copy() -> copy
    org.apache.commons.math3.linear.FieldMatrix add(org.apache.commons.math3.linear.FieldMatrix) -> add
    org.apache.commons.math3.linear.BlockFieldMatrix add(org.apache.commons.math3.linear.BlockFieldMatrix) -> add
    org.apache.commons.math3.linear.FieldMatrix subtract(org.apache.commons.math3.linear.FieldMatrix) -> subtract
    org.apache.commons.math3.linear.BlockFieldMatrix subtract(org.apache.commons.math3.linear.BlockFieldMatrix) -> subtract
    org.apache.commons.math3.linear.FieldMatrix scalarAdd(org.apache.commons.math3.FieldElement) -> scalarAdd
    org.apache.commons.math3.linear.FieldMatrix scalarMultiply(org.apache.commons.math3.FieldElement) -> scalarMultiply
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> multiply
    org.apache.commons.math3.linear.BlockFieldMatrix multiply(org.apache.commons.math3.linear.BlockFieldMatrix) -> multiply
    org.apache.commons.math3.FieldElement[][] getData() -> getData
    org.apache.commons.math3.linear.FieldMatrix getSubMatrix(int,int,int,int) -> getSubMatrix
    void copyBlockPart(org.apache.commons.math3.FieldElement[],int,int,int,int,int,org.apache.commons.math3.FieldElement[],int,int,int) -> a
    void setSubMatrix(org.apache.commons.math3.FieldElement[][],int,int) -> setSubMatrix
    org.apache.commons.math3.linear.FieldMatrix getRowMatrix(int) -> getRowMatrix
    void setRowMatrix(int,org.apache.commons.math3.linear.FieldMatrix) -> setRowMatrix
    void setRowMatrix(int,org.apache.commons.math3.linear.BlockFieldMatrix) -> setRowMatrix
    org.apache.commons.math3.linear.FieldMatrix getColumnMatrix(int) -> getColumnMatrix
    void setColumnMatrix(int,org.apache.commons.math3.linear.FieldMatrix) -> setColumnMatrix
    void setColumnMatrix(int,org.apache.commons.math3.linear.BlockFieldMatrix) -> setColumnMatrix
    org.apache.commons.math3.linear.FieldVector getRowVector(int) -> getRowVector
    void setRowVector(int,org.apache.commons.math3.linear.FieldVector) -> setRowVector
    org.apache.commons.math3.linear.FieldVector getColumnVector(int) -> getColumnVector
    void setColumnVector(int,org.apache.commons.math3.linear.FieldVector) -> setColumnVector
    org.apache.commons.math3.FieldElement[] getRow(int) -> getRow
    void setRow(int,org.apache.commons.math3.FieldElement[]) -> setRow
    org.apache.commons.math3.FieldElement[] getColumn(int) -> getColumn
    void setColumn(int,org.apache.commons.math3.FieldElement[]) -> setColumn
    org.apache.commons.math3.FieldElement getEntry(int,int) -> getEntry
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> setEntry
    void addToEntry(int,int,org.apache.commons.math3.FieldElement) -> addToEntry
    void multiplyEntry(int,int,org.apache.commons.math3.FieldElement) -> multiplyEntry
    org.apache.commons.math3.linear.FieldMatrix transpose() -> transpose
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    org.apache.commons.math3.FieldElement[] operate(org.apache.commons.math3.FieldElement[]) -> operate
    org.apache.commons.math3.FieldElement[] preMultiply(org.apache.commons.math3.FieldElement[]) -> preMultiply
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInRowOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor) -> walkInOptimizedOrder
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor) -> walkInOptimizedOrder
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInOptimizedOrder
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInOptimizedOrder
    int blockHeight(int) -> a
    int blockWidth(int) -> b
org.apache.commons.math3.linear.BlockRealMatrix -> org.apache.commons.math3.linear.BlockRealMatrix:
    int BLOCK_SIZE -> BLOCK_SIZE
    long serialVersionUID -> serialVersionUID
    double[][] blocks -> blocks
    int rows -> rows
    int columns -> columns
    int blockRows -> blockRows
    int blockColumns -> blockColumns
    void <init>(int,int) -> <init>
    void <init>(double[][]) -> <init>
    void <init>(int,int,double[][],boolean) -> <init>
    double[][] toBlocksLayout(double[][]) -> toBlocksLayout
    double[][] createBlocksLayout(int,int) -> createBlocksLayout
    org.apache.commons.math3.linear.BlockRealMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.BlockRealMatrix copy() -> copy
    org.apache.commons.math3.linear.BlockRealMatrix add(org.apache.commons.math3.linear.RealMatrix) -> add
    org.apache.commons.math3.linear.BlockRealMatrix add(org.apache.commons.math3.linear.BlockRealMatrix) -> add
    org.apache.commons.math3.linear.BlockRealMatrix subtract(org.apache.commons.math3.linear.RealMatrix) -> subtract
    org.apache.commons.math3.linear.BlockRealMatrix subtract(org.apache.commons.math3.linear.BlockRealMatrix) -> subtract
    org.apache.commons.math3.linear.BlockRealMatrix scalarAdd(double) -> scalarAdd
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> scalarMultiply
    org.apache.commons.math3.linear.BlockRealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> multiply
    org.apache.commons.math3.linear.BlockRealMatrix multiply(org.apache.commons.math3.linear.BlockRealMatrix) -> multiply
    double[][] getData() -> getData
    double getNorm() -> getNorm
    double getFrobeniusNorm() -> getFrobeniusNorm
    org.apache.commons.math3.linear.BlockRealMatrix getSubMatrix(int,int,int,int) -> getSubMatrix
    void copyBlockPart(double[],int,int,int,int,int,double[],int,int,int) -> a
    void setSubMatrix(double[][],int,int) -> setSubMatrix
    org.apache.commons.math3.linear.BlockRealMatrix getRowMatrix(int) -> getRowMatrix
    void setRowMatrix(int,org.apache.commons.math3.linear.RealMatrix) -> setRowMatrix
    void setRowMatrix(int,org.apache.commons.math3.linear.BlockRealMatrix) -> setRowMatrix
    org.apache.commons.math3.linear.BlockRealMatrix getColumnMatrix(int) -> getColumnMatrix
    void setColumnMatrix(int,org.apache.commons.math3.linear.RealMatrix) -> setColumnMatrix
    void setColumnMatrix(int,org.apache.commons.math3.linear.BlockRealMatrix) -> setColumnMatrix
    org.apache.commons.math3.linear.RealVector getRowVector(int) -> getRowVector
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> setRowVector
    org.apache.commons.math3.linear.RealVector getColumnVector(int) -> getColumnVector
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> setColumnVector
    double[] getRow(int) -> getRow
    void setRow(int,double[]) -> setRow
    double[] getColumn(int) -> getColumn
    void setColumn(int,double[]) -> setColumn
    double getEntry(int,int) -> getEntry
    void setEntry(int,int,double) -> setEntry
    void addToEntry(int,int,double) -> addToEntry
    void multiplyEntry(int,int,double) -> multiplyEntry
    org.apache.commons.math3.linear.BlockRealMatrix transpose() -> transpose
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    double[] operate(double[]) -> operate
    double[] preMultiply(double[]) -> preMultiply
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    double walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor) -> walkInOptimizedOrder
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor) -> walkInOptimizedOrder
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor,int,int,int,int) -> walkInOptimizedOrder
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor,int,int,int,int) -> walkInOptimizedOrder
    int blockHeight(int) -> a
    int blockWidth(int) -> b
    org.apache.commons.math3.linear.RealMatrix copy() -> copy
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.RealMatrix transpose() -> transpose
    org.apache.commons.math3.linear.RealMatrix getColumnMatrix(int) -> getColumnMatrix
    org.apache.commons.math3.linear.RealMatrix getRowMatrix(int) -> getRowMatrix
    org.apache.commons.math3.linear.RealMatrix getSubMatrix(int,int,int,int) -> getSubMatrix
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> multiply
    org.apache.commons.math3.linear.RealMatrix scalarAdd(double) -> scalarAdd
    org.apache.commons.math3.linear.RealMatrix subtract(org.apache.commons.math3.linear.RealMatrix) -> subtract
    org.apache.commons.math3.linear.RealMatrix add(org.apache.commons.math3.linear.RealMatrix) -> add
org.apache.commons.math3.linear.DecompositionSolver -> gT:
    double[][] lu -> a
    int[] pivot -> a
    boolean singular -> a
    boolean isNonSingular() -> a
    org.apache.commons.math3.linear.RealMatrix getInverse() -> a
    void <init>(double[][],int[],boolean) -> <init>
    org.apache.commons.math3.linear.RealMatrix solve(org.apache.commons.math3.linear.RealMatrix) -> a
    void <init>(double[][],int[],boolean,byte) -> <init>
org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor -> gU:
    void <init>() -> <init>
    void start$6046c8d5(int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math3.linear.DiagonalMatrix -> org.apache.commons.math3.linear.DiagonalMatrix:
    long serialVersionUID -> serialVersionUID
    double[] data -> data
    void <init>(int) -> <init>
    void <init>(double[]) -> <init>
    void <init>(double[],boolean) -> <init>
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.RealMatrix copy() -> copy
    org.apache.commons.math3.linear.DiagonalMatrix add(org.apache.commons.math3.linear.DiagonalMatrix) -> add
    org.apache.commons.math3.linear.DiagonalMatrix subtract(org.apache.commons.math3.linear.DiagonalMatrix) -> subtract
    org.apache.commons.math3.linear.DiagonalMatrix multiply(org.apache.commons.math3.linear.DiagonalMatrix) -> multiply
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> multiply
    double[][] getData() -> getData
    double[] getDataRef() -> getDataRef
    double getEntry(int,int) -> getEntry
    void setEntry(int,int,double) -> setEntry
    void addToEntry(int,int,double) -> addToEntry
    void multiplyEntry(int,int,double) -> multiplyEntry
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    double[] operate(double[]) -> operate
    double[] preMultiply(double[]) -> preMultiply
    org.apache.commons.math3.linear.RealVector preMultiply(org.apache.commons.math3.linear.RealVector) -> preMultiply
    void ensureZero(double) -> a
    org.apache.commons.math3.linear.DiagonalMatrix inverse() -> inverse
    org.apache.commons.math3.linear.DiagonalMatrix inverse(double) -> inverse
    boolean isSingular(double) -> isSingular
org.apache.commons.math3.linear.EigenDecomposition -> gV:
    byte maxIter -> a
    double[] main -> b
    double[] secondary -> c
    org.apache.commons.math3.linear.TriDiagonalTransformer transformer -> a
    double[] realEigenvalues -> a
    double[] imagEigenvalues -> d
    org.apache.commons.math3.linear.ArrayRealVector[] eigenvectors -> a
    org.apache.commons.math3.linear.RealMatrix cachedV -> a
    org.apache.commons.math3.linear.RealMatrix cachedVt -> b
    boolean isSymmetric -> a
    void <init>(org.apache.commons.math3.linear.RealMatrix) -> <init>
    double[] getRealEigenvalues() -> a
    double[] getImagEigenvalues() -> b
    void findEigenVectors(double[][]) -> a
    org.apache.commons.math3.linear.SchurTransformer transformToSchur(org.apache.commons.math3.linear.RealMatrix) -> a
    org.apache.commons.math3.complex.Complex cdiv(double,double,double,double) -> a
    void findEigenVectorsFromSchur(org.apache.commons.math3.linear.SchurTransformer) -> a
org.apache.commons.math3.linear.FieldMatrix -> gW:
    org.apache.commons.math3.linear.FieldMatrix multiply(org.apache.commons.math3.linear.FieldMatrix) -> multiply
    org.apache.commons.math3.FieldElement getEntry(int,int) -> getEntry
    void setEntry(int,int,org.apache.commons.math3.FieldElement) -> setEntry
    org.apache.commons.math3.FieldElement walkInOptimizedOrder(org.apache.commons.math3.linear.FieldMatrixChangingVisitor) -> walkInOptimizedOrder
org.apache.commons.math3.linear.FieldMatrixChangingVisitor -> gX:
    org.apache.commons.math3.FieldElement zero -> a
    org.apache.commons.math3.FieldElement visit(int,int,org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.FieldElement end() -> a
    void <init>(org.apache.commons.math3.FieldElement) -> <init>
org.apache.commons.math3.linear.FieldMatrixPreservingVisitor -> gY:
    org.apache.commons.math3.FieldElement zero -> a
    void start$6046c8d5(int,int) -> a
    void visit(int,int,org.apache.commons.math3.FieldElement) -> a
    org.apache.commons.math3.FieldElement end() -> a
    void <init>(org.apache.commons.math3.FieldElement) -> <init>
org.apache.commons.math3.linear.FieldVector -> gZ:
    org.apache.commons.math3.Field getField() -> getField
    org.apache.commons.math3.linear.FieldVector mapMultiply(org.apache.commons.math3.FieldElement) -> mapMultiply
    org.apache.commons.math3.FieldElement dotProduct(org.apache.commons.math3.linear.FieldVector) -> dotProduct
    org.apache.commons.math3.FieldElement getEntry(int) -> getEntry
    int getDimension() -> getDimension
    org.apache.commons.math3.FieldElement[] toArray() -> toArray
org.apache.commons.math3.linear.HessenbergTransformer -> ha:
    double[][] householderVectors -> a
    double[] ort -> a
    org.apache.commons.math3.linear.RealMatrix cachedP -> a
    org.apache.commons.math3.linear.RealMatrix cachedH -> b
    void <init>(org.apache.commons.math3.linear.RealMatrix) -> <init>
    org.apache.commons.math3.linear.RealMatrix getP() -> a
    org.apache.commons.math3.linear.RealMatrix getH() -> b
    void transform() -> a
org.apache.commons.math3.linear.LUDecomposition -> hb:
    double[][] lu -> a
    int[] pivot -> a
    boolean even -> a
    boolean singular -> b
    void <init>(org.apache.commons.math3.linear.RealMatrix) -> <init>
    void <init>(org.apache.commons.math3.linear.RealMatrix,double) -> <init>
org.apache.commons.math3.linear.MatrixDimensionMismatchException -> org.apache.commons.math3.linear.MatrixDimensionMismatchException:
    long serialVersionUID -> serialVersionUID
    void <init>(int,int,int,int) -> <init>
    int getWrongRowDimension() -> getWrongRowDimension
    int getExpectedRowDimension() -> getExpectedRowDimension
    int getWrongColumnDimension() -> getWrongColumnDimension
    int getExpectedColumnDimension() -> getExpectedColumnDimension
org.apache.commons.math3.linear.MatrixUtils -> hc:
    org.apache.commons.math3.linear.RealMatrix createRealMatrix(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix createRealMatrix(double[][]) -> a
    org.apache.commons.math3.linear.RealMatrix createRealIdentityMatrix(int) -> a
    org.apache.commons.math3.linear.FieldMatrix createFieldIdentityMatrix(org.apache.commons.math3.Field,int) -> a
    org.apache.commons.math3.linear.RealMatrix createRealDiagonalMatrix(double[]) -> a
    org.apache.commons.math3.linear.RealVector createRealVector(double[]) -> a
    boolean isSymmetric(org.apache.commons.math3.linear.RealMatrix,double) -> a
    void checkMatrixIndex(org.apache.commons.math3.linear.AnyMatrix,int,int) -> a
    void checkRowIndex(org.apache.commons.math3.linear.AnyMatrix,int) -> a
    void checkColumnIndex(org.apache.commons.math3.linear.AnyMatrix,int) -> b
    void checkSubMatrixIndex(org.apache.commons.math3.linear.AnyMatrix,int,int,int,int) -> a
    void checkSubMatrixIndex(org.apache.commons.math3.linear.AnyMatrix,int[],int[]) -> a
    void checkAdditionCompatible(org.apache.commons.math3.linear.AnyMatrix,org.apache.commons.math3.linear.AnyMatrix) -> a
    void checkSubtractionCompatible(org.apache.commons.math3.linear.AnyMatrix,org.apache.commons.math3.linear.AnyMatrix) -> b
    void checkMultiplicationCompatible(org.apache.commons.math3.linear.AnyMatrix,org.apache.commons.math3.linear.AnyMatrix) -> c
    void serializeRealVector(org.apache.commons.math3.linear.RealVector,java.io.ObjectOutputStream) -> a
    void deserializeRealVector(java.lang.Object,java.lang.String,java.io.ObjectInputStream) -> a
    void serializeRealMatrix(org.apache.commons.math3.linear.RealMatrix,java.io.ObjectOutputStream) -> a
    void deserializeRealMatrix(java.lang.Object,java.lang.String,java.io.ObjectInputStream) -> b
    void <clinit>() -> <clinit>
org.apache.commons.math3.linear.NonSquareMatrixException -> org.apache.commons.math3.linear.NonSquareMatrixException:
    long serialVersionUID -> serialVersionUID
    void <init>(int,int) -> <init>
org.apache.commons.math3.linear.OpenMapRealMatrix -> org.apache.commons.math3.linear.OpenMapRealMatrix:
    long serialVersionUID -> serialVersionUID
    int rows -> rows
    int columns -> columns
    org.apache.commons.math3.util.OpenIntToDoubleHashMap entries -> entries
    void <init>(int,int) -> <init>
    void <init>(org.apache.commons.math3.linear.OpenMapRealMatrix) -> <init>
    org.apache.commons.math3.linear.OpenMapRealMatrix copy() -> copy
    org.apache.commons.math3.linear.OpenMapRealMatrix createMatrix(int,int) -> createMatrix
    int getColumnDimension() -> getColumnDimension
    org.apache.commons.math3.linear.OpenMapRealMatrix add(org.apache.commons.math3.linear.OpenMapRealMatrix) -> add
    org.apache.commons.math3.linear.OpenMapRealMatrix subtract(org.apache.commons.math3.linear.RealMatrix) -> subtract
    org.apache.commons.math3.linear.OpenMapRealMatrix subtract(org.apache.commons.math3.linear.OpenMapRealMatrix) -> subtract
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> multiply
    org.apache.commons.math3.linear.OpenMapRealMatrix multiply(org.apache.commons.math3.linear.OpenMapRealMatrix) -> multiply
    double getEntry(int,int) -> getEntry
    int getRowDimension() -> getRowDimension
    void setEntry(int,int,double) -> setEntry
    void addToEntry(int,int,double) -> addToEntry
    void multiplyEntry(int,int,double) -> multiplyEntry
    int computeKey(int,int) -> a
    org.apache.commons.math3.linear.RealMatrix copy() -> copy
    org.apache.commons.math3.linear.RealMatrix createMatrix(int,int) -> createMatrix
    org.apache.commons.math3.linear.RealMatrix subtract(org.apache.commons.math3.linear.RealMatrix) -> subtract
org.apache.commons.math3.linear.RealLinearOperator -> hd:
    void <init>() -> <init>
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    org.apache.commons.math3.linear.RealVector operate(org.apache.commons.math3.linear.RealVector) -> operate
    org.apache.commons.math3.linear.RealVector operateTranspose(org.apache.commons.math3.linear.RealVector) -> operateTranspose
    boolean isTransposable() -> isTransposable
org.apache.commons.math3.linear.RealMatrix -> he:
    org.apache.commons.math3.linear.RealMatrix scalarMultiply(double) -> scalarMultiply
    org.apache.commons.math3.linear.RealMatrix multiply(org.apache.commons.math3.linear.RealMatrix) -> multiply
    double[][] getData() -> getData
    void setRowVector(int,org.apache.commons.math3.linear.RealVector) -> setRowVector
    void setColumnVector(int,org.apache.commons.math3.linear.RealVector) -> setColumnVector
    double getEntry(int,int) -> getEntry
    void setEntry(int,int,double) -> setEntry
    org.apache.commons.math3.linear.RealMatrix transpose() -> transpose
    org.apache.commons.math3.linear.RealVector operate(org.apache.commons.math3.linear.RealVector) -> operate
    double walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixChangingVisitor) -> walkInOptimizedOrder
org.apache.commons.math3.linear.RealMatrixChangingVisitor -> hf:
    double visit(int,int,double) -> a
    void <init>() -> <init>
org.apache.commons.math3.linear.RealMatrixFormat -> hg:
    java.lang.String prefix -> a
    java.lang.String suffix -> b
    java.lang.String rowPrefix -> c
    java.lang.String rowSuffix -> d
    java.lang.String rowSeparator -> e
    java.lang.String columnSeparator -> f
    java.text.NumberFormat format -> a
    void <init>() -> <init>
    void <init>(java.text.NumberFormat) -> <init>
    void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.text.NumberFormat) -> <init>
    org.apache.commons.math3.linear.RealMatrixFormat getInstance(java.util.Locale) -> a
    java.lang.StringBuffer format(org.apache.commons.math3.linear.RealMatrix,java.lang.StringBuffer,java.text.FieldPosition) -> a
org.apache.commons.math3.linear.RealMatrixPreservingVisitor -> hh:
    void start$6046c8d5(int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math3.linear.RealVector -> hi:
    void <init>() -> <init>
    int getDimension() -> getDimension
    double getEntry(int) -> getEntry
    void setEntry(int,double) -> setEntry
    void addToEntry(int,double) -> addToEntry
    org.apache.commons.math3.linear.RealVector append(org.apache.commons.math3.linear.RealVector) -> append
    org.apache.commons.math3.linear.RealVector append(double) -> append
    org.apache.commons.math3.linear.RealVector getSubVector(int,int) -> getSubVector
    void setSubVector(int,org.apache.commons.math3.linear.RealVector) -> setSubVector
    boolean isNaN() -> isNaN
    boolean isInfinite() -> isInfinite
    void checkVectorDimensions(org.apache.commons.math3.linear.RealVector) -> checkVectorDimensions
    void checkVectorDimensions(int) -> checkVectorDimensions
    void checkIndex(int) -> checkIndex
    void checkIndices(int,int) -> checkIndices
    org.apache.commons.math3.linear.RealVector add(org.apache.commons.math3.linear.RealVector) -> add
    org.apache.commons.math3.linear.RealVector subtract(org.apache.commons.math3.linear.RealVector) -> subtract
    org.apache.commons.math3.linear.RealVector mapAdd(double) -> mapAdd
    org.apache.commons.math3.linear.RealVector mapAddToSelf(double) -> mapAddToSelf
    org.apache.commons.math3.linear.RealVector copy() -> copy
    double dotProduct(org.apache.commons.math3.linear.RealVector) -> dotProduct
    double cosine(org.apache.commons.math3.linear.RealVector) -> cosine
    org.apache.commons.math3.linear.RealVector ebeDivide(org.apache.commons.math3.linear.RealVector) -> ebeDivide
    org.apache.commons.math3.linear.RealVector ebeMultiply(org.apache.commons.math3.linear.RealVector) -> ebeMultiply
    double getDistance(org.apache.commons.math3.linear.RealVector) -> getDistance
    double getNorm() -> getNorm
    double getL1Norm() -> getL1Norm
    double getLInfNorm() -> getLInfNorm
    double getL1Distance(org.apache.commons.math3.linear.RealVector) -> getL1Distance
    double getLInfDistance(org.apache.commons.math3.linear.RealVector) -> getLInfDistance
    int getMinIndex() -> getMinIndex
    double getMinValue() -> getMinValue
    int getMaxIndex() -> getMaxIndex
    double getMaxValue() -> getMaxValue
    org.apache.commons.math3.linear.RealVector mapMultiply(double) -> mapMultiply
    org.apache.commons.math3.linear.RealVector mapMultiplyToSelf(double) -> mapMultiplyToSelf
    org.apache.commons.math3.linear.RealVector mapSubtract(double) -> mapSubtract
    org.apache.commons.math3.linear.RealVector mapSubtractToSelf(double) -> mapSubtractToSelf
    org.apache.commons.math3.linear.RealVector mapDivide(double) -> mapDivide
    org.apache.commons.math3.linear.RealVector mapDivideToSelf(double) -> mapDivideToSelf
    org.apache.commons.math3.linear.RealMatrix outerProduct(org.apache.commons.math3.linear.RealVector) -> outerProduct
    org.apache.commons.math3.linear.RealVector projection(org.apache.commons.math3.linear.RealVector) -> projection
    void set(double) -> set
    double[] toArray() -> toArray
    org.apache.commons.math3.linear.RealVector unitVector() -> unitVector
    void unitize() -> unitize
    java.util.Iterator sparseIterator() -> sparseIterator
    java.util.Iterator iterator() -> iterator
    org.apache.commons.math3.linear.RealVector map(org.apache.commons.math3.analysis.UnivariateFunction) -> map
    org.apache.commons.math3.linear.RealVector mapToSelf(org.apache.commons.math3.analysis.UnivariateFunction) -> mapToSelf
    org.apache.commons.math3.linear.RealVector combine(double,double,org.apache.commons.math3.linear.RealVector) -> combine
    org.apache.commons.math3.linear.RealVector combineToSelf(double,double,org.apache.commons.math3.linear.RealVector) -> combineToSelf
    double walkInDefaultOrder$5d3267c1(edu.jas.poly.RelationGenerator) -> walkInDefaultOrder$5d3267c1
    double walkInDefaultOrder$25d7285f(edu.jas.poly.RelationGenerator,int,int) -> walkInDefaultOrder$25d7285f
    double walkInOptimizedOrder$5d3267c1(edu.jas.poly.RelationGenerator) -> walkInOptimizedOrder$5d3267c1
    double walkInOptimizedOrder$25d7285f(edu.jas.poly.RelationGenerator,int,int) -> walkInOptimizedOrder$25d7285f
    double walkInDefaultOrder$27435cdd(edu.jas.poly.RelationGenerator) -> walkInDefaultOrder$27435cdd
    double walkInDefaultOrder$63d0f5bd(edu.jas.poly.RelationGenerator,int,int) -> walkInDefaultOrder$63d0f5bd
    double walkInOptimizedOrder$27435cdd(edu.jas.poly.RelationGenerator) -> walkInOptimizedOrder$27435cdd
    double walkInOptimizedOrder$63d0f5bd(edu.jas.poly.RelationGenerator,int,int) -> walkInOptimizedOrder$63d0f5bd
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.linear.RealVector unmodifiableRealVector(org.apache.commons.math3.linear.RealVector) -> unmodifiableRealVector
org.apache.commons.math3.linear.RealVector$1 -> hj:
    int i -> a
    org.apache.commons.math3.linear.RealVector$Entry e -> a
    int val$dim -> b
    org.apache.commons.math3.linear.RealVector this$0 -> a
    void <init>(org.apache.commons.math3.linear.RealVector,int) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.apache.commons.math3.linear.RealVector$2 -> hk:
    org.apache.commons.math3.linear.RealVector val$v -> a
    void <init>(org.apache.commons.math3.linear.RealVector) -> <init>
    org.apache.commons.math3.linear.RealVector mapToSelf(org.apache.commons.math3.analysis.UnivariateFunction) -> mapToSelf
    org.apache.commons.math3.linear.RealVector map(org.apache.commons.math3.analysis.UnivariateFunction) -> map
    java.util.Iterator iterator() -> iterator
    java.util.Iterator sparseIterator() -> sparseIterator
    org.apache.commons.math3.linear.RealVector copy() -> copy
    org.apache.commons.math3.linear.RealVector add(org.apache.commons.math3.linear.RealVector) -> add
    org.apache.commons.math3.linear.RealVector subtract(org.apache.commons.math3.linear.RealVector) -> subtract
    org.apache.commons.math3.linear.RealVector mapAdd(double) -> mapAdd
    org.apache.commons.math3.linear.RealVector mapAddToSelf(double) -> mapAddToSelf
    org.apache.commons.math3.linear.RealVector mapSubtract(double) -> mapSubtract
    org.apache.commons.math3.linear.RealVector mapSubtractToSelf(double) -> mapSubtractToSelf
    org.apache.commons.math3.linear.RealVector mapMultiply(double) -> mapMultiply
    org.apache.commons.math3.linear.RealVector mapMultiplyToSelf(double) -> mapMultiplyToSelf
    org.apache.commons.math3.linear.RealVector mapDivide(double) -> mapDivide
    org.apache.commons.math3.linear.RealVector mapDivideToSelf(double) -> mapDivideToSelf
    org.apache.commons.math3.linear.RealVector ebeMultiply(org.apache.commons.math3.linear.RealVector) -> ebeMultiply
    org.apache.commons.math3.linear.RealVector ebeDivide(org.apache.commons.math3.linear.RealVector) -> ebeDivide
    double dotProduct(org.apache.commons.math3.linear.RealVector) -> dotProduct
    double cosine(org.apache.commons.math3.linear.RealVector) -> cosine
    double getNorm() -> getNorm
    double getL1Norm() -> getL1Norm
    double getLInfNorm() -> getLInfNorm
    double getDistance(org.apache.commons.math3.linear.RealVector) -> getDistance
    double getL1Distance(org.apache.commons.math3.linear.RealVector) -> getL1Distance
    double getLInfDistance(org.apache.commons.math3.linear.RealVector) -> getLInfDistance
    org.apache.commons.math3.linear.RealVector unitVector() -> unitVector
    void unitize() -> unitize
    org.apache.commons.math3.linear.RealMatrix outerProduct(org.apache.commons.math3.linear.RealVector) -> outerProduct
    double getEntry(int) -> getEntry
    void setEntry(int,double) -> setEntry
    void addToEntry(int,double) -> addToEntry
    int getDimension() -> getDimension
    org.apache.commons.math3.linear.RealVector append(org.apache.commons.math3.linear.RealVector) -> append
    org.apache.commons.math3.linear.RealVector append(double) -> append
    org.apache.commons.math3.linear.RealVector getSubVector(int,int) -> getSubVector
    void setSubVector(int,org.apache.commons.math3.linear.RealVector) -> setSubVector
    void set(double) -> set
    double[] toArray() -> toArray
    boolean isNaN() -> isNaN
    boolean isInfinite() -> isInfinite
    org.apache.commons.math3.linear.RealVector combine(double,double,org.apache.commons.math3.linear.RealVector) -> combine
    org.apache.commons.math3.linear.RealVector combineToSelf(double,double,org.apache.commons.math3.linear.RealVector) -> combineToSelf
org.apache.commons.math3.linear.RealVector$2$1 -> hl:
    org.apache.commons.math3.linear.RealVector$2$UnmodifiableEntry e -> a
    java.util.Iterator val$i -> a
    org.apache.commons.math3.linear.RealVector$2 this$0 -> a
    void <init>(org.apache.commons.math3.linear.RealVector$2,java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.apache.commons.math3.linear.RealVector$2$2 -> hm:
    org.apache.commons.math3.linear.RealVector$2$UnmodifiableEntry e -> a
    java.util.Iterator val$i -> a
    org.apache.commons.math3.linear.RealVector$2 this$0 -> a
    void <init>(org.apache.commons.math3.linear.RealVector$2,java.util.Iterator) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.apache.commons.math3.linear.RealVector$2$UnmodifiableEntry -> hn:
    org.apache.commons.math3.linear.RealVector$2 this$0 -> a
    void <init>(org.apache.commons.math3.linear.RealVector$2) -> <init>
    double getValue() -> a
    void setValue(double) -> a
org.apache.commons.math3.linear.RealVector$Entry -> ho:
    int index -> a
    org.apache.commons.math3.linear.RealVector this$0 -> a
    void <init>(org.apache.commons.math3.linear.RealVector) -> <init>
    double getValue() -> a
    void setValue(double) -> a
org.apache.commons.math3.linear.RealVector$SparseEntryIterator -> hp:
    int dim -> a
    org.apache.commons.math3.linear.RealVector$Entry current -> a
    org.apache.commons.math3.linear.RealVector$Entry next -> b
    void <init>(org.apache.commons.math3.linear.RealVector) -> <init>
    void advance(org.apache.commons.math3.linear.RealVector$Entry) -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.apache.commons.math3.linear.RealVectorFormat -> hq:
    java.lang.String prefix -> a
    java.lang.String suffix -> b
    java.lang.String separator -> c
    java.text.NumberFormat format -> a
    void <init>() -> <init>
    void <init>(java.text.NumberFormat) -> <init>
    void <init>(java.lang.String,java.lang.String,java.lang.String,java.text.NumberFormat) -> <init>
    java.lang.StringBuffer format(org.apache.commons.math3.linear.RealVector,java.lang.StringBuffer,java.text.FieldPosition) -> a
org.apache.commons.math3.linear.SchurTransformer -> hr:
    double[][] matrixP -> a
    double[][] matrixT -> b
    org.apache.commons.math3.linear.RealMatrix cachedP -> a
    org.apache.commons.math3.linear.RealMatrix cachedT -> b
    double epsilon -> a
    void <init>(org.apache.commons.math3.linear.RealMatrix) -> <init>
    org.apache.commons.math3.linear.RealMatrix getT() -> a
    void transform() -> a
org.apache.commons.math3.linear.SchurTransformer$ShiftInfo -> hs:
    double x -> a
    double y -> b
    double w -> c
    double exShift -> d
    void <init>() -> <init>
    void <init>(byte) -> <init>
org.apache.commons.math3.linear.SingularMatrixException -> org.apache.commons.math3.linear.SingularMatrixException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.apache.commons.math3.linear.SingularValueDecomposition -> ht:
    double[] singularValues -> a
    int m -> a
    int n -> b
    boolean transposed -> a
    org.apache.commons.math3.linear.RealMatrix cachedU -> a
    org.apache.commons.math3.linear.RealMatrix cachedS -> b
    org.apache.commons.math3.linear.RealMatrix cachedV -> c
    void <init>(org.apache.commons.math3.linear.RealMatrix) -> <init>
org.apache.commons.math3.linear.SparseRealVector -> hu:
    void <init>() -> <init>
org.apache.commons.math3.linear.TriDiagonalTransformer -> hv:
    double[][] householderVectors -> a
    double[] main -> a
    double[] secondary -> b
    org.apache.commons.math3.linear.RealMatrix cachedQ -> a
    org.apache.commons.math3.linear.RealMatrix cachedQt -> b
    void <init>(org.apache.commons.math3.linear.RealMatrix) -> <init>
    org.apache.commons.math3.linear.RealMatrix getQT() -> a
    void transform() -> a
org.apache.commons.math3.optim.AbstractOptimizationProblem -> hw:
    org.apache.commons.math3.optim.AbstractOptimizationProblem$MaxEvalCallback MAX_EVAL_CALLBACK -> a
    org.apache.commons.math3.optim.AbstractOptimizationProblem$MaxIterCallback MAX_ITER_CALLBACK -> a
    int maxEvaluations -> a
    int maxIterations -> b
    edu.jas.poly.RelationGenerator checker$5134ffaa -> a
    void <init>(int,int,edu.jas.poly.RelationGenerator) -> <init>
    org.apache.commons.math3.util.Incrementor getEvaluationCounter() -> a
    org.apache.commons.math3.util.Incrementor getIterationCounter() -> b
    edu.jas.poly.RelationGenerator getConvergenceChecker$45ee8af7() -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.optim.AbstractOptimizationProblem$MaxEvalCallback -> hx:
    void <init>() -> <init>
    void trigger(int) -> a
    void <init>(byte) -> <init>
org.apache.commons.math3.optim.AbstractOptimizationProblem$MaxIterCallback -> hy:
    void <init>() -> <init>
    void trigger(int) -> a
    void <init>(byte) -> <init>
org.apache.commons.math3.optim.BaseMultivariateOptimizer -> hz:
    double[] start -> a
    double[] lowerBound -> b
    double[] upperBound -> c
    void <init>(edu.jas.poly.RelationGenerator) -> <init>
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.BaseOptimizer -> hA:
    org.apache.commons.math3.util.Incrementor evaluations -> a
    org.apache.commons.math3.util.Incrementor iterations -> b
    void <init>(edu.jas.poly.RelationGenerator) -> <init>
    void <init>(edu.jas.poly.RelationGenerator,int,int) -> <init>
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object doOptimize() -> a
    void incrementIterationCount() -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.BaseOptimizer$MaxEvalCallback -> hB:
    void <init>() -> <init>
    void trigger(int) -> a
    void <init>(byte) -> <init>
org.apache.commons.math3.optim.BaseOptimizer$MaxIterCallback -> hC:
    void <init>() -> <init>
    void trigger(int) -> a
    void <init>(byte) -> <init>
org.apache.commons.math3.optim.InitialGuess -> hD:
    double[] init -> a
    double[] getInitialGuess() -> a
org.apache.commons.math3.optim.MaxEval -> hE:
    int maxEval -> a
org.apache.commons.math3.optim.MaxIter -> hF:
    int maxIter -> a
org.apache.commons.math3.optim.OptimizationProblem -> hG:
    org.apache.commons.math3.util.Incrementor getEvaluationCounter() -> a
    org.apache.commons.math3.util.Incrementor getIterationCounter() -> b
    edu.jas.poly.RelationGenerator getConvergenceChecker$45ee8af7() -> a
org.apache.commons.math3.optim.PointValuePair -> org.apache.commons.math3.optim.PointValuePair:
    long serialVersionUID -> serialVersionUID
    void <init>(double[],double) -> <init>
    void <init>(double[],double,boolean) -> <init>
    double[] getPoint() -> getPoint
    double[] getPointRef() -> getPointRef
    java.lang.Object writeReplace() -> writeReplace
org.apache.commons.math3.optim.PointValuePair$DataTransferObject -> org.apache.commons.math3.optim.PointValuePair$DataTransferObject:
    long serialVersionUID -> serialVersionUID
    double[] point -> point
    double value -> value
    void <init>(double[],double) -> <init>
    java.lang.Object readResolve() -> readResolve
org.apache.commons.math3.optim.SimpleBounds -> hH:
    double[] lower -> a
    double[] upper -> b
    double[] getLower() -> a
    double[] getUpper() -> b
org.apache.commons.math3.optim.linear.LinearConstraint -> org.apache.commons.math3.optim.linear.LinearConstraint:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.linear.RealVector coefficients -> a
    org.apache.commons.math3.optim.linear.Relationship relationship -> relationship
    double value -> value
    void <init>(double[],org.apache.commons.math3.optim.linear.Relationship,double) -> <init>
    void <init>(org.apache.commons.math3.linear.RealVector,org.apache.commons.math3.optim.linear.Relationship,double) -> <init>
    void <init>(double[],double,org.apache.commons.math3.optim.linear.Relationship,double[],double) -> <init>
    void <init>(org.apache.commons.math3.linear.RealVector,double,org.apache.commons.math3.optim.linear.Relationship,org.apache.commons.math3.linear.RealVector,double) -> <init>
    org.apache.commons.math3.linear.RealVector getCoefficients() -> getCoefficients
    org.apache.commons.math3.optim.linear.Relationship getRelationship() -> getRelationship
    double getValue() -> getValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
org.apache.commons.math3.optim.linear.LinearConstraintSet -> hI:
    java.util.Set linearConstraints -> a
    void <init>(java.util.Collection) -> <init>
org.apache.commons.math3.optim.linear.LinearObjectiveFunction -> org.apache.commons.math3.optim.linear.LinearObjectiveFunction:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.linear.RealVector coefficients -> a
    double constantTerm -> constantTerm
    void <init>(double[],double) -> <init>
    void <init>(org.apache.commons.math3.linear.RealVector,double) -> <init>
    org.apache.commons.math3.linear.RealVector getCoefficients() -> getCoefficients
    double getConstantTerm() -> getConstantTerm
    double value(double[]) -> value
    double value(org.apache.commons.math3.linear.RealVector) -> value
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
org.apache.commons.math3.optim.linear.LinearOptimizer -> hJ:
    org.apache.commons.math3.optim.linear.LinearObjectiveFunction function -> a
    java.util.Collection linearConstraints -> a
    boolean nonNegative -> a
    void <init>() -> <init>
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.optim.linear.NoFeasibleSolutionException -> org.apache.commons.math3.optim.linear.NoFeasibleSolutionException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.apache.commons.math3.optim.linear.NonNegativeConstraint -> hK:
    boolean isRestricted -> a
    void <init>(boolean) -> <init>
org.apache.commons.math3.optim.linear.PivotSelectionRule -> org.apache.commons.math3.optim.linear.PivotSelectionRule:
    org.apache.commons.math3.optim.linear.PivotSelectionRule DANTZIG -> DANTZIG
    org.apache.commons.math3.optim.linear.PivotSelectionRule BLAND -> BLAND
    org.apache.commons.math3.optim.linear.PivotSelectionRule[] $VALUES -> a
    org.apache.commons.math3.optim.linear.PivotSelectionRule[] values() -> values
    org.apache.commons.math3.optim.linear.PivotSelectionRule valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.optim.linear.Relationship -> org.apache.commons.math3.optim.linear.Relationship:
    org.apache.commons.math3.optim.linear.Relationship EQ -> EQ
    org.apache.commons.math3.optim.linear.Relationship LEQ -> LEQ
    org.apache.commons.math3.optim.linear.Relationship GEQ -> GEQ
    java.lang.String stringValue -> stringValue
    org.apache.commons.math3.optim.linear.Relationship[] $VALUES -> a
    org.apache.commons.math3.optim.linear.Relationship[] values() -> values
    org.apache.commons.math3.optim.linear.Relationship valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    java.lang.String toString() -> toString
    org.apache.commons.math3.optim.linear.Relationship oppositeRelationship() -> oppositeRelationship
    void <clinit>() -> <clinit>
org.apache.commons.math3.optim.linear.Relationship$1 -> hL:
    int[] $SwitchMap$org$apache$commons$math3$optim$linear$Relationship -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.optim.linear.SimplexSolver -> hM:
    double epsilon -> a
    int maxUlps -> a
    double cutOff -> b
    org.apache.commons.math3.optim.linear.PivotSelectionRule pivotSelection -> a
    org.apache.commons.math3.optim.linear.SolutionCallback solutionCallback -> a
    void <init>() -> <init>
    void <init>(double,int,double) -> <init>
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void doIteration(org.apache.commons.math3.optim.linear.SimplexTableau) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object doOptimize() -> a
org.apache.commons.math3.optim.linear.SimplexTableau -> org.apache.commons.math3.optim.linear.SimplexTableau:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.optim.linear.LinearObjectiveFunction f -> f
    java.util.List constraints -> constraints
    boolean restrictToNonNegative -> restrictToNonNegative
    java.util.List columnLabels -> columnLabels
    org.apache.commons.math3.linear.Array2DRowRealMatrix tableau -> a
    int numDecisionVariables -> numDecisionVariables
    int numSlackVariables -> numSlackVariables
    int numArtificialVariables -> numArtificialVariables
    double epsilon -> epsilon
    int maxUlps -> maxUlps
    int[] basicVariables -> basicVariables
    int[] basicRows -> basicRows
    void <init>(org.apache.commons.math3.optim.linear.LinearObjectiveFunction,java.util.Collection,org.apache.commons.math3.optim.nonlinear.scalar.GoalType,boolean,double) -> <init>
    void <init>(org.apache.commons.math3.optim.linear.LinearObjectiveFunction,java.util.Collection,org.apache.commons.math3.optim.nonlinear.scalar.GoalType,boolean,double,int) -> <init>
    void initializeColumnLabels() -> initializeColumnLabels
    org.apache.commons.math3.linear.Array2DRowRealMatrix createTableau(boolean) -> createTableau
    java.util.List normalizeConstraints(java.util.Collection) -> normalizeConstraints
    int getNumObjectiveFunctions() -> getNumObjectiveFunctions
    int getConstraintTypeCounts(org.apache.commons.math3.optim.linear.Relationship) -> a
    double getInvertedCoefficientSum(org.apache.commons.math3.linear.RealVector) -> getInvertedCoefficientSum
    java.lang.Integer getBasicRow(int) -> getBasicRow
    int getBasicVariable(int) -> getBasicVariable
    void initializeBasicVariables(int) -> a
    void dropPhase1Objective() -> dropPhase1Objective
    void copyArray(double[],double[]) -> a
    boolean isOptimal() -> isOptimal
    org.apache.commons.math3.optim.PointValuePair getSolution() -> getSolution
    void performRowOperations(int,int) -> performRowOperations
    void divideRow(int,double) -> divideRow
    void subtractRow(int,int,double) -> subtractRow
    int getWidth() -> getWidth
    int getHeight() -> getHeight
    double getEntry(int,int) -> getEntry
    void setEntry(int,int,double) -> setEntry
    int getSlackVariableOffset() -> getSlackVariableOffset
    int getArtificialVariableOffset() -> getArtificialVariableOffset
    int getRhsOffset() -> getRhsOffset
    int getNumDecisionVariables() -> getNumDecisionVariables
    int getOriginalNumDecisionVariables() -> getOriginalNumDecisionVariables
    int getNumSlackVariables() -> getNumSlackVariables
    int getNumArtificialVariables() -> getNumArtificialVariables
    double[] getRow(int) -> getRow
    double[][] getData() -> getData
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
org.apache.commons.math3.optim.linear.SolutionCallback -> hN:
    void <init>() -> <init>
org.apache.commons.math3.optim.linear.UnboundedSolutionException -> org.apache.commons.math3.optim.linear.UnboundedSolutionException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.apache.commons.math3.optim.nonlinear.scalar.GoalType -> org.apache.commons.math3.optim.nonlinear.scalar.GoalType:
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType MAXIMIZE -> MAXIMIZE
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType MINIMIZE -> MINIMIZE
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType[] $VALUES -> a
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType[] values() -> values
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer -> hO:
    org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal -> a
    void <init>(edu.jas.poly.RelationGenerator) -> <init>
    org.apache.commons.math3.optim.PointValuePair optimize$60ab8232(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    void parseOptimizationData$8327f6f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
    java.lang.Object optimize$6605553f(org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> a
org.apache.commons.math3.random.AbstractWell -> org.apache.commons.math3.random.AbstractWell:
    long serialVersionUID -> serialVersionUID
    int index -> index
    int[] v -> v
    int[] iRm1 -> iRm1
    int[] iRm2 -> iRm2
    int[] i1 -> i1
    int[] i2 -> i2
    int[] i3 -> i3
    void <init>(int,int,int,int) -> <init>
    void <init>(int,int,int,int,int) -> <init>
    void <init>(int,int,int,int,int[]) -> <init>
    void <init>(int,int,int,int,long) -> <init>
    void setSeed(int) -> setSeed
    void setSeed(int[]) -> setSeed
    void setSeed(long) -> setSeed
    int next(int) -> next
org.apache.commons.math3.random.BitsStreamGenerator -> org.apache.commons.math3.random.BitsStreamGenerator:
    long serialVersionUID -> serialVersionUID
    double nextGaussian -> nextGaussian
    void <init>() -> <init>
    void setSeed(int) -> setSeed
    void setSeed(int[]) -> setSeed
    void setSeed(long) -> setSeed
    int next(int) -> next
    boolean nextBoolean() -> nextBoolean
    void nextBytes(byte[]) -> nextBytes
    double nextDouble() -> nextDouble
    float nextFloat() -> nextFloat
    double nextGaussian() -> nextGaussian
    int nextInt() -> nextInt
    int nextInt(int) -> nextInt
    long nextLong() -> nextLong
    long nextLong(long) -> nextLong
    void clear() -> clear
org.apache.commons.math3.random.RandomDataGenerator -> org.apache.commons.math3.random.RandomDataGenerator:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.random.RandomGenerator rand -> rand
    org.apache.commons.math3.random.RandomGenerator secRand -> secRand
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator) -> <init>
    java.lang.String nextHexString(int) -> nextHexString
    int nextInt(int,int) -> nextInt
    long nextLong(long,long) -> nextLong
    long nextLong(org.apache.commons.math3.random.RandomGenerator,long) -> a
    java.lang.String nextSecureHexString(int) -> nextSecureHexString
    int nextSecureInt(int,int) -> nextSecureInt
    long nextSecureLong(long,long) -> nextSecureLong
    long nextPoisson(double) -> nextPoisson
    double nextGaussian(double,double) -> nextGaussian
    double nextExponential(double) -> nextExponential
    double nextGamma(double,double) -> nextGamma
    int nextHypergeometric(int,int,int) -> nextHypergeometric
    int nextPascal(int,double) -> nextPascal
    double nextT(double) -> nextT
    double nextWeibull(double,double) -> nextWeibull
    int nextZipf(int,double) -> nextZipf
    double nextBeta(double,double) -> nextBeta
    int nextBinomial(int,double) -> nextBinomial
    double nextCauchy(double,double) -> nextCauchy
    double nextChiSquare(double) -> nextChiSquare
    double nextF(double,double) -> nextF
    double nextUniform(double,double) -> nextUniform
    double nextUniform(double,double,boolean) -> nextUniform
    int[] nextPermutation(int,int) -> nextPermutation
    java.lang.Object[] nextSample(java.util.Collection,int) -> nextSample
    void reSeed(long) -> reSeed
    void reSeedSecure() -> reSeedSecure
    void reSeedSecure(long) -> reSeedSecure
    void reSeed() -> reSeed
    void setSecureAlgorithm(java.lang.String,java.lang.String) -> setSecureAlgorithm
    org.apache.commons.math3.random.RandomGenerator getRandomGenerator() -> getRandomGenerator
    org.apache.commons.math3.random.RandomGenerator getSecRan() -> a
org.apache.commons.math3.random.RandomDataImpl -> org.apache.commons.math3.random.RandomDataImpl:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.random.RandomDataGenerator delegate -> delegate
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.random.RandomGenerator) -> <init>
    org.apache.commons.math3.random.RandomDataGenerator getDelegate() -> getDelegate
    java.lang.String nextHexString(int) -> nextHexString
    int nextInt(int,int) -> nextInt
    long nextLong(long,long) -> nextLong
    java.lang.String nextSecureHexString(int) -> nextSecureHexString
    int nextSecureInt(int,int) -> nextSecureInt
    long nextSecureLong(long,long) -> nextSecureLong
    long nextPoisson(double) -> nextPoisson
    double nextGaussian(double,double) -> nextGaussian
    double nextExponential(double) -> nextExponential
    double nextUniform(double,double) -> nextUniform
    double nextUniform(double,double,boolean) -> nextUniform
    double nextBeta(double,double) -> nextBeta
    int nextBinomial(int,double) -> nextBinomial
    double nextCauchy(double,double) -> nextCauchy
    double nextChiSquare(double) -> nextChiSquare
    double nextF(double,double) -> nextF
    double nextGamma(double,double) -> nextGamma
    int nextHypergeometric(int,int,int) -> nextHypergeometric
    int nextPascal(int,double) -> nextPascal
    double nextT(double) -> nextT
    double nextWeibull(double,double) -> nextWeibull
    int nextZipf(int,double) -> nextZipf
    void reSeed(long) -> reSeed
    void reSeedSecure() -> reSeedSecure
    void reSeedSecure(long) -> reSeedSecure
    void reSeed() -> reSeed
    void setSecureAlgorithm(java.lang.String,java.lang.String) -> setSecureAlgorithm
    int[] nextPermutation(int,int) -> nextPermutation
    java.lang.Object[] nextSample(java.util.Collection,int) -> nextSample
    double nextInversionDeviate(org.apache.commons.math3.distribution.RealDistribution) -> nextInversionDeviate
    int nextInversionDeviate(org.apache.commons.math3.distribution.IntegerDistribution) -> nextInversionDeviate
org.apache.commons.math3.random.RandomGenerator -> hP:
    void setSeed(long) -> setSeed
    void nextBytes(byte[]) -> nextBytes
    int nextInt() -> nextInt
    int nextInt(int) -> nextInt
    long nextLong() -> nextLong
    double nextDouble() -> nextDouble
    double nextGaussian() -> nextGaussian
org.apache.commons.math3.random.RandomGeneratorFactory$1 -> hQ:
    java.util.Random val$rng -> a
    void <init>(java.util.Random) -> <init>
    void setSeed(long) -> setSeed
    void nextBytes(byte[]) -> nextBytes
    int nextInt() -> nextInt
    int nextInt(int) -> nextInt
    long nextLong() -> nextLong
    double nextDouble() -> nextDouble
    double nextGaussian() -> nextGaussian
org.apache.commons.math3.random.Well19937c -> org.apache.commons.math3.random.Well19937c:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(int[]) -> <init>
    void <init>(long) -> <init>
    int next(int) -> next
org.apache.commons.math3.special.Beta -> hR:
    double[] DELTA -> a
    double regularizedBeta(double,double,double) -> a
    double regularizedBeta(double,double,double,double,int) -> a
    double logGammaSum(double,double) -> b
    double logGammaMinusLogGammaSum(double,double) -> c
    double deltaMinusDeltaSum(double,double) -> d
    double logBeta(double,double) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.special.Beta$1 -> hS:
    double val$b -> a
    double val$a -> b
    void <init>(double,double) -> <init>
    double getB(int,double) -> a
    double getA(int,double) -> b
org.apache.commons.math3.special.Gamma -> hT:
    double[] LANCZOS -> a
    double HALF_LOG_2_PI -> a
    double logGamma(double) -> a
    double regularizedGammaP(double,double) -> a
    double regularizedGammaP(double,double,double,int) -> a
    double regularizedGammaQ(double,double,double,int) -> b
    double lanczos(double) -> b
    double invGamma1pm1(double) -> e
    double logGamma1p(double) -> c
    double gamma(double) -> d
    void <clinit>() -> <clinit>
org.apache.commons.math3.special.Gamma$1 -> hU:
    double val$a -> a
    void <init>(double) -> <init>
    double getA(int,double) -> b
    double getB(int,double) -> a
org.apache.commons.math3.stat.StatUtils -> hV:
    org.apache.commons.math3.stat.descriptive.moment.GeometricMean GEOMETRIC_MEAN -> a
    double geometricMean(double[]) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic -> hW:
    void <init>() -> <init>
    double evaluate(double[]) -> evaluate
    double evaluate(double[],int,int) -> evaluate
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    void clear() -> clear
    double getResult() -> getResult
    void increment(double) -> increment
    void incrementAll(double[]) -> incrementAll
    void incrementAll(double[],int,int) -> incrementAll
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic -> hX:
    double[] storedData -> storedData
    void <init>() -> <init>
    void setData(double[]) -> setData
    double[] getData() -> getData
    double[] getDataRef() -> getDataRef
    void setData(double[],int,int) -> setData
    double evaluate() -> evaluate
    double evaluate(double[]) -> evaluate
    double evaluate(double[],int,int) -> evaluate
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
    boolean test(double[],int,int) -> test
    boolean test(double[],int,int,boolean) -> test
    boolean test(double[],double[],int,int) -> test
    boolean test(double[],double[],int,int,boolean) -> test
org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic -> hY:
    void increment(double) -> increment
    double getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
org.apache.commons.math3.stat.descriptive.moment.FirstMoment -> org.apache.commons.math3.stat.descriptive.moment.FirstMoment:
    long serialVersionUID -> serialVersionUID
    long n -> n
    double m1 -> m1
    double dev -> dev
    double nDev -> nDev
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.moment.FirstMoment) -> <init>
    void increment(double) -> increment
    void clear() -> clear
    double getResult() -> getResult
    long getN() -> getN
    org.apache.commons.math3.stat.descriptive.moment.FirstMoment copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.moment.FirstMoment,org.apache.commons.math3.stat.descriptive.moment.FirstMoment) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.moment.GeometricMean -> org.apache.commons.math3.stat.descriptive.moment.GeometricMean:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic sumOfLogs -> sumOfLogs
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.moment.GeometricMean) -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.summary.SumOfLogs) -> <init>
    org.apache.commons.math3.stat.descriptive.moment.GeometricMean copy() -> copy
    void increment(double) -> increment
    double getResult() -> getResult
    void clear() -> clear
    double evaluate(double[],int,int) -> evaluate
    long getN() -> getN
    void setSumLogImpl(org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic) -> setSumLogImpl
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic getSumLogImpl() -> getSumLogImpl
    void copy(org.apache.commons.math3.stat.descriptive.moment.GeometricMean,org.apache.commons.math3.stat.descriptive.moment.GeometricMean) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.moment.Mean -> org.apache.commons.math3.stat.descriptive.moment.Mean:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.stat.descriptive.moment.FirstMoment moment -> moment
    boolean incMoment -> incMoment
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.moment.FirstMoment) -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.moment.Mean) -> <init>
    void increment(double) -> increment
    void clear() -> clear
    double getResult() -> getResult
    long getN() -> getN
    double evaluate(double[],int,int) -> evaluate
    double evaluate(double[],double[],int,int) -> evaluate
    double evaluate(double[],double[]) -> evaluate
    org.apache.commons.math3.stat.descriptive.moment.Mean copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.moment.Mean,org.apache.commons.math3.stat.descriptive.moment.Mean) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.moment.SecondMoment -> org.apache.commons.math3.stat.descriptive.moment.SecondMoment:
    long serialVersionUID -> serialVersionUID
    double m2 -> m2
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.moment.SecondMoment) -> <init>
    void increment(double) -> increment
    void clear() -> clear
    double getResult() -> getResult
    org.apache.commons.math3.stat.descriptive.moment.SecondMoment copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.moment.SecondMoment,org.apache.commons.math3.stat.descriptive.moment.SecondMoment) -> copy
    org.apache.commons.math3.stat.descriptive.moment.FirstMoment copy() -> copy
    long getN() -> getN
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.moment.Variance -> org.apache.commons.math3.stat.descriptive.moment.Variance:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.stat.descriptive.moment.SecondMoment moment -> moment
    boolean incMoment -> incMoment
    boolean isBiasCorrected -> isBiasCorrected
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.moment.SecondMoment) -> <init>
    void <init>(boolean) -> <init>
    void <init>(boolean,org.apache.commons.math3.stat.descriptive.moment.SecondMoment) -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.moment.Variance) -> <init>
    void increment(double) -> increment
    double getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    double evaluate(double[]) -> evaluate
    double evaluate(double[],int,int) -> evaluate
    double evaluate(double[],double[],int,int) -> evaluate
    double evaluate(double[],double[]) -> evaluate
    double evaluate(double[],double,int,int) -> evaluate
    double evaluate(double[],double) -> evaluate
    double evaluate(double[],double[],double,int,int) -> evaluate
    double evaluate(double[],double[],double) -> evaluate
    boolean isBiasCorrected() -> isBiasCorrected
    void setBiasCorrected(boolean) -> setBiasCorrected
    org.apache.commons.math3.stat.descriptive.moment.Variance copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.moment.Variance,org.apache.commons.math3.stat.descriptive.moment.Variance) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.rank.Max -> org.apache.commons.math3.stat.descriptive.rank.Max:
    long serialVersionUID -> serialVersionUID
    long n -> n
    double value -> value
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.rank.Max) -> <init>
    void increment(double) -> increment
    void clear() -> clear
    double getResult() -> getResult
    long getN() -> getN
    double evaluate(double[],int,int) -> evaluate
    org.apache.commons.math3.stat.descriptive.rank.Max copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.rank.Max,org.apache.commons.math3.stat.descriptive.rank.Max) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.rank.Min -> org.apache.commons.math3.stat.descriptive.rank.Min:
    long serialVersionUID -> serialVersionUID
    long n -> n
    double value -> value
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.rank.Min) -> <init>
    void increment(double) -> increment
    void clear() -> clear
    double getResult() -> getResult
    long getN() -> getN
    double evaluate(double[],int,int) -> evaluate
    org.apache.commons.math3.stat.descriptive.rank.Min copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.rank.Min,org.apache.commons.math3.stat.descriptive.rank.Min) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.rank.Percentile -> org.apache.commons.math3.stat.descriptive.rank.Percentile:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.util.KthSelector kthSelector -> kthSelector
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType estimationType -> estimationType
    org.apache.commons.math3.stat.ranking.NaNStrategy nanStrategy -> nanStrategy
    double quantile -> quantile
    int[] cachedPivots -> cachedPivots
    void <init>() -> <init>
    void <init>(double) -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.rank.Percentile) -> <init>
    void <init>(double,org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType,org.apache.commons.math3.stat.ranking.NaNStrategy,org.apache.commons.math3.util.KthSelector) -> <init>
    void setData(double[]) -> setData
    void setData(double[],int,int) -> setData
    double evaluate(double) -> evaluate
    double evaluate(double[],double) -> evaluate
    double evaluate(double[],int,int) -> evaluate
    double evaluate(double[],int,int,double) -> evaluate
    int medianOf3(double[],int,int) -> medianOf3
    double getQuantile() -> getQuantile
    void setQuantile(double) -> setQuantile
    org.apache.commons.math3.stat.descriptive.rank.Percentile copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.rank.Percentile,org.apache.commons.math3.stat.descriptive.rank.Percentile) -> copy
    double[] getWorkArray(double[],int,int) -> getWorkArray
    double[] copyOf(double[],int,int) -> a
    double[] replaceAndSlice(double[],int,int,double,double) -> a
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType getEstimationType() -> getEstimationType
    org.apache.commons.math3.stat.descriptive.rank.Percentile withEstimationType(org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType) -> withEstimationType
    org.apache.commons.math3.stat.ranking.NaNStrategy getNaNStrategy() -> getNaNStrategy
    org.apache.commons.math3.stat.descriptive.rank.Percentile withNaNStrategy(org.apache.commons.math3.stat.ranking.NaNStrategy) -> withNaNStrategy
    org.apache.commons.math3.util.KthSelector getKthSelector() -> getKthSelector
    org.apache.commons.math3.util.PivotingStrategyInterface getPivotingStrategy() -> getPivotingStrategy
    org.apache.commons.math3.stat.descriptive.rank.Percentile withKthSelector(org.apache.commons.math3.util.KthSelector) -> withKthSelector
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.rank.Percentile$1 -> hZ:
    int[] $SwitchMap$org$apache$commons$math3$stat$ranking$NaNStrategy -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType:
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType LEGACY -> LEGACY
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_1 -> R_1
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_2 -> R_2
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_3 -> R_3
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_4 -> R_4
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_5 -> R_5
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_6 -> R_6
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_7 -> R_7
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_8 -> R_8
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType R_9 -> R_9
    java.lang.String name -> name
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType[] $VALUES -> a
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType[] values() -> values
    org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
    double estimate(double[],int[],double,int,org.apache.commons.math3.util.KthSelector) -> estimate
    double evaluate(double[],int[],double,org.apache.commons.math3.util.KthSelector) -> evaluate
    double evaluate(double[],double,org.apache.commons.math3.util.KthSelector) -> evaluate
    java.lang.String getName() -> getName
    void <init>(java.lang.String,int,java.lang.String,org.apache.commons.math3.stat.descriptive.rank.Percentile$1) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$1 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$1:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$10 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$10:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$2 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$2:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
    double estimate(double[],int[],double,int,org.apache.commons.math3.util.KthSelector) -> estimate
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$3 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$3:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
    double estimate(double[],int[],double,int,org.apache.commons.math3.util.KthSelector) -> estimate
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$4 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$4:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$5 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$5:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$6 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$6:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$7 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$7:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$8 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$8:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$9 -> org.apache.commons.math3.stat.descriptive.rank.Percentile$EstimationType$9:
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    double index(double,int) -> index
org.apache.commons.math3.stat.descriptive.summary.Product -> org.apache.commons.math3.stat.descriptive.summary.Product:
    long serialVersionUID -> serialVersionUID
    long n -> n
    double value -> value
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.summary.Product) -> <init>
    void increment(double) -> increment
    double getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    double evaluate(double[],int,int) -> evaluate
    double evaluate(double[],double[],int,int) -> evaluate
    double evaluate(double[],double[]) -> evaluate
    org.apache.commons.math3.stat.descriptive.summary.Product copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.summary.Product,org.apache.commons.math3.stat.descriptive.summary.Product) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.summary.Sum -> org.apache.commons.math3.stat.descriptive.summary.Sum:
    long serialVersionUID -> serialVersionUID
    long n -> n
    double value -> value
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.summary.Sum) -> <init>
    void increment(double) -> increment
    double getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    double evaluate(double[],int,int) -> evaluate
    double evaluate(double[],double[],int,int) -> evaluate
    double evaluate(double[],double[]) -> evaluate
    org.apache.commons.math3.stat.descriptive.summary.Sum copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.summary.Sum,org.apache.commons.math3.stat.descriptive.summary.Sum) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.summary.SumOfLogs -> org.apache.commons.math3.stat.descriptive.summary.SumOfLogs:
    long serialVersionUID -> serialVersionUID
    int n -> n
    double value -> value
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.summary.SumOfLogs) -> <init>
    void increment(double) -> increment
    double getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    double evaluate(double[],int,int) -> evaluate
    org.apache.commons.math3.stat.descriptive.summary.SumOfLogs copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.summary.SumOfLogs,org.apache.commons.math3.stat.descriptive.summary.SumOfLogs) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.descriptive.summary.SumOfSquares -> org.apache.commons.math3.stat.descriptive.summary.SumOfSquares:
    long serialVersionUID -> serialVersionUID
    long n -> n
    double value -> value
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.stat.descriptive.summary.SumOfSquares) -> <init>
    void increment(double) -> increment
    double getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    double evaluate(double[],int,int) -> evaluate
    org.apache.commons.math3.stat.descriptive.summary.SumOfSquares copy() -> copy
    void copy(org.apache.commons.math3.stat.descriptive.summary.SumOfSquares,org.apache.commons.math3.stat.descriptive.summary.SumOfSquares) -> copy
    org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic copy() -> copy
    org.apache.commons.math3.util.MathArrays$Function copy$31ac316d() -> copy$31ac316d
org.apache.commons.math3.stat.ranking.NaNStrategy -> org.apache.commons.math3.stat.ranking.NaNStrategy:
    org.apache.commons.math3.stat.ranking.NaNStrategy MINIMAL -> MINIMAL
    org.apache.commons.math3.stat.ranking.NaNStrategy MAXIMAL -> MAXIMAL
    org.apache.commons.math3.stat.ranking.NaNStrategy REMOVED -> REMOVED
    org.apache.commons.math3.stat.ranking.NaNStrategy FIXED -> FIXED
    org.apache.commons.math3.stat.ranking.NaNStrategy FAILED -> FAILED
    org.apache.commons.math3.stat.ranking.NaNStrategy[] $VALUES -> a
    org.apache.commons.math3.stat.ranking.NaNStrategy[] values() -> values
    org.apache.commons.math3.stat.ranking.NaNStrategy valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.transform.DftNormalization -> org.apache.commons.math3.transform.DftNormalization:
    org.apache.commons.math3.transform.DftNormalization STANDARD -> STANDARD
    org.apache.commons.math3.transform.DftNormalization UNITARY -> UNITARY
    org.apache.commons.math3.transform.DftNormalization[] $VALUES -> a
    org.apache.commons.math3.transform.DftNormalization[] values() -> values
    org.apache.commons.math3.transform.DftNormalization valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.transform.FastFourierTransformer -> org.apache.commons.math3.transform.FastFourierTransformer:
    long serialVersionUID -> serialVersionUID
    double[] W_SUB_N_R -> a
    double[] W_SUB_N_I -> b
    org.apache.commons.math3.transform.DftNormalization normalization -> normalization
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(org.apache.commons.math3.transform.DftNormalization) -> <init>
    void normalizeTransformedData(double[][],org.apache.commons.math3.transform.DftNormalization,org.apache.commons.math3.transform.TransformType) -> a
    void transformInPlace(double[][],org.apache.commons.math3.transform.DftNormalization,org.apache.commons.math3.transform.TransformType) -> transformInPlace
    org.apache.commons.math3.complex.Complex[] transform(double[],org.apache.commons.math3.transform.TransformType) -> transform
    org.apache.commons.math3.complex.Complex[] transform(org.apache.commons.math3.analysis.UnivariateFunction,double,double,int,org.apache.commons.math3.transform.TransformType) -> transform
    org.apache.commons.math3.complex.Complex[] transform(org.apache.commons.math3.complex.Complex[],org.apache.commons.math3.transform.TransformType) -> transform
    java.lang.Object mdfft(java.lang.Object,org.apache.commons.math3.transform.TransformType) -> mdfft
    void mdfft(org.apache.commons.math3.transform.FastFourierTransformer$MultiDimensionalComplexMatrix,org.apache.commons.math3.transform.TransformType,int,int[]) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.transform.FastFourierTransformer$1 -> ia:
    int[] $SwitchMap$org$apache$commons$math3$transform$DftNormalization -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.transform.FastFourierTransformer$MultiDimensionalComplexMatrix -> ib:
    int[] dimensionSize -> a
    java.lang.Object multiDimensionalComplexArray -> a
    void <init>(java.lang.Object) -> <init>
    org.apache.commons.math3.complex.Complex get(int[]) -> a
    org.apache.commons.math3.complex.Complex set(org.apache.commons.math3.complex.Complex,int[]) -> a
    int[] getDimensionSizes() -> a
    java.lang.Object getArray() -> a
    java.lang.Object clone() -> clone
org.apache.commons.math3.transform.TransformType -> org.apache.commons.math3.transform.TransformType:
    org.apache.commons.math3.transform.TransformType FORWARD -> FORWARD
    org.apache.commons.math3.transform.TransformType INVERSE -> INVERSE
    org.apache.commons.math3.transform.TransformType[] $VALUES -> a
    org.apache.commons.math3.transform.TransformType[] values() -> values
    org.apache.commons.math3.transform.TransformType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.transform.TransformUtils -> ic:
    double[][] createRealImaginaryArray(org.apache.commons.math3.complex.Complex[]) -> a
    org.apache.commons.math3.complex.Complex[] createComplexArray(double[][]) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.BigReal -> org.apache.commons.math3.util.BigReal:
    org.apache.commons.math3.util.BigReal ZERO -> ZERO
    org.apache.commons.math3.util.BigReal ONE -> ONE
    long serialVersionUID -> serialVersionUID
    java.math.BigDecimal d -> d
    java.math.RoundingMode roundingMode -> roundingMode
    int scale -> scale
    void <init>(java.math.BigDecimal) -> <init>
    void <init>(java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger,int) -> <init>
    void <init>(java.math.BigInteger,int,java.math.MathContext) -> <init>
    void <init>(java.math.BigInteger,java.math.MathContext) -> <init>
    void <init>(char[]) -> <init>
    void <init>(char[],int,int) -> <init>
    void <init>(char[],int,int,java.math.MathContext) -> <init>
    void <init>(char[],java.math.MathContext) -> <init>
    void <init>(double) -> <init>
    void <init>(double,java.math.MathContext) -> <init>
    void <init>(int) -> <init>
    void <init>(int,java.math.MathContext) -> <init>
    void <init>(long) -> <init>
    void <init>(long,java.math.MathContext) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.math.MathContext) -> <init>
    java.math.RoundingMode getRoundingMode() -> getRoundingMode
    void setRoundingMode(java.math.RoundingMode) -> setRoundingMode
    int getScale() -> getScale
    void setScale(int) -> setScale
    org.apache.commons.math3.util.BigReal add(org.apache.commons.math3.util.BigReal) -> add
    org.apache.commons.math3.util.BigReal subtract(org.apache.commons.math3.util.BigReal) -> subtract
    org.apache.commons.math3.util.BigReal negate() -> negate
    org.apache.commons.math3.util.BigReal divide(org.apache.commons.math3.util.BigReal) -> divide
    org.apache.commons.math3.util.BigReal reciprocal() -> reciprocal
    org.apache.commons.math3.util.BigReal multiply(org.apache.commons.math3.util.BigReal) -> multiply
    org.apache.commons.math3.util.BigReal multiply(int) -> multiply
    int compareTo(org.apache.commons.math3.util.BigReal) -> compareTo
    double doubleValue() -> doubleValue
    java.math.BigDecimal bigDecimalValue() -> bigDecimalValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math3.Field getField() -> getField
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.BigRealField -> org.apache.commons.math3.util.BigRealField:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    org.apache.commons.math3.util.BigRealField getInstance() -> getInstance
    org.apache.commons.math3.util.BigReal getOne() -> getOne
    org.apache.commons.math3.util.BigReal getZero() -> getZero
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    java.lang.Object readResolve() -> readResolve
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
    void <init>(cc.redberry.core.math.frobenius.DummySolutionProvider) -> <init>
org.apache.commons.math3.util.BigRealField$LazyHolder -> id:
    org.apache.commons.math3.util.BigRealField INSTANCE -> a
    org.apache.commons.math3.util.BigRealField access$000() -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.CombinatoricsUtils -> ie:
    long[] FACTORIALS -> a
    long binomialCoefficient(int,int) -> a
    double binomialCoefficientDouble(int,int) -> a
    double binomialCoefficientLog(int,int) -> b
    long factorial(int) -> a
    double factorialLog(int) -> a
    void checkBinomial(int,int) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.ContinuedFraction -> if:
    void <init>() -> <init>
    double getA(int,double) -> b
    double getB(int,double) -> a
    double evaluate(double,double,int) -> a
org.apache.commons.math3.util.Decimal64 -> org.apache.commons.math3.util.Decimal64:
    org.apache.commons.math3.util.Decimal64 ZERO -> ZERO
    org.apache.commons.math3.util.Decimal64 ONE -> ONE
    org.apache.commons.math3.util.Decimal64 NEGATIVE_INFINITY -> NEGATIVE_INFINITY
    org.apache.commons.math3.util.Decimal64 POSITIVE_INFINITY -> POSITIVE_INFINITY
    org.apache.commons.math3.util.Decimal64 NAN -> NAN
    long serialVersionUID -> serialVersionUID
    double value -> value
    void <init>(double) -> <init>
    org.apache.commons.math3.Field getField() -> getField
    org.apache.commons.math3.util.Decimal64 add(org.apache.commons.math3.util.Decimal64) -> add
    org.apache.commons.math3.util.Decimal64 subtract(org.apache.commons.math3.util.Decimal64) -> subtract
    org.apache.commons.math3.util.Decimal64 negate() -> negate
    org.apache.commons.math3.util.Decimal64 multiply(org.apache.commons.math3.util.Decimal64) -> multiply
    org.apache.commons.math3.util.Decimal64 multiply(int) -> multiply
    org.apache.commons.math3.util.Decimal64 divide(org.apache.commons.math3.util.Decimal64) -> divide
    org.apache.commons.math3.util.Decimal64 reciprocal() -> reciprocal
    byte byteValue() -> byteValue
    short shortValue() -> shortValue
    int intValue() -> intValue
    long longValue() -> longValue
    float floatValue() -> floatValue
    double doubleValue() -> doubleValue
    int compareTo(org.apache.commons.math3.util.Decimal64) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean isInfinite() -> isInfinite
    boolean isNaN() -> isNaN
    double getReal() -> getReal
    org.apache.commons.math3.util.Decimal64 add(double) -> add
    org.apache.commons.math3.util.Decimal64 subtract(double) -> subtract
    org.apache.commons.math3.util.Decimal64 multiply(double) -> multiply
    org.apache.commons.math3.util.Decimal64 divide(double) -> divide
    org.apache.commons.math3.util.Decimal64 remainder(double) -> remainder
    org.apache.commons.math3.util.Decimal64 remainder(org.apache.commons.math3.util.Decimal64) -> remainder
    org.apache.commons.math3.util.Decimal64 abs() -> abs
    org.apache.commons.math3.util.Decimal64 ceil() -> ceil
    org.apache.commons.math3.util.Decimal64 floor() -> floor
    org.apache.commons.math3.util.Decimal64 rint() -> rint
    long round() -> round
    org.apache.commons.math3.util.Decimal64 signum() -> signum
    org.apache.commons.math3.util.Decimal64 copySign(org.apache.commons.math3.util.Decimal64) -> copySign
    org.apache.commons.math3.util.Decimal64 copySign(double) -> copySign
    org.apache.commons.math3.util.Decimal64 scalb(int) -> scalb
    org.apache.commons.math3.util.Decimal64 hypot(org.apache.commons.math3.util.Decimal64) -> hypot
    org.apache.commons.math3.util.Decimal64 sqrt() -> sqrt
    org.apache.commons.math3.util.Decimal64 cbrt() -> cbrt
    org.apache.commons.math3.util.Decimal64 rootN(int) -> rootN
    org.apache.commons.math3.util.Decimal64 pow(double) -> pow
    org.apache.commons.math3.util.Decimal64 pow(int) -> pow
    org.apache.commons.math3.util.Decimal64 pow(org.apache.commons.math3.util.Decimal64) -> pow
    org.apache.commons.math3.util.Decimal64 exp() -> exp
    org.apache.commons.math3.util.Decimal64 expm1() -> expm1
    org.apache.commons.math3.util.Decimal64 log() -> log
    org.apache.commons.math3.util.Decimal64 log1p() -> log1p
    org.apache.commons.math3.util.Decimal64 log10() -> log10
    org.apache.commons.math3.util.Decimal64 cos() -> cos
    org.apache.commons.math3.util.Decimal64 sin() -> sin
    org.apache.commons.math3.util.Decimal64 tan() -> tan
    org.apache.commons.math3.util.Decimal64 acos() -> acos
    org.apache.commons.math3.util.Decimal64 asin() -> asin
    org.apache.commons.math3.util.Decimal64 atan() -> atan
    org.apache.commons.math3.util.Decimal64 atan2(org.apache.commons.math3.util.Decimal64) -> atan2
    org.apache.commons.math3.util.Decimal64 cosh() -> cosh
    org.apache.commons.math3.util.Decimal64 sinh() -> sinh
    org.apache.commons.math3.util.Decimal64 tanh() -> tanh
    org.apache.commons.math3.util.Decimal64 acosh() -> acosh
    org.apache.commons.math3.util.Decimal64 asinh() -> asinh
    org.apache.commons.math3.util.Decimal64 atanh() -> atanh
    org.apache.commons.math3.util.Decimal64 linearCombination(org.apache.commons.math3.util.Decimal64[],org.apache.commons.math3.util.Decimal64[]) -> linearCombination
    org.apache.commons.math3.util.Decimal64 linearCombination(double[],org.apache.commons.math3.util.Decimal64[]) -> linearCombination
    org.apache.commons.math3.util.Decimal64 linearCombination(org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64) -> linearCombination
    org.apache.commons.math3.util.Decimal64 linearCombination(double,org.apache.commons.math3.util.Decimal64,double,org.apache.commons.math3.util.Decimal64) -> linearCombination
    org.apache.commons.math3.util.Decimal64 linearCombination(org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64) -> linearCombination
    org.apache.commons.math3.util.Decimal64 linearCombination(double,org.apache.commons.math3.util.Decimal64,double,org.apache.commons.math3.util.Decimal64,double,org.apache.commons.math3.util.Decimal64) -> linearCombination
    org.apache.commons.math3.util.Decimal64 linearCombination(org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64,org.apache.commons.math3.util.Decimal64) -> linearCombination
    org.apache.commons.math3.util.Decimal64 linearCombination(double,org.apache.commons.math3.util.Decimal64,double,org.apache.commons.math3.util.Decimal64,double,org.apache.commons.math3.util.Decimal64,double,org.apache.commons.math3.util.Decimal64) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double,java.lang.Object,double,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object) -> linearCombination
    java.lang.Object linearCombination(double[],java.lang.Object[]) -> linearCombination
    java.lang.Object linearCombination(java.lang.Object[],java.lang.Object[]) -> linearCombination
    java.lang.Object atanh() -> atanh
    java.lang.Object asinh() -> asinh
    java.lang.Object acosh() -> acosh
    java.lang.Object tanh() -> tanh
    java.lang.Object sinh() -> sinh
    java.lang.Object cosh() -> cosh
    java.lang.Object atan2(java.lang.Object) -> atan2
    java.lang.Object atan() -> atan
    java.lang.Object asin() -> asin
    java.lang.Object acos() -> acos
    java.lang.Object tan() -> tan
    java.lang.Object sin() -> sin
    java.lang.Object cos() -> cos
    java.lang.Object log1p() -> log1p
    java.lang.Object log() -> log
    java.lang.Object expm1() -> expm1
    java.lang.Object exp() -> exp
    java.lang.Object pow(java.lang.Object) -> pow
    java.lang.Object pow(int) -> pow
    java.lang.Object pow(double) -> pow
    java.lang.Object rootN(int) -> rootN
    java.lang.Object cbrt() -> cbrt
    java.lang.Object sqrt() -> sqrt
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object hypot(java.lang.Object) -> hypot
    java.lang.Object scalb(int) -> scalb
    java.lang.Object copySign(double) -> copySign
    java.lang.Object copySign(java.lang.Object) -> copySign
    java.lang.Object signum() -> signum
    java.lang.Object rint() -> rint
    java.lang.Object floor() -> floor
    java.lang.Object ceil() -> ceil
    java.lang.Object abs() -> abs
    java.lang.Object remainder(java.lang.Object) -> remainder
    java.lang.Object remainder(double) -> remainder
    java.lang.Object divide(double) -> divide
    java.lang.Object multiply(double) -> multiply
    java.lang.Object subtract(double) -> subtract
    java.lang.Object add(double) -> add
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.Decimal64Field -> org.apache.commons.math3.util.Decimal64Field:
    org.apache.commons.math3.util.Decimal64Field INSTANCE -> a
    void <init>() -> <init>
    org.apache.commons.math3.util.Decimal64Field getInstance() -> getInstance
    org.apache.commons.math3.util.Decimal64 getZero() -> getZero
    org.apache.commons.math3.util.Decimal64 getOne() -> getOne
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.FastMath -> ig:
    double LOG_MAX_VALUE -> a
    double[][] LN_QUICK_COEF -> a
    double[][] LN_HI_PREC_COEF -> b
    double[] SINE_TABLE_A -> a
    double[] SINE_TABLE_B -> b
    double[] COSINE_TABLE_A -> c
    double[] COSINE_TABLE_B -> d
    double[] TANGENT_TABLE_A -> e
    double[] TANGENT_TABLE_B -> f
    long[] RECIP_2PI -> a
    long[] PI_O_4_BITS -> b
    double[] EIGHTHS -> g
    double[] CBRTTWO -> h
    double doubleHighPart(double) -> A
    double sqrt(double) -> a
    double cosh(double) -> b
    double sinh(double) -> c
    double tanh(double) -> d
    double acosh(double) -> e
    double asinh(double) -> f
    double atanh(double) -> g
    double signum(double) -> h
    double exp(double) -> i
    double exp(double,double,double[]) -> a
    double expm1(double) -> j
    double expm1(double,double[]) -> a
    double log(double) -> k
    double log(double,double[]) -> b
    double log1p(double) -> l
    double log10(double) -> m
    double pow(double,double) -> a
    double pow(double,int) -> a
    double polySine(double) -> B
    double polyCosine(double) -> C
    double sinQ(double,double) -> h
    double cosQ(double,double) -> i
    double tanQ(double,double,boolean) -> a
    void reducePayneHanek(double,double[]) -> a
    double sin(double) -> n
    double cos(double) -> o
    double tan(double) -> p
    double atan(double) -> q
    double atan(double,double,boolean) -> b
    double atan2(double,double) -> b
    double asin(double) -> r
    double acos(double) -> s
    double cbrt(double) -> t
    double toRadians(double) -> u
    double toDegrees(double) -> v
    int abs(int) -> a
    long abs(long) -> a
    double abs(double) -> w
    double scalb(double,int) -> b
    double floor(double) -> x
    double ceil(double) -> y
    double rint(double) -> z
    long round(double) -> a
    int min(int,int) -> a
    long min(long,long) -> a
    double min(double,double) -> c
    int max(int,int) -> b
    double max(double,double) -> d
    double hypot(double,double) -> e
    double IEEEremainder(double,double) -> f
    double copySign(double,double) -> g
    int getExponent(double) -> a
    int getExponent(float) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.FastMath$CodyWaite -> ih:
    int finalK -> a
    double finalRemA -> a
    double finalRemB -> b
    void <init>(double) -> <init>
org.apache.commons.math3.util.FastMath$ExpFracTable -> ii:
    double[] EXP_FRAC_TABLE_A -> a
    double[] EXP_FRAC_TABLE_B -> b
    double[] access$200() -> a
    double[] access$300() -> b
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.FastMath$ExpIntTable -> ij:
    double[] EXP_INT_TABLE_A -> a
    double[] EXP_INT_TABLE_B -> b
    double[] access$000() -> a
    double[] access$100() -> b
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.FastMath$lnMant -> ik:
    double[][] LN_MANT -> a
    double[][] access$400() -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.FastMathLiteralArrays -> il:
    double[] EXP_INT_A -> a
    double[] EXP_INT_B -> b
    double[] EXP_FRAC_A -> c
    double[] EXP_FRAC_B -> d
    double[][] LN_MANT -> a
    double[] loadExpIntA() -> a
    double[] loadExpIntB() -> b
    double[] loadExpFracA() -> c
    double[] loadExpFracB() -> d
    double[][] loadLnMant() -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.Incrementor -> im:
    int maximalCount -> a
    int count -> b
    org.apache.commons.math3.util.Incrementor$MaxCountExceededCallback maxCountCallback -> a
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(int,org.apache.commons.math3.util.Incrementor$MaxCountExceededCallback) -> <init>
    void incrementCount() -> a
org.apache.commons.math3.util.Incrementor$1 -> in:
    void <init>() -> <init>
    void trigger(int) -> a
org.apache.commons.math3.util.Incrementor$MaxCountExceededCallback -> io:
    void trigger(int) -> a
org.apache.commons.math3.util.KthSelector -> org.apache.commons.math3.util.KthSelector:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.util.PivotingStrategyInterface pivotingStrategy -> pivotingStrategy
    void <init>() -> <init>
    void <init>(org.apache.commons.math3.util.PivotingStrategyInterface) -> <init>
    org.apache.commons.math3.util.PivotingStrategyInterface getPivotingStrategy() -> getPivotingStrategy
    double select(double[],int[],int) -> select
org.apache.commons.math3.util.MathArrays$3 -> ip:
    int[] $SwitchMap$org$apache$commons$math3$util$MathArrays$OrderDirection -> a
    int[] $SwitchMap$org$apache$commons$math3$util$MathArrays$Position -> b
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.MathArrays$Function -> iq:
    double evaluate(double[],int,int) -> evaluate
org.apache.commons.math3.util.MathArrays$OrderDirection -> org.apache.commons.math3.util.MathArrays$OrderDirection:
    org.apache.commons.math3.util.MathArrays$OrderDirection INCREASING -> INCREASING
    org.apache.commons.math3.util.MathArrays$OrderDirection DECREASING -> DECREASING
    org.apache.commons.math3.util.MathArrays$OrderDirection[] $VALUES -> a
    org.apache.commons.math3.util.MathArrays$OrderDirection[] values() -> values
    org.apache.commons.math3.util.MathArrays$OrderDirection valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.MathArrays$Position -> org.apache.commons.math3.util.MathArrays$Position:
    org.apache.commons.math3.util.MathArrays$Position HEAD -> HEAD
    org.apache.commons.math3.util.MathArrays$Position TAIL -> TAIL
    org.apache.commons.math3.util.MathArrays$Position[] $VALUES -> a
    org.apache.commons.math3.util.MathArrays$Position[] values() -> values
    org.apache.commons.math3.util.MathArrays$Position valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.MedianOf3PivotingStrategy -> org.apache.commons.math3.util.MedianOf3PivotingStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    int pivotIndex(double[],int,int) -> pivotIndex
org.apache.commons.math3.util.OpenIntToDoubleHashMap -> org.apache.commons.math3.util.OpenIntToDoubleHashMap:
    byte FREE -> FREE
    byte FULL -> FULL
    byte REMOVED -> REMOVED
    long serialVersionUID -> serialVersionUID
    int[] keys -> keys
    double[] values -> values
    byte[] states -> states
    double missingEntries -> missingEntries
    int size -> size
    int mask -> mask
    int count -> a
    void <init>() -> <init>
    void <init>(double) -> <init>
    void <init>(int) -> <init>
    void <init>(int,double) -> <init>
    void <init>(org.apache.commons.math3.util.OpenIntToDoubleHashMap) -> <init>
    double get(int) -> get
    boolean containsKey(int) -> containsKey
    org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator iterator() -> iterator
    int findInsertionIndex(int[],byte[],int,int) -> a
    int probe(int,int) -> a
    int size() -> size
    double remove(int) -> remove
    boolean containsKey(int,int) -> a
    double doRemove(int) -> a
    double put(int,double) -> put
    int hashOf(int) -> a
    void readObject(java.io.ObjectInputStream) -> readObject
    int access$100(org.apache.commons.math3.util.OpenIntToDoubleHashMap) -> access$100
    int[] access$200(org.apache.commons.math3.util.OpenIntToDoubleHashMap) -> access$200
    double[] access$300(org.apache.commons.math3.util.OpenIntToDoubleHashMap) -> access$300
    byte[] access$400(org.apache.commons.math3.util.OpenIntToDoubleHashMap) -> access$400
org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator -> ir:
    int referenceCount -> a
    int current -> b
    int next -> c
    org.apache.commons.math3.util.OpenIntToDoubleHashMap this$0 -> a
    void <init>(org.apache.commons.math3.util.OpenIntToDoubleHashMap) -> <init>
    boolean hasNext() -> a
    int key() -> a
    double value() -> a
    void advance() -> a
    void <init>(org.apache.commons.math3.util.OpenIntToDoubleHashMap,byte) -> <init>
org.apache.commons.math3.util.Pair -> is:
    java.lang.Object key -> key
    java.lang.Object value -> value
    void <init>(java.lang.Object,java.lang.Object) -> <init>
    void <init>(org.apache.commons.math3.util.Pair) -> <init>
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object getFirst() -> getFirst
    java.lang.Object getSecond() -> getSecond
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    org.apache.commons.math3.util.Pair create(java.lang.Object,java.lang.Object) -> create
org.apache.commons.math3.util.PivotingStrategyInterface -> it:
    int pivotIndex(double[],int,int) -> pivotIndex
org.apache.commons.math3.util.Precision -> iu:
    double EPSILON -> a
    double SAFE_MIN -> b
    long POSITIVE_ZERO_DOUBLE_BITS -> a
    long NEGATIVE_ZERO_DOUBLE_BITS -> b
    int POSITIVE_ZERO_FLOAT_BITS -> a
    int NEGATIVE_ZERO_FLOAT_BITS -> b
    int compareTo(double,double,double) -> a
    boolean equalsIncludingNaN(float,float) -> a
    boolean equals(double,double) -> a
    boolean equalsIncludingNaN(double,double) -> b
    boolean equals(double,double,double) -> a
    boolean equalsWithRelativeTolerance(double,double,double) -> b
    boolean equals(double,double,int) -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.ResizableDoubleArray -> org.apache.commons.math3.util.ResizableDoubleArray:
    int ADDITIVE_MODE -> ADDITIVE_MODE
    int MULTIPLICATIVE_MODE -> MULTIPLICATIVE_MODE
    long serialVersionUID -> serialVersionUID
    double contractionCriterion -> contractionCriterion
    double expansionFactor -> expansionFactor
    org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode expansionMode -> expansionMode
    double[] internalArray -> internalArray
    int numElements -> numElements
    int startIndex -> startIndex
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(double[]) -> <init>
    void <init>(int,float) -> <init>
    void <init>(int,double) -> <init>
    void <init>(int,float,float) -> <init>
    void <init>(int,double,double) -> <init>
    void <init>(int,float,float,int) -> <init>
    void <init>(int,double,double,org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode,double[]) -> <init>
    void <init>(org.apache.commons.math3.util.ResizableDoubleArray) -> <init>
    void addElement(double) -> addElement
    void addElements(double[]) -> addElements
    double addElementRolling(double) -> addElementRolling
    double substituteMostRecentElement(double) -> substituteMostRecentElement
    void checkContractExpand(float,float) -> checkContractExpand
    void checkContractExpand(double,double) -> checkContractExpand
    void clear() -> clear
    void contract() -> contract
    void discardFrontElements(int) -> discardFrontElements
    void discardMostRecentElements(int) -> discardMostRecentElements
    void discardExtremeElements(int,boolean) -> a
    void expand() -> expand
    void expandTo(int) -> a
    float getContractionCriteria() -> getContractionCriteria
    double getContractionCriterion() -> getContractionCriterion
    double getElement(int) -> getElement
    double[] getElements() -> getElements
    float getExpansionFactor() -> getExpansionFactor
    int getExpansionMode() -> getExpansionMode
    int getInternalLength() -> getInternalLength
    int getCapacity() -> getCapacity
    int getNumElements() -> getNumElements
    double[] getInternalValues() -> getInternalValues
    double[] getArrayRef() -> getArrayRef
    int getStartIndex() -> getStartIndex
    void setContractionCriteria(float) -> setContractionCriteria
    double compute(org.apache.commons.math3.util.MathArrays$Function) -> compute
    void setElement(int,double) -> setElement
    void setExpansionFactor(float) -> setExpansionFactor
    void setExpansionMode(int) -> setExpansionMode
    void setExpansionMode(org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode) -> setExpansionMode
    void setInitialCapacity(int) -> setInitialCapacity
    void setNumElements(int) -> setNumElements
    boolean shouldContract() -> a
    int start() -> start
    void copy(org.apache.commons.math3.util.ResizableDoubleArray,org.apache.commons.math3.util.ResizableDoubleArray) -> copy
    org.apache.commons.math3.util.ResizableDoubleArray copy() -> copy
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math3.util.ResizableDoubleArray$1 -> iv:
    int[] $SwitchMap$org$apache$commons$math3$util$ResizableDoubleArray$ExpansionMode -> a
    void <clinit>() -> <clinit>
org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode -> org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode:
    org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode MULTIPLICATIVE -> MULTIPLICATIVE
    org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode ADDITIVE -> ADDITIVE
    org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode[] $VALUES -> a
    org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode[] values() -> values
    org.apache.commons.math3.util.ResizableDoubleArray$ExpansionMode valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.apfloat.Apcomplex -> org.apfloat.Apcomplex:
    org.apfloat.Apint MINUS_ONE -> MINUS_ONE
    org.apfloat.Apint ZERO -> ZERO
    org.apfloat.Apint ONE -> ONE
    org.apfloat.Apcomplex I -> I
    long INFINITE -> INFINITE
    long DEFAULT -> DEFAULT
    int EXTRA_PRECISION -> EXTRA_PRECISION
    org.apfloat.Apint[] ONES -> ONES
    long serialVersionUID -> serialVersionUID
    org.apfloat.Apfloat real -> real
    org.apfloat.Apfloat imag -> imag
    void <init>() -> <init>
    void <init>(org.apfloat.Apfloat) -> <init>
    void <init>(org.apfloat.Apfloat,org.apfloat.Apfloat) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.io.PushbackReader) -> <init>
    int radix() -> radix
    org.apfloat.Apfloat real() -> real
    org.apfloat.Apfloat imag() -> imag
    org.apfloat.Apcomplex conj() -> conj
    long precision() -> precision
    org.apfloat.Apcomplex precision(long) -> precision
    long scale() -> scale
    long size() -> size
    org.apfloat.Apcomplex negate() -> negate
    org.apfloat.Apcomplex inverse() -> inverse
    org.apfloat.Apcomplex add(org.apfloat.Apcomplex) -> add
    org.apfloat.Apcomplex subtract(org.apfloat.Apcomplex) -> subtract
    org.apfloat.Apcomplex multiply(org.apfloat.Apcomplex) -> multiply
    org.apfloat.Apcomplex divide(org.apfloat.Apcomplex) -> divide
    double doubleValue() -> doubleValue
    float floatValue() -> floatValue
    byte byteValue() -> byteValue
    short shortValue() -> shortValue
    int intValue() -> intValue
    long longValue() -> longValue
    long equalDigits(org.apfloat.Apcomplex) -> equalDigits
    org.apfloat.Apcomplex toRadix(int) -> toRadix
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer) -> writeTo
    void writeTo(java.io.Writer,boolean) -> writeTo
    void formatTo(java.util.Formatter,int,int,int) -> formatTo
    void <clinit>() -> <clinit>
org.apfloat.ApcomplexMath -> iw:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    org.apfloat.Apfloat abs(org.apfloat.Apcomplex) -> a
    org.apfloat.Apfloat norm(org.apfloat.Apcomplex) -> b
    org.apfloat.Apfloat arg(org.apfloat.Apcomplex) -> c
    org.apfloat.Apcomplex scale(org.apfloat.Apcomplex,long) -> b
    org.apfloat.Apcomplex powAbs(org.apfloat.Apcomplex,long) -> c
    org.apfloat.Apcomplex sqrt(org.apfloat.Apcomplex) -> a
    org.apfloat.Apcomplex inverseRoot(org.apfloat.Apcomplex,long) -> a
    org.apfloat.Apcomplex inverseRootAbs(org.apfloat.Apcomplex,long,long) -> a
    org.apfloat.Apcomplex agm(org.apfloat.Apcomplex,org.apfloat.Apcomplex) -> b
    org.apfloat.Apcomplex log(org.apfloat.Apcomplex) -> b
    org.apfloat.Apcomplex exp(org.apfloat.Apcomplex) -> c
    org.apfloat.Apcomplex pow(org.apfloat.Apcomplex,org.apfloat.Apcomplex) -> a
    org.apfloat.Apcomplex acos(org.apfloat.Apcomplex) -> d
    org.apfloat.Apcomplex acosh(org.apfloat.Apcomplex) -> e
    org.apfloat.Apcomplex asin(org.apfloat.Apcomplex) -> f
    org.apfloat.Apcomplex asinh(org.apfloat.Apcomplex) -> g
    org.apfloat.Apcomplex atan(org.apfloat.Apcomplex) -> h
    org.apfloat.Apcomplex atanh(org.apfloat.Apcomplex) -> i
    org.apfloat.Apcomplex cos(org.apfloat.Apcomplex) -> j
    org.apfloat.Apcomplex cosh(org.apfloat.Apcomplex) -> k
    org.apfloat.Apcomplex sin(org.apfloat.Apcomplex) -> l
    org.apfloat.Apcomplex sinh(org.apfloat.Apcomplex) -> m
    org.apfloat.Apcomplex tan(org.apfloat.Apcomplex) -> n
    org.apfloat.Apcomplex tanh(org.apfloat.Apcomplex) -> o
    org.apfloat.Apcomplex w(org.apfloat.Apcomplex) -> p
    org.apfloat.Apcomplex lastIterationExtendPrecision(int,int,org.apfloat.Apcomplex) -> a
    void <clinit>() -> <clinit>
org.apfloat.Apfloat -> org.apfloat.Apfloat:
    long serialVersionUID -> serialVersionUID
    org.apfloat.spi.ApfloatImpl impl -> impl
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>() -> <init>
    void <init>(org.apfloat.spi.ApfloatImpl) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,long) -> <init>
    void <init>(java.lang.String,long,int) -> <init>
    void <init>(long) -> <init>
    void <init>(long,long) -> <init>
    void <init>(long,long,int) -> <init>
    void <init>(float) -> <init>
    void <init>(float,long) -> <init>
    void <init>(float,long,int) -> <init>
    void <init>(double) -> <init>
    void <init>(double,long) -> <init>
    void <init>(double,long,int) -> <init>
    void <init>(java.io.PushbackReader) -> <init>
    void <init>(java.io.PushbackReader,long) -> <init>
    void <init>(java.io.PushbackReader,long,int) -> <init>
    void <init>(java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger,long) -> <init>
    void <init>(java.math.BigInteger,long,int) -> <init>
    void <init>(java.math.BigDecimal) -> <init>
    void <init>(java.math.BigDecimal,long) -> <init>
    int radix() -> radix
    org.apfloat.Apfloat real() -> real
    org.apfloat.Apfloat imag() -> imag
    long precision() -> precision
    org.apfloat.Apfloat precision(long) -> precision
    long scale() -> scale
    long size() -> size
    int signum() -> signum
    boolean isShort() -> isShort
    org.apfloat.Apfloat negate() -> negate
    org.apfloat.Apfloat inverse() -> inverse
    org.apfloat.Apfloat add(org.apfloat.Apfloat) -> add
    org.apfloat.Apfloat subtract(org.apfloat.Apfloat) -> subtract
    org.apfloat.Apfloat addOrSubtract(org.apfloat.Apfloat,boolean) -> a
    org.apfloat.Apfloat multiply(org.apfloat.Apfloat) -> multiply
    org.apfloat.Apfloat divide(org.apfloat.Apfloat) -> divide
    org.apfloat.Apfloat mod(org.apfloat.Apfloat) -> mod
    org.apfloat.Apint floor() -> floor
    org.apfloat.Apint ceil() -> ceil
    org.apfloat.Apint truncate() -> truncate
    org.apfloat.Apfloat frac() -> frac
    double doubleValue() -> doubleValue
    float floatValue() -> floatValue
    byte byteValue() -> byteValue
    short shortValue() -> shortValue
    int intValue() -> intValue
    long longValue() -> longValue
    long equalDigits(org.apfloat.Apfloat) -> equalDigits
    org.apfloat.Apfloat toRadix(int) -> toRadix
    int compareTo(org.apfloat.Apfloat) -> compareTo
    boolean preferCompare(org.apfloat.Apfloat) -> preferCompare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer,boolean) -> writeTo
    void formatTo(java.util.Formatter,int,int,int) -> formatTo
    org.apfloat.spi.ApfloatImpl getImpl(long) -> getImpl
    org.apfloat.Apint roundAway() -> roundAway
    org.apfloat.Apfloat scale(long) -> scale
    org.apfloat.Apfloat abs() -> abs
    int compareToHalf() -> compareToHalf
    org.apfloat.spi.ApfloatImpl getImpl() -> a
    org.apfloat.Apcomplex toRadix(int) -> toRadix
    org.apfloat.Apcomplex inverse() -> inverse
    org.apfloat.Apcomplex negate() -> negate
    org.apfloat.Apcomplex precision(long) -> precision
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
org.apfloat.ApfloatConfigurationException -> org.apfloat.ApfloatConfigurationException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.ApfloatContext -> ix:
    org.apfloat.ApfloatContext globalContext -> a
    java.util.Map threadContexts -> a
    java.util.Properties defaultProperties -> a
    java.util.concurrent.ExecutorService defaultExecutorService -> b
    org.apfloat.spi.BuilderFactory builderFactory -> a
    org.apfloat.spi.FilenameGenerator filenameGenerator -> a
    int defaultRadix -> a
    long maxMemoryBlockSize -> a
    int cacheL1Size -> b
    int cacheL2Size -> c
    int cacheBurst -> d
    long memoryThreshold -> b
    long sharedMemoryTreshold -> c
    int blockSize -> e
    int numberOfProcessors -> f
    org.apfloat.ApfloatContext$CleanupThread cleanupThread -> a
    java.util.Properties properties -> b
    java.lang.Object sharedMemoryLock -> a
    java.util.concurrent.ExecutorService executorService -> a
    java.util.concurrent.ConcurrentHashMap attributes -> a
    void <init>(java.util.Properties) -> <init>
    org.apfloat.ApfloatContext getContext() -> a
    void setFilenameGenerator(org.apfloat.spi.FilenameGenerator) -> a
    void setNumberOfProcessors(int) -> a
    java.lang.String getProperty(java.lang.String) -> a
    java.util.Properties loadProperties() -> a
    void setProperties(java.util.Properties) -> a
    java.lang.Object clone() -> clone
    void <clinit>() -> <clinit>
org.apfloat.ApfloatContext$1 -> iy:
    java.util.concurrent.ThreadFactory defaultThreadFactory -> a
    void <init>() -> <init>
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
org.apfloat.ApfloatContext$CleanupThread -> iz:
    org.apfloat.spi.BuilderFactory builderFactory -> a
    void run() -> run
org.apfloat.ApfloatHelper -> iA:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl implCreateApfloat(java.lang.String,long,int,boolean) -> b
    org.apfloat.spi.ApfloatImpl createApfloat(long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl implCreateApfloat(long,long,int) -> b
    org.apfloat.spi.ApfloatImpl createApfloat(float) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(float,long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(float,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl implCreateApfloat(double,long,int) -> b
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl implCreateApfloat(java.io.PushbackReader,long,int,boolean) -> b
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigInteger) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigInteger,long) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigInteger,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigDecimal) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.math.BigDecimal,long) -> a
    boolean readMatch(java.io.PushbackReader,int) -> a
    void extractWhitespace(java.io.PushbackReader) -> a
    long[] getMatchingPrecisions(org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    long[] getMatchingPrecisions(org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    void checkPrecision(long) -> a
    void checkPowPrecision(long) -> b
    org.apfloat.Apcomplex checkPowBasic(org.apfloat.Apcomplex,org.apfloat.Apcomplex,long) -> b
    org.apfloat.Apcomplex checkPow(org.apfloat.Apcomplex,org.apfloat.Apcomplex,long) -> a
    org.apfloat.Apfloat checkPow(org.apfloat.Apfloat,org.apfloat.Apfloat,long) -> a
    int getFloatPrecision(int) -> c
    int getDoublePrecision(int) -> a
    int getLongPrecision(int) -> b
    org.apfloat.Apfloat limitPrecision(org.apfloat.Apfloat,long) -> a
    org.apfloat.Apfloat ensurePrecision(org.apfloat.Apfloat,long) -> b
    long extendPrecision(long,long) -> a
    long extendPrecision(long) -> a
    org.apfloat.Apfloat extendPrecision(org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat extendPrecision(org.apfloat.Apfloat,long) -> c
    org.apfloat.Apcomplex setPrecision(org.apfloat.Apcomplex,long) -> a
    org.apfloat.Apcomplex limitPrecision(org.apfloat.Apcomplex,long) -> b
    org.apfloat.Apcomplex ensurePrecision(org.apfloat.Apcomplex,long) -> c
    org.apfloat.Apcomplex extendPrecision(org.apfloat.Apcomplex) -> a
    org.apfloat.Apcomplex extendPrecision(org.apfloat.Apcomplex,long) -> d
    java.math.BigInteger toBigInteger(org.apfloat.Apint) -> a
    int getDefaultRadix() -> a
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> a
    void <clinit>() -> <clinit>
org.apfloat.ApfloatHelper$1 -> iB:
    int b -> a
    int bytePosition -> b
    boolean hi -> a
    byte[] val$bytes -> a
    boolean val$startHi -> b
    void <init>(byte[],boolean) -> <init>
    void write(int) -> write
    void write(char[],int,int) -> write
    void close() -> close
    void flush() -> flush
org.apfloat.ApfloatHelper$2 -> iC:
    int b -> a
    int val$startB -> b
    void <init>(byte[],int) -> <init>
    int read() -> read
    int read(byte[],int,int) -> read
org.apfloat.ApfloatMath -> iD:
    java.util.Map SHUTDOWN_MAP -> a
    java.util.concurrent.ConcurrentMap radixPiKeys -> a
    java.util.Map radixPi -> b
    java.util.Map radixPiCalculator -> c
    java.util.Map radixPiT -> d
    java.util.Map radixPiQ -> e
    java.util.Map radixPiP -> f
    java.util.Map radixPiInverseRoot -> g
    java.util.Map radixPiTerms -> h
    java.util.concurrent.ConcurrentMap radixLogKeys -> b
    java.util.Map radixLog -> i
    java.util.Map radixLogPi -> j
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    org.apfloat.Apfloat pow(org.apfloat.Apfloat,long) -> d
    org.apfloat.Apfloat sqrt(org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat root(org.apfloat.Apfloat,long) -> a
    org.apfloat.Apfloat inverseRoot(org.apfloat.Apfloat,long) -> b
    org.apfloat.Apfloat inverseRoot(org.apfloat.Apfloat,long,long) -> a
    org.apfloat.Apfloat inverseRoot(org.apfloat.Apfloat,long,long,org.apfloat.Apfloat) -> a
    org.apfloat.Apint floor(org.apfloat.Apfloat) -> a
    org.apfloat.Apint ceil(org.apfloat.Apfloat) -> b
    org.apfloat.Apfloat round(org.apfloat.Apfloat,long,java.math.RoundingMode) -> a
    org.apfloat.Apfloat abs(org.apfloat.Apfloat) -> b
    org.apfloat.Apfloat scale(org.apfloat.Apfloat,long) -> c
    org.apfloat.Apfloat fmod(org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat multiplyAdd(org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat multiplySubtract(org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat) -> b
    org.apfloat.Apfloat multiplyAddOrSubtract(org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,org.apfloat.Apfloat,boolean) -> a
    org.apfloat.Apfloat agm(org.apfloat.Apfloat,org.apfloat.Apfloat) -> b
    org.apfloat.Apfloat pi(long) -> a
    org.apfloat.Apfloat pi(long,int) -> a
    org.apfloat.Apfloat log(org.apfloat.Apfloat) -> c
    org.apfloat.Apfloat rawLog(org.apfloat.Apfloat,boolean) -> a
    org.apfloat.Apfloat logRadix(long,int) -> b
    org.apfloat.Apfloat logRadix(long,int,boolean) -> a
    org.apfloat.Apfloat exp(org.apfloat.Apfloat) -> d
    org.apfloat.Apfloat pow(org.apfloat.Apfloat,org.apfloat.Apfloat) -> c
    org.apfloat.Apfloat acosh(org.apfloat.Apfloat) -> e
    org.apfloat.Apfloat asinh(org.apfloat.Apfloat) -> f
    org.apfloat.Apfloat atanh(org.apfloat.Apfloat) -> g
    org.apfloat.Apfloat cosh(org.apfloat.Apfloat) -> h
    org.apfloat.Apfloat sinh(org.apfloat.Apfloat) -> i
    org.apfloat.Apfloat tanh(org.apfloat.Apfloat) -> j
    org.apfloat.Apfloat acos(org.apfloat.Apfloat) -> k
    org.apfloat.Apfloat asin(org.apfloat.Apfloat) -> l
    org.apfloat.Apfloat atan(org.apfloat.Apfloat) -> m
    org.apfloat.Apfloat atan2(org.apfloat.Apfloat,org.apfloat.Apfloat) -> d
    org.apfloat.Apfloat cos(org.apfloat.Apfloat) -> n
    org.apfloat.Apfloat sin(org.apfloat.Apfloat) -> o
    org.apfloat.Apfloat tan(org.apfloat.Apfloat) -> p
    org.apfloat.Apfloat w(org.apfloat.Apfloat) -> q
    org.apfloat.Apfloat lastIterationExtendPrecision(int,int,org.apfloat.Apfloat) -> a
    void cleanUp() -> a
    void <clinit>() -> <clinit>
org.apfloat.ApfloatMath$ApfloatHolder -> iE:
    org.apfloat.Apfloat apfloat -> a
    void <init>() -> <init>
    void <init>(org.apfloat.Apfloat) -> <init>
org.apfloat.ApfloatMath$PiCalculator -> iF:
    org.apfloat.Apfloat A -> a
    org.apfloat.Apfloat B -> b
    org.apfloat.Apfloat J -> c
    org.apfloat.Apfloat ONE -> d
    org.apfloat.Apfloat TWO -> e
    org.apfloat.Apfloat FIVE -> f
    org.apfloat.Apfloat SIX -> g
    int radix -> a
    boolean $assertionsDisabled -> a
    void <init>(int) -> <init>
    void r(long,long,org.apfloat.ApfloatMath$ApfloatHolder,org.apfloat.ApfloatMath$ApfloatHolder,org.apfloat.ApfloatMath$ApfloatHolder) -> a
    void <clinit>() -> <clinit>
org.apfloat.ApfloatRuntimeException -> org.apfloat.ApfloatRuntimeException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.Apint -> org.apfloat.Apint:
    long serialVersionUID -> serialVersionUID
    org.apfloat.Apfloat value -> value
    void <init>() -> <init>
    void <init>(org.apfloat.Apfloat) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,int) -> <init>
    void <init>(long) -> <init>
    void <init>(long,int) -> <init>
    void <init>(java.io.PushbackReader) -> <init>
    void <init>(java.io.PushbackReader,int) -> <init>
    void <init>(java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger,int) -> <init>
    org.apfloat.Apint numerator() -> numerator
    org.apfloat.Apint denominator() -> denominator
    int radix() -> radix
    long scale() -> scale
    long size() -> size
    int signum() -> signum
    boolean isShort() -> isShort
    org.apfloat.Apint negate() -> negate
    org.apfloat.Apint add(org.apfloat.Apint) -> add
    org.apfloat.Apint subtract(org.apfloat.Apint) -> subtract
    org.apfloat.Apint multiply(org.apfloat.Apint) -> multiply
    org.apfloat.Apint divide(org.apfloat.Apint) -> divide
    org.apfloat.Apint mod(org.apfloat.Apint) -> mod
    org.apfloat.Apint floor() -> floor
    org.apfloat.Apint ceil() -> ceil
    org.apfloat.Apint truncate() -> truncate
    org.apfloat.Apint frac() -> frac
    java.math.BigInteger toBigInteger() -> toBigInteger
    org.apfloat.Apint toRadix(int) -> toRadix
    int compareTo(org.apfloat.Apint) -> compareTo
    int compareTo(org.apfloat.Aprational) -> compareTo
    int compareTo(org.apfloat.Apfloat) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer,boolean) -> writeTo
    void formatTo(java.util.Formatter,int,int,int) -> formatTo
    org.apfloat.spi.ApfloatImpl getImpl(long) -> getImpl
    org.apfloat.Apint roundAway() -> roundAway
    org.apfloat.Apint abs() -> abs
    org.apfloat.Aprational abs() -> abs
    org.apfloat.Aprational toRadix(int) -> toRadix
    org.apfloat.Aprational frac() -> frac
    org.apfloat.Aprational negate() -> negate
    org.apfloat.Apfloat abs() -> abs
    org.apfloat.Apfloat toRadix(int) -> toRadix
    org.apfloat.Apfloat frac() -> frac
    org.apfloat.Apfloat negate() -> negate
    int compareTo(java.lang.Object) -> compareTo
    org.apfloat.Apcomplex toRadix(int) -> toRadix
    org.apfloat.Apcomplex negate() -> negate
org.apfloat.ApintMath -> iG:
    void <init>() -> <init>
    org.apfloat.Apint pow(org.apfloat.Apint,long) -> a
    org.apfloat.Apint abs(org.apfloat.Apint) -> a
    org.apfloat.Apint scale(org.apfloat.Apint,long) -> b
    org.apfloat.Apint[] div(org.apfloat.Apint,org.apfloat.Apint) -> a
    org.apfloat.Apint gcd(org.apfloat.Apint,org.apfloat.Apint) -> a
    void <clinit>() -> <clinit>
org.apfloat.Aprational -> org.apfloat.Aprational:
    long serialVersionUID -> serialVersionUID
    org.apfloat.Apint numerator -> numerator
    org.apfloat.Apint denominator -> denominator
    long scale -> scale
    long size -> size
    java.lang.ref.SoftReference inverseDen -> a
    java.lang.ref.SoftReference approx -> b
    void <init>() -> <init>
    void <init>(org.apfloat.Apint) -> <init>
    void <init>(org.apfloat.Apint,org.apfloat.Apint) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,int) -> <init>
    void <init>(java.io.PushbackReader) -> <init>
    void <init>(java.io.PushbackReader,int) -> <init>
    void <init>(java.math.BigInteger) -> <init>
    void <init>(java.math.BigInteger,int) -> <init>
    org.apfloat.Apint numerator() -> numerator
    org.apfloat.Apint denominator() -> denominator
    int radix() -> radix
    long precision() -> precision
    long scale() -> scale
    long size() -> size
    int signum() -> signum
    boolean isShort() -> isShort
    org.apfloat.Aprational negate() -> negate
    org.apfloat.Aprational add(org.apfloat.Aprational) -> add
    org.apfloat.Aprational subtract(org.apfloat.Aprational) -> subtract
    org.apfloat.Aprational multiply(org.apfloat.Aprational) -> multiply
    org.apfloat.Aprational divide(org.apfloat.Aprational) -> divide
    org.apfloat.Aprational mod(org.apfloat.Aprational) -> mod
    org.apfloat.Apint floor() -> floor
    org.apfloat.Apint ceil() -> ceil
    org.apfloat.Apint truncate() -> truncate
    org.apfloat.Aprational frac() -> frac
    org.apfloat.Aprational toRadix(int) -> toRadix
    int compareTo(org.apfloat.Aprational) -> compareTo
    int compareTo(org.apfloat.Apfloat) -> compareTo
    boolean preferCompare(org.apfloat.Apfloat) -> preferCompare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer) -> writeTo
    void writeTo(java.io.Writer,boolean) -> writeTo
    void formatTo(java.util.Formatter,int,int,int) -> formatTo
    org.apfloat.spi.ApfloatImpl getImpl(long) -> getImpl
    org.apfloat.Apint roundAway() -> roundAway
    org.apfloat.Aprational scale(long) -> scale
    org.apfloat.Aprational abs() -> abs
    int compareToHalf() -> compareToHalf
    void checkDenominator() -> a
    org.apfloat.Aprational reduce() -> a
    org.apfloat.Apfloat ensureApprox(long) -> a
    void setApprox(org.apfloat.Apfloat) -> a
    org.apfloat.Apfloat abs() -> abs
    org.apfloat.Apfloat scale(long) -> scale
    org.apfloat.Apfloat toRadix(int) -> toRadix
    org.apfloat.Apfloat frac() -> frac
    org.apfloat.Apfloat negate() -> negate
    int compareTo(java.lang.Object) -> compareTo
    org.apfloat.Apcomplex toRadix(int) -> toRadix
    org.apfloat.Apcomplex negate() -> negate
org.apfloat.ConcurrentSoftHashMap -> iH:
    java.util.concurrent.ConcurrentHashMap map -> a
    void <init>() -> <init>
    void clear() -> clear
    java.util.Set entrySet() -> entrySet
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object remove(java.lang.Object) -> remove
    int size() -> size
    java.lang.Object unwrap(java.lang.ref.SoftReference) -> a
org.apfloat.ConcurrentWeakHashMap -> iI:
    java.util.concurrent.ConcurrentHashMap map -> a
    java.lang.ref.ReferenceQueue queue -> a
    void <init>() -> <init>
    void clear() -> clear
    java.util.Set entrySet() -> entrySet
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object remove(java.lang.Object) -> remove
    boolean isEmpty() -> isEmpty
    int size() -> size
    org.apfloat.ConcurrentWeakHashMap$Key wrap(java.lang.Object) -> a
    void expungeStaleEntries() -> a
org.apfloat.ConcurrentWeakHashMap$Key -> iJ:
    int hashCode -> a
    void <init>(java.lang.Object,java.lang.ref.ReferenceQueue) -> <init>
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apfloat.FormattingHelper$AppendableWriter -> iK:
    java.lang.Appendable out -> a
    void <init>(java.lang.Appendable) -> <init>
    void write(int) -> write
    void write(char[],int,int) -> write
    void write(java.lang.String,int,int) -> write
    java.io.Writer append(java.lang.CharSequence) -> append
    java.io.Writer append(java.lang.CharSequence,int,int) -> append
    void flush() -> flush
    void close() -> close
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
org.apfloat.FormattingHelper$BufferWriter -> iL:
    java.io.Writer out -> a
    void <init>(java.io.Writer) -> <init>
org.apfloat.FormattingHelper$CountWriter -> iM:
    long count -> a
    void <init>(java.io.Writer) -> <init>
    void write(int) -> write
    void write(char[],int,int) -> write
    void write(java.lang.String,int,int) -> write
org.apfloat.FormattingHelper$LocalizeWriter -> iN:
    java.util.Locale locale -> a
    boolean localizeDigits -> a
    boolean isUpperCase -> b
    char zero -> a
    char decimalSeparator -> b
    void <init>(java.io.Writer,java.util.Locale,boolean,boolean) -> <init>
    void write(int) -> write
    void write(char[],int,int) -> write
    void write(java.lang.String,int,int) -> write
org.apfloat.GCDHelper -> iO:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    org.apfloat.Apint gcd(org.apfloat.Apint,org.apfloat.Apint) -> a
    org.apfloat.Apint elementaryGcd(org.apfloat.Apint,org.apfloat.Apint) -> b
    org.apfloat.Apint recursiveGcd(org.apfloat.Apint,org.apfloat.Apint) -> c
    org.apfloat.GCDHelper$HalfGcdType halfBinaryGcd(org.apfloat.Apint,org.apfloat.Apint,long) -> a
    org.apfloat.Apint[] binaryDivide(org.apfloat.Apint,org.apfloat.Apint) -> a
    long v(org.apfloat.Apint) -> a
    org.apfloat.Apint powerOfTwo(long) -> a
    void <clinit>() -> <clinit>
org.apfloat.GCDHelper$HalfGcdType -> iP:
    long j -> a
    org.apfloat.GCDHelper$Matrix r -> a
    void <init>(long,org.apfloat.GCDHelper$Matrix) -> <init>
org.apfloat.GCDHelper$Matrix -> iQ:
    org.apfloat.Apint r11 -> a
    org.apfloat.Apint r12 -> b
    org.apfloat.Apint r21 -> c
    org.apfloat.Apint r22 -> d
    void <init>(org.apfloat.Apint,org.apfloat.Apint,org.apfloat.Apint,org.apfloat.Apint) -> <init>
    org.apfloat.GCDHelper$Matrix multiply(org.apfloat.GCDHelper$Matrix) -> a
    org.apfloat.Apint multiplyAdd(org.apfloat.Apint,org.apfloat.Apint,org.apfloat.Apint,org.apfloat.Apint) -> a
org.apfloat.InfiniteExpansionException -> org.apfloat.InfiniteExpansionException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.LambertWHelper -> org.apfloat.LambertWHelper:
    org.apfloat.Apfloat x -> a
    org.apfloat.Apcomplex z -> a
    int radix -> a
    long precision -> a
    long targetPrecision -> b
    long k -> c
    boolean close -> a
    org.apfloat.Apint minusOne -> a
    org.apfloat.Apint one -> b
    org.apfloat.Apint two -> c
    org.apfloat.Apint three -> d
    org.apfloat.Apfloat twoPi -> b
    org.apfloat.Apfloat twoPiK -> c
    org.apfloat.Apfloat e -> d
    org.apfloat.Apfloat minusOnePerE -> e
    org.apfloat.Apcomplex p -> b
    boolean $assertionsDisabled -> b
    void <init>(org.apfloat.Apcomplex,long) -> <init>
    org.apfloat.Apfloat w(org.apfloat.Apfloat) -> a
    org.apfloat.Apcomplex w(org.apfloat.Apcomplex) -> a
    org.apfloat.Apfloat real() -> a
    org.apfloat.Apfloat doReal() -> b
    org.apfloat.Apcomplex complex() -> a
    org.apfloat.Apcomplex log(org.apfloat.Apcomplex) -> b
    org.apfloat.Apcomplex logApprox(org.apfloat.Apcomplex) -> c
    org.apfloat.Apcomplex p() -> b
    org.apfloat.Apfloat realSeries(org.apfloat.Apcomplex) -> a
    org.apfloat.Apcomplex complexSeries(org.apfloat.Apcomplex) -> d
    long shiftLeftPrecision(long,int) -> a
    long shiftLeftPrecision(long,int,long) -> a
    org.apfloat.Apfloat twoPi() -> c
    void <clinit>() -> <clinit>
org.apfloat.LambertWHelper$ComplexException -> org.apfloat.LambertWHelper$ComplexException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.ArithmeticException) -> <init>
    java.lang.ArithmeticException getCause() -> getCause
    java.lang.Throwable getCause() -> getCause
org.apfloat.LossOfPrecisionException -> org.apfloat.LossOfPrecisionException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.OverflowException -> org.apfloat.OverflowException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.RadixConversionHelper$RadixPowerList -> iR:
    java.util.List list -> a
    void <init>(int,int,long) -> <init>
    org.apfloat.Apfloat pow(long) -> a
    org.apfloat.Apfloat get(int) -> a
org.apfloat.RoundingHelper$1 -> iS:
    int[] $SwitchMap$java$math$RoundingMode -> a
    void <clinit>() -> <clinit>
org.apfloat.ShutdownMap -> iT:
    void <init>() -> <init>
    java.util.Set entrySet() -> entrySet
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
org.apfloat.internal.AbstractConvolutionBuilder -> iU:
    double LOG2_3 -> a
    void <init>() -> <init>
    org.apfloat.spi.ConvolutionStrategy createConvolution$75792394(int,long,long) -> a
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.AbstractStepFNTStrategy -> iV:
    org.apfloat.spi.NTTStepStrategy stepStrategy -> a
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void transform(org.apfloat.spi.DataStorage,int,int,long,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,int,long,long,int) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.ApfloatInternalException -> org.apfloat.internal.ApfloatInternalException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.internal.BackingStorageException -> org.apfloat.internal.BackingStorageException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.internal.ConcurrentSoftHashMap -> iW:
    java.util.concurrent.ConcurrentHashMap map -> a
    void <init>() -> <init>
    void clear() -> clear
    java.util.Set entrySet() -> entrySet
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object) -> putIfAbsent
    java.lang.Object remove(java.lang.Object) -> remove
    boolean remove(java.lang.Object,java.lang.Object) -> remove
    java.lang.Object replace(java.lang.Object,java.lang.Object) -> replace
    boolean replace(java.lang.Object,java.lang.Object,java.lang.Object) -> replace
    int size() -> size
    java.lang.ref.SoftReference wrap(java.lang.Object) -> a
    java.lang.Object unwrap(java.lang.ref.SoftReference) -> a
org.apfloat.internal.DiskDataStorage -> org.apfloat.internal.DiskDataStorage:
    java.nio.channels.ReadableByteChannel ZERO_CHANNEL -> a
    long serialVersionUID -> serialVersionUID
    java.lang.ref.ReferenceQueue referenceQueue -> a
    java.util.Set references -> a
    java.lang.ThreadLocal threadLocal -> a
    boolean cleanUp -> a
    org.apfloat.internal.DiskDataStorage$FileStorage fileStorage -> fileStorage
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>() -> <init>
    void <init>(org.apfloat.internal.DiskDataStorage,long,long) -> <init>
    boolean isCached() -> isCached
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> implCopyFrom
    long implGetSize() -> implGetSize
    void implSetSize(long) -> implSetSize
    org.apfloat.spi.ArrayAccess implGetArray(int,int,int,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> implGetTransposedArray
    void setArray(org.apfloat.spi.ArrayAccess,int,int,int) -> setArray
    void setTransposedArray(org.apfloat.spi.ArrayAccess,int,int,int) -> setTransposedArray
    void readToArray(long,org.apfloat.spi.ArrayAccess,int,int) -> a
    void writeFromArray(org.apfloat.spi.ArrayAccess,int,long,int) -> a
    org.apfloat.spi.ArrayAccess createArrayAccess(int,int,int,int) -> createArrayAccess
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> createTransposedArrayAccess
    void transferFrom(java.nio.channels.ReadableByteChannel,long,long) -> transferFrom
    void transferTo(java.nio.channels.WritableByteChannel,long,long) -> transferTo
    int getBlockSize() -> getBlockSize
    int getUnitSize() -> getUnitSize
    java.lang.String getFilename() -> getFilename
    java.nio.channels.FileChannel getFileChannel() -> getFileChannel
    void cleanUp() -> cleanUp
    void gc() -> gc
    void pad(long,long) -> a
    org.apfloat.internal.DiskDataStorage$FileStorage createFileStorage() -> a
    void referenceFileStorage(org.apfloat.internal.DiskDataStorage$FileStorage) -> a
    void freeFileStorage() -> a
    void forceFreeFileStorage() -> b
    void access$000(org.apfloat.internal.DiskDataStorage$FileStorage) -> access$000
    void access$100() -> access$100
    java.nio.ByteBuffer access$200() -> access$200
    void <clinit>() -> <clinit>
org.apfloat.internal.DiskDataStorage$1 -> iX:
    void <init>() -> <init>
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.DiskDataStorage$FileStorage -> org.apfloat.internal.DiskDataStorage$FileStorage:
    long serialVersionUID -> serialVersionUID
    java.lang.String filename -> a
    java.io.File file -> a
    java.io.RandomAccessFile randomAccessFile -> a
    java.nio.channels.FileChannel fileChannel -> a
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>() -> <init>
    void init() -> a
    void setSize(long) -> setSize
    void transferFrom(java.nio.channels.ReadableByteChannel,long,long) -> transferFrom
    void transferTo(java.nio.channels.WritableByteChannel,long,long) -> transferTo
    java.lang.String getFilename() -> getFilename
    java.io.File getFile() -> getFile
    java.io.RandomAccessFile getRandomAccessFile() -> getRandomAccessFile
    java.nio.channels.FileChannel getFileChannel() -> getFileChannel
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    void readObject(java.io.ObjectInputStream) -> readObject
    void <clinit>() -> <clinit>
org.apfloat.internal.DiskDataStorage$FileStorageReference -> iY:
    java.io.File file -> a
    java.io.RandomAccessFile randomAccessFile -> a
    java.nio.channels.FileChannel fileChannel -> a
    void <init>(org.apfloat.internal.DiskDataStorage$FileStorage,java.lang.ref.ReferenceQueue) -> <init>
    void dispose() -> a
org.apfloat.internal.DoubleAdditionBuilder -> iZ:
    void <init>() -> <init>
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.internal.DoubleAdditionStrategy -> org.apfloat.internal.DoubleAdditionStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>(int) -> <init>
    java.lang.Double add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Double,org.apfloat.spi.DataStorage$Iterator,long) -> add
    java.lang.Double subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Double,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Double multiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Double,java.lang.Double,org.apfloat.spi.DataStorage$Iterator,long) -> multiplyAdd
    java.lang.Double divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Double,java.lang.Double,org.apfloat.spi.DataStorage$Iterator,long) -> divide
    java.lang.Double zero() -> zero
    java.lang.Object zero() -> zero
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> divide
    java.lang.Object multiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> multiplyAdd
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> add
org.apfloat.internal.DoubleApfloatBuilder -> ja:
    void <init>() -> <init>
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.internal.DoubleApfloatImpl -> org.apfloat.internal.DoubleApfloatImpl:
    org.apfloat.spi.DataStorage$Iterator ZERO_ITERATOR -> a
    long serialVersionUID -> serialVersionUID
    int sign -> sign
    long precision -> precision
    long exponent -> exponent
    org.apfloat.spi.DataStorage dataStorage -> dataStorage
    int radix -> radix
    int hashCode -> hashCode
    int initialDigits -> initialDigits
    int isOne -> isOne
    long leastZeros -> leastZeros
    long size -> size
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int,long,long,org.apfloat.spi.DataStorage,int) -> <init>
    void <init>(java.lang.String,long,int,boolean) -> <init>
    void <init>(long,long,int) -> <init>
    void <init>(double,long,int) -> <init>
    long readExponent(java.io.PushbackReader) -> a
    void <init>(java.io.PushbackReader,long,int,boolean) -> <init>
    long getTrailingZeros(org.apfloat.spi.DataStorage,long) -> a
    long getLeadingZeros(org.apfloat.spi.DataStorage,long) -> b
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> addOrSubtract
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> multiply
    boolean isShort() -> isShort
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> divideShort
    org.apfloat.spi.ApfloatImpl absFloor() -> absFloor
    org.apfloat.spi.ApfloatImpl absCeil() -> absCeil
    org.apfloat.spi.ApfloatImpl frac() -> frac
    org.apfloat.spi.ApfloatImpl zero() -> a
    int radix() -> radix
    long precision() -> precision
    long size() -> size
    long getLeastZeros() -> a
    org.apfloat.spi.ApfloatImpl precision(long) -> precision
    long scale() -> scale
    int signum() -> signum
    org.apfloat.spi.ApfloatImpl negate() -> negate
    double doubleValue() -> doubleValue
    long longValue() -> longValue
    boolean isOne() -> isOne
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> equalDigits
    int compareTo(org.apfloat.spi.ApfloatImpl) -> compareTo
    org.apfloat.spi.DataStorage$Iterator getZeroPaddedIterator(long,long) -> a
    int compareMantissaTo(org.apfloat.internal.DoubleApfloatImpl) -> a
    long findMismatch(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long) -> a
    double getLeastSignificantWord(long,double) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeZeros(java.io.Writer,long) -> a
    void writeTo(java.io.Writer,boolean) -> writeTo
    long getSize() -> b
    int checkRadix(int) -> a
    double getMostSignificantWord(org.apfloat.spi.DataStorage) -> a
    int getInitialDigits() -> a
    int getInitialDigits(org.apfloat.spi.DataStorage) -> a
    int getDigits(double) -> a
    long getBasePrecision() -> c
    long getBasePrecision(long,int) -> a
    double getWord(long) -> a
    void readObject(java.io.ObjectInputStream) -> readObject
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    double access$000(org.apfloat.internal.DoubleApfloatImpl,long,double) -> access$000
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleApfloatImpl$1 -> org.apfloat.internal.DoubleApfloatImpl$1:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.DoubleApfloatImpl this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleApfloatImpl) -> <init>
    void setDouble(double) -> setDouble
    void next() -> next
org.apfloat.internal.DoubleApfloatImpl$2 -> org.apfloat.internal.DoubleApfloatImpl$2:
    long serialVersionUID -> serialVersionUID
    long index -> index
    long val$end -> val$end
    org.apfloat.spi.DataStorage$Iterator val$iterator -> val$iterator
    long val$start -> val$start
    org.apfloat.internal.DoubleApfloatImpl this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleApfloatImpl,long,org.apfloat.spi.DataStorage$Iterator,long) -> <init>
    double getDouble() -> getDouble
    void next() -> next
    void close() -> close
org.apfloat.internal.DoubleApfloatImpl$3 -> org.apfloat.internal.DoubleApfloatImpl$3:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    double getDouble() -> getDouble
    void next() -> next
org.apfloat.internal.DoubleBaseMath -> org.apfloat.internal.DoubleBaseMath:
    long serialVersionUID -> serialVersionUID
    int radix -> radix
    double inverseBase -> inverseBase
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    double baseAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,double,org.apfloat.spi.DataStorage$Iterator,long) -> baseAdd
    double baseSubtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,double,org.apfloat.spi.DataStorage$Iterator,long) -> baseSubtract
    double baseMultiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,double,double,org.apfloat.spi.DataStorage$Iterator,long) -> baseMultiplyAdd
    double baseDivide(org.apfloat.spi.DataStorage$Iterator,double,double,org.apfloat.spi.DataStorage$Iterator,long) -> baseDivide
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleBuilderFactory -> org.apfloat.internal.DoubleBuilderFactory:
    org.apfloat.spi.ApfloatBuilder apfloatBuilder -> a
    org.apfloat.spi.DataStorageBuilder dataStorageBuilder -> a
    org.apfloat.spi.AdditionBuilder additionBuilder -> a
    org.apfloat.spi.ConvolutionBuilder convolutionBuilder -> a
    org.apfloat.spi.NTTBuilder nttBuilder -> a
    org.apfloat.spi.MatrixBuilder matrixBuilder -> a
    org.apfloat.spi.CarryCRTBuilder carryCRTBuilder -> a
    void <init>() -> <init>
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> getApfloatBuilder
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> getDataStorageBuilder
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> getAdditionBuilder
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> getConvolutionBuilder
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> getNTTBuilder
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> getMatrixBuilder
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> getCarryCRTBuilder
    java.lang.Class getElementType() -> getElementType
    java.lang.Class getElementArrayType() -> getElementArrayType
    int getElementSize() -> getElementSize
    void shutdown() -> shutdown
    void gc() -> gc
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleCRTMath -> org.apfloat.internal.DoubleCRTMath:
    long serialVersionUID -> serialVersionUID
    long base -> base
    double inverseBase -> inverseBase
    void <init>(int) -> <init>
    void multiply(double[],double,double[]) -> multiply
    double compare(double[],double[]) -> compare
    double add(double[],double[]) -> add
    void subtract(double[],double[]) -> subtract
    double divide(double[]) -> divide
org.apfloat.internal.DoubleCarryCRTBuilder -> jb:
    void <init>() -> <init>
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.internal.DoubleCarryCRTStepStrategy -> org.apfloat.internal.DoubleCarryCRTStepStrategy:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.DoubleModMath MATH_MOD_0 -> a
    org.apfloat.internal.DoubleModMath MATH_MOD_1 -> b
    org.apfloat.internal.DoubleModMath MATH_MOD_2 -> c
    double T0 -> a
    double T1 -> b
    double T2 -> c
    double[] M01 -> a
    double[] M02 -> b
    double[] M12 -> c
    double[] M012 -> d
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    double[] crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    double[] carry(org.apfloat.spi.DataStorage,long,long,long,long,double[],double[]) -> carry
    org.apfloat.spi.DataStorage$Iterator arrayIterator(double[]) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> carry
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleCarryCRTStepStrategy$1 -> org.apfloat.internal.DoubleCarryCRTStepStrategy$1:
    long serialVersionUID -> serialVersionUID
    int position -> position
    boolean $assertionsDisabled -> $assertionsDisabled
    double[] val$data -> val$data
    void <init>(double[]) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    double getDouble() -> getDouble
    void setDouble(double) -> setDouble
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleCarryCRTStepStrategy$2 -> org.apfloat.internal.DoubleCarryCRTStepStrategy$2:
    long serialVersionUID -> serialVersionUID
    long position -> position
    long val$size -> val$size
    org.apfloat.spi.DataStorage$Iterator val$iterator1 -> val$iterator1
    org.apfloat.spi.DataStorage$Iterator val$iterator2 -> val$iterator2
    void <init>(long,org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    double getDouble() -> getDouble
    void setDouble(double) -> setDouble
    void close() -> close
org.apfloat.internal.DoubleConvolutionBuilder -> jc:
    void <init>() -> <init>
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.DoubleDataStorageBuilder -> jd:
    void <init>() -> <init>
    long getMaxCachedSize() -> a
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.DoubleDiskDataStorage -> org.apfloat.internal.DoubleDiskDataStorage:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(org.apfloat.internal.DoubleDiskDataStorage,long,long) -> <init>
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess createArrayAccess(int,int,int,int) -> createArrayAccess
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> createTransposedArrayAccess
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    int getUnitSize() -> getUnitSize
org.apfloat.internal.DoubleDiskDataStorage$BlockIterator -> org.apfloat.internal.DoubleDiskDataStorage$BlockIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.spi.ArrayAccess arrayAccess -> arrayAccess
    double[] data -> data
    int offset -> offset
    int remaining -> remaining
    boolean $assertionsDisabled -> $assertionsDisabled
    org.apfloat.internal.DoubleDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleDiskDataStorage,int,long,long) -> <init>
    void next() -> next
    double getDouble() -> getDouble
    void setDouble(double) -> setDouble
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void close() -> close
    void checkAvailable() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess -> org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    long fileOffset -> fileOffset
    org.apfloat.internal.DoubleDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleDiskDataStorage,int,long,int) -> <init>
    void close() -> close
org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess$1 -> je:
    int readPosition -> a
    double[] val$array -> a
    void <init>(org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess,org.apfloat.internal.DoubleDiskDataStorage,double[]) -> <init>
    int write(java.nio.ByteBuffer) -> write
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess$2 -> jf:
    int writePosition -> a
    double[] val$array -> a
    void <init>(org.apfloat.internal.DoubleDiskDataStorage$DoubleDiskArrayAccess,double[]) -> <init>
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.DoubleDiskDataStorage$MemoryArrayAccess -> org.apfloat.internal.DoubleDiskDataStorage$MemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int startColumn -> startColumn
    int columns -> columns
    int rows -> rows
    org.apfloat.internal.DoubleDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleDiskDataStorage,int,double[],int,int,int) -> <init>
    void close() -> close
org.apfloat.internal.DoubleDiskDataStorage$TransposedMemoryArrayAccess -> org.apfloat.internal.DoubleDiskDataStorage$TransposedMemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int startColumn -> startColumn
    int columns -> columns
    int rows -> rows
    org.apfloat.internal.DoubleDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleDiskDataStorage,int,double[],int,int,int) -> <init>
    void close() -> close
org.apfloat.internal.DoubleElementaryModMath -> jg:
    long longModulus -> a
    double modulus -> a
    double inverseModulus -> b
    void <init>() -> <init>
    double modMultiply(double,double) -> a
    double modAdd(double,double) -> b
    double modSubtract(double,double) -> c
    void setModulus(double) -> a
org.apfloat.internal.DoubleFactor3NTTStepStrategy -> jh:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleFactor3NTTStepStrategy$1 -> ji:
    org.apfloat.spi.DataStorage val$dataStorage0 -> a
    org.apfloat.spi.DataStorage val$dataStorage1 -> b
    org.apfloat.spi.DataStorage val$dataStorage2 -> c
    long val$startColumn -> a
    double val$w -> a
    double val$ww -> b
    double val$w1 -> c
    double val$w2 -> d
    boolean val$isInverse -> a
    org.apfloat.internal.DoubleFactor3NTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleFactor3NTTStepStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,double,double,double,double,boolean) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.DoubleFactor3NTTStepStrategy$ColumnTransformRunnable -> jj:
    org.apfloat.spi.DataStorage dataStorage0 -> a
    org.apfloat.spi.DataStorage dataStorage1 -> b
    org.apfloat.spi.DataStorage dataStorage2 -> c
    long startColumn -> a
    long columns -> b
    double w -> a
    double ww -> b
    double w1 -> c
    double w2 -> d
    boolean isInverse -> a
    org.apfloat.internal.DoubleFactor3NTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleFactor3NTTStepStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,double,double,double,double,boolean) -> <init>
    void run() -> run
org.apfloat.internal.DoubleKaratsubaConvolutionStrategy -> org.apfloat.internal.DoubleKaratsubaConvolutionStrategy:
    int CUTOFF_POINT -> CUTOFF_POINT
    long serialVersionUID -> serialVersionUID
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    org.apfloat.spi.DataStorage add(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    void subtract(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    boolean isZero(org.apfloat.spi.DataStorage,long) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleMatrixBuilder -> jk:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    void <init>() -> <init>
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleMatrixStrategy -> jl:
    void <init>() -> <init>
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
    void moveBlock(double[],int,int,double[],int,int,int) -> a
    void transposeBlock(double[],int,int,int) -> a
    void transposeSquare(double[],int,int,int) -> b
    void permuteToHalfWidth(double[],int,int,int) -> c
    void permuteToDoubleWidth(double[],int,int,int) -> d
org.apfloat.internal.DoubleMediumConvolutionStrategy -> org.apfloat.internal.DoubleMediumConvolutionStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
org.apfloat.internal.DoubleMediumConvolutionStrategy$1 -> org.apfloat.internal.DoubleMediumConvolutionStrategy$1:
    long serialVersionUID -> serialVersionUID
    double[] buffer -> buffer
    int position -> position
    int val$bufferSize -> val$bufferSize
    org.apfloat.internal.DoubleMediumConvolutionStrategy this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleMediumConvolutionStrategy,int) -> <init>
    void next() -> next
    double getDouble() -> getDouble
    void setDouble(double) -> setDouble
org.apfloat.internal.DoubleMemoryArrayAccess -> org.apfloat.internal.DoubleMemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    double[] data -> data
    void <init>(double[],int,int) -> <init>
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> subsequence
    java.lang.Object getData() -> getData
    double[] getDoubleData() -> getDoubleData
    void close() -> close
org.apfloat.internal.DoubleMemoryDataStorage -> org.apfloat.internal.DoubleMemoryDataStorage:
    long serialVersionUID -> serialVersionUID
    double[] data -> data
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>() -> <init>
    void <init>(org.apfloat.internal.DoubleMemoryDataStorage,long,long) -> <init>
    boolean isCached() -> isCached
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> implCopyFrom
    long implGetSize() -> implGetSize
    void implSetSize(long) -> implSetSize
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetArray(int,int,int,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> implGetTransposedArray
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    double[] access$000(org.apfloat.internal.DoubleMemoryDataStorage) -> access$000
    long access$100(org.apfloat.internal.DoubleMemoryDataStorage) -> access$100
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleMemoryDataStorage$ReadOnlyIterator -> org.apfloat.internal.DoubleMemoryDataStorage$ReadOnlyIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.DoubleMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleMemoryDataStorage,long,long) -> <init>
    void setDouble(double) -> setDouble
org.apfloat.internal.DoubleMemoryDataStorage$ReadWriteIterator -> org.apfloat.internal.DoubleMemoryDataStorage$ReadWriteIterator:
    long serialVersionUID -> serialVersionUID
    double[] data -> data
    int position -> position
    int length -> length
    org.apfloat.internal.DoubleMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleMemoryDataStorage,long,long) -> <init>
    void <init>(org.apfloat.internal.DoubleMemoryDataStorage,int,long,long) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    double getDouble() -> getDouble
    void setDouble(double) -> setDouble
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void checkLength() -> checkLength
org.apfloat.internal.DoubleMemoryDataStorage$WriteOnlyIterator -> org.apfloat.internal.DoubleMemoryDataStorage$WriteOnlyIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.DoubleMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.DoubleMemoryDataStorage,long,long) -> <init>
    double getDouble() -> getDouble
org.apfloat.internal.DoubleModConstants -> jm:
    double[] MODULUS -> a
    double[] PRIMITIVE_ROOT -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleModMath -> jn:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    double getForwardNthRoot(double,long) -> a
    double getInverseNthRoot(double,long) -> b
    double modDivide(double,double) -> d
    double modPow(double,double) -> e
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleNTTBuilder -> jo:
    void <init>() -> <init>
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.DoubleNTTConvolutionStepStrategy -> jp:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleNTTConvolutionStepStrategy$1 -> jq:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.spi.DataStorage val$source -> b
    org.apfloat.internal.DoubleNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleNTTConvolutionStepStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.DoubleNTTConvolutionStepStrategy$2 -> jr:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.internal.DoubleNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleNTTConvolutionStepStrategy,long,org.apfloat.spi.DataStorage) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.DoubleNTTConvolutionStepStrategy$MultiplyInPlaceRunnable -> js:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    org.apfloat.spi.DataStorage source -> b
    long offset -> a
    long length -> b
    org.apfloat.internal.DoubleNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleNTTConvolutionStepStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long) -> <init>
    void run() -> run
org.apfloat.internal.DoubleNTTConvolutionStepStrategy$SquareInPlaceRunnable -> jt:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    long offset -> a
    long length -> b
    org.apfloat.internal.DoubleNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleNTTConvolutionStepStrategy,org.apfloat.spi.DataStorage,long,long) -> <init>
    void run() -> run
org.apfloat.internal.DoubleNTTStepStrategy -> ju:
    void <init>() -> <init>
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.DoubleNTTStepStrategy$1 -> jv:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$columns -> a
    int val$startRow -> b
    int val$startColumn -> c
    double val$w -> a
    double val$scaleFactor -> b
    org.apfloat.internal.DoubleNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleNTTStepStrategy,long,org.apfloat.spi.ArrayAccess,int,int,int,double,double) -> <init>
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.DoubleNTTStepStrategy$2 -> jw:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$length -> a
    boolean val$isInverse -> a
    double[] val$wTable -> a
    int[] val$permutationTable -> a
    org.apfloat.internal.DoubleNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleNTTStepStrategy,long,org.apfloat.spi.ArrayAccess,int,boolean,double[],int[]) -> <init>
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.DoubleNTTStepStrategy$MultiplyRunnable -> jx:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int startRow -> a
    int startColumn -> b
    int rows -> c
    int columns -> d
    double w -> a
    double scaleFactor -> b
    org.apfloat.internal.DoubleNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleNTTStepStrategy,org.apfloat.spi.ArrayAccess,int,int,int,int,double,double) -> <init>
    void run() -> run
org.apfloat.internal.DoubleNTTStepStrategy$TableFNTRunnable -> jy:
    int length -> a
    boolean isInverse -> a
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    double[] wTable -> a
    int[] permutationTable -> a
    org.apfloat.internal.DoubleNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.DoubleNTTStepStrategy,int,boolean,org.apfloat.spi.ArrayAccess,double[],int[]) -> <init>
    void run() -> run
org.apfloat.internal.DoubleRadixConstants -> jz:
    double[] BASE -> a
    int[] BASE_DIGITS -> a
    double[][] MINIMUM_FOR_DIGITS -> a
    long[] MAX_EXPONENT -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleShortConvolutionStrategy -> org.apfloat.internal.DoubleShortConvolutionStrategy:
    long serialVersionUID -> serialVersionUID
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleTableFNT -> jA:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void tableFNT(org.apfloat.spi.ArrayAccess,double[],int[]) -> a
    void inverseTableFNT(org.apfloat.spi.ArrayAccess,double[],int[]) -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.DoubleTableFNTStrategy -> jB:
    void <init>() -> <init>
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void divideElements(org.apfloat.spi.ArrayAccess,double) -> a
org.apfloat.internal.DoubleWTables -> jC:
    java.util.concurrent.ConcurrentMap cache -> a
    double[] getWTable(int,int) -> a
    double[] getInverseWTable(int,int) -> b
    double[] getWTable(int,int,boolean) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.Factor3NTTStrategy -> jD:
    org.apfloat.spi.NTTStrategy factor2Strategy -> a
    org.apfloat.spi.Factor3NTTStepStrategy stepStrategy -> a
    boolean $assertionsDisabled -> a
    void <init>(org.apfloat.spi.NTTStrategy) -> <init>
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatAdditionBuilder -> jE:
    void <init>() -> <init>
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.internal.FloatAdditionStrategy -> org.apfloat.internal.FloatAdditionStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>(int) -> <init>
    java.lang.Float add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Float,org.apfloat.spi.DataStorage$Iterator,long) -> add
    java.lang.Float subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Float,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Float multiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Float,java.lang.Float,org.apfloat.spi.DataStorage$Iterator,long) -> multiplyAdd
    java.lang.Float divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Float,java.lang.Float,org.apfloat.spi.DataStorage$Iterator,long) -> divide
    java.lang.Float zero() -> zero
    java.lang.Object zero() -> zero
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> divide
    java.lang.Object multiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> multiplyAdd
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> add
org.apfloat.internal.FloatApfloatBuilder -> jF:
    void <init>() -> <init>
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.internal.FloatApfloatImpl -> org.apfloat.internal.FloatApfloatImpl:
    org.apfloat.spi.DataStorage$Iterator ZERO_ITERATOR -> a
    long serialVersionUID -> serialVersionUID
    int sign -> sign
    long precision -> precision
    long exponent -> exponent
    org.apfloat.spi.DataStorage dataStorage -> dataStorage
    int radix -> radix
    int hashCode -> hashCode
    int initialDigits -> initialDigits
    int isOne -> isOne
    long leastZeros -> leastZeros
    long size -> size
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int,long,long,org.apfloat.spi.DataStorage,int) -> <init>
    void <init>(java.lang.String,long,int,boolean) -> <init>
    void <init>(long,long,int) -> <init>
    void <init>(double,long,int) -> <init>
    long readExponent(java.io.PushbackReader) -> a
    void <init>(java.io.PushbackReader,long,int,boolean) -> <init>
    long getTrailingZeros(org.apfloat.spi.DataStorage,long) -> a
    long getLeadingZeros(org.apfloat.spi.DataStorage,long) -> b
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> addOrSubtract
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> multiply
    boolean isShort() -> isShort
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> divideShort
    org.apfloat.spi.ApfloatImpl absFloor() -> absFloor
    org.apfloat.spi.ApfloatImpl absCeil() -> absCeil
    org.apfloat.spi.ApfloatImpl frac() -> frac
    org.apfloat.spi.ApfloatImpl zero() -> a
    int radix() -> radix
    long precision() -> precision
    long size() -> size
    long getLeastZeros() -> a
    org.apfloat.spi.ApfloatImpl precision(long) -> precision
    long scale() -> scale
    int signum() -> signum
    org.apfloat.spi.ApfloatImpl negate() -> negate
    double doubleValue() -> doubleValue
    long longValue() -> longValue
    boolean isOne() -> isOne
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> equalDigits
    int compareTo(org.apfloat.spi.ApfloatImpl) -> compareTo
    org.apfloat.spi.DataStorage$Iterator getZeroPaddedIterator(long,long) -> a
    int compareMantissaTo(org.apfloat.internal.FloatApfloatImpl) -> a
    long findMismatch(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long) -> a
    float getLeastSignificantWord(long,float) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeZeros(java.io.Writer,long) -> a
    void writeTo(java.io.Writer,boolean) -> writeTo
    long getSize() -> b
    int checkRadix(int) -> a
    float getMostSignificantWord(org.apfloat.spi.DataStorage) -> a
    int getInitialDigits() -> a
    int getInitialDigits(org.apfloat.spi.DataStorage) -> a
    int getDigits(float) -> a
    long getBasePrecision() -> c
    long getBasePrecision(long,int) -> a
    float getWord(long) -> a
    void readObject(java.io.ObjectInputStream) -> readObject
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    float access$000(org.apfloat.internal.FloatApfloatImpl,long,float) -> access$000
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatApfloatImpl$1 -> org.apfloat.internal.FloatApfloatImpl$1:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.FloatApfloatImpl this$0 -> this$0
    void <init>(org.apfloat.internal.FloatApfloatImpl) -> <init>
    void setFloat(float) -> setFloat
    void next() -> next
org.apfloat.internal.FloatApfloatImpl$2 -> org.apfloat.internal.FloatApfloatImpl$2:
    long serialVersionUID -> serialVersionUID
    long index -> index
    long val$end -> val$end
    org.apfloat.spi.DataStorage$Iterator val$iterator -> val$iterator
    long val$start -> val$start
    org.apfloat.internal.FloatApfloatImpl this$0 -> this$0
    void <init>(org.apfloat.internal.FloatApfloatImpl,long,org.apfloat.spi.DataStorage$Iterator,long) -> <init>
    float getFloat() -> getFloat
    void next() -> next
    void close() -> close
org.apfloat.internal.FloatApfloatImpl$3 -> org.apfloat.internal.FloatApfloatImpl$3:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    float getFloat() -> getFloat
    void next() -> next
org.apfloat.internal.FloatBaseMath -> org.apfloat.internal.FloatBaseMath:
    long serialVersionUID -> serialVersionUID
    int radix -> radix
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    float baseAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,float,org.apfloat.spi.DataStorage$Iterator,long) -> baseAdd
    float baseSubtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,float,org.apfloat.spi.DataStorage$Iterator,long) -> baseSubtract
    float baseMultiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,float,float,org.apfloat.spi.DataStorage$Iterator,long) -> baseMultiplyAdd
    float baseDivide(org.apfloat.spi.DataStorage$Iterator,float,float,org.apfloat.spi.DataStorage$Iterator,long) -> baseDivide
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatBuilderFactory -> org.apfloat.internal.FloatBuilderFactory:
    org.apfloat.spi.ApfloatBuilder apfloatBuilder -> a
    org.apfloat.spi.DataStorageBuilder dataStorageBuilder -> a
    org.apfloat.spi.AdditionBuilder additionBuilder -> a
    org.apfloat.spi.ConvolutionBuilder convolutionBuilder -> a
    org.apfloat.spi.NTTBuilder nttBuilder -> a
    org.apfloat.spi.MatrixBuilder matrixBuilder -> a
    org.apfloat.spi.CarryCRTBuilder carryCRTBuilder -> a
    void <init>() -> <init>
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> getApfloatBuilder
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> getDataStorageBuilder
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> getAdditionBuilder
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> getConvolutionBuilder
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> getNTTBuilder
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> getMatrixBuilder
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> getCarryCRTBuilder
    java.lang.Class getElementType() -> getElementType
    java.lang.Class getElementArrayType() -> getElementArrayType
    int getElementSize() -> getElementSize
    void shutdown() -> shutdown
    void gc() -> gc
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatCRTMath -> org.apfloat.internal.FloatCRTMath:
    long serialVersionUID -> serialVersionUID
    double base -> base
    void <init>(int) -> <init>
    void multiply(float[],float,float[]) -> multiply
    float compare(float[],float[]) -> compare
    float add(float[],float[]) -> add
    void subtract(float[],float[]) -> subtract
    float divide(float[]) -> divide
org.apfloat.internal.FloatCarryCRTBuilder -> jG:
    void <init>() -> <init>
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.internal.FloatCarryCRTStepStrategy -> org.apfloat.internal.FloatCarryCRTStepStrategy:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.FloatModMath MATH_MOD_0 -> a
    org.apfloat.internal.FloatModMath MATH_MOD_1 -> b
    org.apfloat.internal.FloatModMath MATH_MOD_2 -> c
    float T0 -> a
    float T1 -> b
    float T2 -> c
    float[] M01 -> a
    float[] M02 -> b
    float[] M12 -> c
    float[] M012 -> d
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    float[] crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    float[] carry(org.apfloat.spi.DataStorage,long,long,long,long,float[],float[]) -> carry
    org.apfloat.spi.DataStorage$Iterator arrayIterator(float[]) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> carry
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatCarryCRTStepStrategy$1 -> org.apfloat.internal.FloatCarryCRTStepStrategy$1:
    long serialVersionUID -> serialVersionUID
    int position -> position
    boolean $assertionsDisabled -> $assertionsDisabled
    float[] val$data -> val$data
    void <init>(float[]) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    float getFloat() -> getFloat
    void setFloat(float) -> setFloat
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatCarryCRTStepStrategy$2 -> org.apfloat.internal.FloatCarryCRTStepStrategy$2:
    long serialVersionUID -> serialVersionUID
    long position -> position
    long val$size -> val$size
    org.apfloat.spi.DataStorage$Iterator val$iterator1 -> val$iterator1
    org.apfloat.spi.DataStorage$Iterator val$iterator2 -> val$iterator2
    void <init>(long,org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    float getFloat() -> getFloat
    void setFloat(float) -> setFloat
    void close() -> close
org.apfloat.internal.FloatConvolutionBuilder -> jH:
    void <init>() -> <init>
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.FloatDataStorageBuilder -> jI:
    void <init>() -> <init>
    long getMaxCachedSize() -> a
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.FloatDiskDataStorage -> org.apfloat.internal.FloatDiskDataStorage:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(org.apfloat.internal.FloatDiskDataStorage,long,long) -> <init>
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess createArrayAccess(int,int,int,int) -> createArrayAccess
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> createTransposedArrayAccess
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    int getUnitSize() -> getUnitSize
org.apfloat.internal.FloatDiskDataStorage$BlockIterator -> org.apfloat.internal.FloatDiskDataStorage$BlockIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.spi.ArrayAccess arrayAccess -> arrayAccess
    float[] data -> data
    int offset -> offset
    int remaining -> remaining
    boolean $assertionsDisabled -> $assertionsDisabled
    org.apfloat.internal.FloatDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.FloatDiskDataStorage,int,long,long) -> <init>
    void next() -> next
    float getFloat() -> getFloat
    void setFloat(float) -> setFloat
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void close() -> close
    void checkAvailable() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess -> org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    long fileOffset -> fileOffset
    org.apfloat.internal.FloatDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.FloatDiskDataStorage,int,long,int) -> <init>
    void close() -> close
org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess$1 -> jJ:
    int readPosition -> a
    float[] val$array -> a
    void <init>(org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess,org.apfloat.internal.FloatDiskDataStorage,float[]) -> <init>
    int write(java.nio.ByteBuffer) -> write
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess$2 -> jK:
    int writePosition -> a
    float[] val$array -> a
    void <init>(org.apfloat.internal.FloatDiskDataStorage$FloatDiskArrayAccess,float[]) -> <init>
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.FloatDiskDataStorage$MemoryArrayAccess -> org.apfloat.internal.FloatDiskDataStorage$MemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int startColumn -> startColumn
    int columns -> columns
    int rows -> rows
    org.apfloat.internal.FloatDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.FloatDiskDataStorage,int,float[],int,int,int) -> <init>
    void close() -> close
org.apfloat.internal.FloatDiskDataStorage$TransposedMemoryArrayAccess -> org.apfloat.internal.FloatDiskDataStorage$TransposedMemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int startColumn -> startColumn
    int columns -> columns
    int rows -> rows
    org.apfloat.internal.FloatDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.FloatDiskDataStorage,int,float[],int,int,int) -> <init>
    void close() -> close
org.apfloat.internal.FloatElementaryModMath -> jL:
    float modulus -> a
    double inverseModulus -> a
    void <init>() -> <init>
    float modMultiply(float,float) -> a
    float modAdd(float,float) -> b
    float modSubtract(float,float) -> c
    void setModulus(float) -> a
org.apfloat.internal.FloatFactor3NTTStepStrategy -> jM:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatFactor3NTTStepStrategy$1 -> jN:
    org.apfloat.spi.DataStorage val$dataStorage0 -> a
    org.apfloat.spi.DataStorage val$dataStorage1 -> b
    org.apfloat.spi.DataStorage val$dataStorage2 -> c
    long val$startColumn -> a
    float val$w -> a
    float val$ww -> b
    float val$w1 -> c
    float val$w2 -> d
    boolean val$isInverse -> a
    org.apfloat.internal.FloatFactor3NTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatFactor3NTTStepStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,float,float,float,float,boolean) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.FloatFactor3NTTStepStrategy$ColumnTransformRunnable -> jO:
    org.apfloat.spi.DataStorage dataStorage0 -> a
    org.apfloat.spi.DataStorage dataStorage1 -> b
    org.apfloat.spi.DataStorage dataStorage2 -> c
    long startColumn -> a
    long columns -> b
    float w -> a
    float ww -> b
    float w1 -> c
    float w2 -> d
    boolean isInverse -> a
    org.apfloat.internal.FloatFactor3NTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatFactor3NTTStepStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,float,float,float,float,boolean) -> <init>
    void run() -> run
org.apfloat.internal.FloatKaratsubaConvolutionStrategy -> org.apfloat.internal.FloatKaratsubaConvolutionStrategy:
    int CUTOFF_POINT -> CUTOFF_POINT
    long serialVersionUID -> serialVersionUID
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    org.apfloat.spi.DataStorage add(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    void subtract(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    boolean isZero(org.apfloat.spi.DataStorage,long) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatMatrixBuilder -> jP:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    void <init>() -> <init>
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatMatrixStrategy -> jQ:
    void <init>() -> <init>
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
    void moveBlock(float[],int,int,float[],int,int,int) -> a
    void transposeBlock(float[],int,int,int) -> a
    void transposeSquare(float[],int,int,int) -> b
    void permuteToHalfWidth(float[],int,int,int) -> c
    void permuteToDoubleWidth(float[],int,int,int) -> d
org.apfloat.internal.FloatMediumConvolutionStrategy -> org.apfloat.internal.FloatMediumConvolutionStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
org.apfloat.internal.FloatMediumConvolutionStrategy$1 -> org.apfloat.internal.FloatMediumConvolutionStrategy$1:
    long serialVersionUID -> serialVersionUID
    float[] buffer -> buffer
    int position -> position
    int val$bufferSize -> val$bufferSize
    org.apfloat.internal.FloatMediumConvolutionStrategy this$0 -> this$0
    void <init>(org.apfloat.internal.FloatMediumConvolutionStrategy,int) -> <init>
    void next() -> next
    float getFloat() -> getFloat
    void setFloat(float) -> setFloat
org.apfloat.internal.FloatMemoryArrayAccess -> org.apfloat.internal.FloatMemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    float[] data -> data
    void <init>(float[],int,int) -> <init>
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> subsequence
    java.lang.Object getData() -> getData
    float[] getFloatData() -> getFloatData
    void close() -> close
org.apfloat.internal.FloatMemoryDataStorage -> org.apfloat.internal.FloatMemoryDataStorage:
    long serialVersionUID -> serialVersionUID
    float[] data -> data
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>() -> <init>
    void <init>(org.apfloat.internal.FloatMemoryDataStorage,long,long) -> <init>
    boolean isCached() -> isCached
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> implCopyFrom
    long implGetSize() -> implGetSize
    void implSetSize(long) -> implSetSize
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetArray(int,int,int,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> implGetTransposedArray
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    float[] access$000(org.apfloat.internal.FloatMemoryDataStorage) -> access$000
    long access$100(org.apfloat.internal.FloatMemoryDataStorage) -> access$100
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatMemoryDataStorage$ReadOnlyIterator -> org.apfloat.internal.FloatMemoryDataStorage$ReadOnlyIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.FloatMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.FloatMemoryDataStorage,long,long) -> <init>
    void setFloat(float) -> setFloat
org.apfloat.internal.FloatMemoryDataStorage$ReadWriteIterator -> org.apfloat.internal.FloatMemoryDataStorage$ReadWriteIterator:
    long serialVersionUID -> serialVersionUID
    float[] data -> data
    int position -> position
    int length -> length
    org.apfloat.internal.FloatMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.FloatMemoryDataStorage,long,long) -> <init>
    void <init>(org.apfloat.internal.FloatMemoryDataStorage,int,long,long) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    float getFloat() -> getFloat
    void setFloat(float) -> setFloat
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void checkLength() -> checkLength
org.apfloat.internal.FloatMemoryDataStorage$WriteOnlyIterator -> org.apfloat.internal.FloatMemoryDataStorage$WriteOnlyIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.FloatMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.FloatMemoryDataStorage,long,long) -> <init>
    float getFloat() -> getFloat
org.apfloat.internal.FloatModConstants -> jR:
    float[] MODULUS -> a
    float[] PRIMITIVE_ROOT -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatModMath -> jS:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    float getForwardNthRoot(float,long) -> a
    float getInverseNthRoot(float,long) -> b
    float modDivide(float,float) -> d
    float modPow(float,float) -> e
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatNTTBuilder -> jT:
    void <init>() -> <init>
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.FloatNTTConvolutionStepStrategy -> jU:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatNTTConvolutionStepStrategy$1 -> jV:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.spi.DataStorage val$source -> b
    org.apfloat.internal.FloatNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatNTTConvolutionStepStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.FloatNTTConvolutionStepStrategy$2 -> jW:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.internal.FloatNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatNTTConvolutionStepStrategy,long,org.apfloat.spi.DataStorage) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.FloatNTTConvolutionStepStrategy$MultiplyInPlaceRunnable -> jX:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    org.apfloat.spi.DataStorage source -> b
    long offset -> a
    long length -> b
    org.apfloat.internal.FloatNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatNTTConvolutionStepStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long) -> <init>
    void run() -> run
org.apfloat.internal.FloatNTTConvolutionStepStrategy$SquareInPlaceRunnable -> jY:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    long offset -> a
    long length -> b
    org.apfloat.internal.FloatNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatNTTConvolutionStepStrategy,org.apfloat.spi.DataStorage,long,long) -> <init>
    void run() -> run
org.apfloat.internal.FloatNTTStepStrategy -> jZ:
    void <init>() -> <init>
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.FloatNTTStepStrategy$1 -> ka:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$columns -> a
    int val$startRow -> b
    int val$startColumn -> c
    float val$w -> a
    float val$scaleFactor -> b
    org.apfloat.internal.FloatNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatNTTStepStrategy,long,org.apfloat.spi.ArrayAccess,int,int,int,float,float) -> <init>
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.FloatNTTStepStrategy$2 -> kb:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$length -> a
    boolean val$isInverse -> a
    float[] val$wTable -> a
    int[] val$permutationTable -> a
    org.apfloat.internal.FloatNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatNTTStepStrategy,long,org.apfloat.spi.ArrayAccess,int,boolean,float[],int[]) -> <init>
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.FloatNTTStepStrategy$MultiplyRunnable -> kc:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int startRow -> a
    int startColumn -> b
    int rows -> c
    int columns -> d
    float w -> a
    float scaleFactor -> b
    org.apfloat.internal.FloatNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatNTTStepStrategy,org.apfloat.spi.ArrayAccess,int,int,int,int,float,float) -> <init>
    void run() -> run
org.apfloat.internal.FloatNTTStepStrategy$TableFNTRunnable -> kd:
    int length -> a
    boolean isInverse -> a
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    float[] wTable -> a
    int[] permutationTable -> a
    org.apfloat.internal.FloatNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.FloatNTTStepStrategy,int,boolean,org.apfloat.spi.ArrayAccess,float[],int[]) -> <init>
    void run() -> run
org.apfloat.internal.FloatRadixConstants -> ke:
    float[] BASE -> a
    int[] BASE_DIGITS -> a
    float[][] MINIMUM_FOR_DIGITS -> a
    long[] MAX_EXPONENT -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatShortConvolutionStrategy -> org.apfloat.internal.FloatShortConvolutionStrategy:
    long serialVersionUID -> serialVersionUID
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatTableFNT -> kf:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void tableFNT(org.apfloat.spi.ArrayAccess,float[],int[]) -> a
    void inverseTableFNT(org.apfloat.spi.ArrayAccess,float[],int[]) -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.FloatTableFNTStrategy -> kg:
    void <init>() -> <init>
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void divideElements(org.apfloat.spi.ArrayAccess,float) -> a
org.apfloat.internal.FloatWTables -> kh:
    java.util.concurrent.ConcurrentMap cache -> a
    float[] getWTable(int,int) -> a
    float[] getInverseWTable(int,int) -> b
    float[] getWTable(int,int,boolean) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.ImplementationMismatchException -> org.apfloat.internal.ImplementationMismatchException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.internal.IntAdditionBuilder -> ki:
    void <init>() -> <init>
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.internal.IntAdditionStrategy -> org.apfloat.internal.IntAdditionStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>(int) -> <init>
    java.lang.Integer add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Integer,org.apfloat.spi.DataStorage$Iterator,long) -> add
    java.lang.Integer subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Integer,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Integer multiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Integer,java.lang.Integer,org.apfloat.spi.DataStorage$Iterator,long) -> multiplyAdd
    java.lang.Integer divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Integer,java.lang.Integer,org.apfloat.spi.DataStorage$Iterator,long) -> divide
    java.lang.Integer zero() -> zero
    java.lang.Object zero() -> zero
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> divide
    java.lang.Object multiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> multiplyAdd
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> add
org.apfloat.internal.IntApfloatBuilder -> kj:
    void <init>() -> <init>
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.internal.IntApfloatImpl -> org.apfloat.internal.IntApfloatImpl:
    org.apfloat.spi.DataStorage$Iterator ZERO_ITERATOR -> a
    long serialVersionUID -> serialVersionUID
    int sign -> sign
    long precision -> precision
    long exponent -> exponent
    org.apfloat.spi.DataStorage dataStorage -> dataStorage
    int radix -> radix
    int hashCode -> hashCode
    int initialDigits -> initialDigits
    int isOne -> isOne
    long leastZeros -> leastZeros
    long size -> size
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int,long,long,org.apfloat.spi.DataStorage,int) -> <init>
    void <init>(java.lang.String,long,int,boolean) -> <init>
    void <init>(long,long,int) -> <init>
    void <init>(double,long,int) -> <init>
    long readExponent(java.io.PushbackReader) -> a
    void <init>(java.io.PushbackReader,long,int,boolean) -> <init>
    long getTrailingZeros(org.apfloat.spi.DataStorage,long) -> a
    long getLeadingZeros(org.apfloat.spi.DataStorage,long) -> b
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> addOrSubtract
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> multiply
    boolean isShort() -> isShort
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> divideShort
    org.apfloat.spi.ApfloatImpl absFloor() -> absFloor
    org.apfloat.spi.ApfloatImpl absCeil() -> absCeil
    org.apfloat.spi.ApfloatImpl frac() -> frac
    org.apfloat.spi.ApfloatImpl zero() -> a
    int radix() -> radix
    long precision() -> precision
    long size() -> size
    long getLeastZeros() -> a
    org.apfloat.spi.ApfloatImpl precision(long) -> precision
    long scale() -> scale
    int signum() -> signum
    org.apfloat.spi.ApfloatImpl negate() -> negate
    double doubleValue() -> doubleValue
    long longValue() -> longValue
    boolean isOne() -> isOne
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> equalDigits
    int compareTo(org.apfloat.spi.ApfloatImpl) -> compareTo
    org.apfloat.spi.DataStorage$Iterator getZeroPaddedIterator(long,long) -> a
    int compareMantissaTo(org.apfloat.internal.IntApfloatImpl) -> a
    long findMismatch(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long) -> a
    int getLeastSignificantWord(long,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeZeros(java.io.Writer,long) -> a
    void writeTo(java.io.Writer,boolean) -> writeTo
    long getSize() -> b
    int checkRadix(int) -> a
    int getMostSignificantWord(org.apfloat.spi.DataStorage) -> a
    int getInitialDigits() -> a
    int getInitialDigits(org.apfloat.spi.DataStorage) -> b
    int getDigits(int) -> b
    long getBasePrecision() -> c
    long getBasePrecision(long,int) -> a
    int getWord(long) -> a
    void readObject(java.io.ObjectInputStream) -> readObject
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    int access$000(org.apfloat.internal.IntApfloatImpl,long,int) -> access$000
    void <clinit>() -> <clinit>
org.apfloat.internal.IntApfloatImpl$1 -> org.apfloat.internal.IntApfloatImpl$1:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.IntApfloatImpl this$0 -> this$0
    void <init>(org.apfloat.internal.IntApfloatImpl) -> <init>
    void setInt(int) -> setInt
    void next() -> next
org.apfloat.internal.IntApfloatImpl$2 -> org.apfloat.internal.IntApfloatImpl$2:
    long serialVersionUID -> serialVersionUID
    long index -> index
    long val$end -> val$end
    org.apfloat.spi.DataStorage$Iterator val$iterator -> val$iterator
    long val$start -> val$start
    org.apfloat.internal.IntApfloatImpl this$0 -> this$0
    void <init>(org.apfloat.internal.IntApfloatImpl,long,org.apfloat.spi.DataStorage$Iterator,long) -> <init>
    int getInt() -> getInt
    void next() -> next
    void close() -> close
org.apfloat.internal.IntApfloatImpl$3 -> org.apfloat.internal.IntApfloatImpl$3:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    int getInt() -> getInt
    void next() -> next
org.apfloat.internal.IntBaseMath -> org.apfloat.internal.IntBaseMath:
    long serialVersionUID -> serialVersionUID
    int radix -> radix
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    int baseAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,int,org.apfloat.spi.DataStorage$Iterator,long) -> baseAdd
    int baseSubtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,int,org.apfloat.spi.DataStorage$Iterator,long) -> baseSubtract
    int baseMultiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,int,int,org.apfloat.spi.DataStorage$Iterator,long) -> baseMultiplyAdd
    int baseDivide(org.apfloat.spi.DataStorage$Iterator,int,int,org.apfloat.spi.DataStorage$Iterator,long) -> baseDivide
    void <clinit>() -> <clinit>
org.apfloat.internal.IntBuilderFactory -> org.apfloat.internal.IntBuilderFactory:
    org.apfloat.spi.ApfloatBuilder apfloatBuilder -> a
    org.apfloat.spi.DataStorageBuilder dataStorageBuilder -> a
    org.apfloat.spi.AdditionBuilder additionBuilder -> a
    org.apfloat.spi.ConvolutionBuilder convolutionBuilder -> a
    org.apfloat.spi.NTTBuilder nttBuilder -> a
    org.apfloat.spi.MatrixBuilder matrixBuilder -> a
    org.apfloat.spi.CarryCRTBuilder carryCRTBuilder -> a
    void <init>() -> <init>
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> getApfloatBuilder
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> getDataStorageBuilder
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> getAdditionBuilder
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> getConvolutionBuilder
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> getNTTBuilder
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> getMatrixBuilder
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> getCarryCRTBuilder
    java.lang.Class getElementType() -> getElementType
    java.lang.Class getElementArrayType() -> getElementArrayType
    int getElementSize() -> getElementSize
    void shutdown() -> shutdown
    void gc() -> gc
    void <clinit>() -> <clinit>
org.apfloat.internal.IntCRTMath -> org.apfloat.internal.IntCRTMath:
    long serialVersionUID -> serialVersionUID
    int base -> base
    void <init>(int) -> <init>
    void multiply(int[],int,int[]) -> multiply
    int compare(int[],int[]) -> compare
    int add(int[],int[]) -> add
    void subtract(int[],int[]) -> subtract
    int divide(int[]) -> divide
org.apfloat.internal.IntCarryCRTBuilder -> kk:
    void <init>() -> <init>
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.internal.IntCarryCRTStepStrategy -> org.apfloat.internal.IntCarryCRTStepStrategy:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.IntModMath MATH_MOD_0 -> a
    org.apfloat.internal.IntModMath MATH_MOD_1 -> b
    org.apfloat.internal.IntModMath MATH_MOD_2 -> c
    int T0 -> a
    int T1 -> b
    int T2 -> c
    int[] M01 -> a
    int[] M02 -> b
    int[] M12 -> c
    int[] M012 -> d
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    int[] crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    int[] carry(org.apfloat.spi.DataStorage,long,long,long,long,int[],int[]) -> carry
    org.apfloat.spi.DataStorage$Iterator arrayIterator(int[]) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> carry
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    void <clinit>() -> <clinit>
org.apfloat.internal.IntCarryCRTStepStrategy$1 -> org.apfloat.internal.IntCarryCRTStepStrategy$1:
    long serialVersionUID -> serialVersionUID
    int position -> position
    boolean $assertionsDisabled -> $assertionsDisabled
    int[] val$data -> val$data
    void <init>(int[]) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    int getInt() -> getInt
    void setInt(int) -> setInt
    void <clinit>() -> <clinit>
org.apfloat.internal.IntCarryCRTStepStrategy$2 -> org.apfloat.internal.IntCarryCRTStepStrategy$2:
    long serialVersionUID -> serialVersionUID
    long position -> position
    long val$size -> val$size
    org.apfloat.spi.DataStorage$Iterator val$iterator1 -> val$iterator1
    org.apfloat.spi.DataStorage$Iterator val$iterator2 -> val$iterator2
    void <init>(long,org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    int getInt() -> getInt
    void setInt(int) -> setInt
    void close() -> close
org.apfloat.internal.IntConvolutionBuilder -> kl:
    void <init>() -> <init>
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.IntDataStorageBuilder -> km:
    void <init>() -> <init>
    long getMaxCachedSize() -> a
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.IntDiskDataStorage -> org.apfloat.internal.IntDiskDataStorage:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(org.apfloat.internal.IntDiskDataStorage,long,long) -> <init>
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess createArrayAccess(int,int,int,int) -> createArrayAccess
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> createTransposedArrayAccess
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    int getUnitSize() -> getUnitSize
org.apfloat.internal.IntDiskDataStorage$BlockIterator -> org.apfloat.internal.IntDiskDataStorage$BlockIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.spi.ArrayAccess arrayAccess -> arrayAccess
    int[] data -> data
    int offset -> offset
    int remaining -> remaining
    boolean $assertionsDisabled -> $assertionsDisabled
    org.apfloat.internal.IntDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.IntDiskDataStorage,int,long,long) -> <init>
    void next() -> next
    int getInt() -> getInt
    void setInt(int) -> setInt
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void close() -> close
    void checkAvailable() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess -> org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    long fileOffset -> fileOffset
    org.apfloat.internal.IntDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.IntDiskDataStorage,int,long,int) -> <init>
    void close() -> close
org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess$1 -> kn:
    int readPosition -> a
    int[] val$array -> a
    void <init>(org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess,org.apfloat.internal.IntDiskDataStorage,int[]) -> <init>
    int write(java.nio.ByteBuffer) -> write
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess$2 -> ko:
    int writePosition -> a
    int[] val$array -> a
    void <init>(org.apfloat.internal.IntDiskDataStorage$IntDiskArrayAccess,int[]) -> <init>
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.IntDiskDataStorage$MemoryArrayAccess -> org.apfloat.internal.IntDiskDataStorage$MemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int startColumn -> startColumn
    int columns -> columns
    int rows -> rows
    org.apfloat.internal.IntDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.IntDiskDataStorage,int,int[],int,int,int) -> <init>
    void close() -> close
org.apfloat.internal.IntDiskDataStorage$TransposedMemoryArrayAccess -> org.apfloat.internal.IntDiskDataStorage$TransposedMemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int startColumn -> startColumn
    int columns -> columns
    int rows -> rows
    org.apfloat.internal.IntDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.IntDiskDataStorage,int,int[],int,int,int) -> <init>
    void close() -> close
org.apfloat.internal.IntElementaryModMath -> kp:
    int modulus -> a
    double inverseModulus -> a
    void <init>() -> <init>
    int modMultiply(int,int) -> a
    int modAdd(int,int) -> b
    int modSubtract(int,int) -> c
    void setModulus(int) -> a
org.apfloat.internal.IntFactor3NTTStepStrategy -> kq:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.IntFactor3NTTStepStrategy$1 -> kr:
    org.apfloat.spi.DataStorage val$dataStorage0 -> a
    org.apfloat.spi.DataStorage val$dataStorage1 -> b
    org.apfloat.spi.DataStorage val$dataStorage2 -> c
    long val$startColumn -> a
    int val$w -> a
    int val$ww -> b
    int val$w1 -> c
    int val$w2 -> d
    boolean val$isInverse -> a
    org.apfloat.internal.IntFactor3NTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntFactor3NTTStepStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,int,int,int,int,boolean) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.IntFactor3NTTStepStrategy$ColumnTransformRunnable -> ks:
    org.apfloat.spi.DataStorage dataStorage0 -> a
    org.apfloat.spi.DataStorage dataStorage1 -> b
    org.apfloat.spi.DataStorage dataStorage2 -> c
    long startColumn -> a
    long columns -> b
    int w -> a
    int ww -> b
    int w1 -> c
    int w2 -> d
    boolean isInverse -> a
    org.apfloat.internal.IntFactor3NTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntFactor3NTTStepStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,int,int,int,int,boolean) -> <init>
    void run() -> run
org.apfloat.internal.IntKaratsubaConvolutionStrategy -> org.apfloat.internal.IntKaratsubaConvolutionStrategy:
    int CUTOFF_POINT -> CUTOFF_POINT
    long serialVersionUID -> serialVersionUID
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    org.apfloat.spi.DataStorage add(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    void subtract(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    boolean isZero(org.apfloat.spi.DataStorage,long) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.IntMatrixBuilder -> kt:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    void <init>() -> <init>
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.IntMatrixStrategy -> ku:
    void <init>() -> <init>
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
    void moveBlock(int[],int,int,int[],int,int,int) -> a
    void transposeBlock(int[],int,int,int) -> a
    void transposeSquare(int[],int,int,int) -> b
    void permuteToHalfWidth(int[],int,int,int) -> c
    void permuteToDoubleWidth(int[],int,int,int) -> d
org.apfloat.internal.IntMediumConvolutionStrategy -> org.apfloat.internal.IntMediumConvolutionStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
org.apfloat.internal.IntMediumConvolutionStrategy$1 -> org.apfloat.internal.IntMediumConvolutionStrategy$1:
    long serialVersionUID -> serialVersionUID
    int[] buffer -> buffer
    int position -> position
    int val$bufferSize -> val$bufferSize
    org.apfloat.internal.IntMediumConvolutionStrategy this$0 -> this$0
    void <init>(org.apfloat.internal.IntMediumConvolutionStrategy,int) -> <init>
    void next() -> next
    int getInt() -> getInt
    void setInt(int) -> setInt
org.apfloat.internal.IntMemoryArrayAccess -> org.apfloat.internal.IntMemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int[] data -> data
    void <init>(int[],int,int) -> <init>
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> subsequence
    java.lang.Object getData() -> getData
    int[] getIntData() -> getIntData
    void close() -> close
org.apfloat.internal.IntMemoryDataStorage -> org.apfloat.internal.IntMemoryDataStorage:
    long serialVersionUID -> serialVersionUID
    int[] data -> data
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>() -> <init>
    void <init>(org.apfloat.internal.IntMemoryDataStorage,long,long) -> <init>
    boolean isCached() -> isCached
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> implCopyFrom
    long implGetSize() -> implGetSize
    void implSetSize(long) -> implSetSize
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetArray(int,int,int,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> implGetTransposedArray
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    int[] access$000(org.apfloat.internal.IntMemoryDataStorage) -> access$000
    long access$100(org.apfloat.internal.IntMemoryDataStorage) -> access$100
    void <clinit>() -> <clinit>
org.apfloat.internal.IntMemoryDataStorage$ReadOnlyIterator -> org.apfloat.internal.IntMemoryDataStorage$ReadOnlyIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.IntMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.IntMemoryDataStorage,long,long) -> <init>
    void setInt(int) -> setInt
org.apfloat.internal.IntMemoryDataStorage$ReadWriteIterator -> org.apfloat.internal.IntMemoryDataStorage$ReadWriteIterator:
    long serialVersionUID -> serialVersionUID
    int[] data -> data
    int position -> position
    int length -> length
    org.apfloat.internal.IntMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.IntMemoryDataStorage,long,long) -> <init>
    void <init>(org.apfloat.internal.IntMemoryDataStorage,int,long,long) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    int getInt() -> getInt
    void setInt(int) -> setInt
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void checkLength() -> checkLength
org.apfloat.internal.IntMemoryDataStorage$WriteOnlyIterator -> org.apfloat.internal.IntMemoryDataStorage$WriteOnlyIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.IntMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.IntMemoryDataStorage,long,long) -> <init>
    int getInt() -> getInt
org.apfloat.internal.IntModConstants -> kv:
    int[] MODULUS -> a
    int[] PRIMITIVE_ROOT -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.IntModMath -> kw:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    int getForwardNthRoot(int,long) -> a
    int getInverseNthRoot(int,long) -> b
    int modDivide(int,int) -> d
    int modPow(int,int) -> e
    void <clinit>() -> <clinit>
org.apfloat.internal.IntNTTBuilder -> kx:
    void <init>() -> <init>
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.IntNTTConvolutionStepStrategy -> ky:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.IntNTTConvolutionStepStrategy$1 -> kz:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.spi.DataStorage val$source -> b
    org.apfloat.internal.IntNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntNTTConvolutionStepStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.IntNTTConvolutionStepStrategy$2 -> kA:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.internal.IntNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntNTTConvolutionStepStrategy,long,org.apfloat.spi.DataStorage) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.IntNTTConvolutionStepStrategy$MultiplyInPlaceRunnable -> kB:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    org.apfloat.spi.DataStorage source -> b
    long offset -> a
    long length -> b
    org.apfloat.internal.IntNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntNTTConvolutionStepStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long) -> <init>
    void run() -> run
org.apfloat.internal.IntNTTConvolutionStepStrategy$SquareInPlaceRunnable -> kC:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    long offset -> a
    long length -> b
    org.apfloat.internal.IntNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntNTTConvolutionStepStrategy,org.apfloat.spi.DataStorage,long,long) -> <init>
    void run() -> run
org.apfloat.internal.IntNTTStepStrategy -> kD:
    void <init>() -> <init>
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.IntNTTStepStrategy$1 -> kE:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$columns -> a
    int val$startRow -> b
    int val$startColumn -> c
    int val$w -> d
    int val$scaleFactor -> e
    org.apfloat.internal.IntNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntNTTStepStrategy,long,org.apfloat.spi.ArrayAccess,int,int,int,int,int) -> <init>
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.IntNTTStepStrategy$2 -> kF:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$length -> a
    boolean val$isInverse -> a
    int[] val$wTable -> a
    int[] val$permutationTable -> b
    org.apfloat.internal.IntNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntNTTStepStrategy,long,org.apfloat.spi.ArrayAccess,int,boolean,int[],int[]) -> <init>
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.IntNTTStepStrategy$MultiplyRunnable -> kG:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int startRow -> a
    int startColumn -> b
    int rows -> c
    int columns -> d
    int w -> e
    int scaleFactor -> f
    org.apfloat.internal.IntNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntNTTStepStrategy,org.apfloat.spi.ArrayAccess,int,int,int,int,int,int) -> <init>
    void run() -> run
org.apfloat.internal.IntNTTStepStrategy$TableFNTRunnable -> kH:
    int length -> a
    boolean isInverse -> a
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int[] wTable -> a
    int[] permutationTable -> b
    org.apfloat.internal.IntNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.IntNTTStepStrategy,int,boolean,org.apfloat.spi.ArrayAccess,int[],int[]) -> <init>
    void run() -> run
org.apfloat.internal.IntRadixConstants -> kI:
    int[] BASE -> a
    int[] BASE_DIGITS -> b
    int[][] MINIMUM_FOR_DIGITS -> a
    long[] MAX_EXPONENT -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.IntShortConvolutionStrategy -> org.apfloat.internal.IntShortConvolutionStrategy:
    long serialVersionUID -> serialVersionUID
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    void <clinit>() -> <clinit>
org.apfloat.internal.IntTableFNT -> kJ:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void tableFNT(org.apfloat.spi.ArrayAccess,int[],int[]) -> a
    void inverseTableFNT(org.apfloat.spi.ArrayAccess,int[],int[]) -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.IntTableFNTStrategy -> kK:
    void <init>() -> <init>
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void divideElements(org.apfloat.spi.ArrayAccess,int) -> a
org.apfloat.internal.IntWTables -> kL:
    java.util.concurrent.ConcurrentMap cache -> a
    int[] getWTable(int,int) -> a
    int[] getInverseWTable(int,int) -> b
    int[] getWTable(int,int,boolean) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.LongAdditionBuilder -> kM:
    void <init>() -> <init>
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.internal.LongAdditionStrategy -> org.apfloat.internal.LongAdditionStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>(int) -> <init>
    java.lang.Long add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Long,org.apfloat.spi.DataStorage$Iterator,long) -> add
    java.lang.Long subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Long,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Long multiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Long,java.lang.Long,org.apfloat.spi.DataStorage$Iterator,long) -> multiplyAdd
    java.lang.Long divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Long,java.lang.Long,org.apfloat.spi.DataStorage$Iterator,long) -> divide
    java.lang.Long zero() -> zero
    java.lang.Object zero() -> zero
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> divide
    java.lang.Object multiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> multiplyAdd
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> add
org.apfloat.internal.LongApfloatBuilder -> kN:
    void <init>() -> <init>
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.internal.LongApfloatImpl -> org.apfloat.internal.LongApfloatImpl:
    org.apfloat.spi.DataStorage$Iterator ZERO_ITERATOR -> a
    long serialVersionUID -> serialVersionUID
    int sign -> sign
    long precision -> precision
    long exponent -> exponent
    org.apfloat.spi.DataStorage dataStorage -> dataStorage
    int radix -> radix
    int hashCode -> hashCode
    int initialDigits -> initialDigits
    int isOne -> isOne
    long leastZeros -> leastZeros
    long size -> size
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int,long,long,org.apfloat.spi.DataStorage,int) -> <init>
    void <init>(java.lang.String,long,int,boolean) -> <init>
    void <init>(long,long,int) -> <init>
    void <init>(double,long,int) -> <init>
    long readExponent(java.io.PushbackReader) -> a
    void <init>(java.io.PushbackReader,long,int,boolean) -> <init>
    long getTrailingZeros(org.apfloat.spi.DataStorage,long) -> a
    long getLeadingZeros(org.apfloat.spi.DataStorage,long) -> b
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> addOrSubtract
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> multiply
    boolean isShort() -> isShort
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> divideShort
    org.apfloat.spi.ApfloatImpl absFloor() -> absFloor
    org.apfloat.spi.ApfloatImpl absCeil() -> absCeil
    org.apfloat.spi.ApfloatImpl frac() -> frac
    org.apfloat.spi.ApfloatImpl zero() -> a
    int radix() -> radix
    long precision() -> precision
    long size() -> size
    long getLeastZeros() -> a
    org.apfloat.spi.ApfloatImpl precision(long) -> precision
    long scale() -> scale
    int signum() -> signum
    org.apfloat.spi.ApfloatImpl negate() -> negate
    double doubleValue() -> doubleValue
    long longValue() -> longValue
    boolean isOne() -> isOne
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> equalDigits
    int compareTo(org.apfloat.spi.ApfloatImpl) -> compareTo
    org.apfloat.spi.DataStorage$Iterator getZeroPaddedIterator(long,long) -> a
    int compareMantissaTo(org.apfloat.internal.LongApfloatImpl) -> a
    long findMismatch(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long) -> a
    long getLeastSignificantWord(long,long) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeZeros(java.io.Writer,long) -> a
    void writeTo(java.io.Writer,boolean) -> writeTo
    long getSize() -> b
    int checkRadix(int) -> a
    long getMostSignificantWord(org.apfloat.spi.DataStorage) -> a
    int getInitialDigits() -> a
    int getInitialDigits(org.apfloat.spi.DataStorage) -> a
    int getDigits(long) -> a
    long getBasePrecision() -> c
    long getBasePrecision(long,int) -> a
    long getWord(long) -> a
    void readObject(java.io.ObjectInputStream) -> readObject
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    long access$000(org.apfloat.internal.LongApfloatImpl,long,long) -> access$000
    void <clinit>() -> <clinit>
org.apfloat.internal.LongApfloatImpl$1 -> org.apfloat.internal.LongApfloatImpl$1:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.LongApfloatImpl this$0 -> this$0
    void <init>(org.apfloat.internal.LongApfloatImpl) -> <init>
    void setLong(long) -> setLong
    void next() -> next
org.apfloat.internal.LongApfloatImpl$2 -> org.apfloat.internal.LongApfloatImpl$2:
    long serialVersionUID -> serialVersionUID
    long index -> index
    long val$end -> val$end
    org.apfloat.spi.DataStorage$Iterator val$iterator -> val$iterator
    long val$start -> val$start
    org.apfloat.internal.LongApfloatImpl this$0 -> this$0
    void <init>(org.apfloat.internal.LongApfloatImpl,long,org.apfloat.spi.DataStorage$Iterator,long) -> <init>
    long getLong() -> getLong
    void next() -> next
    void close() -> close
org.apfloat.internal.LongApfloatImpl$3 -> org.apfloat.internal.LongApfloatImpl$3:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    long getLong() -> getLong
    void next() -> next
org.apfloat.internal.LongBaseMath -> org.apfloat.internal.LongBaseMath:
    long serialVersionUID -> serialVersionUID
    int radix -> radix
    double inverseBase -> inverseBase
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    long baseAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long,org.apfloat.spi.DataStorage$Iterator,long) -> baseAdd
    long baseSubtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long,org.apfloat.spi.DataStorage$Iterator,long) -> baseSubtract
    long baseMultiplyAdd(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,long,long,org.apfloat.spi.DataStorage$Iterator,long) -> baseMultiplyAdd
    long baseDivide(org.apfloat.spi.DataStorage$Iterator,long,long,org.apfloat.spi.DataStorage$Iterator,long) -> baseDivide
    void <clinit>() -> <clinit>
org.apfloat.internal.LongBuilderFactory -> org.apfloat.internal.LongBuilderFactory:
    org.apfloat.spi.ApfloatBuilder apfloatBuilder -> a
    org.apfloat.spi.DataStorageBuilder dataStorageBuilder -> a
    org.apfloat.spi.AdditionBuilder additionBuilder -> a
    org.apfloat.spi.ConvolutionBuilder convolutionBuilder -> a
    org.apfloat.spi.NTTBuilder nttBuilder -> a
    org.apfloat.spi.MatrixBuilder matrixBuilder -> a
    org.apfloat.spi.CarryCRTBuilder carryCRTBuilder -> a
    void <init>() -> <init>
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> getApfloatBuilder
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> getDataStorageBuilder
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> getAdditionBuilder
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> getConvolutionBuilder
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> getNTTBuilder
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> getMatrixBuilder
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> getCarryCRTBuilder
    java.lang.Class getElementType() -> getElementType
    java.lang.Class getElementArrayType() -> getElementArrayType
    int getElementSize() -> getElementSize
    void shutdown() -> shutdown
    void gc() -> gc
    void <clinit>() -> <clinit>
org.apfloat.internal.LongCRTMath -> org.apfloat.internal.LongCRTMath:
    long serialVersionUID -> serialVersionUID
    long base -> base
    double inverseBase -> inverseBase
    void <init>(int) -> <init>
    void multiply(long[],long,long[]) -> multiply
    long compare(long[],long[]) -> compare
    long add(long[],long[]) -> add
    void subtract(long[],long[]) -> subtract
    long divide(long[]) -> divide
org.apfloat.internal.LongCarryCRTBuilder -> kO:
    void <init>() -> <init>
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.internal.LongCarryCRTStepStrategy -> org.apfloat.internal.LongCarryCRTStepStrategy:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.LongModMath MATH_MOD_0 -> a
    org.apfloat.internal.LongModMath MATH_MOD_1 -> b
    org.apfloat.internal.LongModMath MATH_MOD_2 -> c
    long T0 -> a
    long T1 -> b
    long T2 -> c
    long[] M01 -> a
    long[] M02 -> b
    long[] M12 -> c
    long[] M012 -> d
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    long[] crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    long[] carry(org.apfloat.spi.DataStorage,long,long,long,long,long[],long[]) -> carry
    org.apfloat.spi.DataStorage$Iterator arrayIterator(long[]) -> a
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> carry
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    void <clinit>() -> <clinit>
org.apfloat.internal.LongCarryCRTStepStrategy$1 -> org.apfloat.internal.LongCarryCRTStepStrategy$1:
    long serialVersionUID -> serialVersionUID
    int position -> position
    boolean $assertionsDisabled -> $assertionsDisabled
    long[] val$data -> val$data
    void <init>(long[]) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    long getLong() -> getLong
    void setLong(long) -> setLong
    void <clinit>() -> <clinit>
org.apfloat.internal.LongCarryCRTStepStrategy$2 -> org.apfloat.internal.LongCarryCRTStepStrategy$2:
    long serialVersionUID -> serialVersionUID
    long position -> position
    long val$size -> val$size
    org.apfloat.spi.DataStorage$Iterator val$iterator1 -> val$iterator1
    org.apfloat.spi.DataStorage$Iterator val$iterator2 -> val$iterator2
    void <init>(long,org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    long getLong() -> getLong
    void setLong(long) -> setLong
    void close() -> close
org.apfloat.internal.LongConvolutionBuilder -> kP:
    void <init>() -> <init>
    float getKaratsubaCostFactor() -> a
    float getNTTCostFactor() -> b
    org.apfloat.spi.ConvolutionStrategy createShortConvolutionStrategy(int) -> a
    org.apfloat.spi.ConvolutionStrategy createMediumConvolutionStrategy(int) -> b
    org.apfloat.spi.ConvolutionStrategy createKaratsubaConvolutionStrategy(int) -> c
    org.apfloat.spi.ConvolutionStrategy createThreeNTTConvolutionStrategy(int,org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.LongDataStorageBuilder -> kQ:
    void <init>() -> <init>
    long getMaxCachedSize() -> a
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.LongDiskDataStorage -> org.apfloat.internal.LongDiskDataStorage:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(org.apfloat.internal.LongDiskDataStorage,long,long) -> <init>
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess createArrayAccess(int,int,int,int) -> createArrayAccess
    org.apfloat.spi.ArrayAccess createTransposedArrayAccess(int,int,int,int) -> createTransposedArrayAccess
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    int getUnitSize() -> getUnitSize
org.apfloat.internal.LongDiskDataStorage$BlockIterator -> org.apfloat.internal.LongDiskDataStorage$BlockIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.spi.ArrayAccess arrayAccess -> arrayAccess
    long[] data -> data
    int offset -> offset
    int remaining -> remaining
    boolean $assertionsDisabled -> $assertionsDisabled
    org.apfloat.internal.LongDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.LongDiskDataStorage,int,long,long) -> <init>
    void next() -> next
    long getLong() -> getLong
    void setLong(long) -> setLong
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void close() -> close
    void checkAvailable() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess -> org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    long fileOffset -> fileOffset
    org.apfloat.internal.LongDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.LongDiskDataStorage,int,long,int) -> <init>
    void close() -> close
org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess$1 -> kR:
    int readPosition -> a
    long[] val$array -> a
    void <init>(org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess,org.apfloat.internal.LongDiskDataStorage,long[]) -> <init>
    int write(java.nio.ByteBuffer) -> write
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess$2 -> kS:
    int writePosition -> a
    long[] val$array -> a
    void <init>(org.apfloat.internal.LongDiskDataStorage$LongDiskArrayAccess,long[]) -> <init>
    int read(java.nio.ByteBuffer) -> read
    void close() -> close
    boolean isOpen() -> isOpen
org.apfloat.internal.LongDiskDataStorage$MemoryArrayAccess -> org.apfloat.internal.LongDiskDataStorage$MemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int startColumn -> startColumn
    int columns -> columns
    int rows -> rows
    org.apfloat.internal.LongDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.LongDiskDataStorage,int,long[],int,int,int) -> <init>
    void close() -> close
org.apfloat.internal.LongDiskDataStorage$TransposedMemoryArrayAccess -> org.apfloat.internal.LongDiskDataStorage$TransposedMemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int startColumn -> startColumn
    int columns -> columns
    int rows -> rows
    org.apfloat.internal.LongDiskDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.LongDiskDataStorage,int,long[],int,int,int) -> <init>
    void close() -> close
org.apfloat.internal.LongElementaryModMath -> kT:
    long modulus -> a
    double inverseModulus -> a
    void <init>() -> <init>
    long modMultiply(long,long) -> a
    long modAdd(long,long) -> b
    long modSubtract(long,long) -> c
    void setModulus(long) -> a
org.apfloat.internal.LongFactor3NTTStepStrategy -> kU:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.LongFactor3NTTStepStrategy$1 -> kV:
    org.apfloat.spi.DataStorage val$dataStorage0 -> a
    org.apfloat.spi.DataStorage val$dataStorage1 -> b
    org.apfloat.spi.DataStorage val$dataStorage2 -> c
    long val$startColumn -> a
    long val$w -> b
    long val$ww -> c
    long val$w1 -> d
    long val$w2 -> e
    boolean val$isInverse -> a
    org.apfloat.internal.LongFactor3NTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongFactor3NTTStepStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,long,boolean) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.LongFactor3NTTStepStrategy$ColumnTransformRunnable -> kW:
    org.apfloat.spi.DataStorage dataStorage0 -> a
    org.apfloat.spi.DataStorage dataStorage1 -> b
    org.apfloat.spi.DataStorage dataStorage2 -> c
    long startColumn -> a
    long columns -> b
    long w -> c
    long ww -> d
    long w1 -> e
    long w2 -> f
    boolean isInverse -> a
    org.apfloat.internal.LongFactor3NTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongFactor3NTTStepStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,long,long,boolean) -> <init>
    void run() -> run
org.apfloat.internal.LongKaratsubaConvolutionStrategy -> org.apfloat.internal.LongKaratsubaConvolutionStrategy:
    int CUTOFF_POINT -> CUTOFF_POINT
    long serialVersionUID -> serialVersionUID
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    org.apfloat.spi.DataStorage add(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    void subtract(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> a
    boolean isZero(org.apfloat.spi.DataStorage,long) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.LongMatrixBuilder -> kX:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    void <init>() -> <init>
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.LongMatrixStrategy -> kY:
    void <init>() -> <init>
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
    void moveBlock(long[],int,int,long[],int,int,int) -> a
    void transposeBlock(long[],int,int,int) -> a
    void transposeSquare(long[],int,int,int) -> b
    void permuteToHalfWidth(long[],int,int,int) -> c
    void permuteToDoubleWidth(long[],int,int,int) -> d
org.apfloat.internal.LongMediumConvolutionStrategy -> org.apfloat.internal.LongMediumConvolutionStrategy:
    long serialVersionUID -> serialVersionUID
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
org.apfloat.internal.LongMediumConvolutionStrategy$1 -> org.apfloat.internal.LongMediumConvolutionStrategy$1:
    long serialVersionUID -> serialVersionUID
    long[] buffer -> buffer
    int position -> position
    int val$bufferSize -> val$bufferSize
    org.apfloat.internal.LongMediumConvolutionStrategy this$0 -> this$0
    void <init>(org.apfloat.internal.LongMediumConvolutionStrategy,int) -> <init>
    void next() -> next
    long getLong() -> getLong
    void setLong(long) -> setLong
org.apfloat.internal.LongMemoryArrayAccess -> org.apfloat.internal.LongMemoryArrayAccess:
    long serialVersionUID -> serialVersionUID
    long[] data -> data
    void <init>(long[],int,int) -> <init>
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> subsequence
    java.lang.Object getData() -> getData
    long[] getLongData() -> getLongData
    void close() -> close
org.apfloat.internal.LongMemoryDataStorage -> org.apfloat.internal.LongMemoryDataStorage:
    long serialVersionUID -> serialVersionUID
    long[] data -> data
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>() -> <init>
    void <init>(org.apfloat.internal.LongMemoryDataStorage,long,long) -> <init>
    boolean isCached() -> isCached
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> implCopyFrom
    long implGetSize() -> implGetSize
    void implSetSize(long) -> implSetSize
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetArray(int,int,int,int) -> implGetArray
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> implGetTransposedArray
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    long[] access$000(org.apfloat.internal.LongMemoryDataStorage) -> access$000
    long access$100(org.apfloat.internal.LongMemoryDataStorage) -> access$100
    void <clinit>() -> <clinit>
org.apfloat.internal.LongMemoryDataStorage$ReadOnlyIterator -> org.apfloat.internal.LongMemoryDataStorage$ReadOnlyIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.LongMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.LongMemoryDataStorage,long,long) -> <init>
    void setLong(long) -> setLong
org.apfloat.internal.LongMemoryDataStorage$ReadWriteIterator -> org.apfloat.internal.LongMemoryDataStorage$ReadWriteIterator:
    long serialVersionUID -> serialVersionUID
    long[] data -> data
    int position -> position
    int length -> length
    org.apfloat.internal.LongMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.LongMemoryDataStorage,long,long) -> <init>
    void <init>(org.apfloat.internal.LongMemoryDataStorage,int,long,long) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    long getLong() -> getLong
    void setLong(long) -> setLong
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void checkLength() -> checkLength
org.apfloat.internal.LongMemoryDataStorage$WriteOnlyIterator -> org.apfloat.internal.LongMemoryDataStorage$WriteOnlyIterator:
    long serialVersionUID -> serialVersionUID
    org.apfloat.internal.LongMemoryDataStorage this$0 -> this$0
    void <init>(org.apfloat.internal.LongMemoryDataStorage,long,long) -> <init>
    long getLong() -> getLong
org.apfloat.internal.LongModConstants -> kZ:
    long[] MODULUS -> a
    long[] PRIMITIVE_ROOT -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.LongModMath -> la:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    long getForwardNthRoot(long,long) -> d
    long getInverseNthRoot(long,long) -> e
    long modDivide(long,long) -> f
    long modPow(long,long) -> g
    void <clinit>() -> <clinit>
org.apfloat.internal.LongNTTBuilder -> lb:
    void <init>() -> <init>
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.internal.LongNTTConvolutionStepStrategy -> lc:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.LongNTTConvolutionStepStrategy$1 -> ld:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.spi.DataStorage val$source -> b
    org.apfloat.internal.LongNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongNTTConvolutionStepStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.LongNTTConvolutionStepStrategy$2 -> le:
    org.apfloat.spi.DataStorage val$sourceAndDestination -> a
    org.apfloat.internal.LongNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongNTTConvolutionStepStrategy,long,org.apfloat.spi.DataStorage) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.LongNTTConvolutionStepStrategy$MultiplyInPlaceRunnable -> lf:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    org.apfloat.spi.DataStorage source -> b
    long offset -> a
    long length -> b
    org.apfloat.internal.LongNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongNTTConvolutionStepStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long) -> <init>
    void run() -> run
org.apfloat.internal.LongNTTConvolutionStepStrategy$SquareInPlaceRunnable -> lg:
    org.apfloat.spi.DataStorage sourceAndDestination -> a
    long offset -> a
    long length -> b
    org.apfloat.internal.LongNTTConvolutionStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongNTTConvolutionStepStrategy,org.apfloat.spi.DataStorage,long,long) -> <init>
    void run() -> run
org.apfloat.internal.LongNTTStepStrategy -> lh:
    void <init>() -> <init>
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.internal.LongNTTStepStrategy$1 -> li:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$columns -> a
    int val$startRow -> b
    int val$startColumn -> c
    long val$w -> a
    long val$scaleFactor -> b
    org.apfloat.internal.LongNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongNTTStepStrategy,long,org.apfloat.spi.ArrayAccess,int,int,int,long,long) -> <init>
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.LongNTTStepStrategy$2 -> lj:
    org.apfloat.spi.ArrayAccess val$arrayAccess -> a
    int val$length -> a
    boolean val$isInverse -> a
    long[] val$wTable -> a
    int[] val$permutationTable -> a
    org.apfloat.internal.LongNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongNTTStepStrategy,long,org.apfloat.spi.ArrayAccess,int,boolean,long[],int[]) -> <init>
    java.lang.Runnable getRunnable(int,int) -> a
org.apfloat.internal.LongNTTStepStrategy$MultiplyRunnable -> lk:
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    int startRow -> a
    int startColumn -> b
    int rows -> c
    int columns -> d
    long w -> a
    long scaleFactor -> b
    org.apfloat.internal.LongNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongNTTStepStrategy,org.apfloat.spi.ArrayAccess,int,int,int,int,long,long) -> <init>
    void run() -> run
org.apfloat.internal.LongNTTStepStrategy$TableFNTRunnable -> ll:
    int length -> a
    boolean isInverse -> a
    org.apfloat.spi.ArrayAccess arrayAccess -> a
    long[] wTable -> a
    int[] permutationTable -> a
    org.apfloat.internal.LongNTTStepStrategy this$0 -> a
    void <init>(org.apfloat.internal.LongNTTStepStrategy,int,boolean,org.apfloat.spi.ArrayAccess,long[],int[]) -> <init>
    void run() -> run
org.apfloat.internal.LongRadixConstants -> lm:
    long[] BASE -> a
    int[] BASE_DIGITS -> a
    long[][] MINIMUM_FOR_DIGITS -> a
    long[] MAX_EXPONENT -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.LongShortConvolutionStrategy -> org.apfloat.internal.LongShortConvolutionStrategy:
    long serialVersionUID -> serialVersionUID
    boolean $assertionsDisabled -> $assertionsDisabled
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    void <clinit>() -> <clinit>
org.apfloat.internal.LongTableFNT -> ln:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void tableFNT(org.apfloat.spi.ArrayAccess,long[],int[]) -> a
    void inverseTableFNT(org.apfloat.spi.ArrayAccess,long[],int[]) -> b
    void <clinit>() -> <clinit>
org.apfloat.internal.LongTableFNTStrategy -> lo:
    void <init>() -> <init>
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
    void divideElements(org.apfloat.spi.ArrayAccess,long) -> a
org.apfloat.internal.LongWTables -> lp:
    java.util.concurrent.ConcurrentMap cache -> a
    long[] getWTable(int,int) -> a
    long[] getInverseWTable(int,int) -> b
    long[] getWTable(int,int,boolean) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.MessagePasser -> lq:
    java.util.Map messages -> a
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void sendMessage(java.lang.Object,java.lang.Object) -> a
    java.lang.Object receiveMessage(java.lang.Object) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.ParallelRunnable -> lr:
    long length -> a
    long preferredBatchSize -> b
    java.util.concurrent.atomic.AtomicLong started -> a
    java.util.concurrent.atomic.AtomicLong completed -> b
    void <init>(long) -> <init>
    void run() -> run
    boolean runBatch() -> a
    java.lang.Runnable getRunnable(int,int) -> a
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.ParallelRunner -> ls:
    java.util.Queue tasks -> a
    void runParallel(org.apfloat.internal.ParallelRunnable) -> a
    void wait(java.util.concurrent.Future) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.ParallelThreeNTTConvolutionStrategy -> lt:
    java.util.Map locks -> a
    java.lang.Object key -> a
    boolean $assertionsDisabled -> a
    void <init>(int,org.apfloat.spi.NTTStrategy) -> <init>
    void lock(long) -> a
    void unlock() -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.ParallelThreeNTTConvolutionStrategy$LockFuture -> lu:
    java.util.concurrent.Callable VOID_CALLABLE -> a
    java.util.concurrent.locks.Lock lock -> a
    void <init>(java.util.concurrent.locks.Lock) -> <init>
    boolean isDone() -> isDone
    void <clinit>() -> <clinit>
org.apfloat.internal.ParallelThreeNTTConvolutionStrategy$LockFuture$1 -> lv:
    void <init>() -> <init>
    java.lang.Object call() -> call
org.apfloat.internal.Parallelizable -> lw:
org.apfloat.internal.RadixMismatchException -> org.apfloat.internal.RadixMismatchException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.internal.Scramble -> lx:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    int permute(int,int) -> a
    int[] createScrambleTable(int) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.SixStepFNTStrategy -> ly:
    org.apfloat.spi.MatrixStrategy matrixStrategy -> a
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void transform(org.apfloat.spi.DataStorage,int,int,long,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,int,long,long,int) -> a
    void transposeInitial$3fbfc74b(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeMiddle$3fbfc74b(org.apfloat.spi.ArrayAccess,int,int) -> b
    void transformFirst(org.apfloat.spi.ArrayAccess,int,int,boolean,int) -> a
    void transformSecond(org.apfloat.spi.ArrayAccess,int,int,boolean,int) -> b
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,long,long,boolean,int) -> a
    void <clinit>() -> <clinit>
org.apfloat.internal.StepCarryCRTStrategy -> lz:
    int radix -> a
    void <init>(int) -> <init>
    org.apfloat.spi.DataStorage carryCRT(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.internal.StepCarryCRTStrategy$1 -> lA:
    org.apfloat.spi.DataStorage val$resultMod0 -> a
    org.apfloat.spi.DataStorage val$resultMod1 -> b
    org.apfloat.spi.DataStorage val$resultMod2 -> c
    org.apfloat.spi.DataStorage val$dataStorage -> d
    long val$size -> a
    long val$resultSize -> b
    org.apfloat.internal.MessagePasser val$messagePasser -> a
    org.apfloat.spi.CarryCRTStepStrategy val$stepStrategy -> a
    org.apfloat.internal.StepCarryCRTStrategy this$0 -> a
    void <init>(org.apfloat.internal.StepCarryCRTStrategy,long,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,org.apfloat.internal.MessagePasser,org.apfloat.spi.CarryCRTStepStrategy) -> <init>
    java.lang.Runnable getRunnable(long,long) -> a
org.apfloat.internal.StepCarryCRTStrategy$CarryCRTRunnable -> lB:
    org.apfloat.spi.DataStorage resultMod0 -> a
    org.apfloat.spi.DataStorage resultMod1 -> b
    org.apfloat.spi.DataStorage resultMod2 -> c
    org.apfloat.spi.DataStorage dataStorage -> d
    long size -> a
    long resultSize -> b
    long offset -> c
    long length -> d
    org.apfloat.internal.MessagePasser messagePasser -> a
    org.apfloat.spi.CarryCRTStepStrategy stepStrategy -> a
    boolean $assertionsDisabled -> a
    void <init>(org.apfloat.internal.StepCarryCRTStrategy,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,org.apfloat.internal.MessagePasser,org.apfloat.spi.CarryCRTStepStrategy) -> <init>
    void run() -> run
    void <clinit>() -> <clinit>
org.apfloat.internal.ThreeNTTConvolutionStrategy -> lC:
    org.apfloat.spi.NTTStrategy nttStrategy -> a
    org.apfloat.spi.CarryCRTStrategy carryCRTStrategy -> a
    org.apfloat.spi.NTTConvolutionStepStrategy stepStrategy -> a
    void <init>(int,org.apfloat.spi.NTTStrategy) -> <init>
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
    org.apfloat.spi.DataStorage convoluteOne(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,int,boolean) -> a
    org.apfloat.spi.DataStorage autoConvolute(org.apfloat.spi.DataStorage,long) -> a
    org.apfloat.spi.DataStorage autoConvoluteOne(org.apfloat.spi.DataStorage,long,int,boolean) -> a
    void lock(long) -> a
    void unlock() -> a
    org.apfloat.spi.DataStorage createCachedDataStorage(long) -> a
    org.apfloat.spi.DataStorage createDataStorage(org.apfloat.spi.DataStorage) -> a
org.apfloat.internal.TransformLengthExceededException -> org.apfloat.internal.TransformLengthExceededException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
org.apfloat.internal.TwoPassFNTStrategy -> lD:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    void transform(org.apfloat.spi.DataStorage,int,int,long,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,int,long,long,int) -> a
    org.apfloat.spi.ArrayAccess getColumns(org.apfloat.spi.DataStorage,int,int,int) -> a
    org.apfloat.spi.ArrayAccess getRows(org.apfloat.spi.DataStorage,int,int,int) -> b
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformColumns(org.apfloat.spi.ArrayAccess,int,int,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,int) -> b
    int getMaxMemoryBlockSize(long) -> a
    void <clinit>() -> <clinit>
org.apfloat.spi.AdditionBuilder -> lE:
    org.apfloat.spi.AdditionStrategy createAddition(int) -> a
org.apfloat.spi.AdditionStrategy -> lF:
    java.lang.Object add(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> add
    java.lang.Object subtract(org.apfloat.spi.DataStorage$Iterator,org.apfloat.spi.DataStorage$Iterator,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> subtract
    java.lang.Object divide(org.apfloat.spi.DataStorage$Iterator,java.lang.Object,java.lang.Object,org.apfloat.spi.DataStorage$Iterator,long) -> divide
org.apfloat.spi.ApfloatBuilder -> lG:
    org.apfloat.spi.ApfloatImpl createApfloat(java.lang.String,long,int,boolean) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(long,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(double,long,int) -> a
    org.apfloat.spi.ApfloatImpl createApfloat(java.io.PushbackReader,long,int,boolean) -> a
org.apfloat.spi.ApfloatImpl -> org.apfloat.spi.ApfloatImpl:
    org.apfloat.spi.ApfloatImpl addOrSubtract(org.apfloat.spi.ApfloatImpl,boolean) -> addOrSubtract
    org.apfloat.spi.ApfloatImpl multiply(org.apfloat.spi.ApfloatImpl) -> multiply
    boolean isShort() -> isShort
    org.apfloat.spi.ApfloatImpl divideShort(org.apfloat.spi.ApfloatImpl) -> divideShort
    org.apfloat.spi.ApfloatImpl absFloor() -> absFloor
    org.apfloat.spi.ApfloatImpl absCeil() -> absCeil
    org.apfloat.spi.ApfloatImpl frac() -> frac
    int radix() -> radix
    long precision() -> precision
    long size() -> size
    org.apfloat.spi.ApfloatImpl precision(long) -> precision
    long scale() -> scale
    int signum() -> signum
    org.apfloat.spi.ApfloatImpl negate() -> negate
    double doubleValue() -> doubleValue
    long longValue() -> longValue
    boolean isOne() -> isOne
    long equalDigits(org.apfloat.spi.ApfloatImpl) -> equalDigits
    int compareTo(org.apfloat.spi.ApfloatImpl) -> compareTo
    int hashCode() -> hashCode
    java.lang.String toString(boolean) -> toString
    void writeTo(java.io.Writer,boolean) -> writeTo
org.apfloat.spi.ArrayAccess -> org.apfloat.spi.ArrayAccess:
    long serialVersionUID -> serialVersionUID
    int offset -> offset
    int length -> length
    void <init>(int,int) -> <init>
    org.apfloat.spi.ArrayAccess subsequence(int,int) -> subsequence
    java.lang.Object getData() -> getData
    int[] getIntData() -> getIntData
    long[] getLongData() -> getLongData
    float[] getFloatData() -> getFloatData
    double[] getDoubleData() -> getDoubleData
    int getOffset() -> getOffset
    int getLength() -> getLength
    void close() -> close
org.apfloat.spi.BuilderFactory -> lH:
    org.apfloat.spi.ApfloatBuilder getApfloatBuilder() -> getApfloatBuilder
    org.apfloat.spi.DataStorageBuilder getDataStorageBuilder() -> getDataStorageBuilder
    org.apfloat.spi.AdditionBuilder getAdditionBuilder(java.lang.Class) -> getAdditionBuilder
    org.apfloat.spi.ConvolutionBuilder getConvolutionBuilder() -> getConvolutionBuilder
    org.apfloat.spi.NTTBuilder getNTTBuilder() -> getNTTBuilder
    org.apfloat.spi.MatrixBuilder getMatrixBuilder() -> getMatrixBuilder
    org.apfloat.spi.CarryCRTBuilder getCarryCRTBuilder(java.lang.Class) -> getCarryCRTBuilder
    java.lang.Class getElementArrayType() -> getElementArrayType
    int getElementSize() -> getElementSize
    void shutdown() -> shutdown
org.apfloat.spi.CarryCRTBuilder -> lI:
    org.apfloat.spi.CarryCRTStrategy createCarryCRT(int) -> a
    org.apfloat.spi.CarryCRTStepStrategy createCarryCRTSteps(int) -> a
org.apfloat.spi.CarryCRTStepStrategy -> lJ:
    java.lang.Object crt(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long) -> crt
    java.lang.Object carry(org.apfloat.spi.DataStorage,long,long,long,long,java.lang.Object,java.lang.Object) -> carry
org.apfloat.spi.CarryCRTStrategy -> lK:
    org.apfloat.spi.DataStorage carryCRT(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> a
org.apfloat.spi.ConvolutionBuilder -> lL:
    org.apfloat.spi.ConvolutionStrategy createConvolution$75792394(int,long,long) -> a
org.apfloat.spi.ConvolutionStrategy -> lM:
    org.apfloat.spi.DataStorage convolute(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long) -> convolute
org.apfloat.spi.DataStorage -> org.apfloat.spi.DataStorage:
    int READ -> READ
    int WRITE -> WRITE
    int READ_WRITE -> READ_WRITE
    long serialVersionUID -> serialVersionUID
    long offset -> offset
    long length -> length
    org.apfloat.spi.DataStorage originalDataStorage -> originalDataStorage
    boolean isReadOnly -> isReadOnly
    boolean isSubsequenced -> isSubsequenced
    void <init>() -> <init>
    void <init>(org.apfloat.spi.DataStorage,long,long) -> <init>
    org.apfloat.spi.DataStorage subsequence(long,long) -> subsequence
    org.apfloat.spi.DataStorage implSubsequence(long,long) -> implSubsequence
    void copyFrom(org.apfloat.spi.DataStorage) -> copyFrom
    void copyFrom(org.apfloat.spi.DataStorage,long) -> copyFrom
    void implCopyFrom(org.apfloat.spi.DataStorage,long) -> implCopyFrom
    long getSize() -> getSize
    long implGetSize() -> implGetSize
    void setSize(long) -> setSize
    void implSetSize(long) -> implSetSize
    boolean isReadOnly() -> isReadOnly
    void setReadOnly() -> setReadOnly
    org.apfloat.spi.ArrayAccess getArray(int,long,int) -> getArray
    org.apfloat.spi.ArrayAccess implGetArray(int,long,int) -> implGetArray
    org.apfloat.spi.ArrayAccess getArray(int,int,int,int) -> getArray
    org.apfloat.spi.ArrayAccess implGetArray(int,int,int,int) -> implGetArray
    org.apfloat.spi.ArrayAccess getTransposedArray(int,int,int,int) -> getTransposedArray
    org.apfloat.spi.ArrayAccess implGetTransposedArray(int,int,int,int) -> implGetTransposedArray
    org.apfloat.spi.DataStorage$Iterator iterator(int,long,long) -> iterator
    boolean isSubsequenced() -> isSubsequenced
    boolean isCached() -> isCached
    long getOffset() -> getOffset
org.apfloat.spi.DataStorage$AbstractIterator -> org.apfloat.spi.DataStorage$AbstractIterator:
    long serialVersionUID -> serialVersionUID
    int mode -> mode
    int increment -> increment
    long position -> position
    long length -> length
    org.apfloat.spi.DataStorage this$0 -> this$0
    void <init>(org.apfloat.spi.DataStorage,int,long,long) -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    int getInt() -> getInt
    long getLong() -> getLong
    float getFloat() -> getFloat
    double getDouble() -> getDouble
    void setInt(int) -> setInt
    void setLong(long) -> setLong
    void setFloat(float) -> setFloat
    void setDouble(double) -> setDouble
    void checkGet() -> checkGet
    void checkSet() -> checkSet
    void checkLength() -> checkLength
    int getMode() -> getMode
    long getPosition() -> getPosition
    long getLength() -> getLength
    int getIncrement() -> getIncrement
org.apfloat.spi.DataStorage$Iterator -> org.apfloat.spi.DataStorage$Iterator:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    boolean hasNext() -> hasNext
    void next() -> next
    int getInt() -> getInt
    long getLong() -> getLong
    float getFloat() -> getFloat
    double getDouble() -> getDouble
    void setInt(int) -> setInt
    void setLong(long) -> setLong
    void setFloat(float) -> setFloat
    void setDouble(double) -> setDouble
    java.lang.Object get(java.lang.Class) -> get
    void set(java.lang.Class,java.lang.Object) -> set
    void close() -> close
org.apfloat.spi.DataStorageBuilder -> lN:
    org.apfloat.spi.DataStorage createDataStorage(long) -> a
    org.apfloat.spi.DataStorage createCachedDataStorage(long) -> b
    org.apfloat.spi.DataStorage createDataStorage(org.apfloat.spi.DataStorage) -> a
    void <init>() -> <init>
    long getMaxCachedSize() -> a
    org.apfloat.spi.DataStorage createCachedDataStorage() -> a
    org.apfloat.spi.DataStorage createNonCachedDataStorage() -> b
    boolean isCached(org.apfloat.spi.DataStorage) -> a
org.apfloat.spi.Factor3NTTStepStrategy -> lO:
    void transformColumns(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,long,long,long,long,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.spi.FilenameGenerator -> lP:
    java.lang.String path -> a
    long value -> a
    java.lang.String suffix -> b
    void <init>(java.lang.String,java.lang.String,java.lang.String) -> <init>
    java.lang.String generateFilename() -> a
    java.lang.String getInitialValue() -> b
org.apfloat.spi.MatrixBuilder -> lQ:
    org.apfloat.spi.MatrixStrategy createMatrix() -> a
org.apfloat.spi.MatrixStrategy -> lR:
    void transpose(org.apfloat.spi.ArrayAccess,int,int) -> a
    void transposeSquare(org.apfloat.spi.ArrayAccess,int,int) -> b
org.apfloat.spi.NTTBuilder -> lS:
    org.apfloat.spi.NTTStrategy createNTT(long) -> a
    org.apfloat.spi.NTTStepStrategy createNTTSteps() -> a
    org.apfloat.spi.NTTConvolutionStepStrategy createNTTConvolutionSteps() -> a
    org.apfloat.spi.Factor3NTTStepStrategy createFactor3NTTSteps() -> a
    void <init>() -> <init>
    org.apfloat.spi.NTTStrategy createSimpleFNTStrategy() -> a
    org.apfloat.spi.NTTStrategy createSixStepFNTStrategy() -> b
    org.apfloat.spi.NTTStrategy createTwoPassFNTStrategy() -> c
    org.apfloat.spi.NTTStrategy createFactor3NTTStrategy(org.apfloat.spi.NTTStrategy) -> a
org.apfloat.spi.NTTConvolutionStepStrategy -> lT:
    void multiplyInPlace(org.apfloat.spi.DataStorage,org.apfloat.spi.DataStorage,int) -> a
    void squareInPlace(org.apfloat.spi.DataStorage,int) -> a
org.apfloat.spi.NTTStepStrategy -> lU:
    void multiplyElements(org.apfloat.spi.ArrayAccess,int,int,int,int,long,long,boolean,int) -> a
    void transformRows(org.apfloat.spi.ArrayAccess,int,int,boolean,boolean,int) -> a
    long getMaxTransformLength() -> a
org.apfloat.spi.NTTStrategy -> lV:
    void transform(org.apfloat.spi.DataStorage,int) -> a
    void inverseTransform(org.apfloat.spi.DataStorage,int,long) -> a
    long getTransformLength(long) -> a
org.apfloat.spi.RadixConstants -> lW:
    int[][] RADIX_FACTORS -> a
    int[] FLOAT_PRECISION -> a
    int[] DOUBLE_PRECISION -> b
    int[] LONG_PRECISION -> c
    int[] LONG_DIGITS -> d
    void <clinit>() -> <clinit>
org.apfloat.spi.Util -> lX:
    boolean $assertionsDisabled -> a
    void <init>() -> <init>
    int round2down(int) -> a
    long round2down(long) -> a
    long round2up(long) -> b
    long round23down(long) -> c
    long round23up(long) -> d
    int sqrt4down(int) -> b
    long sqrt4down(long) -> e
    int sqrt4up(int) -> c
    int log2down(long) -> a
    int log2up(long) -> b
    long ifFinite(long,long) -> a
    void <clinit>() -> <clinit>
org.matheclipse.combinatoric.AbstractListStepVisitor -> lY:
    java.util.List list -> list
    java.lang.Object[] array -> array
    void <init>(java.util.List) -> <init>
    void <init>(java.util.List,int) -> <init>
    void <init>(java.util.List,int,int) -> <init>
    void toIntArray(java.util.List,int,int) -> a
    boolean visit(int[][]) -> visit
    boolean visit(int[]) -> visit
    int[] getMultisetArray() -> getMultisetArray
org.matheclipse.combinatoric.IStepVisitor -> lZ:
    boolean visit(int[][]) -> visit
    int[] getMultisetArray() -> getMultisetArray
org.matheclipse.combinatoric.MultisetCombinationIterator -> ma:
    int[] result -> a
    int[] multiset -> b
    int n -> a
    int k -> b
    void <init>(int[],int) -> <init>
    int[] next() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.combinatoric.MultisetPartitionsIterator -> mb:
    int n -> a
    int[] multiset -> a
    int[][] result -> a
    org.matheclipse.combinatoric.RosenNumberPartitionIterator rosen -> a
    org.matheclipse.combinatoric.IStepVisitor handler -> a
    void <init>(org.matheclipse.combinatoric.IStepVisitor,int) -> <init>
    boolean execute() -> a
    void recursiveMultisetCombination(int[],int[],int) -> a
org.matheclipse.combinatoric.NumberPartitionsIterator -> mc:
    int[][] result -> a
    org.matheclipse.combinatoric.RosenNumberPartitionIterator rosen -> a
    org.matheclipse.combinatoric.IStepVisitor handler -> a
    void <init>(org.matheclipse.combinatoric.IStepVisitor,int,int) -> <init>
org.matheclipse.combinatoric.RosenIterator -> md:
    int n -> a
    int k -> b
    int[] a -> a
    long count -> a
    void <init>(int,int) -> <init>
    long count(int,int) -> a
    boolean hasNext() -> hasNext
    int[] next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.combinatoric.RosenNumberPartitionIterator -> me:
    void <init>(int,int) -> <init>
    int[] next() -> a
    java.lang.Object next() -> next
org.matheclipse.combinatoric.StopException -> org.matheclipse.combinatoric.StopException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.matheclipse.commons.math.analysis.solvers.AbstractDifferentiableUnivariateSolver -> mf:
    org.apache.commons.math3.analysis.UnivariateFunction functionDerivative -> b
    void <init>(double) -> <init>
    double computeDerivativeObjectiveValue(double) -> b
    void setup(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double) -> a
org.matheclipse.commons.math.analysis.solvers.DifferentiableUnivariateFunction -> mg:
    org.apache.commons.math3.analysis.UnivariateFunction derivative() -> derivative
org.matheclipse.commons.math.analysis.solvers.NewtonSolver -> mh:
    void <init>() -> <init>
    void <init>(double) -> <init>
    double doSolve() -> a
    double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double) -> a
org.matheclipse.commons.math.linear.AbstractFieldMatrix -> mi:
    void <init>() -> <init>
    void <init>(int,int) -> <init>
    org.matheclipse.core.interfaces.IExpr[][] buildArray(int,int) -> buildArray
    org.matheclipse.core.interfaces.IExpr[] buildArray(int) -> buildArray
    org.matheclipse.commons.math.linear.FieldMatrix createMatrix(int,int) -> createMatrix
    org.matheclipse.commons.math.linear.FieldMatrix copy() -> copy
    org.matheclipse.commons.math.linear.FieldMatrix add(org.matheclipse.commons.math.linear.FieldMatrix) -> add
    org.matheclipse.commons.math.linear.FieldMatrix subtract(org.matheclipse.commons.math.linear.FieldMatrix) -> subtract
    org.matheclipse.commons.math.linear.FieldMatrix scalarAdd(org.matheclipse.core.interfaces.IExpr) -> scalarAdd
    org.matheclipse.commons.math.linear.FieldMatrix scalarMultiply(org.matheclipse.core.interfaces.IExpr) -> scalarMultiply
    org.matheclipse.commons.math.linear.FieldMatrix multiply(org.matheclipse.commons.math.linear.FieldMatrix) -> multiply
    org.matheclipse.commons.math.linear.FieldMatrix preMultiply(org.matheclipse.commons.math.linear.FieldMatrix) -> preMultiply
    org.matheclipse.commons.math.linear.FieldMatrix power(int) -> power
    org.matheclipse.core.interfaces.IExpr[][] getData() -> getData
    org.matheclipse.commons.math.linear.FieldMatrix getSubMatrix(int,int,int,int) -> getSubMatrix
    org.matheclipse.commons.math.linear.FieldMatrix getSubMatrix(int[],int[]) -> getSubMatrix
    void copySubMatrix(int,int,int,int,org.matheclipse.core.interfaces.IExpr[][]) -> copySubMatrix
    void copySubMatrix(int[],int[],org.matheclipse.core.interfaces.IExpr[][]) -> copySubMatrix
    void setSubMatrix(org.matheclipse.core.interfaces.IExpr[][],int,int) -> setSubMatrix
    org.matheclipse.commons.math.linear.FieldMatrix getRowMatrix(int) -> getRowMatrix
    void setRowMatrix(int,org.matheclipse.commons.math.linear.FieldMatrix) -> setRowMatrix
    org.matheclipse.commons.math.linear.FieldMatrix getColumnMatrix(int) -> getColumnMatrix
    void setColumnMatrix(int,org.matheclipse.commons.math.linear.FieldMatrix) -> setColumnMatrix
    org.matheclipse.commons.math.linear.FieldVector getRowVector(int) -> getRowVector
    void setRowVector(int,org.matheclipse.commons.math.linear.FieldVector) -> setRowVector
    org.matheclipse.commons.math.linear.FieldVector getColumnVector(int) -> getColumnVector
    void setColumnVector(int,org.matheclipse.commons.math.linear.FieldVector) -> setColumnVector
    org.matheclipse.core.interfaces.IExpr[] getRow(int) -> getRow
    void setRow(int,org.matheclipse.core.interfaces.IExpr[]) -> setRow
    org.matheclipse.core.interfaces.IExpr[] getColumn(int) -> getColumn
    void setColumn(int,org.matheclipse.core.interfaces.IExpr[]) -> setColumn
    org.matheclipse.core.interfaces.IExpr getEntry(int,int) -> getEntry
    void setEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> setEntry
    void addToEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> addToEntry
    void multiplyEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> multiplyEntry
    org.matheclipse.commons.math.linear.FieldMatrix transpose() -> transpose
    boolean isSquare() -> isSquare
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    org.matheclipse.core.interfaces.IExpr getTrace() -> getTrace
    org.matheclipse.core.interfaces.IExpr[] operate(org.matheclipse.core.interfaces.IExpr[]) -> operate
    org.matheclipse.commons.math.linear.FieldVector operate(org.matheclipse.commons.math.linear.FieldVector) -> operate
    org.matheclipse.core.interfaces.IExpr[] preMultiply(org.matheclipse.core.interfaces.IExpr[]) -> preMultiply
    org.matheclipse.commons.math.linear.FieldVector preMultiply(org.matheclipse.commons.math.linear.FieldVector) -> preMultiply
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInColumnOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor) -> walkInColumnOrder
    org.matheclipse.core.interfaces.IExpr walkInColumnOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor) -> walkInColumnOrder
    org.matheclipse.core.interfaces.IExpr walkInColumnOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInColumnOrder
    org.matheclipse.core.interfaces.IExpr walkInColumnOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInColumnOrder
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor) -> walkInOptimizedOrder
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor) -> walkInOptimizedOrder
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInOptimizedOrder
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInOptimizedOrder
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void checkRowIndex(int) -> checkRowIndex
    void checkColumnIndex(int) -> checkColumnIndex
    void checkSubMatrixIndex(int,int,int,int) -> checkSubMatrixIndex
    void checkSubMatrixIndex(int[],int[]) -> checkSubMatrixIndex
    void checkAdditionCompatible(org.matheclipse.commons.math.linear.FieldMatrix) -> checkAdditionCompatible
    void checkSubtractionCompatible(org.matheclipse.commons.math.linear.FieldMatrix) -> checkSubtractionCompatible
    void checkMultiplicationCompatible(org.matheclipse.commons.math.linear.FieldMatrix) -> checkMultiplicationCompatible
org.matheclipse.commons.math.linear.AbstractFieldMatrix$1 -> mj:
    int[] val$selectedRows -> a
    int[] val$selectedColumns -> b
    org.matheclipse.commons.math.linear.AbstractFieldMatrix this$0 -> a
    void <init>(org.matheclipse.commons.math.linear.AbstractFieldMatrix,org.matheclipse.core.interfaces.IExpr,int[],int[]) -> <init>
    org.matheclipse.core.interfaces.IExpr visit(int,int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.commons.math.linear.AbstractFieldMatrix$2 -> mk:
    int startRow -> a
    int startColumn -> b
    org.matheclipse.core.interfaces.IExpr[][] val$destination -> a
    void <init>(org.matheclipse.commons.math.linear.AbstractFieldMatrix,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[][]) -> <init>
    void start$6046c8d5(int,int) -> a
    void visit(int,int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.commons.math.linear.AbstractFieldMatrix$3 -> ml:
    org.matheclipse.commons.math.linear.FieldMatrix val$out -> a
    void <init>(org.matheclipse.commons.math.linear.AbstractFieldMatrix,org.matheclipse.core.interfaces.IExpr,org.matheclipse.commons.math.linear.FieldMatrix) -> <init>
    void visit(int,int,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.commons.math.linear.AnyMatrix -> mm:
    boolean isSquare() -> isSquare
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
org.matheclipse.commons.math.linear.Array2DRowFieldMatrix -> org.matheclipse.commons.math.linear.Array2DRowFieldMatrix:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr[][] data -> data
    void <init>() -> <init>
    void <init>(int,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[][]) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[][],boolean) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[]) -> <init>
    org.matheclipse.commons.math.linear.FieldMatrix createMatrix(int,int) -> createMatrix
    org.matheclipse.commons.math.linear.FieldMatrix copy() -> copy
    org.matheclipse.commons.math.linear.Array2DRowFieldMatrix add(org.matheclipse.commons.math.linear.Array2DRowFieldMatrix) -> add
    org.matheclipse.commons.math.linear.Array2DRowFieldMatrix subtract(org.matheclipse.commons.math.linear.Array2DRowFieldMatrix) -> subtract
    org.matheclipse.commons.math.linear.Array2DRowFieldMatrix multiply(org.matheclipse.commons.math.linear.Array2DRowFieldMatrix) -> multiply
    org.matheclipse.core.interfaces.IExpr[][] getData() -> getData
    org.matheclipse.core.interfaces.IExpr[][] getDataRef() -> getDataRef
    void setSubMatrix(org.matheclipse.core.interfaces.IExpr[][],int,int) -> setSubMatrix
    org.matheclipse.core.interfaces.IExpr getEntry(int,int) -> getEntry
    void setEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> setEntry
    void addToEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> addToEntry
    void multiplyEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> multiplyEntry
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    org.matheclipse.core.interfaces.IExpr[] operate(org.matheclipse.core.interfaces.IExpr[]) -> operate
    org.matheclipse.core.interfaces.IExpr[] preMultiply(org.matheclipse.core.interfaces.IExpr[]) -> preMultiply
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInColumnOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor) -> walkInColumnOrder
    org.matheclipse.core.interfaces.IExpr walkInColumnOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor) -> walkInColumnOrder
    org.matheclipse.core.interfaces.IExpr walkInColumnOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInColumnOrder
    org.matheclipse.core.interfaces.IExpr walkInColumnOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInColumnOrder
    org.matheclipse.core.interfaces.IExpr[][] copyOut() -> a
org.matheclipse.commons.math.linear.ArrayFieldVector -> org.matheclipse.commons.math.linear.ArrayFieldVector:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr[] data -> data
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(int,org.matheclipse.core.interfaces.IExpr) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[]) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[],boolean) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[],int,int) -> <init>
    void <init>(org.matheclipse.commons.math.linear.FieldVector) -> <init>
    void <init>(org.matheclipse.commons.math.linear.ArrayFieldVector) -> <init>
    void <init>(org.matheclipse.commons.math.linear.ArrayFieldVector,boolean) -> <init>
    void <init>(org.matheclipse.commons.math.linear.ArrayFieldVector,org.matheclipse.commons.math.linear.ArrayFieldVector) -> <init>
    void <init>(org.matheclipse.commons.math.linear.FieldVector,org.matheclipse.commons.math.linear.FieldVector) -> <init>
    void <init>(org.matheclipse.commons.math.linear.ArrayFieldVector,org.matheclipse.core.interfaces.IExpr[]) -> <init>
    void <init>(org.matheclipse.commons.math.linear.FieldVector,org.matheclipse.core.interfaces.IExpr[]) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[],org.matheclipse.commons.math.linear.ArrayFieldVector) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[],org.matheclipse.commons.math.linear.FieldVector) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.IExpr[]) -> <init>
    org.matheclipse.commons.math.linear.FieldVector copy() -> copy
    org.matheclipse.commons.math.linear.FieldVector add(org.matheclipse.commons.math.linear.FieldVector) -> add
    org.matheclipse.commons.math.linear.ArrayFieldVector add(org.matheclipse.commons.math.linear.ArrayFieldVector) -> add
    org.matheclipse.commons.math.linear.FieldVector subtract(org.matheclipse.commons.math.linear.FieldVector) -> subtract
    org.matheclipse.commons.math.linear.ArrayFieldVector subtract(org.matheclipse.commons.math.linear.ArrayFieldVector) -> subtract
    org.matheclipse.commons.math.linear.FieldVector mapAdd(org.matheclipse.core.interfaces.IExpr) -> mapAdd
    org.matheclipse.commons.math.linear.FieldVector mapAddToSelf(org.matheclipse.core.interfaces.IExpr) -> mapAddToSelf
    org.matheclipse.commons.math.linear.FieldVector mapSubtract(org.matheclipse.core.interfaces.IExpr) -> mapSubtract
    org.matheclipse.commons.math.linear.FieldVector mapSubtractToSelf(org.matheclipse.core.interfaces.IExpr) -> mapSubtractToSelf
    org.matheclipse.commons.math.linear.FieldVector mapMultiply(org.matheclipse.core.interfaces.IExpr) -> mapMultiply
    org.matheclipse.commons.math.linear.FieldVector mapMultiplyToSelf(org.matheclipse.core.interfaces.IExpr) -> mapMultiplyToSelf
    org.matheclipse.commons.math.linear.FieldVector mapDivide(org.matheclipse.core.interfaces.IExpr) -> mapDivide
    org.matheclipse.commons.math.linear.FieldVector mapDivideToSelf(org.matheclipse.core.interfaces.IExpr) -> mapDivideToSelf
    org.matheclipse.commons.math.linear.FieldVector mapInv() -> mapInv
    org.matheclipse.commons.math.linear.FieldVector mapInvToSelf() -> mapInvToSelf
    org.matheclipse.commons.math.linear.FieldVector ebeMultiply(org.matheclipse.commons.math.linear.FieldVector) -> ebeMultiply
    org.matheclipse.commons.math.linear.ArrayFieldVector ebeMultiply(org.matheclipse.commons.math.linear.ArrayFieldVector) -> ebeMultiply
    org.matheclipse.commons.math.linear.FieldVector ebeDivide(org.matheclipse.commons.math.linear.FieldVector) -> ebeDivide
    org.matheclipse.commons.math.linear.ArrayFieldVector ebeDivide(org.matheclipse.commons.math.linear.ArrayFieldVector) -> ebeDivide
    org.matheclipse.core.interfaces.IExpr[] getData() -> getData
    org.matheclipse.core.interfaces.IExpr[] getDataRef() -> getDataRef
    org.matheclipse.core.interfaces.IExpr dotProduct(org.matheclipse.commons.math.linear.FieldVector) -> dotProduct
    org.matheclipse.core.interfaces.IExpr dotProduct(org.matheclipse.commons.math.linear.ArrayFieldVector) -> dotProduct
    org.matheclipse.commons.math.linear.FieldVector projection(org.matheclipse.commons.math.linear.FieldVector) -> projection
    org.matheclipse.commons.math.linear.ArrayFieldVector projection(org.matheclipse.commons.math.linear.ArrayFieldVector) -> projection
    org.matheclipse.commons.math.linear.FieldMatrix outerProduct(org.matheclipse.commons.math.linear.FieldVector) -> outerProduct
    org.matheclipse.commons.math.linear.FieldMatrix outerProduct(org.matheclipse.commons.math.linear.ArrayFieldVector) -> outerProduct
    org.matheclipse.core.interfaces.IExpr getEntry(int) -> getEntry
    int getDimension() -> getDimension
    org.matheclipse.commons.math.linear.FieldVector append(org.matheclipse.commons.math.linear.FieldVector) -> append
    org.matheclipse.commons.math.linear.ArrayFieldVector append(org.matheclipse.commons.math.linear.ArrayFieldVector) -> append
    org.matheclipse.commons.math.linear.FieldVector append(org.matheclipse.core.interfaces.IExpr) -> append
    org.matheclipse.commons.math.linear.FieldVector getSubVector(int,int) -> getSubVector
    void setEntry(int,org.matheclipse.core.interfaces.IExpr) -> setEntry
    void setSubVector(int,org.matheclipse.commons.math.linear.FieldVector) -> setSubVector
    void set(int,org.matheclipse.commons.math.linear.ArrayFieldVector) -> set
    void set(org.matheclipse.core.interfaces.IExpr) -> set
    org.matheclipse.core.interfaces.IExpr[] toArray() -> toArray
    void checkVectorDimensions(org.matheclipse.commons.math.linear.FieldVector) -> checkVectorDimensions
    void checkVectorDimensions(int) -> checkVectorDimensions
    org.matheclipse.core.interfaces.IExpr walkInDefaultOrder$427256aa(edu.jas.poly.RelationGenerator) -> walkInDefaultOrder$427256aa
    org.matheclipse.core.interfaces.IExpr walkInDefaultOrder$9f9754a(edu.jas.poly.RelationGenerator,int,int) -> walkInDefaultOrder$9f9754a
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder$427256aa(edu.jas.poly.RelationGenerator) -> walkInOptimizedOrder$427256aa
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder$9f9754a(edu.jas.poly.RelationGenerator,int,int) -> walkInOptimizedOrder$9f9754a
    org.matheclipse.core.interfaces.IExpr walkInDefaultOrder$63dc2ff2(edu.jas.poly.RelationGenerator) -> walkInDefaultOrder$63dc2ff2
    org.matheclipse.core.interfaces.IExpr walkInDefaultOrder$42cdda52(edu.jas.poly.RelationGenerator,int,int) -> walkInDefaultOrder$42cdda52
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder$63dc2ff2(edu.jas.poly.RelationGenerator) -> walkInOptimizedOrder$63dc2ff2
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder$42cdda52(edu.jas.poly.RelationGenerator,int,int) -> walkInOptimizedOrder$42cdda52
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void checkIndex(int) -> a
    void checkIndices(int,int) -> a
org.matheclipse.commons.math.linear.BlockFieldMatrix -> org.matheclipse.commons.math.linear.BlockFieldMatrix:
    int BLOCK_SIZE -> BLOCK_SIZE
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr[][] blocks -> blocks
    int rows -> rows
    int columns -> columns
    int blockRows -> blockRows
    int blockColumns -> blockColumns
    void <init>(int,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[][]) -> <init>
    void <init>(int,int,org.matheclipse.core.interfaces.IExpr[][],boolean) -> <init>
    org.matheclipse.core.interfaces.IExpr[][] toBlocksLayout(org.matheclipse.core.interfaces.IExpr[][]) -> toBlocksLayout
    org.matheclipse.core.interfaces.IExpr[][] createBlocksLayout(int,int) -> createBlocksLayout
    org.matheclipse.commons.math.linear.FieldMatrix createMatrix(int,int) -> createMatrix
    org.matheclipse.commons.math.linear.FieldMatrix copy() -> copy
    org.matheclipse.commons.math.linear.FieldMatrix add(org.matheclipse.commons.math.linear.FieldMatrix) -> add
    org.matheclipse.commons.math.linear.BlockFieldMatrix add(org.matheclipse.commons.math.linear.BlockFieldMatrix) -> add
    org.matheclipse.commons.math.linear.FieldMatrix subtract(org.matheclipse.commons.math.linear.FieldMatrix) -> subtract
    org.matheclipse.commons.math.linear.BlockFieldMatrix subtract(org.matheclipse.commons.math.linear.BlockFieldMatrix) -> subtract
    org.matheclipse.commons.math.linear.FieldMatrix scalarAdd(org.matheclipse.core.interfaces.IExpr) -> scalarAdd
    org.matheclipse.commons.math.linear.FieldMatrix scalarMultiply(org.matheclipse.core.interfaces.IExpr) -> scalarMultiply
    org.matheclipse.commons.math.linear.FieldMatrix multiply(org.matheclipse.commons.math.linear.FieldMatrix) -> multiply
    org.matheclipse.commons.math.linear.BlockFieldMatrix multiply(org.matheclipse.commons.math.linear.BlockFieldMatrix) -> multiply
    org.matheclipse.core.interfaces.IExpr[][] getData() -> getData
    org.matheclipse.commons.math.linear.FieldMatrix getSubMatrix(int,int,int,int) -> getSubMatrix
    void copyBlockPart(org.matheclipse.core.interfaces.IExpr[],int,int,int,int,int,org.matheclipse.core.interfaces.IExpr[],int,int,int) -> a
    void setSubMatrix(org.matheclipse.core.interfaces.IExpr[][],int,int) -> setSubMatrix
    org.matheclipse.commons.math.linear.FieldMatrix getRowMatrix(int) -> getRowMatrix
    void setRowMatrix(int,org.matheclipse.commons.math.linear.FieldMatrix) -> setRowMatrix
    void setRowMatrix(int,org.matheclipse.commons.math.linear.BlockFieldMatrix) -> setRowMatrix
    org.matheclipse.commons.math.linear.FieldMatrix getColumnMatrix(int) -> getColumnMatrix
    void setColumnMatrix(int,org.matheclipse.commons.math.linear.FieldMatrix) -> setColumnMatrix
    void setColumnMatrix(int,org.matheclipse.commons.math.linear.BlockFieldMatrix) -> setColumnMatrix
    org.matheclipse.commons.math.linear.FieldVector getRowVector(int) -> getRowVector
    void setRowVector(int,org.matheclipse.commons.math.linear.FieldVector) -> setRowVector
    org.matheclipse.commons.math.linear.FieldVector getColumnVector(int) -> getColumnVector
    void setColumnVector(int,org.matheclipse.commons.math.linear.FieldVector) -> setColumnVector
    org.matheclipse.core.interfaces.IExpr[] getRow(int) -> getRow
    void setRow(int,org.matheclipse.core.interfaces.IExpr[]) -> setRow
    org.matheclipse.core.interfaces.IExpr[] getColumn(int) -> getColumn
    void setColumn(int,org.matheclipse.core.interfaces.IExpr[]) -> setColumn
    org.matheclipse.core.interfaces.IExpr getEntry(int,int) -> getEntry
    void setEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> setEntry
    void addToEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> addToEntry
    void multiplyEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> multiplyEntry
    org.matheclipse.commons.math.linear.FieldMatrix transpose() -> transpose
    int getRowDimension() -> getRowDimension
    int getColumnDimension() -> getColumnDimension
    org.matheclipse.core.interfaces.IExpr[] operate(org.matheclipse.core.interfaces.IExpr[]) -> operate
    org.matheclipse.core.interfaces.IExpr[] preMultiply(org.matheclipse.core.interfaces.IExpr[]) -> preMultiply
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInRowOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInRowOrder
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor) -> walkInOptimizedOrder
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor) -> walkInOptimizedOrder
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor,int,int,int,int) -> walkInOptimizedOrder
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor,int,int,int,int) -> walkInOptimizedOrder
    int blockHeight(int) -> a
    int blockWidth(int) -> b
org.matheclipse.commons.math.linear.FieldDecompositionSolver -> mn:
    org.matheclipse.commons.math.linear.FieldMatrix originalMatrix -> a
    org.matheclipse.core.interfaces.IExpr[][] lu -> a
    int[] pivot -> a
    boolean singular -> a
    boolean isNonSingular() -> a
    org.matheclipse.commons.math.linear.FieldMatrix getInverse() -> a
    void <init>(org.matheclipse.commons.math.linear.FieldMatrix,org.matheclipse.core.interfaces.IExpr[][],int[],boolean) -> <init>
    org.matheclipse.commons.math.linear.FieldMatrix solve(org.matheclipse.commons.math.linear.FieldMatrix) -> a
    void <init>(org.matheclipse.commons.math.linear.FieldMatrix,org.matheclipse.core.interfaces.IExpr[][],int[],boolean,byte) -> <init>
org.matheclipse.commons.math.linear.FieldLUDecomposition -> mo:
    org.matheclipse.commons.math.linear.FieldMatrix originalMatrix -> a
    org.matheclipse.core.interfaces.IExpr[][] lu -> a
    int[] pivot -> a
    boolean even -> a
    boolean singular -> b
    org.matheclipse.commons.math.linear.FieldMatrix cachedL -> b
    org.matheclipse.commons.math.linear.FieldMatrix cachedU -> c
    void <init>(org.matheclipse.commons.math.linear.FieldMatrix) -> <init>
    int[] getPivot() -> a
org.matheclipse.commons.math.linear.FieldMatrix -> mp:
    org.matheclipse.commons.math.linear.FieldMatrix createMatrix(int,int) -> createMatrix
    org.matheclipse.commons.math.linear.FieldMatrix copy() -> copy
    org.matheclipse.commons.math.linear.FieldMatrix scalarMultiply(org.matheclipse.core.interfaces.IExpr) -> scalarMultiply
    org.matheclipse.commons.math.linear.FieldMatrix multiply(org.matheclipse.commons.math.linear.FieldMatrix) -> multiply
    org.matheclipse.core.interfaces.IExpr[][] getData() -> getData
    org.matheclipse.core.interfaces.IExpr[] getRow(int) -> getRow
    void setRow(int,org.matheclipse.core.interfaces.IExpr[]) -> setRow
    org.matheclipse.core.interfaces.IExpr getEntry(int,int) -> getEntry
    void setEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> setEntry
    void multiplyEntry(int,int,org.matheclipse.core.interfaces.IExpr) -> multiplyEntry
    org.matheclipse.commons.math.linear.FieldVector operate(org.matheclipse.commons.math.linear.FieldVector) -> operate
    org.matheclipse.core.interfaces.IExpr walkInOptimizedOrder(org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor) -> walkInOptimizedOrder
org.matheclipse.commons.math.linear.FieldMatrixChangingVisitor -> mq:
    org.matheclipse.core.interfaces.IExpr zero -> a
    org.matheclipse.core.interfaces.IExpr visit(int,int,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr end() -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
org.matheclipse.commons.math.linear.FieldMatrixPreservingVisitor -> mr:
    org.matheclipse.core.interfaces.IExpr zero -> a
    void start$6046c8d5(int,int) -> a
    void visit(int,int,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr end() -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm -> ms:
    org.matheclipse.commons.math.linear.FieldMatrix originalMatrix -> b
    org.matheclipse.commons.math.linear.FieldMatrix rowReducedMatrix -> a
    org.matheclipse.commons.math.linear.FieldMatrix nullSpaceCache -> c
    int matrixRankCache -> a
    int numRows -> b
    int numCols -> c
    void <init>(org.matheclipse.commons.math.linear.FieldMatrix) -> <init>
    org.matheclipse.core.interfaces.IExpr getCoordinate(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex) -> a
    void swapRow(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex) -> a
    void multiplyAdd(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.commons.math.linear.FieldMatrix getNullSpace(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.commons.math.linear.FieldMatrix rowReduce() -> a
    int getMatrixRank() -> a
    void scaleRow(org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.commons.math.linear.FieldReducedRowEchelonForm$RowColIndex -> mt:
    int row -> a
    int col -> b
    void <init>(int,int) -> <init>
    java.lang.String toString() -> toString
org.matheclipse.commons.math.linear.FieldVector -> mu:
    org.matheclipse.commons.math.linear.FieldVector mapMultiply(org.matheclipse.core.interfaces.IExpr) -> mapMultiply
    org.matheclipse.core.interfaces.IExpr dotProduct(org.matheclipse.commons.math.linear.FieldVector) -> dotProduct
    org.matheclipse.core.interfaces.IExpr getEntry(int) -> getEntry
    int getDimension() -> getDimension
    org.matheclipse.core.interfaces.IExpr[] toArray() -> toArray
org.matheclipse.core.basic.Alloc -> org.matheclipse.core.basic.Alloc:
    void <init>() -> <init>
    double[] vector(int) -> vector
    double[][] matrix(int,int) -> matrix
org.matheclipse.core.basic.Config -> org.matheclipse.core.basic.Config:
    boolean SWING_PLOT_FRAME -> SWING_PLOT_FRAME
    long TIME_CONSTRAINED_MILLISECONDS -> TIME_CONSTRAINED_MILLISECONDS
    long FOREVER -> FOREVER
    long TIME_CONSTRAINED_SLEEP_MILLISECONDS -> TIME_CONSTRAINED_SLEEP_MILLISECONDS
    boolean DEBUG -> DEBUG
    boolean SHOW_STACKTRACE -> SHOW_STACKTRACE
    boolean SHOW_CONSOLE -> SHOW_CONSOLE
    boolean SHOW_PATTERN_EVAL_STEPS -> SHOW_PATTERN_EVAL_STEPS
    java.util.Set SHOW_PATTERN_SYMBOL_STEPS -> SHOW_PATTERN_SYMBOL_STEPS
    boolean PARSER_USE_LOWERCASE_SYMBOLS -> PARSER_USE_LOWERCASE_SYMBOLS
    boolean RUBI_CONVERT_SYMBOLS -> RUBI_CONVERT_SYMBOLS
    boolean SERIALIZE_SYMBOLS -> SERIALIZE_SYMBOLS
    boolean SERVER_MODE -> SERVER_MODE
    double DOUBLE_EPSILON -> DOUBLE_EPSILON
    double DOUBLE_TOLERANCE -> DOUBLE_TOLERANCE
    double DEFAULT_ROOTS_CHOP_DELTA -> DEFAULT_ROOTS_CHOP_DELTA
    int BIGINTEGER_MAX_SIZE -> BIGINTEGER_MAX_SIZE
    int FASTTABLE_MAX_SIZE -> FASTTABLE_MAX_SIZE
    int STRING_MAX_SIZE -> STRING_MAX_SIZE
    int INTEGER_MAX_POOL_SIZE -> INTEGER_MAX_POOL_SIZE
    int FRACTION_MAX_POOL_SIZE -> FRACTION_MAX_POOL_SIZE
    int COMPLEX_MAX_POOL_SIZE -> COMPLEX_MAX_POOL_SIZE
    int DOUBLE_MAX_POOL_SIZE -> DOUBLE_MAX_POOL_SIZE
    int DOUBLECOMPLEX_MAX_POOL_SIZE -> DOUBLECOMPLEX_MAX_POOL_SIZE
    int PATTERN_MAX_POOL_SIZE -> PATTERN_MAX_POOL_SIZE
    int STRING_MAX_POOL_SIZE -> STRING_MAX_POOL_SIZE
    int MAX_DOUBLE_VECTOR_SIZE -> MAX_DOUBLE_VECTOR_SIZE
    int MAX_DOUBLE_MATRIX_SIZE -> MAX_DOUBLE_MATRIX_SIZE
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.boole.QuineMcCluskyFormula -> org.matheclipse.core.boole.QuineMcCluskyFormula:
    java.util.List termList -> a
    java.util.List originalTermList -> b
    org.matheclipse.core.interfaces.IAST variables -> a
    void <init>(java.util.List,org.matheclipse.core.interfaces.IAST) -> <init>
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr toExpr() -> toExpr
    void reduceToPrimeImplicants() -> reduceToPrimeImplicants
    void reducePrimeImplicantsToSubset() -> reducePrimeImplicantsToSubset
    org.matheclipse.core.boole.QuineMcCluskyFormula read(java.io.Reader) -> read
    org.matheclipse.core.boole.QuineMcCluskyFormula read(java.lang.String) -> read
    org.matheclipse.core.boole.QuineMcCluskyFormula read(org.matheclipse.core.interfaces.IAST) -> read
    int extractEssentialImplicant(boolean[][]) -> a
    void extractImplicant(boolean[][],int) -> a
    int extractLargestImplicant(boolean[][]) -> b
org.matheclipse.core.boole.QuineMcCluskyTerm -> mv:
    byte[] varVals -> a
    void <init>(byte[]) -> <init>
    java.lang.String toString() -> toString
    org.matheclipse.core.boole.QuineMcCluskyTerm combine(org.matheclipse.core.boole.QuineMcCluskyTerm) -> a
    int countValues(byte) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.matheclipse.core.boole.QuineMcCluskyTerm read(java.io.Reader) -> a
    void addBytes(java.util.ArrayList,java.util.ArrayList) -> a
org.matheclipse.core.builtin.constant.Catalan -> org.matheclipse.core.builtin.constant.Catalan:
    double CATALAN -> CATALAN
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    double evalReal() -> evalReal
org.matheclipse.core.builtin.constant.ComplexInfinity -> org.matheclipse.core.builtin.constant.ComplexInfinity:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.ISymbol) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.constant.Degree -> org.matheclipse.core.builtin.constant.Degree:
    double DEGREE -> DEGREE
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.ISymbol) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    double evalReal() -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.constant.E -> org.matheclipse.core.builtin.constant.E:
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    org.matheclipse.core.interfaces.IExpr apfloatEval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> apfloatEval
    double evalReal() -> evalReal
org.matheclipse.core.builtin.constant.EulerGamma -> org.matheclipse.core.builtin.constant.EulerGamma:
    double EULER_GAMMA -> EULER_GAMMA
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    double evalReal() -> evalReal
org.matheclipse.core.builtin.constant.Glaisher -> org.matheclipse.core.builtin.constant.Glaisher:
    double GLAISHER -> GLAISHER
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    double evalReal() -> evalReal
org.matheclipse.core.builtin.constant.GoldenRatio -> org.matheclipse.core.builtin.constant.GoldenRatio:
    double GOLDEN_RATIO -> GOLDEN_RATIO
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.ISymbol) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    double evalReal() -> evalReal
org.matheclipse.core.builtin.constant.I -> org.matheclipse.core.builtin.constant.I:
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.ISymbol) -> evaluate
org.matheclipse.core.builtin.constant.Infinity -> org.matheclipse.core.builtin.constant.Infinity:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.ISymbol) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.constant.Khinchin -> org.matheclipse.core.builtin.constant.Khinchin:
    double KHINCHIN -> KHINCHIN
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    double evalReal() -> evalReal
org.matheclipse.core.builtin.constant.Pi -> org.matheclipse.core.builtin.constant.Pi:
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    org.matheclipse.core.interfaces.IExpr apfloatEval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> apfloatEval
    double evalReal() -> evalReal
org.matheclipse.core.builtin.function.And -> org.matheclipse.core.builtin.function.And:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Append -> org.matheclipse.core.builtin.function.Append:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.AppendTo -> org.matheclipse.core.builtin.function.AppendTo:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.AppendTo$AppendToFunction -> mw:
    org.matheclipse.core.interfaces.IExpr value -> a
    void <init>(org.matheclipse.core.builtin.function.AppendTo,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Apply -> org.matheclipse.core.builtin.function.Apply:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Array -> org.matheclipse.core.builtin.function.Array:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateArray(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evaluateArray
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Array$ArrayIterator -> org.matheclipse.core.builtin.function.Array$ArrayIterator:
    int fCurrent -> a
    int fFrom -> b
    int fTo -> c
    void <init>(int) -> <init>
    void <init>(int,int) -> <init>
    boolean setUp() -> setUp
    void tearDown() -> tearDown
    boolean hasNext() -> hasNext
    org.matheclipse.core.interfaces.IExpr next() -> next
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.builtin.function.ArrayQ -> org.matheclipse.core.builtin.function.ArrayQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    int determineDepth(org.matheclipse.core.interfaces.IExpr,int,com.google.common.base.Predicate) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.AtomQ -> org.matheclipse.core.builtin.function.AtomQ:
    org.matheclipse.core.builtin.function.AtomQ CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.Attributes -> org.matheclipse.core.builtin.function.Attributes:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.Blank -> org.matheclipse.core.builtin.function.Blank:
    org.matheclipse.core.builtin.function.Blank CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.Block -> org.matheclipse.core.builtin.function.Block:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Break -> org.matheclipse.core.builtin.function.Break:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Cases -> org.matheclipse.core.builtin.function.Cases:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST cases(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> cases
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Cases$CasesPatternMatcherFunctor -> mx:
    org.matheclipse.core.patternmatching.PatternMatcher matcher -> a
    org.matheclipse.core.interfaces.IAST resultCollection -> a
    int maximumResults -> a
    int resultsCounter -> b
    void <init>(org.matheclipse.core.patternmatching.PatternMatcher,org.matheclipse.core.interfaces.IAST,int) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Cases$CasesRulesFunctor -> my:
    com.google.common.base.Function function -> a
    org.matheclipse.core.interfaces.IAST resultCollection -> a
    int maximumResults -> a
    int resultsCounter -> b
    void <init>(com.google.common.base.Function,org.matheclipse.core.interfaces.IAST,int) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Cases$StopException -> org.matheclipse.core.builtin.function.Cases$StopException:
    void <init>() -> <init>
org.matheclipse.core.builtin.function.Catch -> org.matheclipse.core.builtin.function.Catch:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Chop -> org.matheclipse.core.builtin.function.Chop:
    double DEFAULT_CHOP_DELTA -> DEFAULT_CHOP_DELTA
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Clear -> org.matheclipse.core.builtin.function.Clear:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.ClearAll -> org.matheclipse.core.builtin.function.ClearAll:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Collect -> org.matheclipse.core.builtin.function.Collect:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr collectSingleVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> collectSingleVariable
    void collectToMap(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.IPatternMatcher,java.util.Map,org.matheclipse.core.interfaces.IAST) -> collectToMap
    boolean collectToMapPlus(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.IPatternMatcher,java.util.Map) -> collectToMapPlus
    void addOneIdentityPowerFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,java.util.Map) -> addOneIdentityPowerFactor
    void addPowerFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,java.util.Map) -> addPowerFactor
    boolean isPowerMatched(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.IPatternMatcher) -> isPowerMatched
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Complex -> org.matheclipse.core.builtin.function.Complex:
    org.matheclipse.core.builtin.function.Complex CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.CompoundExpression -> org.matheclipse.core.builtin.function.CompoundExpression:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Condition -> org.matheclipse.core.builtin.function.Condition:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean checkCondition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> checkCondition
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Continue -> org.matheclipse.core.builtin.function.Continue:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Count -> org.matheclipse.core.builtin.function.Count:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Count$CountFunctor -> mz:
    org.matheclipse.core.patternmatching.IPatternMatcher matcher -> a
    int counter -> a
    int getCounter() -> a
    void <init>(org.matheclipse.core.patternmatching.IPatternMatcher) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Defer -> org.matheclipse.core.builtin.function.Defer:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Definition -> org.matheclipse.core.builtin.function.Definition:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Delete -> org.matheclipse.core.builtin.function.Delete:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.DeleteCases -> org.matheclipse.core.builtin.function.DeleteCases:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST deleteCases(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.IPatternMatcher) -> deleteCases
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.DeleteCases$DeleteCasesPatternMatcherFunctor -> mA:
    org.matheclipse.core.patternmatching.IPatternMatcher matcher -> a
    void <init>(org.matheclipse.core.patternmatching.IPatternMatcher) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Depth -> org.matheclipse.core.builtin.function.Depth:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    int depth(org.matheclipse.core.interfaces.IAST,int) -> depth
org.matheclipse.core.builtin.function.DirectedInfinity -> org.matheclipse.core.builtin.function.DirectedInfinity:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    org.matheclipse.core.interfaces.IExpr timesInf(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> timesInf
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Do -> org.matheclipse.core.builtin.function.Do:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Do$DoIterator -> org.matheclipse.core.builtin.function.Do$DoIterator:
    java.util.List fIterList -> a
    int fIndex -> a
    void <init>(java.util.List) -> <init>
    org.matheclipse.core.interfaces.IExpr doIt(org.matheclipse.core.interfaces.IExpr) -> doIt
org.matheclipse.core.builtin.function.Drop -> org.matheclipse.core.builtin.function.Drop:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IAST drop(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.ISequence) -> drop
org.matheclipse.core.builtin.function.Element -> org.matheclipse.core.builtin.function.Element:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean assumeDomain(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
org.matheclipse.core.builtin.function.EvenQ -> org.matheclipse.core.builtin.function.EvenQ:
    org.matheclipse.core.builtin.function.EvenQ CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.Exponent -> org.matheclipse.core.builtin.function.Exponent:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void timesExponent(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.IPatternMatcher,java.util.Set) -> a
org.matheclipse.core.builtin.function.First -> org.matheclipse.core.builtin.function.First:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.FixedPoint -> org.matheclipse.core.builtin.function.FixedPoint:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Flatten -> org.matheclipse.core.builtin.function.Flatten:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Fold -> org.matheclipse.core.builtin.function.Fold:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateNestList(org.matheclipse.core.interfaces.IAST) -> evaluateNestList
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.FoldList -> org.matheclipse.core.builtin.function.FoldList:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateNestList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evaluateNestList
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IAST foldLeft(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int,int,org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IAST) -> foldLeft
org.matheclipse.core.builtin.function.For -> org.matheclipse.core.builtin.function.For:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.FreeQ -> org.matheclipse.core.builtin.function.FreeQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean isFreeOrderless(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> isFreeOrderless
org.matheclipse.core.builtin.function.FullForm -> org.matheclipse.core.builtin.function.FullForm:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Function -> org.matheclipse.core.builtin.function.Function:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> replaceSlots
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Head -> org.matheclipse.core.builtin.function.Head:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.Hold -> org.matheclipse.core.builtin.function.Hold:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.HoldForm -> org.matheclipse.core.builtin.function.HoldForm:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Identity -> org.matheclipse.core.builtin.function.Identity:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.If -> org.matheclipse.core.builtin.function.If:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Implies -> org.matheclipse.core.builtin.function.Implies:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Insert -> org.matheclipse.core.builtin.function.Insert:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.IntegerQ -> org.matheclipse.core.builtin.function.IntegerQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.JavaForm -> org.matheclipse.core.builtin.function.JavaForm:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.lang.String javaForm(org.matheclipse.core.interfaces.IExpr,boolean) -> javaForm
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Last -> org.matheclipse.core.builtin.function.Last:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.LeafCount -> org.matheclipse.core.builtin.function.LeafCount:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.LeafCount$LeafCountVisitor -> org.matheclipse.core.builtin.function.LeafCount$LeafCountVisitor:
    int fHeadOffset -> a
    void <init>() -> <init>
    void <init>(int) -> <init>
    long visit(org.matheclipse.core.interfaces.IFraction) -> visit
    long visit(org.matheclipse.core.interfaces.IComplex) -> visit
    long visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    long visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.builtin.function.Length -> org.matheclipse.core.builtin.function.Length:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.ListQ -> org.matheclipse.core.builtin.function.ListQ:
    org.matheclipse.core.builtin.function.ListQ CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.MatchQ -> org.matheclipse.core.builtin.function.MatchQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.MathMLForm -> org.matheclipse.core.builtin.function.MathMLForm:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.MemberQ -> org.matheclipse.core.builtin.function.MemberQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.Module -> org.matheclipse.core.builtin.function.Module:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean checkModuleCondition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> checkModuleCondition
    org.matheclipse.core.interfaces.IExpr evalModule(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.EvalEngine) -> a
    void rememberVariables(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.EvalEngine,java.lang.String,java.util.Map) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.N -> org.matheclipse.core.builtin.function.N:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Nand -> org.matheclipse.core.builtin.function.Nand:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Nest -> org.matheclipse.core.builtin.function.Nest:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateNest(org.matheclipse.core.interfaces.IAST) -> evaluateNest
    org.matheclipse.core.interfaces.IExpr nest(org.matheclipse.core.interfaces.IExpr,int,com.google.common.base.Function) -> nest
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.NestList -> org.matheclipse.core.builtin.function.NestList:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateNestList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evaluateNestList
    void nestList(org.matheclipse.core.interfaces.IExpr,int,com.google.common.base.Function,java.util.Collection) -> nestList
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.NestWhile -> org.matheclipse.core.builtin.function.NestWhile:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr nestWhile(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> nestWhile
org.matheclipse.core.builtin.function.NestWhileList -> org.matheclipse.core.builtin.function.NestWhileList:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST nestList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function,org.matheclipse.core.interfaces.IAST) -> nestList
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Nor -> org.matheclipse.core.builtin.function.Nor:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.NumberQ -> org.matheclipse.core.builtin.function.NumberQ:
    org.matheclipse.core.builtin.function.NumberQ CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.NumericQ -> org.matheclipse.core.builtin.function.NumericQ:
    void <init>() -> <init>
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.ISignedNumber getSignedNumberNumericQ(org.matheclipse.core.interfaces.IExpr) -> getSignedNumberNumericQ
    org.matheclipse.core.interfaces.INumber getNumberNumericQ(org.matheclipse.core.interfaces.IExpr) -> getNumberNumericQ
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.OddQ -> org.matheclipse.core.builtin.function.OddQ:
    org.matheclipse.core.builtin.function.OddQ CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.Or -> org.matheclipse.core.builtin.function.Or:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Package -> org.matheclipse.core.builtin.function.Package:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void evalPackage(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evalPackage
    org.matheclipse.core.interfaces.IAST convertSymbolsInList(org.matheclipse.core.interfaces.IAST,java.util.HashMap) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void loadPackage(org.matheclipse.core.eval.EvalEngine,java.io.Reader) -> loadPackage
org.matheclipse.core.builtin.function.Pattern -> org.matheclipse.core.builtin.function.Pattern:
    org.matheclipse.core.builtin.function.Pattern CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.Position -> org.matheclipse.core.builtin.function.Position:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST position(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.LevelSpec,com.google.common.base.Predicate,org.matheclipse.core.generic.interfaces.IPositionConverter,int) -> position
    org.matheclipse.core.interfaces.IAST position(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.util.LevelSpec) -> position
org.matheclipse.core.builtin.function.Prepend -> org.matheclipse.core.builtin.function.Prepend:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.PrependTo -> org.matheclipse.core.builtin.function.PrependTo:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.PrependTo$PrependToFunction -> mB:
    org.matheclipse.core.interfaces.IExpr value -> a
    void <init>(org.matheclipse.core.builtin.function.PrependTo,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.builtin.function.Print -> org.matheclipse.core.builtin.function.Print:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.Quiet -> org.matheclipse.core.builtin.function.Quiet:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Rational -> org.matheclipse.core.builtin.function.Rational:
    org.matheclipse.core.builtin.function.Rational CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.Reap -> org.matheclipse.core.builtin.function.Reap:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Refine -> org.matheclipse.core.builtin.function.Refine:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.Rest -> org.matheclipse.core.builtin.function.Rest:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.Return -> org.matheclipse.core.builtin.function.Return:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Riffle -> org.matheclipse.core.builtin.function.Riffle:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr riffleAtom(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> riffleAtom
    org.matheclipse.core.interfaces.IAST riffleAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> riffleAST
org.matheclipse.core.builtin.function.RotateLeft -> org.matheclipse.core.builtin.function.RotateLeft:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.RotateRight -> org.matheclipse.core.builtin.function.RotateRight:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.Rule -> org.matheclipse.core.builtin.function.Rule:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.RuleDelayed -> org.matheclipse.core.builtin.function.RuleDelayed:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Set -> org.matheclipse.core.builtin.function.Set:
    org.matheclipse.core.builtin.function.Set CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.lang.Object[] createPatternMatcher(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> createPatternMatcher
    java.lang.Object[] putDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> putDownRule
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.SetAttributes -> org.matheclipse.core.builtin.function.SetAttributes:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.builtin.function.SetDelayed -> org.matheclipse.core.builtin.function.SetDelayed:
    org.matheclipse.core.builtin.function.SetDelayed CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.lang.Object[] createPatternMatcher(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> createPatternMatcher
    java.lang.Object[] putDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> putDownRule
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.Sow -> org.matheclipse.core.builtin.function.Sow:
    double DEFAULT_CHOP_DELTA -> DEFAULT_CHOP_DELTA
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Switch -> org.matheclipse.core.builtin.function.Switch:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.TeXForm -> org.matheclipse.core.builtin.function.TeXForm:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Throw -> org.matheclipse.core.builtin.function.Throw:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.TimeConstrained -> org.matheclipse.core.builtin.function.TimeConstrained:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Trace -> org.matheclipse.core.builtin.function.Trace:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Unevaluated -> org.matheclipse.core.builtin.function.Unevaluated:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Unique -> org.matheclipse.core.builtin.function.Unique:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.Unset -> org.matheclipse.core.builtin.function.Unset:
    org.matheclipse.core.builtin.function.Unset CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void removePatternMatcher(org.matheclipse.core.interfaces.IExpr,boolean) -> removePatternMatcher
    void removeRule(org.matheclipse.core.interfaces.IExpr,boolean) -> removeRule
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.UpSet -> org.matheclipse.core.builtin.function.UpSet:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.lang.Object[] createPatternMatcher(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> createPatternMatcher
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.UpSetDelayed -> org.matheclipse.core.builtin.function.UpSetDelayed:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.lang.Object[] createPatternMatcher(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> createPatternMatcher
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.ValueQ -> org.matheclipse.core.builtin.function.ValueQ:
    org.matheclipse.core.builtin.function.ValueQ CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
org.matheclipse.core.builtin.function.Which -> org.matheclipse.core.builtin.function.Which:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.builtin.function.While -> org.matheclipse.core.builtin.function.While:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.convert.AST2Expr -> org.matheclipse.core.convert.AST2Expr:
    java.lang.String[] UPPERCASE_SYMBOL_STRINGS -> UPPERCASE_SYMBOL_STRINGS
    java.lang.String[] SYMBOL_STRINGS -> SYMBOL_STRINGS
    java.lang.String[] FUNCTION_STRINGS -> FUNCTION_STRINGS
    java.util.Map RUBI_STATISTICS_MAP -> RUBI_STATISTICS_MAP
    java.util.Map PREDEFINED_SYMBOLS_MAP -> PREDEFINED_SYMBOLS_MAP
    java.lang.String[] ALIASES_STRINGS -> a
    java.lang.String[] ALIASES_SUBSTITUTES -> b
    java.util.Map PREDEFINED_ALIASES_MAP -> PREDEFINED_ALIASES_MAP
    java.lang.String TIMES_STRING -> TIMES_STRING
    java.lang.String TRUE_STRING -> TRUE_STRING
    org.matheclipse.core.convert.AST2Expr CONST -> CONST
    org.matheclipse.core.convert.AST2Expr CONST_LC -> CONST_LC
    int fPrecision -> a
    boolean fLowercaseEnabled -> a
    void <init>(java.lang.Class,java.lang.Class) -> <init>
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    org.matheclipse.core.interfaces.IAST convert(org.matheclipse.core.interfaces.IAST,org.matheclipse.parser.client.ast.FunctionNode) -> convert
    org.matheclipse.core.interfaces.IExpr convert(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.core.eval.EvalEngine) -> convert
    org.matheclipse.core.interfaces.IExpr convert(org.matheclipse.parser.client.ast.ASTNode) -> convert
    org.matheclipse.core.interfaces.IExpr convertSymbol(java.lang.String) -> convertSymbol
    org.matheclipse.core.interfaces.IExpr rewriteLessGreaterAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol) -> a
    void <clinit>() -> <clinit>
org.matheclipse.core.convert.ConversionException -> org.matheclipse.core.convert.ConversionException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
org.matheclipse.core.convert.Convert -> org.matheclipse.core.convert.Convert:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr doubleToExprTranspose(double[][]) -> doubleToExprTranspose
    org.apache.commons.math3.linear.RealMatrix list2RealMatrix(org.matheclipse.core.interfaces.IAST) -> list2RealMatrix
    org.matheclipse.core.interfaces.IAST realMatrix2List(org.apache.commons.math3.linear.RealMatrix) -> realMatrix2List
    org.apache.commons.math3.linear.RealVector list2RealVector(org.matheclipse.core.interfaces.IAST) -> list2RealVector
    org.matheclipse.core.interfaces.IAST realVector2List(org.apache.commons.math3.linear.RealVector) -> realVector2List
    org.matheclipse.core.interfaces.IExpr polynomialFunction2Expr(org.apache.commons.math3.analysis.polynomials.PolynomialFunction,org.matheclipse.core.interfaces.ISymbol) -> polynomialFunction2Expr
    org.matheclipse.core.interfaces.IExpr polynomialFunction2Expr(double[],org.matheclipse.core.interfaces.ISymbol) -> polynomialFunction2Expr
    org.matheclipse.commons.math.linear.FieldMatrix list2Matrix(org.matheclipse.core.interfaces.IAST) -> list2Matrix
    org.matheclipse.commons.math.linear.FieldMatrix list2Matrix(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> list2Matrix
    org.matheclipse.commons.math.linear.FieldVector list2Vector(org.matheclipse.core.interfaces.IAST) -> list2Vector
    org.matheclipse.core.interfaces.IAST matrix2List(org.matheclipse.commons.math.linear.FieldMatrix) -> matrix2List
    org.matheclipse.core.interfaces.IAST vector2List(org.matheclipse.commons.math.linear.FieldVector) -> vector2List
org.matheclipse.core.convert.Expr2LP -> org.matheclipse.core.convert.Expr2LP:
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    java.util.List fVariables -> a
    org.matheclipse.core.convert.VariablesSet fVariablesSet -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.convert.VariablesSet) -> <init>
    org.apache.commons.math3.optim.linear.LinearConstraint expr2Constraint() -> expr2Constraint
    org.apache.commons.math3.optim.linear.LinearObjectiveFunction expr2ObjectiveFunction() -> expr2ObjectiveFunction
    org.matheclipse.core.interfaces.ISignedNumber expr2ObjectiveFunction(org.matheclipse.core.interfaces.IExpr,double[]) -> a
org.matheclipse.core.convert.Expr2Object -> org.matheclipse.core.convert.Expr2Object:
    void <init>() -> <init>
    double[] toDoubleVector(org.matheclipse.core.interfaces.IAST) -> toDoubleVector
    double[][] toDoubleMatrix(org.matheclipse.core.interfaces.IAST) -> toDoubleMatrix
    double[] toPolynomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> toPolynomial
    java.util.Map toPolynomialMap(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> toPolynomialMap
    void addCoefficient(java.util.Map,double,int) -> a
org.matheclipse.core.convert.JASConvert -> org.matheclipse.core.convert.JASConvert:
    edu.jas.structure.RingFactory fRingFactory -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    edu.jas.poly.GenPolynomialRing fBigIntegerPolyFactory -> b
    java.util.List fVariables -> a
    void <init>(org.matheclipse.core.interfaces.IExpr,edu.jas.structure.RingFactory) -> <init>
    void <init>(java.util.List,edu.jas.structure.RingFactory) -> <init>
    void <init>(java.util.List,edu.jas.structure.RingFactory,edu.jas.poly.TermOrder) -> <init>
    edu.jas.poly.GenPolynomial expr2JAS(org.matheclipse.core.interfaces.IExpr,boolean) -> expr2JAS
    edu.jas.poly.GenPolynomial numericExpr2JAS(org.matheclipse.core.interfaces.IExpr) -> numericExpr2JAS
    edu.jas.poly.GenPolynomial expr2Poly(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    edu.jas.poly.GenPolynomial fraction2Poly(org.matheclipse.core.interfaces.IFraction) -> a
    java.lang.Object[] factorTerms(edu.jas.poly.GenPolynomial) -> factorTerms
    edu.jas.poly.GenPolynomialRing getPolynomialRingFactory() -> getPolynomialRingFactory
    edu.jas.poly.GenPolynomial integerFromRationalCoefficients(edu.jas.poly.GenPolynomial) -> integerFromRationalCoefficients
    org.matheclipse.core.interfaces.IExpr integerPoly2Expr(edu.jas.poly.GenPolynomial) -> integerPoly2Expr
    org.matheclipse.core.interfaces.IExpr complexPoly2Expr(edu.jas.poly.GenPolynomial) -> complexPoly2Expr
    org.matheclipse.core.interfaces.IAST integral2Expr(edu.jas.integrate.Integral) -> integral2Expr
    org.matheclipse.core.interfaces.IAST logIntegral2Expr(edu.jas.integrate.LogIntegral) -> logIntegral2Expr
    org.matheclipse.core.interfaces.IAST poly2Expr(edu.jas.poly.GenPolynomial) -> poly2Expr
    org.matheclipse.core.interfaces.IAST poly2Expr(edu.jas.poly.GenPolynomial,org.matheclipse.core.interfaces.IExpr) -> poly2Expr
    org.matheclipse.core.interfaces.IExpr exprPoly2Expr(edu.jas.poly.GenPolynomial,org.matheclipse.core.interfaces.IExpr) -> exprPoly2Expr
    org.matheclipse.core.interfaces.IAST polyAlgebraicNumber2Expr(edu.jas.poly.GenPolynomial) -> polyAlgebraicNumber2Expr
    org.matheclipse.core.interfaces.IAST algebraicNumber2Expr(edu.jas.poly.AlgebraicNumber,org.matheclipse.core.interfaces.IExpr) -> algebraicNumber2Expr
    org.matheclipse.core.interfaces.IAST quotIntegral2Expr(edu.jas.integrate.QuotIntegral) -> quotIntegral2Expr
    org.matheclipse.core.interfaces.IAST rationalPoly2Expr(edu.jas.poly.GenPolynomial) -> rationalPoly2Expr
    edu.jas.arith.ModIntegerRing option2ModIntegerRing(org.matheclipse.core.interfaces.ISignedNumber) -> option2ModIntegerRing
    org.matheclipse.core.interfaces.IComplex jas2Complex(edu.jas.poly.Complex) -> jas2Complex
    org.matheclipse.core.interfaces.INumber jas2Numeric(edu.jas.poly.Complex,double) -> jas2Numeric
    org.matheclipse.core.interfaces.INumber jas2Numeric(org.apache.commons.math3.complex.Complex,double) -> jas2Numeric
    java.lang.Object[] rationalFromRationalCoefficientsFactor(edu.jas.poly.GenPolynomialRing,edu.jas.poly.GenPolynomial) -> rationalFromRationalCoefficientsFactor
org.matheclipse.core.convert.JASConvert$RatToRatFactor -> mC:
    java.math.BigInteger lcm -> a
    java.math.BigInteger gcd -> b
    void <init>(java.math.BigInteger,java.math.BigInteger) -> <init>
    edu.jas.structure.Element eval(edu.jas.structure.Element) -> a
org.matheclipse.core.convert.JASIExpr -> org.matheclipse.core.convert.JASIExpr:
    edu.jas.structure.RingFactory fRingFactory -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    edu.jas.poly.GenPolynomialRing fBigIntegerPolyFactory -> b
    java.util.List fVariables -> a
    boolean fNumericFunction -> a
    void <init>(org.matheclipse.core.interfaces.IExpr,boolean) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,edu.jas.structure.RingFactory) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,edu.jas.structure.RingFactory,boolean) -> <init>
    void <init>(java.util.List) -> <init>
    void <init>(java.util.List,boolean) -> <init>
    void <init>(java.util.List,edu.jas.structure.RingFactory) -> <init>
    void <init>(java.util.List,edu.jas.structure.RingFactory,edu.jas.poly.TermOrder,boolean) -> <init>
    org.matheclipse.core.interfaces.IExpr complexPoly2Expr(edu.jas.poly.GenPolynomial) -> complexPoly2Expr
    edu.jas.poly.GenPolynomial expr2IExprJAS(org.matheclipse.core.interfaces.IExpr) -> expr2IExprJAS
    edu.jas.poly.GenPolynomial expr2IExprJAS(org.matheclipse.core.polynomials.ExprPolynomial) -> expr2IExprJAS
    edu.jas.poly.GenPolynomial expr2IExprPoly(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr exprPoly2Expr(edu.jas.poly.GenPolynomial) -> exprPoly2Expr
    org.matheclipse.core.interfaces.IExpr exprPoly2Expr(edu.jas.poly.GenPolynomial,org.matheclipse.core.interfaces.IExpr) -> exprPoly2Expr
    java.lang.Object[] factorTerms(edu.jas.poly.GenPolynomial) -> factorTerms
    edu.jas.poly.GenPolynomialRing getPolynomialRingFactory() -> getPolynomialRingFactory
    edu.jas.poly.GenPolynomial integerFromRationalCoefficients(edu.jas.poly.GenPolynomial) -> integerFromRationalCoefficients
    org.matheclipse.core.interfaces.IExpr integerPoly2Expr(edu.jas.poly.GenPolynomial) -> integerPoly2Expr
org.matheclipse.core.convert.JASModInteger -> org.matheclipse.core.convert.JASModInteger:
    edu.jas.arith.ModLongRing fRingFactory -> a
    edu.jas.poly.TermOrder fTermOrder -> a
    edu.jas.poly.GenPolynomialRing fPolyFactory -> a
    java.util.List fVariables -> a
    void <init>(org.matheclipse.core.interfaces.IExpr,edu.jas.arith.ModLongRing) -> <init>
    void <init>(java.util.List,edu.jas.arith.ModLongRing) -> <init>
    void <init>(java.util.List,edu.jas.arith.ModLongRing,edu.jas.poly.TermOrder) -> <init>
    edu.jas.poly.GenPolynomial expr2JAS(org.matheclipse.core.interfaces.IExpr) -> expr2JAS
    edu.jas.poly.GenPolynomial numericExpr2JAS(org.matheclipse.core.interfaces.IExpr) -> numericExpr2JAS
    edu.jas.poly.GenPolynomial expr2IExprJAS(org.matheclipse.core.interfaces.IExpr) -> expr2IExprJAS
    edu.jas.poly.GenPolynomial expr2Poly(org.matheclipse.core.interfaces.IExpr,boolean) -> a
    edu.jas.poly.GenPolynomial expr2IExprPoly(org.matheclipse.core.interfaces.IExpr) -> a
    edu.jas.poly.GenPolynomialRing getPolynomialRingFactory() -> getPolynomialRingFactory
    org.matheclipse.core.interfaces.IExpr modLongPoly2Expr(edu.jas.poly.GenPolynomial) -> modLongPoly2Expr
    edu.jas.arith.ModLongRing option2ModLongRing(org.matheclipse.core.interfaces.ISignedNumber) -> option2ModLongRing
org.matheclipse.core.convert.Lists -> org.matheclipse.core.convert.Lists:
    void <init>() -> <init>
    int sizeOf(java.lang.Object[]) -> sizeOf
    org.matheclipse.core.interfaces.IAST asAST(boolean[]) -> asAST
    org.matheclipse.core.interfaces.IAST asList(double[]) -> asList
    org.matheclipse.core.interfaces.IAST asList(float[]) -> asList
    org.matheclipse.core.interfaces.IAST asList(java.lang.String[]) -> asList
    org.matheclipse.core.interfaces.IAST asListSymbols(java.lang.String[]) -> asListSymbols
    org.matheclipse.core.interfaces.IAST asList(short[]) -> asList
    org.matheclipse.core.interfaces.IAST asList(int[]) -> asList
    org.matheclipse.core.interfaces.IAST asList(long[]) -> asList
    org.matheclipse.core.interfaces.IAST asList(java.lang.Object[]) -> asList
org.matheclipse.core.convert.Object2Expr -> org.matheclipse.core.convert.Object2Expr:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr convert(java.lang.Object) -> convert
    org.matheclipse.core.interfaces.IAST convertComplex(org.apache.commons.math3.complex.Complex[]) -> convertComplex
org.matheclipse.core.convert.VariablesSet -> org.matheclipse.core.convert.VariablesSet:
    java.util.Set fVariablesSet -> a
    com.google.common.base.Predicate isFree(org.matheclipse.core.convert.VariablesSet) -> isFree
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    boolean add(org.matheclipse.core.interfaces.ISymbol) -> add
    void addVarList(org.matheclipse.core.interfaces.IExpr) -> addVarList
    java.util.List appendToList(java.util.List) -> appendToList
    boolean contains(org.matheclipse.core.interfaces.ISymbol) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    java.util.List getArrayList() -> getArrayList
    org.matheclipse.core.interfaces.IAST getVarList() -> getVarList
    java.lang.String[] getVarListAsString() -> getVarListAsString
    boolean isEmpty() -> isEmpty
    boolean isSize(int) -> isSize
    int size() -> size
    org.matheclipse.core.interfaces.IExpr[] toArray(org.matheclipse.core.interfaces.IExpr[]) -> toArray
    java.util.Set access$000(org.matheclipse.core.convert.VariablesSet) -> a
org.matheclipse.core.convert.VariablesSet$1 -> mD:
    org.matheclipse.core.convert.VariablesSet$IsMemberVisitor visitor -> a
    org.matheclipse.core.convert.VariablesSet val$exprVar -> a
    void <init>(org.matheclipse.core.convert.VariablesSet) -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.convert.VariablesSet$IsMemberVisitor -> org.matheclipse.core.convert.VariablesSet$IsMemberVisitor:
    org.matheclipse.core.convert.VariablesSet this$0 -> a
    void <init>(org.matheclipse.core.convert.VariablesSet) -> <init>
    boolean visit(org.matheclipse.core.interfaces.IAST) -> visit
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> visit
org.matheclipse.core.convert.VariablesSet$VariablesVisitor -> org.matheclipse.core.convert.VariablesSet$VariablesVisitor:
    void <init>(java.util.Collection) -> <init>
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> visit
org.matheclipse.core.eval.Console -> org.matheclipse.core.eval.Console:
    org.matheclipse.core.eval.ExprEvaluator fEvaluator -> a
    java.io.File fFile -> a
    java.lang.String fDefaultSystemRulesFilename -> a
    int COUNTER -> a
    void main(java.lang.String[]) -> main
    void printUsage() -> a
    void <init>() -> <init>
    java.lang.String interpreter(java.lang.String) -> interpreter
    void printException(java.io.Writer,java.lang.Throwable) -> a
    void printPrompt(java.io.PrintStream,java.lang.String) -> printPrompt
    java.lang.String readString(java.io.PrintStream) -> readString
    java.lang.String readString(java.io.PrintStream,java.lang.String) -> readString
    void setFile(java.io.File) -> setFile
    java.io.File getFile() -> getFile
    java.lang.String getDefaultSystemRulesFilename() -> getDefaultSystemRulesFilename
    void <clinit>() -> <clinit>
org.matheclipse.core.eval.CoreCallbackFunction -> org.matheclipse.core.eval.CoreCallbackFunction:
    org.matheclipse.core.eval.CoreCallbackFunction CONST -> CONST
    void <init>() -> <init>
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode,double[]) -> evaluate
    void <clinit>() -> <clinit>
org.matheclipse.core.eval.EvalAttributes -> org.matheclipse.core.eval.EvalAttributes:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST flatten(org.matheclipse.core.interfaces.IAST) -> flatten
    boolean flatten(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> flatten
    boolean flatten(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,int) -> flatten
    void sort(org.matheclipse.core.interfaces.IAST) -> sort
    void sort(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.ExprComparator) -> sort
    org.matheclipse.core.interfaces.IAST threadList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int) -> threadList
org.matheclipse.core.eval.EvalComplex -> org.matheclipse.core.eval.EvalComplex:
    void <init>() -> <init>
    double[] eval(org.matheclipse.core.eval.util.DoubleStack,int,org.matheclipse.core.interfaces.IExpr) -> eval
    double[] evalAST(org.matheclipse.core.eval.util.DoubleStack,int,org.matheclipse.core.interfaces.IAST) -> evalAST
    double[] evalSymbol(org.matheclipse.core.interfaces.ISymbol) -> evalSymbol
org.matheclipse.core.eval.EvalDouble -> org.matheclipse.core.eval.EvalDouble:
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    void <init>(org.matheclipse.parser.client.ast.ASTNode,boolean) -> <init>
    double eval(double[],int,org.matheclipse.core.interfaces.IExpr) -> eval
    double evalAST(double[],int,org.matheclipse.core.interfaces.IAST) -> evalAST
    double evalSymbol(org.matheclipse.core.interfaces.ISymbol) -> evalSymbol
    void <clinit>() -> <clinit>
org.matheclipse.core.eval.EvalEngine -> org.matheclipse.core.eval.EvalEngine:
    long serialVersionUID -> serialVersionUID
    java.util.Map fUserVariableMap -> fUserVariableMap
    java.util.IdentityHashMap fLocalVariableStackMap -> a
    boolean fStopRequested -> fStopRequested
    int fRecursionCounter -> fRecursionCounter
    boolean fNumericMode -> fNumericMode
    int fNumericPrecision -> fNumericPrecision
    boolean fEvalLHSMode -> fEvalLHSMode
    java.lang.String fSessionID -> fSessionID
    boolean fTraceMode -> fTraceMode
    org.matheclipse.core.eval.util.IAssumptions fAssumptions -> fAssumptions
    org.matheclipse.core.interfaces.IEvalStepListener fTraceStack -> fTraceStack
    java.io.PrintStream fOutPrintStream -> fOutPrintStream
    int fRecursionLimit -> fRecursionLimit
    int fIterationLimit -> fIterationLimit
    int fAnonymousCounter -> fAnonymousCounter
    boolean fPackageMode -> fPackageMode
    int fModuleCounter -> fModuleCounter
    boolean fRelaxedSyntax -> fRelaxedSyntax
    org.matheclipse.core.interfaces.IAST reapList -> reapList
    java.util.Set fModifiedVariablesList -> fModifiedVariablesList
    org.matheclipse.core.eval.LastCalculationsHistory fOutList -> fOutList
    org.matheclipse.core.interfaces.IExpr fAnswer -> fAnswer
    boolean fOutListDisabled -> a
    boolean fQuietMode -> fQuietMode
    int DOUBLE_PRECISION -> DOUBLE_PRECISION
    boolean DEBUG -> DEBUG
    java.lang.ThreadLocal instance -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr evalBlock(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> evalBlock
    org.matheclipse.core.interfaces.IExpr evalQuiet(org.matheclipse.core.interfaces.IExpr) -> evalQuiet
    org.matheclipse.core.interfaces.IExpr evalQuietNull(org.matheclipse.core.interfaces.IExpr) -> evalQuietNull
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.IExpr) -> evalNull
    int getNextAnonymousCounter() -> getNextAnonymousCounter
    java.lang.String getNextCounter() -> getNextCounter
    java.util.Stack localStack(org.matheclipse.core.interfaces.ISymbol) -> localStack
    java.util.Stack localStackCreate(org.matheclipse.core.interfaces.ISymbol) -> localStackCreate
    void set(org.matheclipse.core.eval.EvalEngine) -> set
    org.matheclipse.core.interfaces.IAST threadASTListArgs(org.matheclipse.core.interfaces.IAST) -> threadASTListArgs
    org.matheclipse.core.eval.EvalEngine get() -> get
    void remove() -> remove
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    void <init>(boolean,boolean) -> <init>
    void <init>(java.lang.String,int,int,java.io.PrintStream,boolean,boolean) -> <init>
    void <init>(java.lang.String,int,java.io.PrintStream,boolean,boolean) -> <init>
    void <init>(java.lang.String,java.io.PrintStream) -> <init>
    boolean addModifiedVariable(org.matheclipse.core.interfaces.ISymbol) -> addModifiedVariable
    void addOut(org.matheclipse.core.interfaces.IExpr) -> addOut
    void addRules(org.matheclipse.core.interfaces.IAST) -> addRules
    void setStepListener(org.matheclipse.core.interfaces.IEvalStepListener) -> setStepListener
    org.matheclipse.core.interfaces.IAST endTrace() -> a
    org.matheclipse.core.interfaces.IAST evalArgs(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr evalAST(org.matheclipse.core.interfaces.IAST) -> evalAST
    org.matheclipse.core.interfaces.IExpr evalRules(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST) -> evalRules
    org.matheclipse.core.interfaces.IExpr evalASTAttributes(org.matheclipse.core.interfaces.IAST) -> evalASTAttributes
    org.matheclipse.core.interfaces.IExpr evalAttributes(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST) -> evalAttributes
    org.matheclipse.core.interfaces.IExpr evalASTBuiltinFunction(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr evalLoop(org.matheclipse.core.interfaces.IExpr) -> evalLoop
    org.matheclipse.core.interfaces.IExpr evalSetAttributes(org.matheclipse.core.interfaces.IAST) -> evalSetAttributes
    org.matheclipse.core.interfaces.IExpr evalSetAttributes(org.matheclipse.core.interfaces.IAST,boolean) -> evalSetAttributes
    org.matheclipse.core.interfaces.IExpr evalSetAttributesRecursive(org.matheclipse.core.interfaces.IAST,boolean,boolean,int) -> a
    org.matheclipse.core.interfaces.IAST evalSetAttributeArg(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,boolean,int) -> a
    org.matheclipse.core.interfaces.IExpr evalSetOrderless(org.matheclipse.core.interfaces.IAST,int,boolean,int) -> a
    org.matheclipse.core.interfaces.IAST evalFlatOrderlessAttributesRecursive(org.matheclipse.core.interfaces.IAST) -> evalFlatOrderlessAttributesRecursive
    org.matheclipse.core.interfaces.IAST evalTrace(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> evalTrace
    boolean evalTrue(org.matheclipse.core.interfaces.IExpr) -> evalTrue
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr) -> evaluate
    org.matheclipse.core.interfaces.IExpr evalPattern(org.matheclipse.core.interfaces.IExpr) -> evalPattern
    org.matheclipse.core.patternmatching.IPatternMatcher evalPatternMatcher(org.matheclipse.core.interfaces.IExpr) -> evalPatternMatcher
    org.matheclipse.core.interfaces.IExpr evaluate(java.lang.String) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateNull(org.matheclipse.core.interfaces.IExpr) -> evaluateNull
    org.matheclipse.core.interfaces.IExpr evalWithoutNumericReset(org.matheclipse.core.interfaces.IExpr) -> evalWithoutNumericReset
    org.matheclipse.core.interfaces.IAST flattenSequences(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr getAnswer() -> getAnswer
    org.matheclipse.core.eval.util.IAssumptions getAssumptions() -> getAssumptions
    int getIterationLimit() -> getIterationLimit
    java.util.Map getLocalVariableStackMap() -> getLocalVariableStackMap
    java.util.Set getModifiedVariables() -> getModifiedVariables
    org.matheclipse.core.eval.LastCalculationsHistory getOutList() -> getOutList
    java.io.PrintStream getOutPrintStream() -> getOutPrintStream
    org.matheclipse.core.interfaces.IAST getReapList() -> getReapList
    int getRecursionLimit() -> getRecursionLimit
    int getRecursionCounter() -> getRecursionCounter
    java.lang.String getSessionID() -> getSessionID
    org.matheclipse.core.interfaces.IEvalStepListener getStepListener() -> getStepListener
    org.matheclipse.core.interfaces.ISymbol getUserVariable(java.lang.String) -> getUserVariable
    org.matheclipse.core.interfaces.ISymbol putUserVariable(java.lang.String,org.matheclipse.core.interfaces.ISymbol) -> putUserVariable
    void removeUserVariables(java.util.Map) -> removeUserVariables
    int incModuleCounter() -> incModuleCounter
    void init() -> init
    boolean isEvalLHSMode() -> isEvalLHSMode
    boolean isNumericMode() -> isNumericMode
    boolean isOutListDisabled() -> isOutListDisabled
    boolean isPackageMode() -> isPackageMode
    boolean isQuietMode() -> isQuietMode
    boolean isRelaxedSyntax() -> isRelaxedSyntax
    boolean isStopRequested() -> isStopRequested
    boolean isTraceMode() -> isTraceMode
    org.matheclipse.core.interfaces.IExpr parse(java.lang.String) -> parse
    org.matheclipse.parser.client.ast.ASTNode parseNode(java.lang.String) -> parseNode
    void reset() -> reset
    void setAssumptions(org.matheclipse.core.eval.util.IAssumptions) -> setAssumptions
    void setIterationLimit(int) -> setIterationLimit
    void setNumericMode(boolean) -> setNumericMode
    void setNumericMode(boolean,int) -> setNumericMode
    int getNumericPrecision() -> getNumericPrecision
    boolean isApfloat() -> isApfloat
    boolean isApfloat(int) -> isApfloat
    void setNumericPrecision(int) -> setNumericPrecision
    void setOutListDisabled(boolean,int) -> setOutListDisabled
    void setOutPrintStream(java.io.PrintStream) -> setOutPrintStream
    void setPackageMode(boolean) -> setPackageMode
    void setQuietMode(boolean) -> setQuietMode
    void setReapList(org.matheclipse.core.interfaces.IAST) -> setReapList
    void setRecursionLimit(int) -> setRecursionLimit
    void setRelaxedSyntax(boolean) -> setRelaxedSyntax
    void setSessionID(java.lang.String) -> setSessionID
    void setStopRequested(boolean) -> setStopRequested
    void setTraceMode(boolean) -> setTraceMode
    int sizeOut() -> sizeOut
    void stopRequest() -> stopRequest
    java.lang.String toString() -> toString
    void printMessage(java.lang.String) -> printMessage
    void <clinit>() -> <clinit>
org.matheclipse.core.eval.EvalEngine$1 -> mE:
    int fID -> a
    void <init>() -> <init>
    java.lang.Object initialValue() -> initialValue
org.matheclipse.core.eval.EvalUtilities -> org.matheclipse.core.eval.EvalUtilities:
    void <init>() -> <init>
    void <init>(boolean,boolean) -> <init>
    void <init>(org.matheclipse.core.eval.EvalEngine,boolean,boolean) -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(java.lang.String) -> evaluate
    org.matheclipse.core.interfaces.IExpr eval(java.lang.String,org.matheclipse.core.eval.EvalEngine) -> eval
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr) -> evaluate
    java.lang.String toJavaForm(java.lang.String) -> toJavaForm
    org.matheclipse.core.interfaces.IAST evalTrace(java.lang.String,com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> evalTrace
    org.matheclipse.core.interfaces.IAST evalTrace(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> evalTrace
    void toMathML(java.lang.String,java.io.Writer) -> toMathML
org.matheclipse.core.eval.ExprEvaluator -> org.matheclipse.core.eval.ExprEvaluator:
    java.util.Map fVariableMap -> a
    java.util.List fVariables -> a
    org.matheclipse.core.eval.EvalEngine engine -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    void <init>() -> <init>
    void <init>(boolean,int) -> <init>
    void clearVariables() -> clearVariables
    org.matheclipse.core.interfaces.ISymbol defineVariable(org.matheclipse.core.interfaces.ISymbol) -> defineVariable
    org.matheclipse.core.interfaces.ISymbol defineVariable(org.matheclipse.core.interfaces.ISymbol,double) -> defineVariable
    org.matheclipse.core.interfaces.ISymbol defineVariable(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> defineVariable
    org.matheclipse.core.interfaces.ISymbol defineVariable(java.lang.String) -> defineVariable
    void defineVariable(java.lang.String,boolean) -> defineVariable
    org.matheclipse.core.interfaces.ISymbol defineVariable(java.lang.String,double) -> defineVariable
    org.matheclipse.core.interfaces.ISymbol defineVariable(java.lang.String,org.matheclipse.core.interfaces.IExpr) -> defineVariable
    org.matheclipse.core.interfaces.IExpr evaluate() -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(java.lang.String) -> evaluate
    org.matheclipse.core.eval.EvalEngine getEvalEngine() -> getEvalEngine
    org.matheclipse.core.interfaces.IExpr getVariable(java.lang.String) -> getVariable
    java.lang.String toJavaForm(java.lang.String) -> toJavaForm
org.matheclipse.core.eval.LastCalculationsHistory -> org.matheclipse.core.eval.LastCalculationsHistory:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr[] fOutHistory -> fOutHistory
    int fMaximumCapacity -> fMaximumCapacity
    int fIndex -> fIndex
    int fAllEntriesCounter -> fAllEntriesCounter
    void <init>(int) -> <init>
    void add(org.matheclipse.core.interfaces.IExpr) -> add
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    int size() -> size
org.matheclipse.core.eval.MathMLContentUtilities -> org.matheclipse.core.eval.MathMLContentUtilities:
    org.matheclipse.core.eval.EvalEngine fEvalEngine -> fEvalEngine
    org.matheclipse.core.form.mathml.MathMLContentFormFactory fMathMLFactory -> fMathMLFactory
    org.matheclipse.parser.client.Parser fParser -> a
    void <init>(org.matheclipse.core.eval.EvalEngine,boolean) -> <init>
    void toMathML(java.lang.String,java.io.Writer) -> toMathML
    void toMathML(org.matheclipse.core.interfaces.IExpr,java.io.Writer) -> toMathML
    void startRequest() -> startRequest
    void stopRequest() -> stopRequest
org.matheclipse.core.eval.MathMLUtilities -> org.matheclipse.core.eval.MathMLUtilities:
    org.matheclipse.core.eval.EvalEngine fEvalEngine -> fEvalEngine
    org.matheclipse.core.form.mathml.MathMLFormFactory fMathMLFactory -> fMathMLFactory
    boolean fMSIE -> a
    boolean fMathMLHeader -> b
    void <init>(org.matheclipse.core.eval.EvalEngine,boolean,boolean) -> <init>
    org.matheclipse.core.eval.EvalEngine getEvalEngine() -> getEvalEngine
    void toMathML(java.lang.String,java.io.Writer) -> toMathML
    void toMathML(org.matheclipse.core.interfaces.IExpr,java.io.Writer) -> toMathML
    void toJava(java.lang.String,java.io.Writer,boolean) -> toJava
    void startRequest() -> startRequest
    void stopRequest() -> stopRequest
    void <clinit>() -> <clinit>
org.matheclipse.core.eval.MathUtils -> org.matheclipse.core.eval.MathUtils:
    java.lang.Double[][] rom -> rom
    void <init>() -> <init>
    double romberg(int,int) -> a
    double arcLength(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> arcLength
    double integrate(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> integrate
    double integrate(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> integrate
    double integrate(java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> integrate
    double getFunctionVal(java.lang.String,double) -> getFunctionVal
    double getFunctionVal(java.lang.String,java.lang.String,java.lang.String) -> getFunctionVal
    java.lang.String getFunctionVal(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[]) -> getFunctionVal
    boolean isValid(java.lang.String,java.lang.String[]) -> isValid
    boolean[] isValid(java.lang.String[],java.lang.String[]) -> isValid
    java.lang.String getDerivative(java.lang.String,java.lang.String[],java.lang.String) -> getDerivative
    java.lang.String getPowerSeries(java.lang.String,java.lang.String,java.lang.String,int) -> getPowerSeries
    java.lang.String tangentLine(java.lang.String,java.lang.String,java.lang.String) -> tangentLine
    double surfaceArea(java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> surfaceArea
    java.lang.String evaluate(java.lang.String,java.lang.String) -> evaluate
    java.lang.String evaluate(java.lang.String,org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr parse(java.lang.String,org.matheclipse.core.interfaces.IAST) -> parse
org.matheclipse.core.eval.Namespace -> org.matheclipse.core.eval.Namespace:
    java.util.ArrayList fNamespaces -> a
    java.util.ArrayList fNamespacesString -> b
    java.util.Map fPackageNamespaceMap -> a
    char[] NO_CHAR -> NO_CHAR
    void <init>() -> <init>
    boolean add(java.lang.String) -> add
    boolean add(org.matheclipse.core.eval.Namespace) -> add
    void setEvaluator(org.matheclipse.core.interfaces.ISymbol) -> setEvaluator
    void setEquals(org.matheclipse.core.expression.Symbol) -> setEquals
    void <clinit>() -> <clinit>
org.matheclipse.core.eval.PlusOp -> org.matheclipse.core.eval.PlusOp:
    java.util.Map plusMap -> a
    boolean evaled -> a
    org.matheclipse.core.interfaces.IExpr numberValue -> a
    void <init>(int) -> <init>
    boolean addMerge(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr getSum() -> getSum
    org.matheclipse.core.interfaces.IExpr infinityPlus(org.matheclipse.core.interfaces.IExpr) -> a
    boolean isEvaled() -> isEvaled
    org.matheclipse.core.interfaces.IExpr negativeInfinityPlus(org.matheclipse.core.interfaces.IExpr) -> b
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr plusUntilPosition(org.matheclipse.core.interfaces.IAST,int) -> plusUntilPosition
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IAST) -> plus
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> plus
org.matheclipse.core.eval.PowerOp -> org.matheclipse.core.eval.PowerOp:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr power(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> power
org.matheclipse.core.eval.Range -> org.matheclipse.core.eval.Range:
    org.matheclipse.core.interfaces.IAST fList -> a
    int fStart -> a
    int fEnd -> b
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,int,int) -> <init>
    boolean all(com.google.common.base.Predicate) -> all
    boolean all(com.google.common.base.Predicate[]) -> all
    boolean any(com.google.common.base.Predicate) -> any
    boolean any(com.google.common.base.Predicate[]) -> any
    boolean compareAdjacent(org.matheclipse.core.generic.interfaces.BiPredicate) -> compareAdjacent
    java.util.Collection complement(java.util.Collection,org.matheclipse.core.eval.Range) -> complement
    boolean contains(org.matheclipse.core.interfaces.IExpr) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    int count(java.lang.Object) -> count
    int countIf(com.google.common.base.Predicate) -> countIf
    java.util.Collection difference(java.util.Collection,org.matheclipse.core.eval.Range) -> difference
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,java.util.Collection,com.google.common.base.Predicate) -> filter
    java.util.Collection filter(java.util.Collection,java.util.Collection,com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate,int) -> filter
    int findAdjacent(java.lang.Object) -> findAdjacent
    int findAdjacent(java.lang.Object,int) -> findAdjacent
    int findAdjacent(com.google.common.base.Predicate) -> findAdjacent
    org.matheclipse.core.interfaces.IExpr foldLeft(org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IExpr) -> foldLeft
    org.matheclipse.core.interfaces.IExpr foldRight(org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IExpr) -> foldRight
    org.matheclipse.core.interfaces.IExpr forEach(com.google.common.base.Function) -> forEach
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    int getEnd() -> getEnd
    org.matheclipse.core.interfaces.IAST getList() -> getList
    int getStart() -> getStart
    int indexOf(org.matheclipse.core.interfaces.IExpr) -> indexOf
    int indexOf(org.matheclipse.core.interfaces.IExpr,int) -> indexOf
    int indexOf(com.google.common.base.Predicate) -> indexOf
    int indexOf(com.google.common.base.Predicate,int) -> indexOf
    java.util.Collection intersection(java.util.Collection,org.matheclipse.core.eval.Range) -> intersection
    java.util.Iterator iterator() -> iterator
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    int lastIndexOf(com.google.common.base.Predicate) -> lastIndexOf
    boolean map(java.util.Collection,org.matheclipse.core.generic.interfaces.BiFunction) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.interfaces.IUnaryIndexFunction) -> map
    org.matheclipse.core.interfaces.IAST mapLeft(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IExpr) -> mapLeft
    java.util.Collection mapRight(java.util.Collection,org.matheclipse.core.generic.interfaces.BiFunction,org.matheclipse.core.interfaces.IExpr) -> mapRight
    org.matheclipse.core.interfaces.IExpr max(java.util.Comparator) -> max
    org.matheclipse.core.interfaces.IExpr min(java.util.Comparator) -> min
    java.util.Collection removeAll(java.util.Collection,com.google.common.base.Predicate) -> removeAll
    java.util.Collection replaceAll(java.util.Collection,com.google.common.base.Function) -> replaceAll
    java.util.Collection reverse(java.util.Collection) -> reverse
    java.util.Collection rotateLeft(java.util.Collection,int) -> rotateLeft
    java.util.Collection rotateRight(java.util.Collection,int) -> rotateRight
    int size() -> size
    org.matheclipse.core.interfaces.IAST sort(org.matheclipse.core.generic.ExprComparator) -> sort
    org.matheclipse.core.interfaces.IExpr[] toArray(org.matheclipse.core.interfaces.IExpr[]) -> toArray
    java.util.List toList(java.util.List) -> toList
    java.util.Collection union(java.util.Collection,org.matheclipse.core.eval.Range) -> union
org.matheclipse.core.eval.Range$RangeIterator -> mF:
    int fCurrrent -> a
    org.matheclipse.core.eval.Range fRange -> a
    void <init>(org.matheclipse.core.eval.Range,org.matheclipse.core.eval.Range) -> <init>
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.eval.SymjaInterpreter -> org.matheclipse.core.eval.SymjaInterpreter:
    java.lang.String codeString -> a
    java.io.PrintStream outStream -> a
    void <init>(java.lang.String,java.io.OutputStream) -> <init>
    java.lang.String interpreter(java.lang.String) -> interpreter
    java.lang.String interpreter(org.matheclipse.core.interfaces.IAST) -> interpreter
    void printException(java.lang.Appendable,java.lang.Throwable) -> a
    void eval(java.lang.String) -> eval
    void eval(org.matheclipse.core.interfaces.IAST) -> eval
org.matheclipse.core.eval.SystemNamespace -> org.matheclipse.core.eval.SystemNamespace:
    org.matheclipse.core.eval.Namespace DEFAULT -> DEFAULT
    java.lang.String DEFAULT_PACKAGE -> DEFAULT_PACKAGE
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.eval.TeXUtilities -> org.matheclipse.core.eval.TeXUtilities:
    org.matheclipse.core.eval.EvalEngine fEvalEngine -> fEvalEngine
    org.matheclipse.core.form.tex.TeXFormFactory fTeXFactory -> fTeXFactory
    org.matheclipse.parser.client.Parser fParser -> a
    void <init>(org.matheclipse.core.eval.EvalEngine,boolean) -> <init>
    void toTeX(java.lang.String,java.io.Writer) -> toTeX
    void toTeX(org.matheclipse.core.interfaces.IExpr,java.io.Writer) -> toTeX
    void stopRequest() -> stopRequest
org.matheclipse.core.eval.TimeConstrainedEvaluator -> org.matheclipse.core.eval.TimeConstrainedEvaluator:
    org.matheclipse.core.interfaces.IExpr fEvaluationResult -> fEvaluationResult
    java.lang.Throwable fException -> fException
    org.matheclipse.core.interfaces.IExpr fParsedExpression -> fParsedExpression
    long fMilliSeconds -> a
    boolean fRelaxedSyntax -> a
    boolean fTraceEvaluation -> b
    void <init>(org.matheclipse.core.eval.EvalEngine,boolean,long) -> <init>
    void <init>(org.matheclipse.core.eval.EvalEngine,boolean,long,boolean) -> <init>
    void run() -> run
    org.matheclipse.core.interfaces.IExpr constrainedEval(java.io.Writer,java.lang.String,boolean) -> constrainedEval
    org.matheclipse.core.interfaces.IExpr constrainedEval(java.io.Writer,org.matheclipse.core.interfaces.IExpr) -> constrainedEval
    org.matheclipse.core.interfaces.IExpr getParsedExpression() -> getParsedExpression
org.matheclipse.core.eval.TimesOp -> org.matheclipse.core.eval.TimesOp:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IAST) -> times
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.IExpr timesNull(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> timesNull
org.matheclipse.core.eval.TraceStack -> org.matheclipse.core.eval.TraceStack:
    java.util.Stack fStack -> a
    com.google.common.base.Predicate fMatcher -> a
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fTraceList -> b
    void <init>(com.google.common.base.Predicate,org.matheclipse.core.interfaces.IAST) -> <init>
    void pushList() -> pushList
    void popList() -> popList
    org.matheclipse.core.interfaces.IAST getList() -> getList
    void add(org.matheclipse.core.interfaces.IExpr) -> add
    void addIfEmpty(org.matheclipse.core.interfaces.IExpr) -> addIfEmpty
    void setUp(org.matheclipse.core.interfaces.IExpr,int) -> setUp
    void tearDown(int) -> tearDown
    void add(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int,long,java.lang.String) -> add
org.matheclipse.core.eval.exception.AbortException -> org.matheclipse.core.eval.exception.AbortException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.matheclipse.core.eval.exception.BooleanFunctionConversionException -> org.matheclipse.core.eval.exception.BooleanFunctionConversionException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.matheclipse.core.eval.exception.BreakException -> org.matheclipse.core.eval.exception.BreakException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.matheclipse.core.eval.exception.ConditionException -> org.matheclipse.core.eval.exception.ConditionException:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr value -> value
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr getValue() -> getValue
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.ContinueException -> org.matheclipse.core.eval.exception.ContinueException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.matheclipse.core.eval.exception.DimensionException -> org.matheclipse.core.eval.exception.DimensionException:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
org.matheclipse.core.eval.exception.DivisionByZero -> org.matheclipse.core.eval.exception.DivisionByZero:
    long serialVersionUID -> serialVersionUID
    java.lang.String fReason -> fReason
    void <init>(java.lang.String) -> <init>
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.FlowControlException -> org.matheclipse.core.eval.exception.FlowControlException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.String) -> <init>
org.matheclipse.core.eval.exception.IndeterminateException -> org.matheclipse.core.eval.exception.IndeterminateException:
    long serialVersionUID -> serialVersionUID
    int fPosition -> fPosition
    org.matheclipse.core.interfaces.IExpr fArg -> fArg
    org.matheclipse.core.interfaces.IAST fExpr -> fExpr
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> <init>
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.IterationLimitExceeded -> org.matheclipse.core.eval.exception.IterationLimitExceeded:
    long serialVersionUID -> serialVersionUID
    long fLimit -> fLimit
    org.matheclipse.core.interfaces.IExpr fExpr -> fExpr
    void <init>(long,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.String getMessage() -> getMessage
    void throwIt(long,org.matheclipse.core.interfaces.IExpr) -> throwIt
org.matheclipse.core.eval.exception.JASConversionException -> org.matheclipse.core.eval.exception.JASConversionException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.matheclipse.core.eval.exception.NoEvalException -> org.matheclipse.core.eval.exception.NoEvalException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.matheclipse.core.eval.exception.NonNegativeIntegerExpected -> org.matheclipse.core.eval.exception.NonNegativeIntegerExpected:
    long serialVersionUID -> serialVersionUID
    int fCurrent -> fCurrent
    org.matheclipse.core.interfaces.IAST fExpr -> fExpr
    void <init>(org.matheclipse.core.interfaces.IAST,int) -> <init>
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.RecursionLimitExceeded -> org.matheclipse.core.eval.exception.RecursionLimitExceeded:
    long serialVersionUID -> serialVersionUID
    int fLimit -> fLimit
    org.matheclipse.core.interfaces.IExpr fExpr -> fExpr
    void <init>(int,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.String getMessage() -> getMessage
    void throwIt(int,org.matheclipse.core.interfaces.IExpr) -> throwIt
org.matheclipse.core.eval.exception.ReturnException -> org.matheclipse.core.eval.exception.ReturnException:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr value -> value
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr getValue() -> getValue
org.matheclipse.core.eval.exception.RuleCreationError -> org.matheclipse.core.eval.exception.RuleCreationError:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr fLHS -> fLHS
    org.matheclipse.core.interfaces.IExpr fRHS -> fRHS
    org.matheclipse.core.interfaces.IExpr fCondition -> fCondition
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.ThrowException -> org.matheclipse.core.eval.exception.ThrowException:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr value -> value
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr getValue() -> getValue
org.matheclipse.core.eval.exception.TimeExceeded -> org.matheclipse.core.eval.exception.TimeExceeded:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
org.matheclipse.core.eval.exception.UnsupportedParameterException -> org.matheclipse.core.eval.exception.UnsupportedParameterException:
    long serialVersionUID -> serialVersionUID
    int fPosition -> fPosition
    org.matheclipse.core.interfaces.IExpr fArg -> fArg
    org.matheclipse.core.interfaces.IAST fExpr -> fExpr
    java.lang.String fMessage -> fMessage
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int,java.lang.String) -> <init>
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.Validate -> org.matheclipse.core.eval.exception.Validate:
    int checkIntType(org.matheclipse.core.interfaces.IAST,int) -> checkIntType
    int checkPowerExponent(org.matheclipse.core.interfaces.IAST) -> checkPowerExponent
    long checkLongPowerExponent(org.matheclipse.core.interfaces.IAST) -> checkLongPowerExponent
    long checkLongType(org.matheclipse.core.interfaces.IExpr) -> checkLongType
    int checkIntType(org.matheclipse.core.interfaces.IAST,int,int) -> checkIntType
    int checkIntType(org.matheclipse.core.interfaces.IExpr) -> checkIntType
    int checkIntType(org.matheclipse.core.interfaces.IExpr,int) -> checkIntType
    org.matheclipse.core.interfaces.IInteger checkIntegerType(org.matheclipse.core.interfaces.IAST,int) -> checkIntegerType
    org.matheclipse.core.interfaces.IAST checkRange(org.matheclipse.core.interfaces.IAST,int) -> checkRange
    org.matheclipse.core.interfaces.IAST checkRange(org.matheclipse.core.interfaces.IAST,int,int) -> checkRange
    org.matheclipse.core.interfaces.IAST checkSize(org.matheclipse.core.interfaces.IAST,int) -> checkSize
    org.matheclipse.core.interfaces.IAST checkEven(org.matheclipse.core.interfaces.IAST) -> checkEven
    org.matheclipse.core.interfaces.IAST checkOdd(org.matheclipse.core.interfaces.IAST) -> checkOdd
    org.matheclipse.core.interfaces.IStringX checkStringType(org.matheclipse.core.interfaces.IAST,int) -> checkStringType
    org.matheclipse.core.interfaces.IAST checkSymbolOrSymbolList(org.matheclipse.core.interfaces.IAST,int) -> checkSymbolOrSymbolList
    org.matheclipse.core.interfaces.ISymbol checkAssignedVariable(org.matheclipse.core.interfaces.IExpr) -> checkAssignedVariable
    org.matheclipse.core.interfaces.ISymbol checkSymbolType(org.matheclipse.core.interfaces.IAST,int) -> checkSymbolType
    org.matheclipse.core.interfaces.IAST checkASTUpRuleType(org.matheclipse.core.interfaces.IExpr) -> checkASTUpRuleType
    org.matheclipse.core.interfaces.IAST checkASTType(org.matheclipse.core.interfaces.IAST,int) -> checkASTType
    org.matheclipse.core.interfaces.IAST checkASTType(org.matheclipse.core.interfaces.IExpr) -> checkASTType
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST checkEquations(org.matheclipse.core.interfaces.IAST,int) -> checkEquations
org.matheclipse.core.eval.exception.WrappedException -> org.matheclipse.core.eval.exception.WrappedException:
    long serialVersionUID -> serialVersionUID
    java.lang.Throwable fThrowable -> fThrowable
    void <init>(java.lang.Throwable) -> <init>
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.WrongArgumentType -> org.matheclipse.core.eval.exception.WrongArgumentType:
    long serialVersionUID -> serialVersionUID
    int fPosition -> fPosition
    org.matheclipse.core.interfaces.IExpr fArg -> fArg
    org.matheclipse.core.interfaces.IAST fExpr -> fExpr
    java.lang.String fMessage -> fMessage
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,java.lang.String) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int,java.lang.String) -> <init>
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.exception.WrongNumberOfArguments -> org.matheclipse.core.eval.exception.WrongNumberOfArguments:
    long serialVersionUID -> serialVersionUID
    int fAllowed -> fAllowed
    int fCurrent -> fCurrent
    org.matheclipse.core.interfaces.IAST fExpr -> fExpr
    int fTextNumber -> fTextNumber
    void <init>(org.matheclipse.core.interfaces.IAST,int,int) -> <init>
    void <init>(int,org.matheclipse.core.interfaces.IAST,int) -> <init>
    java.lang.String getMessage() -> getMessage
org.matheclipse.core.eval.interfaces.AbstractArg1 -> org.matheclipse.core.eval.interfaces.AbstractArg1:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    org.matheclipse.core.interfaces.IExpr e1IntArg(org.matheclipse.core.interfaces.IInteger) -> e1IntArg
    org.matheclipse.core.interfaces.IExpr e1FraArg(org.matheclipse.core.interfaces.IFraction) -> e1FraArg
    org.matheclipse.core.interfaces.IExpr e1ComArg(org.matheclipse.core.interfaces.IComplex) -> e1ComArg
    org.matheclipse.core.interfaces.IExpr e1SymArg(org.matheclipse.core.interfaces.ISymbol) -> e1SymArg
    org.matheclipse.core.interfaces.IExpr e1FunArg(org.matheclipse.core.interfaces.IAST) -> e1FunArg
org.matheclipse.core.eval.interfaces.AbstractArg12 -> org.matheclipse.core.eval.interfaces.AbstractArg12:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr unaryOperator(org.matheclipse.core.interfaces.IExpr) -> unaryOperator
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> e1DblComArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    org.matheclipse.core.interfaces.IExpr e1IntArg(org.matheclipse.core.interfaces.IInteger) -> e1IntArg
    org.matheclipse.core.interfaces.IExpr e1FraArg(org.matheclipse.core.interfaces.IFraction) -> e1FraArg
    org.matheclipse.core.interfaces.IExpr e1ComArg(org.matheclipse.core.interfaces.IComplex) -> e1ComArg
    org.matheclipse.core.interfaces.IExpr e1SymArg(org.matheclipse.core.interfaces.ISymbol) -> e1SymArg
    org.matheclipse.core.interfaces.IExpr e1FunArg(org.matheclipse.core.interfaces.IAST) -> e1FunArg
    org.matheclipse.core.interfaces.IExpr binaryOperator(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> binaryOperator
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> e2ComArg
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> e2DblArg
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> e2DblComArg
    org.matheclipse.core.interfaces.IExpr e2ApfloatArg(org.matheclipse.core.expression.ApfloatNum,org.matheclipse.core.expression.ApfloatNum) -> e2ApfloatArg
    org.matheclipse.core.interfaces.IExpr e2ApcomplexArg(org.matheclipse.core.expression.ApcomplexNum,org.matheclipse.core.expression.ApcomplexNum) -> e2ApcomplexArg
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> e2FraArg
    org.matheclipse.core.interfaces.IExpr e2SymArg(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> e2SymArg
    org.matheclipse.core.interfaces.IExpr e2FunArg(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> e2FunArg
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
    org.matheclipse.core.interfaces.IExpr eComFraArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IFraction) -> eComFraArg
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> eComIntArg
    org.matheclipse.core.interfaces.IExpr eFunIntArg(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IInteger) -> eFunIntArg
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.eval.interfaces.AbstractArg2 -> org.matheclipse.core.eval.interfaces.AbstractArg2:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr binaryOperator(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> binaryOperator
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> e2ComArg
    org.matheclipse.core.interfaces.IExpr e2ApfloatArg(org.matheclipse.core.expression.ApfloatNum,org.matheclipse.core.expression.ApfloatNum) -> e2ApfloatArg
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> e2DblArg
    org.matheclipse.core.interfaces.IExpr e2ApcomplexArg(org.matheclipse.core.expression.ApcomplexNum,org.matheclipse.core.expression.ApcomplexNum) -> e2ApcomplexArg
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> e2DblComArg
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> e2FraArg
    org.matheclipse.core.interfaces.IExpr e2SymArg(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> e2SymArg
    org.matheclipse.core.interfaces.IExpr e2FunArg(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> e2FunArg
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
    org.matheclipse.core.interfaces.IExpr eComFraArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IFraction) -> eComFraArg
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> eComIntArg
    org.matheclipse.core.interfaces.IExpr eFunIntArg(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IInteger) -> eFunIntArg
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.eval.interfaces.AbstractArgMultiple -> org.matheclipse.core.eval.interfaces.AbstractArgMultiple:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> getHashRuleMap
    org.matheclipse.core.interfaces.IAST evaluateHashs(org.matheclipse.core.interfaces.IAST) -> evaluateHashs
    void defineHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> defineHashRule
    void setUpHashRule2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> setUpHashRule2
    void setUpHashRule(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> setUpHashRule
    void setUpHashRule(java.lang.String,java.lang.String,java.lang.String) -> setUpHashRule
    org.matheclipse.core.interfaces.IExpr binaryOperator(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> binaryOperator
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
org.matheclipse.core.eval.interfaces.AbstractCoreFunctionEvaluator -> org.matheclipse.core.eval.interfaces.AbstractCoreFunctionEvaluator:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.eval.interfaces.AbstractEvaluator -> org.matheclipse.core.eval.interfaces.AbstractEvaluator:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.eval.interfaces.AbstractFunctionEvaluator -> org.matheclipse.core.eval.interfaces.AbstractFunctionEvaluator:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void createRuleFromMethod(org.matheclipse.core.interfaces.ISymbol,java.lang.String,java.lang.String) -> createRuleFromMethod
    boolean isNegativeExpression(org.matheclipse.core.interfaces.IExpr) -> isNegativeExpression
    org.matheclipse.core.interfaces.IExpr getNormalizedNegativeExpression(org.matheclipse.core.interfaces.IExpr) -> getNormalizedNegativeExpression
    org.matheclipse.core.interfaces.IExpr getNormalizedNegativeExpression(org.matheclipse.core.interfaces.IExpr,boolean) -> getNormalizedNegativeExpression
    org.matheclipse.core.interfaces.IExpr[] getPeriodicParts(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> getPeriodicParts
    org.matheclipse.core.interfaces.IExpr getPureImaginaryPart(org.matheclipse.core.interfaces.IExpr) -> getPureImaginaryPart
    void initSerializedRules(org.matheclipse.core.interfaces.ISymbol) -> initSerializedRules
org.matheclipse.core.eval.interfaces.AbstractMatrix1Expr -> org.matheclipse.core.eval.interfaces.AbstractMatrix1Expr:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    org.matheclipse.core.interfaces.IExpr matrixEval(org.matheclipse.commons.math.linear.FieldMatrix) -> matrixEval
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> realMatrixEval
org.matheclipse.core.eval.interfaces.AbstractMatrix1Matrix -> org.matheclipse.core.eval.interfaces.AbstractMatrix1Matrix:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    org.matheclipse.commons.math.linear.FieldMatrix matrixEval(org.matheclipse.commons.math.linear.FieldMatrix) -> matrixEval
    org.apache.commons.math3.linear.RealMatrix realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> realMatrixEval
org.matheclipse.core.eval.interfaces.AbstractNonOrderlessArgMultiple -> org.matheclipse.core.eval.interfaces.AbstractNonOrderlessArgMultiple:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.eval.interfaces.AbstractSymbolEvaluator -> org.matheclipse.core.eval.interfaces.AbstractSymbolEvaluator:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.ISymbol) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    org.matheclipse.core.interfaces.IExpr apfloatEval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> apfloatEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.eval.interfaces.AbstractTrigArg1 -> org.matheclipse.core.eval.interfaces.AbstractTrigArg1:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
org.matheclipse.core.eval.interfaces.ICoreFunctionEvaluator -> org.matheclipse.core.eval.interfaces.ICoreFunctionEvaluator:
org.matheclipse.core.eval.interfaces.ICreatePatternMatcher -> org.matheclipse.core.eval.interfaces.ICreatePatternMatcher:
    java.lang.Object[] createPatternMatcher(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> createPatternMatcher
org.matheclipse.core.eval.interfaces.IFunctionEvaluator -> org.matheclipse.core.eval.interfaces.IFunctionEvaluator:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.eval.interfaces.INumeric -> org.matheclipse.core.eval.interfaces.INumeric:
    double evalReal(double[],int,int) -> evalReal
org.matheclipse.core.eval.interfaces.INumericComplex -> org.matheclipse.core.eval.interfaces.INumericComplex:
    double[] evalComplex(org.matheclipse.core.eval.util.DoubleStack,int) -> evalComplex
org.matheclipse.core.eval.interfaces.INumericComplexConstant -> org.matheclipse.core.eval.interfaces.INumericComplexConstant:
    double[] evalComplex() -> evalComplex
org.matheclipse.core.eval.interfaces.ISignedNumberConstant -> org.matheclipse.core.eval.interfaces.ISignedNumberConstant:
    double evalReal() -> evalReal
org.matheclipse.core.eval.interfaces.ISymbolEvaluator -> org.matheclipse.core.eval.interfaces.ISymbolEvaluator:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.ISymbol) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.ISymbol) -> numericEval
    org.matheclipse.core.interfaces.IExpr apfloatEval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> apfloatEval
org.matheclipse.core.eval.util.AbstractAssumptions -> org.matheclipse.core.eval.util.AbstractAssumptions:
    void <init>() -> <init>
    boolean isNegative(org.matheclipse.core.interfaces.IExpr) -> isNegative
    boolean isPositive(org.matheclipse.core.interfaces.IExpr) -> isPositive
    boolean isNonNegative(org.matheclipse.core.interfaces.IExpr) -> isNonNegative
    boolean isAlgebraic(org.matheclipse.core.interfaces.IExpr) -> isAlgebraic
    boolean isBoolean(org.matheclipse.core.interfaces.IExpr) -> isBoolean
    boolean isComplex(org.matheclipse.core.interfaces.IExpr) -> isComplex
    boolean isInteger(org.matheclipse.core.interfaces.IExpr) -> isInteger
    boolean isPrime(org.matheclipse.core.interfaces.IExpr) -> isPrime
    boolean isRational(org.matheclipse.core.interfaces.IExpr) -> isRational
    boolean isReal(org.matheclipse.core.interfaces.IExpr) -> isReal
    boolean assumeNegative(org.matheclipse.core.interfaces.IExpr) -> assumeNegative
    boolean assumePositive(org.matheclipse.core.interfaces.IExpr) -> assumePositive
    boolean assumeNonNegative(org.matheclipse.core.interfaces.IExpr) -> assumeNonNegative
    boolean assumeAlgebraic(org.matheclipse.core.interfaces.IExpr) -> assumeAlgebraic
    boolean assumeBoolean(org.matheclipse.core.interfaces.IExpr) -> assumeBoolean
    boolean assumeComplex(org.matheclipse.core.interfaces.IExpr) -> assumeComplex
    boolean assumeInteger(org.matheclipse.core.interfaces.IExpr) -> assumeInteger
    boolean assumePrime(org.matheclipse.core.interfaces.IExpr) -> assumePrime
    boolean assumeRational(org.matheclipse.core.interfaces.IExpr) -> assumeRational
    boolean assumeReal(org.matheclipse.core.interfaces.IExpr) -> assumeReal
org.matheclipse.core.eval.util.AbstractSequence -> org.matheclipse.core.eval.util.AbstractSequence:
    int fStartOffset -> fStartOffset
    int fEndOffset -> fEndOffset
    int fStep -> fStep
    void <init>(int,int,int) -> <init>
    int getStep() -> getStep
    int[] getIndices() -> getIndices
org.matheclipse.core.eval.util.Assumptions -> org.matheclipse.core.eval.util.Assumptions:
    java.util.Map elementsMap -> a
    java.util.Map valueMap -> b
    void <init>() -> <init>
    org.matheclipse.core.eval.util.IAssumptions getInstance(org.matheclipse.core.interfaces.IExpr) -> getInstance
    boolean addElement(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.Assumptions) -> a
    boolean addGreater(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.Assumptions) -> b
    boolean addGreaterEqual(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.Assumptions) -> c
    boolean addLess(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.Assumptions) -> d
    boolean addLessEqual(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.Assumptions) -> e
    boolean isNegative(org.matheclipse.core.interfaces.IExpr) -> isNegative
    boolean isPositive(org.matheclipse.core.interfaces.IExpr) -> isPositive
    boolean isNonNegative(org.matheclipse.core.interfaces.IExpr) -> isNonNegative
    boolean isDomain(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    boolean isAlgebraic(org.matheclipse.core.interfaces.IExpr) -> isAlgebraic
    boolean isBoolean(org.matheclipse.core.interfaces.IExpr) -> isBoolean
    boolean isComplex(org.matheclipse.core.interfaces.IExpr) -> isComplex
    boolean isInteger(org.matheclipse.core.interfaces.IExpr) -> isInteger
    boolean isPrime(org.matheclipse.core.interfaces.IExpr) -> isPrime
    boolean isRational(org.matheclipse.core.interfaces.IExpr) -> isRational
    boolean isReal(org.matheclipse.core.interfaces.IExpr) -> isReal
org.matheclipse.core.eval.util.Assumptions$SignedNumberRelations -> mG:
    org.matheclipse.core.interfaces.ISignedNumber[] values -> a
    void <init>() -> <init>
org.matheclipse.core.eval.util.DoubleStack -> org.matheclipse.core.eval.util.DoubleStack:
    double[] stack -> a
    int top -> a
    void <init>(int) -> <init>
    void ensureCapacity(int) -> ensureCapacity
    boolean isEmpty() -> isEmpty
    double peek() -> peek
    double push(double) -> push
    double pop() -> pop
org.matheclipse.core.eval.util.IAssumptions -> org.matheclipse.core.eval.util.IAssumptions:
    boolean isNegative(org.matheclipse.core.interfaces.IExpr) -> isNegative
    boolean isPositive(org.matheclipse.core.interfaces.IExpr) -> isPositive
    boolean isNonNegative(org.matheclipse.core.interfaces.IExpr) -> isNonNegative
    boolean isAlgebraic(org.matheclipse.core.interfaces.IExpr) -> isAlgebraic
    boolean isBoolean(org.matheclipse.core.interfaces.IExpr) -> isBoolean
    boolean isComplex(org.matheclipse.core.interfaces.IExpr) -> isComplex
    boolean isInteger(org.matheclipse.core.interfaces.IExpr) -> isInteger
    boolean isPrime(org.matheclipse.core.interfaces.IExpr) -> isPrime
    boolean isRational(org.matheclipse.core.interfaces.IExpr) -> isRational
    boolean isReal(org.matheclipse.core.interfaces.IExpr) -> isReal
org.matheclipse.core.eval.util.IIndexFunction -> org.matheclipse.core.eval.util.IIndexFunction:
    java.lang.Object evaluate(int[]) -> evaluate
org.matheclipse.core.eval.util.ISequence -> org.matheclipse.core.eval.util.ISequence:
    int getEnd() -> getEnd
    int[] getIndices() -> getIndices
    int getStart() -> getStart
    int getStep() -> getStep
    void setListSize(int) -> setListSize
org.matheclipse.core.eval.util.IndexFunctionDiagonal -> org.matheclipse.core.eval.util.IndexFunctionDiagonal:
    org.matheclipse.core.interfaces.IExpr[] fValues -> a
    void <init>(org.matheclipse.core.interfaces.IExpr[]) -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(int[]) -> evaluate
    boolean isMatched(int[]) -> isMatched
    java.lang.Object evaluate(int[]) -> evaluate
org.matheclipse.core.eval.util.IndexTableGenerator -> org.matheclipse.core.eval.util.IndexTableGenerator:
    int[] fIndexArray -> a
    org.matheclipse.core.interfaces.IAST fPrototypeList -> a
    org.matheclipse.core.eval.util.IIndexFunction fFunction -> a
    int fIndex -> a
    int[] fCurrentIndex -> b
    void <init>(int[],org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.util.IIndexFunction) -> <init>
    org.matheclipse.core.interfaces.IExpr table() -> table
org.matheclipse.core.eval.util.Iterator -> org.matheclipse.core.eval.util.Iterator:
    org.matheclipse.core.interfaces.IExpr count -> a
    boolean fNumericMode -> a
    org.matheclipse.core.eval.EvalEngine evalEngine -> a
    org.matheclipse.core.interfaces.IExpr start -> b
    org.matheclipse.core.interfaces.IExpr maxCounterOrList -> c
    int maxCounterOrListIndex -> a
    org.matheclipse.core.interfaces.IExpr step -> d
    org.matheclipse.core.interfaces.IExpr originalStart -> e
    org.matheclipse.core.interfaces.IExpr originalMaxCount -> f
    org.matheclipse.core.interfaces.IExpr originalStep -> g
    org.matheclipse.core.interfaces.ISymbol variable -> a
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.EvalEngine) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.expression.Symbol,org.matheclipse.core.eval.EvalEngine) -> <init>
    org.matheclipse.core.interfaces.IExpr getMaxCount() -> getMaxCount
    org.matheclipse.core.interfaces.IExpr getStart() -> getStart
    org.matheclipse.core.interfaces.IExpr getStep() -> getStep
    org.matheclipse.core.interfaces.ISymbol getVariable() -> getVariable
    boolean hasNext() -> hasNext
    boolean isValidVariable() -> isValidVariable
    boolean isNumericFunction() -> isNumericFunction
    boolean isSetIterator() -> isSetIterator
    org.matheclipse.core.interfaces.IExpr next() -> next
    void remove() -> remove
    boolean setUp() -> setUp
    void tearDown() -> tearDown
    java.lang.Object next() -> next
org.matheclipse.core.eval.util.LevelSpec -> org.matheclipse.core.eval.util.LevelSpec:
    int fFromLevel -> fFromLevel
    int fToLevel -> fToLevel
    int fFromDepth -> fFromDepth
    int fToDepth -> fToDepth
    boolean fIncludeHeads -> fIncludeHeads
    int fCurrentLevel -> fCurrentLevel
    int fCurrentDepth -> fCurrentDepth
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(int,boolean) -> <init>
    void <init>(int,int) -> <init>
    void <init>(int,int,boolean) -> <init>
    void <init>(int,int,int,int,boolean) -> <init>
    int getCurrentLevel() -> getCurrentLevel
    void resetCurrentLevel() -> resetCurrentLevel
    void setFromLevelAsCurrent() -> setFromLevelAsCurrent
    void setToLevelAsCurrent() -> setToLevelAsCurrent
    void decCurrentDepth() -> decCurrentDepth
    void incCurrentLevel() -> incCurrentLevel
    void decCurrentLevel() -> decCurrentLevel
    boolean isInRange() -> isInRange
    boolean isInScope() -> isInScope
    int getCurrentDepth() -> getCurrentDepth
    void setCurrentDepth(int) -> setCurrentDepth
    void setCurrentLevel(int) -> setCurrentLevel
    int getFromLevel() -> getFromLevel
    int getToLevel() -> getToLevel
    int getFromDepth() -> getFromDepth
    int getToDepth() -> getToDepth
    boolean isIncludeHeads() -> isIncludeHeads
org.matheclipse.core.eval.util.LevelSpecification -> org.matheclipse.core.eval.util.LevelSpecification:
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,boolean) -> <init>
    void <init>(int) -> <init>
    void <init>(int,int) -> <init>
    int getFrom() -> getFrom
    int getTo() -> getTo
    boolean includesDepth(int) -> includesDepth
    boolean includesLevel(int) -> includesLevel
    int compareDepth(int) -> compareDepth
    int compareLevel() -> compareLevel
    int compareLevel(int) -> compareLevel
    void setFrom(int) -> setFrom
    void setTo(int) -> setTo
org.matheclipse.core.eval.util.ListSizeSequence -> org.matheclipse.core.eval.util.ListSizeSequence:
    int fHeadOffset -> fHeadOffset
    int fListSize -> fListSize
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(int,int) -> <init>
    void <init>(int,int,int) -> <init>
    void <init>(int,int,int,int) -> <init>
    void setListSize(int) -> setListSize
    int getStart() -> getStart
    int getEnd() -> getEnd
org.matheclipse.core.eval.util.OpenIntToIExprHashMap -> org.matheclipse.core.eval.util.OpenIntToIExprHashMap:
    byte FREE -> FREE
    byte FULL -> FULL
    byte REMOVED -> REMOVED
    long serialVersionUID -> serialVersionUID
    int[] keys -> keys
    org.matheclipse.core.interfaces.IExpr[] values -> values
    byte[] states -> states
    int size -> size
    int mask -> mask
    int count -> a
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(org.matheclipse.core.eval.util.OpenIntToIExprHashMap) -> <init>
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    boolean containsKey(int) -> containsKey
    org.matheclipse.core.eval.util.OpenIntToIExprHashMap$Iterator iterator() -> iterator
    int findInsertionIndex(int[],byte[],int,int) -> a
    int probe(int,int) -> a
    int size() -> size
    org.matheclipse.core.interfaces.IExpr remove(int) -> remove
    boolean containsKey(int,int) -> a
    org.matheclipse.core.interfaces.IExpr doRemove(int) -> a
    org.matheclipse.core.interfaces.IExpr put(int,org.matheclipse.core.interfaces.IExpr) -> put
    int hashOf(int) -> a
    void readObject(java.io.ObjectInputStream) -> readObject
    int access$100(org.matheclipse.core.eval.util.OpenIntToIExprHashMap) -> access$100
    int[] access$200(org.matheclipse.core.eval.util.OpenIntToIExprHashMap) -> access$200
    org.matheclipse.core.interfaces.IExpr[] access$300(org.matheclipse.core.eval.util.OpenIntToIExprHashMap) -> access$300
    byte[] access$400(org.matheclipse.core.eval.util.OpenIntToIExprHashMap) -> access$400
org.matheclipse.core.eval.util.OpenIntToIExprHashMap$Iterator -> org.matheclipse.core.eval.util.OpenIntToIExprHashMap$Iterator:
    int referenceCount -> a
    int current -> b
    int next -> c
    org.matheclipse.core.eval.util.OpenIntToIExprHashMap this$0 -> a
    void <init>(org.matheclipse.core.eval.util.OpenIntToIExprHashMap) -> <init>
    boolean hasNext() -> hasNext
    int key() -> key
    org.matheclipse.core.interfaces.IExpr value() -> value
    void advance() -> advance
    void <init>(org.matheclipse.core.eval.util.OpenIntToIExprHashMap,byte) -> <init>
org.matheclipse.core.eval.util.Options -> org.matheclipse.core.eval.util.Options:
    org.matheclipse.core.interfaces.IAST fDefaultOptionsList -> a
    org.matheclipse.core.interfaces.IAST fCurrentOptionsList -> b
    void <init>(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> <init>
    boolean isOption(java.lang.String) -> isOption
    org.matheclipse.core.interfaces.IExpr getOption(java.lang.String) -> getOption
    org.matheclipse.core.interfaces.IExpr getOption(org.matheclipse.core.interfaces.ISymbol) -> getOption
    org.matheclipse.core.interfaces.IAST replaceAll(org.matheclipse.core.interfaces.IAST) -> replaceAll
org.matheclipse.core.eval.util.Sequence -> org.matheclipse.core.eval.util.Sequence:
    void <init>(org.matheclipse.core.interfaces.IInteger) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.eval.util.Sequence createSequence(org.matheclipse.core.interfaces.IExpr) -> createSequence
    org.matheclipse.core.eval.util.Sequence[] createSequences(org.matheclipse.core.interfaces.IAST,int) -> createSequences
org.matheclipse.core.eval.util.SimpleSequence -> org.matheclipse.core.eval.util.SimpleSequence:
    void <init>(int,int) -> <init>
    void <init>(int,int,int) -> <init>
    void setListSize(int) -> setListSize
    int getEnd() -> getEnd
    int getStart() -> getStart
org.matheclipse.core.eval.util.TableGenerator -> org.matheclipse.core.eval.util.TableGenerator:
    java.util.List fIterList -> a
    org.matheclipse.core.interfaces.IExpr fDefaultValue -> a
    org.matheclipse.core.interfaces.IAST fPrototypeList -> a
    org.matheclipse.core.generic.interfaces.IArrayFunction fFunction -> a
    int fIndex -> a
    org.matheclipse.core.interfaces.IExpr[] fCurrentIndex -> a
    void <init>(java.util.List,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.interfaces.IArrayFunction) -> <init>
    void <init>(java.util.List,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.interfaces.IArrayFunction,org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr table() -> table
org.matheclipse.core.eval.util.WriterOutputStream -> org.matheclipse.core.eval.util.WriterOutputStream:
    java.io.Writer fWriter -> fWriter
    java.lang.String fEncoding -> fEncoding
    byte[] fBuffer -> a
    void <init>(java.io.Writer,java.lang.String) -> <init>
    void <init>(java.io.Writer) -> <init>
    void close() -> close
    void flush() -> flush
    void write(byte[]) -> write
    void write(byte[],int,int) -> write
    void write(int) -> write
org.matheclipse.core.eval.util.WrongSequenceException -> org.matheclipse.core.eval.util.WrongSequenceException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.String) -> <init>
org.matheclipse.core.expression.AST -> org.matheclipse.core.expression.AST:
    java.util.EnumMap fProperties -> fProperties
    long serialVersionUID -> serialVersionUID
    java.lang.Object getProperty(org.matheclipse.core.interfaces.IAST$PROPERTY) -> getProperty
    int hashCode() -> hashCode
    java.lang.Object putProperty(org.matheclipse.core.interfaces.IAST$PROPERTY,java.lang.Object) -> putProperty
    void <init>(int,boolean) -> <init>
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[]) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[]) -> <init>
    org.matheclipse.core.interfaces.IAST parse(java.lang.String) -> parse
    void parseList(java.util.StringTokenizer,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.expression.AST clone() -> clone
    org.matheclipse.core.interfaces.IAST addOneIdentity(org.matheclipse.core.interfaces.IAST) -> addOneIdentity
    boolean addAll(java.util.List) -> addAll
    boolean addAll(java.util.List,int,int) -> addAll
    org.matheclipse.core.expression.AST newInstance(int,org.matheclipse.core.interfaces.IExpr) -> newInstance
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.IExpr) -> newInstance
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.IAST,int) -> newInstance
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.ISymbol,int[]) -> newInstance
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.ISymbol,double[]) -> newInstance
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.ISymbol,org.apache.commons.math3.complex.Complex[]) -> newInstance
    org.matheclipse.core.expression.AST newInstance(org.matheclipse.core.interfaces.ISymbol,double[][]) -> newInstance
    java.lang.Object writeReplace() -> writeReplace
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    org.matheclipse.core.interfaces.IAST clone() -> clone
    java.lang.Object clone() -> clone
org.matheclipse.core.expression.AST0 -> org.matheclipse.core.expression.AST0:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr arg0 -> arg0
    int hashValue -> hashValue
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr arg1() -> arg1
    org.matheclipse.core.interfaces.IExpr arg2() -> arg2
    org.matheclipse.core.interfaces.IExpr arg3() -> arg3
    org.matheclipse.core.interfaces.IExpr arg4() -> arg4
    org.matheclipse.core.interfaces.IExpr arg5() -> arg5
    boolean add(org.matheclipse.core.interfaces.IExpr) -> add
    void add(int,org.matheclipse.core.interfaces.IExpr) -> add
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
    boolean addAll(java.util.List) -> addAll
    boolean addAll(java.util.List,int,int) -> addAll
    org.matheclipse.core.interfaces.IAST addOneIdentity(org.matheclipse.core.interfaces.IAST) -> addOneIdentity
    void clear() -> clear
    org.matheclipse.core.interfaces.IAST clone() -> clone
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    int hashCode() -> hashCode
    org.matheclipse.core.interfaces.IExpr head() -> head
    void readExternal(java.io.ObjectInput) -> readExternal
    org.matheclipse.core.interfaces.IExpr remove(int) -> remove
    boolean remove(java.lang.Object) -> remove
    void removeRange(int,int) -> removeRange
    org.matheclipse.core.interfaces.IExpr set(int,org.matheclipse.core.interfaces.IExpr) -> set
    int size() -> size
    java.lang.Object[] toArray() -> toArray
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    java.lang.Object writeReplace() -> writeReplace
    java.lang.Object remove(int) -> remove
    void add(int,java.lang.Object) -> add
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    boolean add(java.lang.Object) -> add
    java.lang.Object clone() -> clone
org.matheclipse.core.expression.AST1 -> org.matheclipse.core.expression.AST1:
    org.matheclipse.core.interfaces.IExpr arg1 -> arg1
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr arg1() -> arg1
    org.matheclipse.core.interfaces.IAST clone() -> clone
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    int hashCode() -> hashCode
    org.matheclipse.core.interfaces.IExpr set(int,org.matheclipse.core.interfaces.IExpr) -> set
    int size() -> size
    java.lang.Object[] toArray() -> toArray
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    java.lang.Object clone() -> clone
org.matheclipse.core.expression.AST2 -> org.matheclipse.core.expression.AST2:
    org.matheclipse.core.interfaces.IExpr arg2 -> arg2
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr arg2() -> arg2
    org.matheclipse.core.interfaces.IAST clone() -> clone
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    int hashCode() -> hashCode
    org.matheclipse.core.interfaces.IExpr set(int,org.matheclipse.core.interfaces.IExpr) -> set
    int size() -> size
    java.lang.Object[] toArray() -> toArray
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    java.lang.Object clone() -> clone
org.matheclipse.core.expression.AST3 -> org.matheclipse.core.expression.AST3:
    org.matheclipse.core.interfaces.IExpr arg3 -> arg3
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr arg3() -> arg3
    org.matheclipse.core.interfaces.IAST clone() -> clone
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    int hashCode() -> hashCode
    org.matheclipse.core.interfaces.IExpr set(int,org.matheclipse.core.interfaces.IExpr) -> set
    int size() -> size
    java.lang.Object[] toArray() -> toArray
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    java.lang.Object clone() -> clone
org.matheclipse.core.expression.ASTDelegate -> org.matheclipse.core.expression.ASTDelegate:
    org.matheclipse.core.interfaces.IAST fAst -> fAst
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.interfaces.IAST createAST(int) -> createAST
    org.matheclipse.core.interfaces.IAST createAST(int[]) -> createAST
    int getRows() -> getRows
    org.matheclipse.core.interfaces.IExpr getAt(int) -> getAt
    int size() -> size
    java.lang.String toFullForm() -> toFullForm
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IAST getAST() -> getAST
org.matheclipse.core.expression.ASTRange -> org.matheclipse.core.expression.ASTRange:
    void <init>(org.matheclipse.core.interfaces.IAST,int,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    java.util.List toList() -> toList
org.matheclipse.core.expression.AbstractAST -> org.matheclipse.core.expression.AbstractAST:
    long serialVersionUID -> serialVersionUID
    int fEvalFlags -> fEvalFlags
    int hashValue -> hashValue
    void internalFormOrderless(org.matheclipse.core.interfaces.IAST,java.lang.StringBuffer,java.lang.String,boolean,int) -> a
    org.matheclipse.core.interfaces.IExpr variables2Slots(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,com.google.common.base.Function) -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr abs() -> abs
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.IAST addAtClone(int,org.matheclipse.core.interfaces.IExpr) -> addAtClone
    void addEvalFlags(int) -> addEvalFlags
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IAST appendClone(org.matheclipse.core.interfaces.IExpr) -> appendClone
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr) -> apply
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr[]) -> apply
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr,int) -> apply
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr,int,int) -> apply
    org.matheclipse.core.interfaces.IExpr apply(java.util.List) -> apply
    org.matheclipse.core.expression.ASTRange args() -> args
    java.lang.Object asType(java.lang.Class) -> asType
    org.matheclipse.core.interfaces.IExpr copy() -> copy
    org.matheclipse.core.interfaces.IAST copyHead() -> copyHead
    org.matheclipse.core.interfaces.IAST copyUntil(int) -> copyUntil
    org.matheclipse.core.interfaces.IAST clone() -> clone
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    int compareToAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    int compareToTimes(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> b
    boolean contains(java.lang.Object) -> contains
    org.matheclipse.core.interfaces.IExpr divide(org.matheclipse.core.interfaces.IExpr) -> divide
    org.matheclipse.core.interfaces.IExpr[] egcd(org.matheclipse.core.interfaces.IExpr) -> egcd
    boolean equals(java.lang.Object) -> equals
    boolean equalsAt(int,org.matheclipse.core.interfaces.IExpr) -> equalsAt
    boolean equalsFromPosition(int,org.matheclipse.core.interfaces.IAST,int) -> equalsFromPosition
    double evalDouble() -> evalDouble
    org.apache.commons.math3.complex.Complex evalComplex() -> evalComplex
    org.matheclipse.core.interfaces.INumber evalNumber() -> evalNumber
    org.matheclipse.core.interfaces.ISignedNumber evalSignedNumber() -> evalSignedNumber
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    edu.jas.structure.ElemFactory factory() -> factory
    org.matheclipse.core.interfaces.IAST[] filter(com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate,int) -> filter
    org.matheclipse.core.interfaces.IAST[] filter(com.google.common.base.Predicate) -> filter
    int findFirstEquals(org.matheclipse.core.interfaces.IExpr) -> findFirstEquals
    java.lang.String fullFormString() -> fullFormString
    org.matheclipse.core.interfaces.IExpr gcd(org.matheclipse.core.interfaces.IExpr) -> gcd
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    org.matheclipse.core.interfaces.IAST getAST(int) -> getAST
    org.matheclipse.core.interfaces.IExpr getAt(int) -> getAt
    int getEvalFlags() -> getEvalFlags
    org.matheclipse.core.interfaces.IInteger getInt(int) -> getInt
    org.matheclipse.core.interfaces.IAST getList(int) -> getList
    org.matheclipse.core.interfaces.INumber getNumber(int) -> getNumber
    org.matheclipse.core.interfaces.IExpr getOneIdentity(org.matheclipse.core.interfaces.IExpr) -> getOneIdentity
    org.matheclipse.core.interfaces.IExpr getPart(int[]) -> getPart
    org.matheclipse.core.interfaces.IExpr getPart(java.util.List) -> getPart
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    int indexOf(java.lang.Object) -> indexOf
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    boolean isAllExpanded() -> isAllExpanded
    boolean isAnd() -> isAnd
    boolean isArcCos() -> isArcCos
    boolean isArcCosh() -> isArcCosh
    boolean isArcSin() -> isArcSin
    boolean isArcSinh() -> isArcSinh
    boolean isArcTan() -> isArcTan
    boolean isArcTanh() -> isArcTanh
    boolean isAST() -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,org.matheclipse.core.interfaces.IExpr[]) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,int) -> isAST
    boolean isAST(java.lang.String) -> isAST
    boolean isAST(java.lang.String,int) -> isAST
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> isASTSizeGE
    boolean isAtom() -> isAtom
    boolean isBlank() -> isBlank
    boolean isComplex() -> isComplex
    boolean isComplexInfinity() -> isComplexInfinity
    boolean isComplexNumeric() -> isComplexNumeric
    boolean isCondition() -> isCondition
    boolean isConstant() -> isConstant
    boolean isCos() -> isCos
    boolean isCosh() -> isCosh
    org.matheclipse.core.interfaces.IAST[] isDerivative() -> isDerivative
    boolean isDirectedInfinity() -> isDirectedInfinity
    boolean isE() -> isE
    boolean isEmpty() -> isEmpty
    boolean isEvalFlagOff(int) -> isEvalFlagOff
    boolean isEvalFlagOn(int) -> isEvalFlagOn
    boolean isExpanded() -> isExpanded
    boolean isFalse() -> isFalse
    boolean isFlatAST() -> isFlatAST
    boolean isFraction() -> isFraction
    boolean isFree(org.matheclipse.core.interfaces.IExpr) -> isFree
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> isFree
    boolean isFree(com.google.common.base.Predicate,boolean) -> isFree
    boolean isFreeAST(org.matheclipse.core.interfaces.IExpr) -> isFreeAST
    boolean isFreeAST(com.google.common.base.Predicate) -> isFreeAST
    boolean isFreeAt(int,org.matheclipse.core.interfaces.IExpr) -> isFreeAt
    boolean isFreeOfPatterns() -> isFreeOfPatterns
    boolean isFunction() -> isFunction
    boolean isGEOrdered(org.matheclipse.core.interfaces.IExpr) -> isGEOrdered
    boolean isGTOrdered(org.matheclipse.core.interfaces.IExpr) -> isGTOrdered
    boolean isIndeterminate() -> isIndeterminate
    boolean isInfinity() -> isInfinity
    boolean isInteger() -> isInteger
    boolean isIntegerResult() -> isIntegerResult
    boolean isRationalResult() -> isRationalResult
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> isLEOrdered
    boolean isList() -> isList
    boolean isListOfLists() -> isListOfLists
    boolean isLog() -> isLog
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> isLTOrdered
    int[] isMatrix() -> isMatrix
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> isMember
    boolean isMember(com.google.common.base.Predicate,boolean) -> isMember
    boolean isMinusOne() -> isMinusOne
    boolean isModule() -> isModule
    boolean isNegative() -> isNegative
    boolean isNegativeInfinity() -> isNegativeInfinity
    boolean isNegativeResult() -> isNegativeResult
    boolean isNonNegativeResult() -> isNonNegativeResult
    boolean isNot() -> isNot
    boolean isNumber() -> isNumber
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumEqualRational(org.matheclipse.core.interfaces.IRational) -> isNumEqualRational
    boolean isNumeric() -> isNumeric
    boolean isNumericFunction() -> isNumericFunction
    boolean isNumericMode() -> isNumericMode
    boolean isNumIntValue() -> isNumIntValue
    boolean isOne() -> isOne
    boolean isONE() -> isONE
    boolean isOr() -> isOr
    boolean isOrderlessAST() -> isOrderlessAST
    boolean isPattern() -> isPattern
    boolean isPatternDefault() -> isPatternDefault
    boolean isPatternExpr() -> isPatternExpr
    boolean isPatternSequence() -> isPatternSequence
    boolean isPi() -> isPi
    boolean isPlus() -> isPlus
    boolean isPlusTimesPower() -> isPlusTimesPower
    boolean isPolynomial(org.matheclipse.core.interfaces.IAST) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.ISymbol) -> isPolynomial
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.IAST,long) -> isPolynomialOfMaxDegree
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.ISymbol,long) -> isPolynomialOfMaxDegree
    boolean isPositive() -> isPositive
    boolean isPositiveResult() -> isPositiveResult
    boolean isPower() -> isPower
    boolean isRational() -> isRational
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isRealResult() -> isRealResult
    boolean isRuleAST() -> isRuleAST
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> isSame
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    boolean isSameHead(org.matheclipse.core.interfaces.IExpr) -> isSameHead
    boolean isSameHead(org.matheclipse.core.interfaces.IExpr,int) -> isSameHead
    boolean isSameHead(org.matheclipse.core.interfaces.IExpr,int,int) -> isSameHead
    boolean isSameHeadSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> isSameHeadSizeGE
    boolean isSequence() -> isSequence
    boolean isSignedNumber() -> isSignedNumber
    boolean isSin() -> isSin
    boolean isSinh() -> isSinh
    boolean isSlot() -> isSlot
    boolean isSlotSequence() -> isSlotSequence
    boolean isSymbol() -> isSymbol
    boolean isTan() -> isTan
    boolean isTanh() -> isTanh
    boolean isTimes() -> isTimes
    boolean isTrue() -> isTrue
    boolean isUnit() -> isUnit
    boolean isValue() -> isValue
    boolean isVariable() -> isVariable
    int isVector() -> isVector
    boolean isZero() -> isZero
    boolean isZERO() -> isZERO
    java.util.Iterator iterator() -> iterator
    java.util.Iterator iterator0() -> iterator0
    org.matheclipse.core.interfaces.IExpr last() -> last
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    long leafCount() -> leafCount
    java.util.List leaves() -> leaves
    org.matheclipse.core.interfaces.IAST map(com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.interfaces.BiFunction) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST mapAt(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int) -> mapAt
    org.matheclipse.core.interfaces.IAST mapAt(org.matheclipse.core.interfaces.IAST,int) -> mapAt
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.IExpr negative() -> negative
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr optional(org.matheclipse.core.interfaces.IExpr) -> optional
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr) -> or
    int patternHashCode() -> patternHashCode
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr inc() -> inc
    org.matheclipse.core.interfaces.IExpr dec() -> dec
    org.matheclipse.core.interfaces.IExpr power(org.matheclipse.core.interfaces.IExpr) -> power
    org.matheclipse.core.interfaces.IExpr power(long) -> power
    org.matheclipse.core.interfaces.IAST prependClone(org.matheclipse.core.interfaces.IExpr) -> prependClone
    org.matheclipse.core.expression.ASTRange range() -> range
    org.matheclipse.core.expression.ASTRange range(int) -> range
    org.matheclipse.core.expression.ASTRange range(int,int) -> range
    org.matheclipse.core.interfaces.IExpr remainder(org.matheclipse.core.interfaces.IExpr) -> remainder
    org.matheclipse.core.interfaces.IAST removeAtClone(int) -> removeAtClone
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> replacePart
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> replaceSlots
    org.matheclipse.core.interfaces.IAST setAtClone(int,org.matheclipse.core.interfaces.IExpr) -> setAtClone
    void setEvalFlags(int) -> setEvalFlags
    int signum() -> signum
    int size() -> size
    org.matheclipse.core.interfaces.IExpr subtract(org.matheclipse.core.interfaces.IExpr) -> subtract
    org.matheclipse.core.interfaces.IExpr sum(org.matheclipse.core.interfaces.IExpr) -> sum
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    java.lang.String toFullFormString() -> a
    org.matheclipse.core.interfaces.ISymbol topHead() -> topHead
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    java.lang.Object get(int) -> get
    java.lang.Object clone() -> clone
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
org.matheclipse.core.expression.AbstractAST$ASTIterator -> org.matheclipse.core.expression.AbstractAST$ASTIterator:
    int _currentIndex -> a
    int _end -> b
    int _nextIndex -> c
    int _start -> d
    org.matheclipse.core.expression.AbstractAST _table -> a
    void <init>() -> <init>
    void add(org.matheclipse.core.interfaces.IExpr) -> add
    boolean hasNext() -> hasNext
    boolean hasPrevious() -> hasPrevious
    org.matheclipse.core.interfaces.IExpr next() -> next
    int nextIndex() -> nextIndex
    org.matheclipse.core.interfaces.IExpr previous() -> previous
    int previousIndex() -> previousIndex
    void remove() -> remove
    void set(org.matheclipse.core.interfaces.IExpr) -> set
    void add(java.lang.Object) -> add
    void set(java.lang.Object) -> set
    java.lang.Object previous() -> previous
    java.lang.Object next() -> next
    org.matheclipse.core.expression.AbstractAST access$002(org.matheclipse.core.expression.AbstractAST$ASTIterator,org.matheclipse.core.expression.AbstractAST) -> a
    int access$102(org.matheclipse.core.expression.AbstractAST$ASTIterator,int) -> a
    int access$202(org.matheclipse.core.expression.AbstractAST$ASTIterator,int) -> b
    int access$302(org.matheclipse.core.expression.AbstractAST$ASTIterator,int) -> c
    int access$402(org.matheclipse.core.expression.AbstractAST$ASTIterator,int) -> d
org.matheclipse.core.expression.ApcomplexNum -> org.matheclipse.core.expression.ApcomplexNum:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.expression.ApcomplexNum I -> I
    org.matheclipse.core.expression.ApcomplexNum ONE -> ONE
    org.matheclipse.core.expression.ApcomplexNum ZERO -> ZERO
    org.apfloat.Apcomplex fApcomplex -> fApcomplex
    org.matheclipse.core.expression.ApcomplexNum valueOf(org.apfloat.Apcomplex) -> valueOf
    org.matheclipse.core.expression.ApcomplexNum valueOf(org.apfloat.Apfloat,org.apfloat.Apfloat) -> valueOf
    org.matheclipse.core.expression.ApcomplexNum valueOf(double,long) -> valueOf
    org.matheclipse.core.expression.ApcomplexNum valueOf(double,double,long) -> valueOf
    org.matheclipse.core.expression.ApcomplexNum valueOf(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,int) -> valueOf
    void <init>(org.apfloat.Apcomplex) -> <init>
    void <init>(org.apfloat.Apfloat,org.apfloat.Apfloat) -> <init>
    double getImaginaryPart() -> getImaginaryPart
    org.apfloat.Apcomplex apcomplexValue() -> apcomplexValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    double getRealPart() -> getRealPart
    boolean isZero() -> isZero
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IComplexNum add(org.matheclipse.core.interfaces.IComplexNum) -> add
    org.matheclipse.core.expression.ApcomplexNum add(org.matheclipse.core.expression.ApcomplexNum) -> add
    org.matheclipse.core.interfaces.IComplexNum multiply(org.matheclipse.core.interfaces.IComplexNum) -> multiply
    org.matheclipse.core.interfaces.IComplexNum pow(org.matheclipse.core.interfaces.IComplexNum) -> pow
    org.apfloat.Apcomplex add(org.apfloat.Apcomplex) -> add
    org.matheclipse.core.interfaces.IComplexNum conjugate() -> conjugate
    org.apfloat.Apcomplex divide(org.apfloat.Apcomplex) -> divide
    org.matheclipse.core.expression.ApcomplexNum divide(org.matheclipse.core.expression.ApcomplexNum) -> divide
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    double dabs() -> dabs
    org.matheclipse.core.expression.Num eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    double getImaginary() -> getImaginary
    double getReal() -> getReal
    int hashCode() -> hashCode
    org.matheclipse.core.expression.ApcomplexNum multiply(org.matheclipse.core.expression.ApcomplexNum) -> multiply
    org.matheclipse.core.expression.ApcomplexNum negate() -> negate
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.apfloat.Apcomplex subtract(org.apfloat.Apcomplex) -> subtract
    org.matheclipse.core.expression.ApcomplexNum subtract(org.matheclipse.core.expression.ApcomplexNum) -> subtract
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    java.lang.String toString() -> toString
    int complexSign() -> complexSign
    int compareTo(org.apfloat.Apcomplex) -> compareTo
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> head
    org.apfloat.Apcomplex getComplex() -> getComplex
    org.matheclipse.parser.client.math.Complex getCMComplex() -> getCMComplex
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber floor() -> floor
    long precision() -> precision
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.INumber conjugate() -> conjugate
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> negate
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.ApfloatNum -> org.matheclipse.core.expression.ApfloatNum:
    long serialVersionUID -> serialVersionUID
    org.apfloat.Apfloat fApfloat -> fApfloat
    org.matheclipse.core.expression.ApfloatNum valueOf(double,long) -> valueOf
    org.matheclipse.core.expression.ApfloatNum valueOf(org.apfloat.Apfloat) -> valueOf
    org.matheclipse.core.expression.ApfloatNum valueOf(java.math.BigInteger,long) -> valueOf
    org.matheclipse.core.expression.ApfloatNum valueOf(java.math.BigInteger,java.math.BigInteger,long) -> valueOf
    org.matheclipse.core.expression.ApfloatNum valueOf(java.lang.String,int) -> valueOf
    void <init>(double,long) -> <init>
    void <init>(java.lang.String,long) -> <init>
    void <init>(java.math.BigInteger,long) -> <init>
    void <init>(org.apfloat.Apfloat) -> <init>
    int hierarchy() -> hierarchy
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumEqualRational(org.matheclipse.core.interfaces.IRational) -> isNumEqualRational
    boolean isNumIntValue() -> isNumIntValue
    boolean isNegative() -> isNegative
    boolean isPositive() -> isPositive
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INum add(org.matheclipse.core.interfaces.INum) -> add
    org.matheclipse.core.interfaces.INum multiply(org.matheclipse.core.interfaces.INum) -> multiply
    org.matheclipse.core.interfaces.INum pow(org.matheclipse.core.interfaces.INum) -> pow
    long precision() -> precision
    org.matheclipse.core.expression.ApfloatNum eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    double doubleValue() -> doubleValue
    org.apfloat.Apfloat apfloatValue() -> apfloatValue
    boolean equals(java.lang.Object) -> equals
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    org.apfloat.Apfloat exp() -> exp
    int hashCode() -> hashCode
    int intValue() -> intValue
    int toInt() -> toInt
    long toLong() -> toLong
    org.apfloat.Apfloat log() -> log
    long longValue() -> longValue
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.expression.ApfloatNum negate() -> negate
    org.matheclipse.core.expression.ApfloatNum opposite() -> opposite
    org.matheclipse.core.expression.ApfloatNum inverse() -> inverse
    org.apfloat.Apfloat sqrt() -> sqrt
    double getRealPart() -> getRealPart
    boolean isE() -> isE
    boolean isMinusOne() -> isMinusOne
    boolean isOne() -> isOne
    boolean isPi() -> isPi
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isZero() -> isZero
    org.matheclipse.core.interfaces.IInteger round() -> round
    int sign() -> sign
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISymbol head() -> head
    java.lang.String toString() -> toString
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    org.apfloat.Apcomplex apcomplexValue(long) -> apcomplexValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> negate
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.Blank -> org.matheclipse.core.expression.Blank:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr fCondition -> fCondition
    boolean fDefault -> fDefault
    org.matheclipse.core.expression.Blank NULL_PATTERN -> a
    org.matheclipse.core.interfaces.IPattern valueOf() -> valueOf
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.IExpr) -> valueOf
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,boolean) -> <init>
    int[] addPattern(org.matheclipse.core.patternmatching.PatternMap,java.util.Map) -> addPattern
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean equivalent(org.matheclipse.core.interfaces.IPatternObject,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> equivalent
    boolean equals(java.lang.Object) -> equals
    boolean matchPattern(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap) -> matchPattern
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    int getIndex(org.matheclipse.core.patternmatching.PatternMap) -> getIndex
    int getEvalFlags() -> getEvalFlags
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> getSymbol
    int hashCode() -> hashCode
    org.matheclipse.core.interfaces.ISymbol head() -> head
    int hierarchy() -> hierarchy
    boolean isBlank() -> isBlank
    boolean isCase(org.matheclipse.core.interfaces.IExpr) -> isCase
    boolean isPatternDefault() -> isPatternDefault
    boolean isPatternExpr() -> isPatternExpr
    boolean isFreeOfPatterns() -> isFreeOfPatterns
    boolean isConditionMatched(org.matheclipse.core.interfaces.IExpr) -> isConditionMatched
    java.lang.String internalFormString(boolean,int) -> internalFormString
    java.lang.String fullFormString() -> fullFormString
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    java.lang.Object writeReplace() -> writeReplace
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> compareTo
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.ComplexNum -> org.matheclipse.core.expression.ComplexNum:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.expression.ComplexNum I -> I
    org.matheclipse.core.expression.ComplexNum NaN -> NaN
    org.matheclipse.core.expression.ComplexNum ONE -> ONE
    org.matheclipse.core.expression.ComplexNum ZERO -> ZERO
    org.apache.commons.math3.complex.Complex fComplex -> fComplex
    org.matheclipse.core.expression.ComplexNum newInstance(org.apache.commons.math3.complex.Complex) -> newInstance
    org.matheclipse.core.expression.ComplexNum valueOf(org.matheclipse.core.interfaces.INum) -> valueOf
    org.matheclipse.core.expression.ComplexNum valueOf(org.apache.commons.math3.complex.Complex) -> valueOf
    org.matheclipse.core.expression.ComplexNum valueOf(double) -> valueOf
    org.matheclipse.core.expression.ComplexNum valueOf(double,double) -> valueOf
    void <init>(double,double) -> <init>
    double getImaginaryPart() -> getImaginaryPart
    double getRealPart() -> getRealPart
    boolean isZero() -> isZero
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IComplexNum add(org.matheclipse.core.interfaces.IComplexNum) -> add
    org.matheclipse.core.expression.ComplexNum add(org.matheclipse.core.expression.ComplexNum) -> add
    org.apfloat.Apcomplex apcomplexValue(long) -> apcomplexValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    org.matheclipse.core.interfaces.IComplexNum multiply(org.matheclipse.core.interfaces.IComplexNum) -> multiply
    org.matheclipse.core.interfaces.IComplexNum pow(org.matheclipse.core.interfaces.IComplexNum) -> pow
    org.apache.commons.math3.complex.Complex add(org.apache.commons.math3.complex.Complex) -> add
    org.matheclipse.core.interfaces.IComplexNum conjugate() -> conjugate
    org.apache.commons.math3.complex.Complex divide(org.apache.commons.math3.complex.Complex) -> divide
    org.matheclipse.core.expression.ComplexNum divide(org.matheclipse.core.expression.ComplexNum) -> divide
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    double dabs() -> dabs
    double dabs(org.apache.commons.math3.complex.Complex) -> dabs
    org.matheclipse.core.expression.Num eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    double getImaginary() -> getImaginary
    double getReal() -> getReal
    int hashCode() -> hashCode
    boolean isInfinite() -> isInfinite
    boolean isNaN() -> isNaN
    org.matheclipse.core.expression.ComplexNum multiply(org.matheclipse.core.expression.ComplexNum) -> multiply
    org.matheclipse.core.expression.ComplexNum negate() -> negate
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.apache.commons.math3.complex.Complex subtract(org.apache.commons.math3.complex.Complex) -> subtract
    org.matheclipse.core.expression.ComplexNum subtract(org.matheclipse.core.expression.ComplexNum) -> subtract
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    java.lang.String toString() -> toString
    int complexSign() -> complexSign
    int compareTo(org.apache.commons.math3.complex.Complex) -> compareTo
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> head
    org.apache.commons.math3.complex.Complex complexValue() -> complexValue
    org.matheclipse.parser.client.math.Complex getCMComplex() -> getCMComplex
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.INumber conjugate() -> conjugate
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> negate
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.ComplexSym -> org.matheclipse.core.expression.ComplexSym:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.fraction.BigFraction _real -> _real
    org.apache.commons.math3.fraction.BigFraction _imaginary -> _imaginary
    int fHashValue -> a
    org.matheclipse.core.expression.ComplexSym ZERO -> ZERO
    void <init>() -> <init>
    org.matheclipse.core.expression.ComplexSym valueOf(java.math.BigInteger,java.math.BigInteger) -> valueOf
    org.matheclipse.core.expression.ComplexSym valueOf(java.math.BigInteger) -> valueOf
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> valueOf
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IInteger) -> valueOf
    org.matheclipse.core.expression.ComplexSym valueOf(org.apache.commons.math3.fraction.BigFraction) -> valueOf
    org.matheclipse.core.expression.ComplexSym valueOf(org.apache.commons.math3.fraction.BigFraction,org.apache.commons.math3.fraction.BigFraction) -> valueOf
    org.matheclipse.core.expression.ComplexSym valueOf(long,long,long,long) -> valueOf
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IFraction) -> valueOf
    org.matheclipse.core.expression.ComplexSym valueOf(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> valueOf
    org.matheclipse.core.interfaces.IComplex conjugate() -> conjugate
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    org.matheclipse.core.expression.ComplexSym add(org.matheclipse.core.expression.ComplexSym) -> add
    org.matheclipse.core.interfaces.IComplex add(org.matheclipse.core.interfaces.IComplex) -> add
    org.apfloat.Apcomplex apcomplexValue(long) -> apcomplexValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INumber numericNumber() -> numericNumber
    org.apache.commons.math3.fraction.BigFraction getImaginaryPart() -> getImaginaryPart
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.apache.commons.math3.fraction.BigFraction getRealPart() -> getRealPart
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    boolean isZero() -> isZero
    org.matheclipse.core.interfaces.IComplex multiply(org.matheclipse.core.interfaces.IComplex) -> multiply
    org.matheclipse.core.interfaces.IComplex pow(int) -> pow
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.expression.ComplexSym negate() -> negate
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.INumber normalize() -> normalize
    int complexSign() -> complexSign
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> head
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.INumber conjugate() -> conjugate
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> negate
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.ComplexUtils -> org.matheclipse.core.expression.ComplexUtils:
    void <init>() -> <init>
    org.matheclipse.core.expression.ComplexNum acos(org.matheclipse.core.expression.ComplexNum) -> acos
    org.matheclipse.core.expression.ComplexNum asin(org.matheclipse.core.expression.ComplexNum) -> asin
    org.matheclipse.core.expression.ComplexNum atan(org.matheclipse.core.expression.ComplexNum) -> atan
    org.matheclipse.core.expression.ComplexNum cos(org.matheclipse.core.expression.ComplexNum) -> cos
    org.matheclipse.core.expression.ComplexNum cosh(org.matheclipse.core.expression.ComplexNum) -> cosh
    org.matheclipse.core.expression.ComplexNum exp(org.matheclipse.core.expression.ComplexNum) -> exp
    org.matheclipse.core.expression.ComplexNum log(org.matheclipse.core.expression.ComplexNum) -> log
    org.matheclipse.core.expression.ComplexNum polar2Complex(double,double) -> polar2Complex
    org.matheclipse.core.expression.ComplexNum pow(org.matheclipse.core.expression.ComplexNum,org.matheclipse.core.expression.ComplexNum) -> pow
    org.matheclipse.core.expression.ComplexNum sin(org.matheclipse.core.expression.ComplexNum) -> sin
    org.matheclipse.core.expression.ComplexNum sinh(org.matheclipse.core.expression.ComplexNum) -> sinh
    org.matheclipse.core.expression.ComplexNum sqrt(org.matheclipse.core.expression.ComplexNum) -> sqrt
    org.matheclipse.core.expression.ComplexNum sqrt1z(org.matheclipse.core.expression.ComplexNum) -> sqrt1z
    org.matheclipse.core.expression.ComplexNum tan(org.matheclipse.core.expression.ComplexNum) -> tan
    org.matheclipse.core.expression.ComplexNum tanh(org.matheclipse.core.expression.ComplexNum) -> tanh
org.matheclipse.core.expression.ExprField -> org.matheclipse.core.expression.ExprField:
    org.matheclipse.core.expression.ExprField CONST -> CONST
    org.matheclipse.core.expression.ExprFieldElement ONE -> ONE
    org.matheclipse.core.expression.ExprFieldElement ZERO -> ZERO
    void <init>() -> <init>
    org.matheclipse.core.expression.ExprFieldElement getOne() -> getOne
    org.matheclipse.core.expression.ExprFieldElement getZero() -> getZero
    java.lang.Class getRuntimeClass() -> getRuntimeClass
    org.apache.commons.math3.linear.FieldVector list2Vector(org.matheclipse.core.interfaces.IAST) -> list2Vector
    org.apache.commons.math3.linear.FieldMatrix list2Matrix(org.matheclipse.core.interfaces.IAST) -> list2Matrix
    org.matheclipse.core.interfaces.IAST matrix2List(org.apache.commons.math3.linear.FieldMatrix) -> matrix2List
    org.matheclipse.core.interfaces.IAST vector2List(org.apache.commons.math3.linear.FieldVector) -> vector2List
    java.lang.Object getOne() -> getOne
    java.lang.Object getZero() -> getZero
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.ExprFieldElement -> org.matheclipse.core.expression.ExprFieldElement:
    org.matheclipse.core.interfaces.IExpr val -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.expression.ExprFieldElement add(org.matheclipse.core.expression.ExprFieldElement) -> add
    int compareTo(org.matheclipse.core.expression.ExprFieldElement) -> compareTo
    org.matheclipse.core.expression.ExprFieldElement divide(org.matheclipse.core.expression.ExprFieldElement) -> divide
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr getExpr() -> getExpr
    org.apache.commons.math3.Field getField() -> getField
    int hashCode() -> hashCode
    org.matheclipse.core.expression.ExprFieldElement multiply(org.matheclipse.core.expression.ExprFieldElement) -> multiply
    org.matheclipse.core.expression.ExprFieldElement multiply(int) -> multiply
    org.matheclipse.core.expression.ExprFieldElement negate() -> negate
    org.matheclipse.core.expression.ExprFieldElement reciprocal() -> reciprocal
    org.matheclipse.core.expression.ExprFieldElement subtract(org.matheclipse.core.expression.ExprFieldElement) -> subtract
    java.lang.String toString() -> toString
    java.lang.Object reciprocal() -> reciprocal
    java.lang.Object divide(java.lang.Object) -> divide
    java.lang.Object multiply(java.lang.Object) -> multiply
    java.lang.Object multiply(int) -> multiply
    java.lang.Object negate() -> negate
    java.lang.Object subtract(java.lang.Object) -> subtract
    java.lang.Object add(java.lang.Object) -> add
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.expression.ExprID -> org.matheclipse.core.expression.ExprID:
    long serialVersionUID -> serialVersionUID
    short fExprID -> fExprID
    void <init>(short) -> <init>
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    short getExprID() -> getExprID
    org.matheclipse.core.interfaces.ISymbol head() -> head
    int hierarchy() -> hierarchy
    java.lang.Object readResolve() -> readResolve
    org.matheclipse.core.interfaces.IExpr head() -> head
org.matheclipse.core.expression.ExprImpl -> org.matheclipse.core.expression.ExprImpl:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.visit.VisitorReplaceAll) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr abs() -> abs
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr[]) -> apply
    org.matheclipse.core.interfaces.IExpr apply(java.util.List) -> apply
    java.lang.Object asType(java.lang.Class) -> asType
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.IExpr copy() -> copy
    org.matheclipse.core.interfaces.INumber conjugate() -> conjugate
    org.matheclipse.core.interfaces.IExpr divide(org.matheclipse.core.interfaces.IExpr) -> divide
    org.matheclipse.core.interfaces.IExpr[] egcd(org.matheclipse.core.interfaces.IExpr) -> egcd
    double evalDouble() -> evalDouble
    org.apache.commons.math3.complex.Complex evalComplex() -> evalComplex
    org.matheclipse.core.interfaces.INumber evalNumber() -> evalNumber
    org.matheclipse.core.interfaces.ISignedNumber evalSignedNumber() -> evalSignedNumber
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    edu.jas.structure.ElemFactory factory() -> factory
    java.lang.String fullFormString() -> fullFormString
    org.matheclipse.core.interfaces.IExpr gcd(org.matheclipse.core.interfaces.IExpr) -> gcd
    org.matheclipse.core.interfaces.IExpr getAt(int) -> getAt
    org.matheclipse.core.interfaces.ISymbol head() -> head
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    boolean isAnd() -> isAnd
    boolean isArcCos() -> isArcCos
    boolean isArcCosh() -> isArcCosh
    boolean isArcSin() -> isArcSin
    boolean isArcSinh() -> isArcSinh
    boolean isArcTan() -> isArcTan
    boolean isArcTanh() -> isArcTanh
    boolean isAST() -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,int) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,org.matheclipse.core.interfaces.IExpr[]) -> isAST
    boolean isAST(java.lang.String) -> isAST
    boolean isAST(java.lang.String,int) -> isAST
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> isASTSizeGE
    boolean isAtom() -> isAtom
    boolean isBlank() -> isBlank
    boolean isComplex() -> isComplex
    boolean isComplexInfinity() -> isComplexInfinity
    boolean isComplexNumeric() -> isComplexNumeric
    boolean isCondition() -> isCondition
    boolean isConstant() -> isConstant
    boolean isCos() -> isCos
    boolean isCosh() -> isCosh
    org.matheclipse.core.interfaces.IAST[] isDerivative() -> isDerivative
    boolean isDirectedInfinity() -> isDirectedInfinity
    boolean isE() -> isE
    boolean isExpanded() -> isExpanded
    boolean isAllExpanded() -> isAllExpanded
    boolean isPlusTimesPower() -> isPlusTimesPower
    boolean isFalse() -> isFalse
    boolean isFlatAST() -> isFlatAST
    boolean isFraction() -> isFraction
    boolean isFree(org.matheclipse.core.interfaces.IExpr) -> isFree
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> isFree
    boolean isFree(com.google.common.base.Predicate,boolean) -> isFree
    boolean isFreeAST(org.matheclipse.core.interfaces.IExpr) -> isFreeAST
    boolean isFreeAST(com.google.common.base.Predicate) -> isFreeAST
    boolean isFreeOfPatterns() -> isFreeOfPatterns
    boolean isFunction() -> isFunction
    boolean isGEOrdered(org.matheclipse.core.interfaces.IExpr) -> isGEOrdered
    boolean isGTOrdered(org.matheclipse.core.interfaces.IExpr) -> isGTOrdered
    boolean isIndeterminate() -> isIndeterminate
    boolean isInfinity() -> isInfinity
    boolean isInteger() -> isInteger
    boolean isIntegerResult() -> isIntegerResult
    boolean isRationalResult() -> isRationalResult
    boolean isRealResult() -> isRealResult
    boolean isNegativeResult() -> isNegativeResult
    boolean isPositiveResult() -> isPositiveResult
    boolean isNonNegativeResult() -> isNonNegativeResult
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> isLEOrdered
    boolean isList() -> isList
    boolean isListOfLists() -> isListOfLists
    boolean isLog() -> isLog
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> isLTOrdered
    int[] isMatrix() -> isMatrix
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> isMember
    boolean isMember(com.google.common.base.Predicate,boolean) -> isMember
    boolean isMinusOne() -> isMinusOne
    boolean isModule() -> isModule
    boolean isNegative() -> isNegative
    boolean isNegativeInfinity() -> isNegativeInfinity
    boolean isNot() -> isNot
    boolean isNumber() -> isNumber
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumEqualRational(org.matheclipse.core.interfaces.IRational) -> isNumEqualRational
    boolean isNumeric() -> isNumeric
    boolean isNumericFunction() -> isNumericFunction
    boolean isNumericMode() -> isNumericMode
    boolean isNumIntValue() -> isNumIntValue
    boolean isOne() -> isOne
    boolean isONE() -> isONE
    boolean isOr() -> isOr
    boolean isOrderlessAST() -> isOrderlessAST
    boolean isPattern() -> isPattern
    boolean isPatternDefault() -> isPatternDefault
    boolean isPatternExpr() -> isPatternExpr
    boolean isPatternSequence() -> isPatternSequence
    boolean isPi() -> isPi
    boolean isPlus() -> isPlus
    boolean isPolynomial(org.matheclipse.core.interfaces.ISymbol) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.IAST) -> isPolynomial
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.ISymbol,long) -> isPolynomialOfMaxDegree
    boolean isPositive() -> isPositive
    boolean isPower() -> isPower
    boolean isRational() -> isRational
    boolean isRuleAST() -> isRuleAST
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> isSame
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    boolean isSequence() -> isSequence
    boolean isSignedNumber() -> isSignedNumber
    boolean isSin() -> isSin
    boolean isSinh() -> isSinh
    boolean isSlot() -> isSlot
    boolean isSlotSequence() -> isSlotSequence
    boolean isSymbol() -> isSymbol
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isTan() -> isTan
    boolean isTanh() -> isTanh
    boolean isTimes() -> isTimes
    boolean isTrue() -> isTrue
    boolean isUnit() -> isUnit
    boolean isValue() -> isValue
    boolean isVariable() -> isVariable
    int isVector() -> isVector
    boolean isZero() -> isZero
    boolean isZERO() -> isZERO
    long leafCount() -> leafCount
    java.util.List leaves() -> leaves
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.IExpr negative() -> negative
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr optional(org.matheclipse.core.interfaces.IExpr) -> optional
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr inc() -> inc
    org.matheclipse.core.interfaces.IExpr dec() -> dec
    org.matheclipse.core.interfaces.IExpr power(org.matheclipse.core.interfaces.IExpr) -> power
    org.matheclipse.core.interfaces.IExpr power(long) -> power
    org.matheclipse.core.interfaces.IExpr remainder(org.matheclipse.core.interfaces.IExpr) -> remainder
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> replacePart
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> replaceSlots
    int signum() -> signum
    org.matheclipse.core.interfaces.IExpr subtract(org.matheclipse.core.interfaces.IExpr) -> subtract
    org.matheclipse.core.interfaces.IExpr sum(org.matheclipse.core.interfaces.IExpr) -> sum
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.ISymbol topHead() -> topHead
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    edu.jas.structure.AbelianGroupElem subtract(edu.jas.structure.AbelianGroupElem) -> subtract
    edu.jas.structure.AbelianGroupElem sum(edu.jas.structure.AbelianGroupElem) -> sum
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.Element copy() -> copy
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    edu.jas.structure.MonoidElem divide(edu.jas.structure.MonoidElem) -> divide
    edu.jas.structure.MonoidElem multiply(edu.jas.structure.MonoidElem) -> multiply
org.matheclipse.core.expression.ExprRingFactory -> org.matheclipse.core.expression.ExprRingFactory:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.expression.ExprRingFactory CONST -> CONST
    void <init>() -> <init>
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    org.matheclipse.core.interfaces.IExpr fromInteger(long) -> fromInteger
    org.matheclipse.core.interfaces.IExpr valueOf(long) -> valueOf
    org.matheclipse.core.interfaces.IExpr getZERO() -> getZERO
    org.matheclipse.core.interfaces.IExpr copy(org.matheclipse.core.interfaces.IExpr) -> copy
    org.matheclipse.core.interfaces.IExpr fromInteger(java.math.BigInteger) -> fromInteger
    java.util.List generators() -> generators
    boolean isFinite() -> isFinite
    org.matheclipse.core.interfaces.IExpr parse(java.lang.String) -> parse
    org.matheclipse.core.interfaces.IExpr parse(java.io.Reader) -> parse
    org.matheclipse.core.interfaces.IExpr random(int) -> random
    org.matheclipse.core.interfaces.IExpr random(int,java.util.Random) -> random
    java.lang.String toScript() -> toScript
    org.matheclipse.core.interfaces.IExpr getONE() -> getONE
    boolean isAssociative() -> isAssociative
    boolean isCommutative() -> isCommutative
    edu.jas.structure.AbelianGroupElem getZERO() -> getZERO
    edu.jas.structure.Element parse(java.io.Reader) -> parse
    edu.jas.structure.Element parse(java.lang.String) -> parse
    edu.jas.structure.Element copy(edu.jas.structure.Element) -> copy
    edu.jas.structure.Element random(int,java.util.Random) -> random
    edu.jas.structure.Element random(int) -> random
    edu.jas.structure.Element fromInteger(java.math.BigInteger) -> fromInteger
    edu.jas.structure.Element fromInteger(long) -> fromInteger
    edu.jas.structure.MonoidElem getONE() -> getONE
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.F -> org.matheclipse.core.expression.F:
    boolean isSystemStarted -> isSystemStarted
    boolean isSystemInitialized -> isSystemInitialized
    java.util.Map PREDEFINED_INTERNAL_FORM_STRINGS -> PREDEFINED_INTERNAL_FORM_STRINGS
    java.util.Map PREDEFINED_PATTERN_MAP -> PREDEFINED_PATTERN_MAP
    java.util.Map PREDEFINED_SYMBOLS_MAP -> PREDEFINED_SYMBOLS_MAP
    org.matheclipse.core.expression.ISymbolObserver SYMBOL_OBSERVER -> SYMBOL_OBSERVER
    org.matheclipse.core.interfaces.ISymbol Catalan -> Catalan
    org.matheclipse.core.interfaces.ISymbol ComplexInfinity -> ComplexInfinity
    org.matheclipse.core.interfaces.ISymbol Degree -> Degree
    org.matheclipse.core.interfaces.ISymbol E -> E
    org.matheclipse.core.interfaces.ISymbol EulerGamma -> EulerGamma
    org.matheclipse.core.interfaces.ISymbol Glaisher -> Glaisher
    org.matheclipse.core.interfaces.ISymbol GoldenRatio -> GoldenRatio
    org.matheclipse.core.interfaces.ISymbol I -> I
    org.matheclipse.core.interfaces.ISymbol Infinity -> Infinity
    org.matheclipse.core.interfaces.ISymbol Khinchin -> Khinchin
    org.matheclipse.core.interfaces.ISymbol Pi -> Pi
    org.matheclipse.core.interfaces.ISymbol Aborted -> Aborted
    org.matheclipse.core.interfaces.ISymbol Assumptions -> Assumptions
    org.matheclipse.core.interfaces.ISymbol IntegerHead -> IntegerHead
    org.matheclipse.core.interfaces.ISymbol SymbolHead -> SymbolHead
    org.matheclipse.core.interfaces.ISymbol RealHead -> RealHead
    org.matheclipse.core.interfaces.ISymbol PatternHead -> PatternHead
    org.matheclipse.core.interfaces.ISymbol BlankHead -> BlankHead
    org.matheclipse.core.interfaces.ISymbol StringHead -> StringHead
    org.matheclipse.core.interfaces.ISymbol MethodHead -> MethodHead
    org.matheclipse.core.interfaces.ISymbol Algebraics -> Algebraics
    org.matheclipse.core.interfaces.ISymbol Booleans -> Booleans
    org.matheclipse.core.interfaces.ISymbol Complexes -> Complexes
    org.matheclipse.core.interfaces.ISymbol Integers -> Integers
    org.matheclipse.core.interfaces.ISymbol Primes -> Primes
    org.matheclipse.core.interfaces.ISymbol Rationals -> Rationals
    org.matheclipse.core.interfaces.ISymbol Reals -> Reals
    org.matheclipse.core.interfaces.ISymbol False -> False
    org.matheclipse.core.interfaces.ISymbol Alternatives -> Alternatives
    org.matheclipse.core.interfaces.ISymbol Direction -> Direction
    org.matheclipse.core.interfaces.ISymbol List -> List
    org.matheclipse.core.interfaces.ISymbol True -> True
    org.matheclipse.core.interfaces.ISymbol Null -> Null
    org.matheclipse.core.interfaces.ISymbol Second -> Second
    org.matheclipse.core.interfaces.ISymbol Indeterminate -> Indeterminate
    org.matheclipse.core.interfaces.ISymbol Listable -> Listable
    org.matheclipse.core.interfaces.ISymbol Constant -> Constant
    org.matheclipse.core.interfaces.ISymbol NumericFunction -> NumericFunction
    org.matheclipse.core.interfaces.ISymbol Orderless -> Orderless
    org.matheclipse.core.interfaces.ISymbol OneIdentity -> OneIdentity
    org.matheclipse.core.interfaces.ISymbol Flat -> Flat
    org.matheclipse.core.interfaces.ISymbol HoldFirst -> HoldFirst
    org.matheclipse.core.interfaces.ISymbol HoldRest -> HoldRest
    org.matheclipse.core.interfaces.ISymbol HoldAll -> HoldAll
    org.matheclipse.core.interfaces.ISymbol NHoldFirst -> NHoldFirst
    org.matheclipse.core.interfaces.ISymbol NHoldRest -> NHoldRest
    org.matheclipse.core.interfaces.ISymbol NHoldAll -> NHoldAll
    org.matheclipse.core.interfaces.ISymbol Line -> Line
    org.matheclipse.core.interfaces.ISymbol BoxRatios -> BoxRatios
    org.matheclipse.core.interfaces.ISymbol Modulus -> Modulus
    org.matheclipse.core.interfaces.ISymbol MeshRange -> MeshRange
    org.matheclipse.core.interfaces.ISymbol PlotRange -> PlotRange
    org.matheclipse.core.interfaces.ISymbol AxesStyle -> AxesStyle
    org.matheclipse.core.interfaces.ISymbol Automatic -> Automatic
    org.matheclipse.core.interfaces.ISymbol AxesOrigin -> AxesOrigin
    org.matheclipse.core.interfaces.ISymbol Axes -> Axes
    org.matheclipse.core.interfaces.ISymbol Background -> Background
    org.matheclipse.core.interfaces.ISymbol White -> White
    org.matheclipse.core.interfaces.ISymbol Slot -> Slot
    org.matheclipse.core.interfaces.ISymbol SlotSequence -> SlotSequence
    org.matheclipse.core.interfaces.ISymbol Options -> Options
    org.matheclipse.core.interfaces.ISymbol Graphics -> Graphics
    org.matheclipse.core.interfaces.ISymbol Graphics3D -> Graphics3D
    org.matheclipse.core.interfaces.ISymbol Show -> Show
    org.matheclipse.core.interfaces.ISymbol SurfaceGraphics -> SurfaceGraphics
    org.matheclipse.core.interfaces.ISymbol ArcCosh -> ArcCosh
    org.matheclipse.core.interfaces.ISymbol ArcCoth -> ArcCoth
    org.matheclipse.core.interfaces.ISymbol ArcCsc -> ArcCsc
    org.matheclipse.core.interfaces.ISymbol ArcCsch -> ArcCsch
    org.matheclipse.core.interfaces.ISymbol ArcSec -> ArcSec
    org.matheclipse.core.interfaces.ISymbol ArcSech -> ArcSech
    org.matheclipse.core.interfaces.ISymbol ArcSinh -> ArcSinh
    org.matheclipse.core.interfaces.ISymbol ArcTanh -> ArcTanh
    org.matheclipse.core.interfaces.ISymbol Plot -> Plot
    org.matheclipse.core.interfaces.ISymbol Plot3D -> Plot3D
    org.matheclipse.core.interfaces.ISymbol RootOf -> RootOf
    org.matheclipse.core.interfaces.ISymbol Sequence -> Sequence
    org.matheclipse.core.interfaces.ISymbol And -> And
    org.matheclipse.core.interfaces.ISymbol Append -> Append
    org.matheclipse.core.interfaces.ISymbol AppendTo -> AppendTo
    org.matheclipse.core.interfaces.ISymbol Apply -> Apply
    org.matheclipse.core.interfaces.ISymbol Attributes -> Attributes
    org.matheclipse.core.interfaces.ISymbol Array -> Array
    org.matheclipse.core.interfaces.ISymbol ArrayQ -> ArrayQ
    org.matheclipse.core.interfaces.ISymbol AtomQ -> AtomQ
    org.matheclipse.core.interfaces.ISymbol Blank -> Blank
    org.matheclipse.core.interfaces.ISymbol Block -> Block
    org.matheclipse.core.interfaces.ISymbol Break -> Break
    org.matheclipse.core.interfaces.ISymbol Cases -> Cases
    org.matheclipse.core.interfaces.ISymbol Catch -> Catch
    org.matheclipse.core.interfaces.ISymbol Chop -> Chop
    org.matheclipse.core.interfaces.ISymbol Clear -> Clear
    org.matheclipse.core.interfaces.ISymbol ClearAll -> ClearAll
    org.matheclipse.core.interfaces.ISymbol Collect -> Collect
    org.matheclipse.core.interfaces.ISymbol Complex -> Complex
    org.matheclipse.core.interfaces.ISymbol CompoundExpression -> CompoundExpression
    org.matheclipse.core.interfaces.ISymbol Condition -> Condition
    org.matheclipse.core.interfaces.ISymbol Continue -> Continue
    org.matheclipse.core.interfaces.ISymbol Count -> Count
    org.matheclipse.core.interfaces.ISymbol Defer -> Defer
    org.matheclipse.core.interfaces.ISymbol Definition -> Definition
    org.matheclipse.core.interfaces.ISymbol Delete -> Delete
    org.matheclipse.core.interfaces.ISymbol DeleteCases -> DeleteCases
    org.matheclipse.core.interfaces.ISymbol Depth -> Depth
    org.matheclipse.core.interfaces.ISymbol DirectedInfinity -> DirectedInfinity
    org.matheclipse.core.interfaces.ISymbol Drop -> Drop
    org.matheclipse.core.interfaces.ISymbol Do -> Do
    org.matheclipse.core.interfaces.ISymbol Element -> Element
    org.matheclipse.core.interfaces.ISymbol EvenQ -> EvenQ
    org.matheclipse.core.interfaces.ISymbol Exponent -> Exponent
    org.matheclipse.core.interfaces.ISymbol First -> First
    org.matheclipse.core.interfaces.ISymbol FixedPoint -> FixedPoint
    org.matheclipse.core.interfaces.ISymbol Flatten -> Flatten
    org.matheclipse.core.interfaces.ISymbol Fold -> Fold
    org.matheclipse.core.interfaces.ISymbol FoldList -> FoldList
    org.matheclipse.core.interfaces.ISymbol For -> For
    org.matheclipse.core.interfaces.ISymbol FreeQ -> FreeQ
    org.matheclipse.core.interfaces.ISymbol FullForm -> FullForm
    org.matheclipse.core.interfaces.ISymbol Function -> A
    org.matheclipse.core.interfaces.ISymbol Head -> Head
    org.matheclipse.core.interfaces.ISymbol Hold -> Hold
    org.matheclipse.core.interfaces.ISymbol HoldForm -> HoldForm
    org.matheclipse.core.interfaces.ISymbol Identity -> Identity
    org.matheclipse.core.interfaces.ISymbol If -> If
    org.matheclipse.core.interfaces.ISymbol Implies -> Implies
    org.matheclipse.core.interfaces.ISymbol Insert -> Insert
    org.matheclipse.core.interfaces.ISymbol IntegerQ -> IntegerQ
    org.matheclipse.core.interfaces.ISymbol JavaForm -> JavaForm
    org.matheclipse.core.interfaces.ISymbol Last -> Last
    org.matheclipse.core.interfaces.ISymbol LeafCount -> LeafCount
    org.matheclipse.core.interfaces.ISymbol Length -> Length
    org.matheclipse.core.interfaces.ISymbol ListQ -> ListQ
    org.matheclipse.core.interfaces.ISymbol MatchQ -> MatchQ
    org.matheclipse.core.interfaces.ISymbol MathMLForm -> MathMLForm
    org.matheclipse.core.interfaces.ISymbol MemberQ -> MemberQ
    org.matheclipse.core.interfaces.ISymbol Module -> Module
    org.matheclipse.core.interfaces.ISymbol N -> N
    org.matheclipse.core.interfaces.ISymbol Nand -> Nand
    org.matheclipse.core.interfaces.ISymbol Nest -> Nest
    org.matheclipse.core.interfaces.ISymbol NestList -> NestList
    org.matheclipse.core.interfaces.ISymbol NestWhile -> NestWhile
    org.matheclipse.core.interfaces.ISymbol NestWhileList -> NestWhileList
    org.matheclipse.core.interfaces.ISymbol Nor -> Nor
    org.matheclipse.core.interfaces.ISymbol NumberQ -> NumberQ
    org.matheclipse.core.interfaces.ISymbol NumericQ -> NumericQ
    org.matheclipse.core.interfaces.ISymbol OddQ -> OddQ
    org.matheclipse.core.interfaces.ISymbol Or -> Or
    org.matheclipse.core.interfaces.ISymbol Package -> Package
    org.matheclipse.core.interfaces.ISymbol Pattern -> Pattern
    org.matheclipse.core.interfaces.ISymbol Position -> Position
    org.matheclipse.core.interfaces.ISymbol Prepend -> Prepend
    org.matheclipse.core.interfaces.ISymbol PrependTo -> PrependTo
    org.matheclipse.core.interfaces.ISymbol Print -> Print
    org.matheclipse.core.interfaces.ISymbol Quiet -> Quiet
    org.matheclipse.core.interfaces.ISymbol Rational -> Rational
    org.matheclipse.core.interfaces.ISymbol Refine -> Refine
    org.matheclipse.core.interfaces.ISymbol Reap -> Reap
    org.matheclipse.core.interfaces.ISymbol Rest -> Rest
    org.matheclipse.core.interfaces.ISymbol Return -> Return
    org.matheclipse.core.interfaces.ISymbol Riffle -> Riffle
    org.matheclipse.core.interfaces.ISymbol RotateLeft -> RotateLeft
    org.matheclipse.core.interfaces.ISymbol RotateRight -> RotateRight
    org.matheclipse.core.interfaces.ISymbol Rule -> Rule
    org.matheclipse.core.interfaces.ISymbol RuleDelayed -> RuleDelayed
    org.matheclipse.core.interfaces.ISymbol Set -> Set
    org.matheclipse.core.interfaces.ISymbol SetAttributes -> SetAttributes
    org.matheclipse.core.interfaces.ISymbol SetDelayed -> SetDelayed
    org.matheclipse.core.interfaces.ISymbol Sow -> Sow
    org.matheclipse.core.interfaces.ISymbol Switch -> Switch
    org.matheclipse.core.interfaces.ISymbol TeXForm -> TeXForm
    org.matheclipse.core.interfaces.ISymbol TimeConstrained -> TimeConstrained
    org.matheclipse.core.interfaces.ISymbol Throw -> Throw
    org.matheclipse.core.interfaces.ISymbol Trace -> Trace
    org.matheclipse.core.interfaces.ISymbol Unevaluated -> Unevaluated
    org.matheclipse.core.interfaces.ISymbol Unique -> Unique
    org.matheclipse.core.interfaces.ISymbol Unset -> Unset
    org.matheclipse.core.interfaces.ISymbol UpSet -> UpSet
    org.matheclipse.core.interfaces.ISymbol UpSetDelayed -> UpSetDelayed
    org.matheclipse.core.interfaces.ISymbol ValueQ -> ValueQ
    org.matheclipse.core.interfaces.ISymbol Which -> Which
    org.matheclipse.core.interfaces.ISymbol While -> While
    org.matheclipse.core.interfaces.ISymbol Abs -> Abs
    org.matheclipse.core.interfaces.ISymbol AddTo -> AddTo
    org.matheclipse.core.interfaces.ISymbol Apart -> Apart
    org.matheclipse.core.interfaces.ISymbol ArcCos -> ArcCos
    org.matheclipse.core.interfaces.ISymbol ArcCot -> ArcCot
    org.matheclipse.core.interfaces.ISymbol ArcSin -> ArcSin
    org.matheclipse.core.interfaces.ISymbol ArcTan -> ArcTan
    org.matheclipse.core.interfaces.ISymbol Arg -> Arg
    org.matheclipse.core.interfaces.ISymbol Binomial -> Binomial
    org.matheclipse.core.interfaces.ISymbol Boole -> Boole
    org.matheclipse.core.interfaces.ISymbol BooleanMinimize -> BooleanMinimize
    org.matheclipse.core.interfaces.ISymbol Cancel -> Cancel
    org.matheclipse.core.interfaces.ISymbol CartesianProduct -> CartesianProduct
    org.matheclipse.core.interfaces.ISymbol CatalanNumber -> CatalanNumber
    org.matheclipse.core.interfaces.ISymbol Ceiling -> Ceiling
    org.matheclipse.core.interfaces.ISymbol CharacteristicPolynomial -> CharacteristicPolynomial
    org.matheclipse.core.interfaces.ISymbol ChessboardDistance -> ChessboardDistance
    org.matheclipse.core.interfaces.ISymbol Coefficient -> Coefficient
    org.matheclipse.core.interfaces.ISymbol CoefficientList -> CoefficientList
    org.matheclipse.core.interfaces.ISymbol Complement -> Complement
    org.matheclipse.core.interfaces.ISymbol ComposeList -> ComposeList
    org.matheclipse.core.interfaces.ISymbol Conjugate -> Conjugate
    org.matheclipse.core.interfaces.ISymbol ConjugateTranspose -> ConjugateTranspose
    org.matheclipse.core.interfaces.ISymbol ConstantArray -> ConstantArray
    org.matheclipse.core.interfaces.ISymbol ContinuedFraction -> ContinuedFraction
    org.matheclipse.core.interfaces.ISymbol CoprimeQ -> CoprimeQ
    org.matheclipse.core.interfaces.ISymbol Cos -> Cos
    org.matheclipse.core.interfaces.ISymbol Cosh -> Cosh
    org.matheclipse.core.interfaces.ISymbol Cot -> Cot
    org.matheclipse.core.interfaces.ISymbol Coth -> Coth
    org.matheclipse.core.interfaces.ISymbol Cross -> Cross
    org.matheclipse.core.interfaces.ISymbol Csc -> Csc
    org.matheclipse.core.interfaces.ISymbol Csch -> Csch
    org.matheclipse.core.interfaces.ISymbol Curl -> Curl
    org.matheclipse.core.interfaces.ISymbol D -> D
    org.matheclipse.core.interfaces.ISymbol Decrement -> Decrement
    org.matheclipse.core.interfaces.ISymbol Default -> Default
    org.matheclipse.core.interfaces.ISymbol Denominator -> Denominator
    org.matheclipse.core.interfaces.ISymbol Derivative -> Derivative
    org.matheclipse.core.interfaces.ISymbol Det -> Det
    org.matheclipse.core.interfaces.ISymbol DiagonalMatrix -> DiagonalMatrix
    org.matheclipse.core.interfaces.ISymbol DigitQ -> DigitQ
    org.matheclipse.core.interfaces.ISymbol Dimensions -> Dimensions
    org.matheclipse.core.interfaces.ISymbol Discriminant -> Discriminant
    org.matheclipse.core.interfaces.ISymbol Distribute -> Distribute
    org.matheclipse.core.interfaces.ISymbol Divergence -> Divergence
    org.matheclipse.core.interfaces.ISymbol DivideBy -> DivideBy
    org.matheclipse.core.interfaces.ISymbol Divisible -> Divisible
    org.matheclipse.core.interfaces.ISymbol Dot -> Dot
    org.matheclipse.core.interfaces.ISymbol Eigenvalues -> Eigenvalues
    org.matheclipse.core.interfaces.ISymbol Eigenvectors -> Eigenvectors
    org.matheclipse.core.interfaces.ISymbol Equal -> Equal
    org.matheclipse.core.interfaces.ISymbol Equivalent -> Equivalent
    org.matheclipse.core.interfaces.ISymbol Erf -> Erf
    org.matheclipse.core.interfaces.ISymbol Erfc -> Erfc
    org.matheclipse.core.interfaces.ISymbol Erfi -> Erfi
    org.matheclipse.core.interfaces.ISymbol EuclidianDistance -> EuclidianDistance
    org.matheclipse.core.interfaces.ISymbol EulerPhi -> EulerPhi
    org.matheclipse.core.interfaces.ISymbol Exp -> Exp
    org.matheclipse.core.interfaces.ISymbol Expand -> Expand
    org.matheclipse.core.interfaces.ISymbol ExpandAll -> ExpandAll
    org.matheclipse.core.interfaces.ISymbol ExtendedGCD -> ExtendedGCD
    org.matheclipse.core.interfaces.ISymbol Extract -> Extract
    org.matheclipse.core.interfaces.ISymbol Factor -> Factor
    org.matheclipse.core.interfaces.ISymbol Factorial -> Factorial
    org.matheclipse.core.interfaces.ISymbol Factorial2 -> Factorial2
    org.matheclipse.core.interfaces.ISymbol FactorInteger -> FactorInteger
    org.matheclipse.core.interfaces.ISymbol FactorSquareFree -> FactorSquareFree
    org.matheclipse.core.interfaces.ISymbol FactorSquareFreeList -> FactorSquareFreeList
    org.matheclipse.core.interfaces.ISymbol FactorTerms -> FactorTerms
    org.matheclipse.core.interfaces.ISymbol Fibonacci -> Fibonacci
    org.matheclipse.core.interfaces.ISymbol FindRoot -> FindRoot
    org.matheclipse.core.interfaces.ISymbol Fit -> Fit
    org.matheclipse.core.interfaces.ISymbol Floor -> Floor
    org.matheclipse.core.interfaces.ISymbol FractionalPart -> FractionalPart
    org.matheclipse.core.interfaces.ISymbol FrobeniusSolve -> FrobeniusSolve
    org.matheclipse.core.interfaces.ISymbol FromCharacterCode -> FromCharacterCode
    org.matheclipse.core.interfaces.ISymbol FromContinuedFraction -> FromContinuedFraction
    org.matheclipse.core.interfaces.ISymbol FullSimplify -> FullSimplify
    org.matheclipse.core.interfaces.ISymbol Gamma -> Gamma
    org.matheclipse.core.interfaces.ISymbol GCD -> GCD
    org.matheclipse.core.interfaces.ISymbol GeometricMean -> GeometricMean
    org.matheclipse.core.interfaces.ISymbol Greater -> Greater
    org.matheclipse.core.interfaces.ISymbol GreaterEqual -> GreaterEqual
    org.matheclipse.core.interfaces.ISymbol GroebnerBasis -> GroebnerBasis
    org.matheclipse.core.interfaces.ISymbol HarmonicNumber -> HarmonicNumber
    org.matheclipse.core.interfaces.ISymbol HilbertMatrix -> HilbertMatrix
    org.matheclipse.core.interfaces.ISymbol Horner -> Horner
    org.matheclipse.core.interfaces.ISymbol HurwitzZeta -> HurwitzZeta
    org.matheclipse.core.interfaces.ISymbol IdentityMatrix -> IdentityMatrix
    org.matheclipse.core.interfaces.ISymbol Im -> Im
    org.matheclipse.core.interfaces.ISymbol Increment -> Increment
    org.matheclipse.core.interfaces.ISymbol Inner -> Inner
    org.matheclipse.core.interfaces.ISymbol IntegerPart -> IntegerPart
    org.matheclipse.core.interfaces.ISymbol IntegerPartitions -> IntegerPartitions
    org.matheclipse.core.interfaces.ISymbol Integrate -> Integrate
    org.matheclipse.core.interfaces.ISymbol Intersection -> Intersection
    org.matheclipse.core.interfaces.ISymbol Inverse -> Inverse
    org.matheclipse.core.interfaces.ISymbol InverseErf -> InverseErf
    org.matheclipse.core.interfaces.ISymbol InverseFunction -> InverseFunction
    org.matheclipse.core.interfaces.ISymbol JacobiMatrix -> JacobiMatrix
    org.matheclipse.core.interfaces.ISymbol JacobiSymbol -> JacobiSymbol
    org.matheclipse.core.interfaces.ISymbol Join -> Join
    org.matheclipse.core.interfaces.ISymbol KOrderlessPartitions -> KOrderlessPartitions
    org.matheclipse.core.interfaces.ISymbol KPartitions -> KPartitions
    org.matheclipse.core.interfaces.ISymbol LaplaceTransform -> LaplaceTransform
    org.matheclipse.core.interfaces.ISymbol LCM -> LCM
    org.matheclipse.core.interfaces.ISymbol Less -> Less
    org.matheclipse.core.interfaces.ISymbol LessEqual -> LessEqual
    org.matheclipse.core.interfaces.ISymbol LetterQ -> LetterQ
    org.matheclipse.core.interfaces.ISymbol Level -> Level
    org.matheclipse.core.interfaces.ISymbol Limit -> Limit
    org.matheclipse.core.interfaces.ISymbol LinearProgramming -> LinearProgramming
    org.matheclipse.core.interfaces.ISymbol LinearSolve -> LinearSolve
    org.matheclipse.core.interfaces.ISymbol Log -> Log
    org.matheclipse.core.interfaces.ISymbol LowerCaseQ -> LowerCaseQ
    org.matheclipse.core.interfaces.ISymbol LUDecomposition -> LUDecomposition
    org.matheclipse.core.interfaces.ISymbol ManhattanDistance -> ManhattanDistance
    org.matheclipse.core.interfaces.ISymbol Map -> Map
    org.matheclipse.core.interfaces.ISymbol MapAll -> MapAll
    org.matheclipse.core.interfaces.ISymbol MapThread -> MapThread
    org.matheclipse.core.interfaces.ISymbol MatrixPower -> MatrixPower
    org.matheclipse.core.interfaces.ISymbol MatrixQ -> MatrixQ
    org.matheclipse.core.interfaces.ISymbol Max -> Max
    org.matheclipse.core.interfaces.ISymbol Mean -> Mean
    org.matheclipse.core.interfaces.ISymbol Median -> Median
    org.matheclipse.core.interfaces.ISymbol Min -> Min
    org.matheclipse.core.interfaces.ISymbol Mod -> Mod
    org.matheclipse.core.interfaces.ISymbol MoebiusMu -> MoebiusMu
    org.matheclipse.core.interfaces.ISymbol Most -> Most
    org.matheclipse.core.interfaces.ISymbol Multinomial -> Multinomial
    org.matheclipse.core.interfaces.ISymbol Negative -> Negative
    org.matheclipse.core.interfaces.ISymbol NextPrime -> NextPrime
    org.matheclipse.core.interfaces.ISymbol NFourierTransform -> NFourierTransform
    org.matheclipse.core.interfaces.ISymbol NIntegrate -> NIntegrate
    org.matheclipse.core.interfaces.ISymbol NonCommutativeMultiply -> NonCommutativeMultiply
    org.matheclipse.core.interfaces.ISymbol NonNegative -> NonNegative
    org.matheclipse.core.interfaces.ISymbol Norm -> Norm
    org.matheclipse.core.interfaces.ISymbol Not -> Not
    org.matheclipse.core.interfaces.ISymbol NRoots -> NRoots
    org.matheclipse.core.interfaces.ISymbol NSolve -> NSolve
    org.matheclipse.core.interfaces.ISymbol Numerator -> Numerator
    org.matheclipse.core.interfaces.ISymbol O -> O
    org.matheclipse.core.interfaces.ISymbol Order -> Order
    org.matheclipse.core.interfaces.ISymbol OrderedQ -> OrderedQ
    org.matheclipse.core.interfaces.ISymbol Out -> Out
    org.matheclipse.core.interfaces.ISymbol Outer -> Outer
    org.matheclipse.core.interfaces.ISymbol PadLeft -> PadLeft
    org.matheclipse.core.interfaces.ISymbol PadRight -> PadRight
    org.matheclipse.core.interfaces.ISymbol Part -> Part
    org.matheclipse.core.interfaces.ISymbol Partition -> Partition
    org.matheclipse.core.interfaces.ISymbol Permutations -> Permutations
    org.matheclipse.core.interfaces.ISymbol Piecewise -> Piecewise
    org.matheclipse.core.interfaces.ISymbol Plus -> Plus
    org.matheclipse.core.interfaces.ISymbol PolynomialExtendedGCD -> PolynomialExtendedGCD
    org.matheclipse.core.interfaces.ISymbol PolynomialGCD -> PolynomialGCD
    org.matheclipse.core.interfaces.ISymbol PolynomialLCM -> PolynomialLCM
    org.matheclipse.core.interfaces.ISymbol PolynomialQ -> PolynomialQ
    org.matheclipse.core.interfaces.ISymbol PolynomialQuotient -> PolynomialQuotient
    org.matheclipse.core.interfaces.ISymbol PolynomialQuotientRemainder -> PolynomialQuotientRemainder
    org.matheclipse.core.interfaces.ISymbol PolynomialRemainder -> PolynomialRemainder
    org.matheclipse.core.interfaces.ISymbol Positive -> Positive
    org.matheclipse.core.interfaces.ISymbol PossibleZeroQ -> PossibleZeroQ
    org.matheclipse.core.interfaces.ISymbol Power -> Power
    org.matheclipse.core.interfaces.ISymbol PowerExpand -> PowerExpand
    org.matheclipse.core.interfaces.ISymbol PowerMod -> PowerMod
    org.matheclipse.core.interfaces.ISymbol PreDecrement -> PreDecrement
    org.matheclipse.core.interfaces.ISymbol PreIncrement -> PreIncrement
    org.matheclipse.core.interfaces.ISymbol PrimeQ -> PrimeQ
    org.matheclipse.core.interfaces.ISymbol PrimitiveRoots -> PrimitiveRoots
    org.matheclipse.core.interfaces.ISymbol Product -> Product
    org.matheclipse.core.interfaces.ISymbol ProductLog -> ProductLog
    org.matheclipse.core.interfaces.ISymbol Quotient -> Quotient
    org.matheclipse.core.interfaces.ISymbol RandomInteger -> RandomInteger
    org.matheclipse.core.interfaces.ISymbol RandomReal -> RandomReal
    org.matheclipse.core.interfaces.ISymbol Range -> Range
    org.matheclipse.core.interfaces.ISymbol Rationalize -> Rationalize
    org.matheclipse.core.interfaces.ISymbol Re -> Re
    org.matheclipse.core.interfaces.ISymbol ReplaceAll -> ReplaceAll
    org.matheclipse.core.interfaces.ISymbol ReplacePart -> ReplacePart
    org.matheclipse.core.interfaces.ISymbol ReplaceRepeated -> ReplaceRepeated
    org.matheclipse.core.interfaces.ISymbol Resultant -> Resultant
    org.matheclipse.core.interfaces.ISymbol Reverse -> Reverse
    org.matheclipse.core.interfaces.ISymbol RootIntervals -> RootIntervals
    org.matheclipse.core.interfaces.ISymbol Roots -> Roots
    org.matheclipse.core.interfaces.ISymbol Round -> Round
    org.matheclipse.core.interfaces.ISymbol RowReduce -> RowReduce
    org.matheclipse.core.interfaces.ISymbol SameQ -> SameQ
    org.matheclipse.core.interfaces.ISymbol Scan -> Scan
    org.matheclipse.core.interfaces.ISymbol Sec -> Sec
    org.matheclipse.core.interfaces.ISymbol Sech -> Sech
    org.matheclipse.core.interfaces.ISymbol Select -> Select
    org.matheclipse.core.interfaces.ISymbol Series -> Series
    org.matheclipse.core.interfaces.ISymbol SeriesData -> SeriesData
    org.matheclipse.core.interfaces.ISymbol Sign -> Sign
    org.matheclipse.core.interfaces.ISymbol SignCmp -> SignCmp
    org.matheclipse.core.interfaces.ISymbol Simplify -> Simplify
    org.matheclipse.core.interfaces.ISymbol Sin -> Sin
    org.matheclipse.core.interfaces.ISymbol Sinc -> Sinc
    org.matheclipse.core.interfaces.ISymbol SingularValueDecomposition -> SingularValueDecomposition
    org.matheclipse.core.interfaces.ISymbol Sinh -> Sinh
    org.matheclipse.core.interfaces.ISymbol Solve -> Solve
    org.matheclipse.core.interfaces.ISymbol Sort -> Sort
    org.matheclipse.core.interfaces.ISymbol Sqrt -> Sqrt
    org.matheclipse.core.interfaces.ISymbol SquaredEuclidianDistance -> SquaredEuclidianDistance
    org.matheclipse.core.interfaces.ISymbol SquareFreeQ -> SquareFreeQ
    org.matheclipse.core.interfaces.ISymbol StirlingS2 -> StirlingS2
    org.matheclipse.core.interfaces.ISymbol StringDrop -> StringDrop
    org.matheclipse.core.interfaces.ISymbol StringJoin -> StringJoin
    org.matheclipse.core.interfaces.ISymbol StringLength -> StringLength
    org.matheclipse.core.interfaces.ISymbol StringTake -> StringTake
    org.matheclipse.core.interfaces.ISymbol Subfactorial -> Subfactorial
    org.matheclipse.core.interfaces.ISymbol Subscript -> Subscript
    org.matheclipse.core.interfaces.ISymbol Subsuperscript -> Subsuperscript
    org.matheclipse.core.interfaces.ISymbol Subsets -> Subsets
    org.matheclipse.core.interfaces.ISymbol SubtractFrom -> SubtractFrom
    org.matheclipse.core.interfaces.ISymbol Superscript -> Superscript
    org.matheclipse.core.interfaces.ISymbol Sum -> Sum
    org.matheclipse.core.interfaces.ISymbol Surd -> Surd
    org.matheclipse.core.interfaces.ISymbol SyntaxLength -> SyntaxLength
    org.matheclipse.core.interfaces.ISymbol SyntaxQ -> SyntaxQ
    org.matheclipse.core.interfaces.ISymbol Table -> Table
    org.matheclipse.core.interfaces.ISymbol Take -> Take
    org.matheclipse.core.interfaces.ISymbol Tan -> Tan
    org.matheclipse.core.interfaces.ISymbol Tanh -> Tanh
    org.matheclipse.core.interfaces.ISymbol Taylor -> Taylor
    org.matheclipse.core.interfaces.ISymbol Thread -> Thread
    org.matheclipse.core.interfaces.ISymbol Through -> Through
    org.matheclipse.core.interfaces.ISymbol Times -> Times
    org.matheclipse.core.interfaces.ISymbol TimesBy -> TimesBy
    org.matheclipse.core.interfaces.ISymbol Timing -> Timing
    org.matheclipse.core.interfaces.ISymbol ToCharacterCode -> ToCharacterCode
    org.matheclipse.core.interfaces.ISymbol Together -> Together
    org.matheclipse.core.interfaces.ISymbol ToString -> ToString
    org.matheclipse.core.interfaces.ISymbol Total -> Total
    org.matheclipse.core.interfaces.ISymbol ToUnicode -> ToUnicode
    org.matheclipse.core.interfaces.ISymbol Tr -> Tr
    org.matheclipse.core.interfaces.ISymbol Transpose -> Transpose
    org.matheclipse.core.interfaces.ISymbol TrigExpand -> TrigExpand
    org.matheclipse.core.interfaces.ISymbol TrigReduce -> TrigReduce
    org.matheclipse.core.interfaces.ISymbol TrigToExp -> TrigToExp
    org.matheclipse.core.interfaces.ISymbol TrueQ -> TrueQ
    org.matheclipse.core.interfaces.ISymbol Unequal -> Unequal
    org.matheclipse.core.interfaces.ISymbol Union -> Union
    org.matheclipse.core.interfaces.ISymbol UnitStep -> UnitStep
    org.matheclipse.core.interfaces.ISymbol UnsameQ -> UnsameQ
    org.matheclipse.core.interfaces.ISymbol UpperCaseQ -> UpperCaseQ
    org.matheclipse.core.interfaces.ISymbol VandermondeMatrix -> VandermondeMatrix
    org.matheclipse.core.interfaces.ISymbol Variables -> Variables
    org.matheclipse.core.interfaces.ISymbol VectorQ -> VectorQ
    org.matheclipse.core.interfaces.ISymbol Xor -> Xor
    org.matheclipse.core.interfaces.ISymbol a -> a
    org.matheclipse.core.interfaces.ISymbol b -> b
    org.matheclipse.core.interfaces.ISymbol c -> c
    org.matheclipse.core.interfaces.ISymbol d -> d
    org.matheclipse.core.interfaces.ISymbol e -> e
    org.matheclipse.core.interfaces.ISymbol f -> f
    org.matheclipse.core.interfaces.ISymbol g -> g
    org.matheclipse.core.interfaces.ISymbol h -> h
    org.matheclipse.core.interfaces.ISymbol i -> i
    org.matheclipse.core.interfaces.ISymbol j -> j
    org.matheclipse.core.interfaces.ISymbol k -> k
    org.matheclipse.core.interfaces.ISymbol l -> l
    org.matheclipse.core.interfaces.ISymbol m -> m
    org.matheclipse.core.interfaces.ISymbol n -> n
    org.matheclipse.core.interfaces.ISymbol o -> o
    org.matheclipse.core.interfaces.ISymbol p -> p
    org.matheclipse.core.interfaces.ISymbol q -> q
    org.matheclipse.core.interfaces.ISymbol r -> r
    org.matheclipse.core.interfaces.ISymbol s -> s
    org.matheclipse.core.interfaces.ISymbol t -> t
    org.matheclipse.core.interfaces.ISymbol u -> u
    org.matheclipse.core.interfaces.ISymbol v -> v
    org.matheclipse.core.interfaces.ISymbol w -> w
    org.matheclipse.core.interfaces.ISymbol x -> x
    org.matheclipse.core.interfaces.ISymbol y -> y
    org.matheclipse.core.interfaces.ISymbol z -> z
    org.matheclipse.core.interfaces.ISymbol ASymbol -> ASymbol
    org.matheclipse.core.interfaces.ISymbol BSymbol -> BSymbol
    org.matheclipse.core.interfaces.ISymbol CSymbol -> CSymbol
    org.matheclipse.core.interfaces.ISymbol FSymbol -> FSymbol
    org.matheclipse.core.interfaces.ISymbol GSymbol -> GSymbol
    org.matheclipse.core.interfaces.IPattern a_ -> a_
    org.matheclipse.core.interfaces.IPattern b_ -> b_
    org.matheclipse.core.interfaces.IPattern c_ -> c_
    org.matheclipse.core.interfaces.IPattern d_ -> d_
    org.matheclipse.core.interfaces.IPattern e_ -> e_
    org.matheclipse.core.interfaces.IPattern f_ -> f_
    org.matheclipse.core.interfaces.IPattern g_ -> g_
    org.matheclipse.core.interfaces.IPattern h_ -> h_
    org.matheclipse.core.interfaces.IPattern i_ -> i_
    org.matheclipse.core.interfaces.IPattern j_ -> j_
    org.matheclipse.core.interfaces.IPattern k_ -> k_
    org.matheclipse.core.interfaces.IPattern l_ -> l_
    org.matheclipse.core.interfaces.IPattern m_ -> m_
    org.matheclipse.core.interfaces.IPattern n_ -> n_
    org.matheclipse.core.interfaces.IPattern o_ -> o_
    org.matheclipse.core.interfaces.IPattern p_ -> p_
    org.matheclipse.core.interfaces.IPattern q_ -> q_
    org.matheclipse.core.interfaces.IPattern r_ -> r_
    org.matheclipse.core.interfaces.IPattern s_ -> s_
    org.matheclipse.core.interfaces.IPattern t_ -> t_
    org.matheclipse.core.interfaces.IPattern u_ -> u_
    org.matheclipse.core.interfaces.IPattern v_ -> v_
    org.matheclipse.core.interfaces.IPattern w_ -> w_
    org.matheclipse.core.interfaces.IPattern x_ -> x_
    org.matheclipse.core.interfaces.IPattern y_ -> y_
    org.matheclipse.core.interfaces.IPattern z_ -> z_
    org.matheclipse.core.interfaces.IPattern A_ -> A_
    org.matheclipse.core.interfaces.IPattern B_ -> B_
    org.matheclipse.core.interfaces.IPattern C_ -> C_
    org.matheclipse.core.interfaces.IPattern F_ -> F_
    org.matheclipse.core.interfaces.IPattern G_ -> G_
    org.matheclipse.core.interfaces.IPattern a_Symbol -> a_Symbol
    org.matheclipse.core.interfaces.IPattern b_Symbol -> b_Symbol
    org.matheclipse.core.interfaces.IPattern c_Symbol -> c_Symbol
    org.matheclipse.core.interfaces.IPattern d_Symbol -> d_Symbol
    org.matheclipse.core.interfaces.IPattern e_Symbol -> e_Symbol
    org.matheclipse.core.interfaces.IPattern f_Symbol -> f_Symbol
    org.matheclipse.core.interfaces.IPattern g_Symbol -> g_Symbol
    org.matheclipse.core.interfaces.IPattern h_Symbol -> h_Symbol
    org.matheclipse.core.interfaces.IPattern i_Symbol -> i_Symbol
    org.matheclipse.core.interfaces.IPattern j_Symbol -> j_Symbol
    org.matheclipse.core.interfaces.IPattern k_Symbol -> k_Symbol
    org.matheclipse.core.interfaces.IPattern l_Symbol -> l_Symbol
    org.matheclipse.core.interfaces.IPattern m_Symbol -> m_Symbol
    org.matheclipse.core.interfaces.IPattern n_Symbol -> n_Symbol
    org.matheclipse.core.interfaces.IPattern o_Symbol -> o_Symbol
    org.matheclipse.core.interfaces.IPattern p_Symbol -> p_Symbol
    org.matheclipse.core.interfaces.IPattern q_Symbol -> q_Symbol
    org.matheclipse.core.interfaces.IPattern r_Symbol -> r_Symbol
    org.matheclipse.core.interfaces.IPattern s_Symbol -> s_Symbol
    org.matheclipse.core.interfaces.IPattern t_Symbol -> t_Symbol
    org.matheclipse.core.interfaces.IPattern u_Symbol -> u_Symbol
    org.matheclipse.core.interfaces.IPattern v_Symbol -> v_Symbol
    org.matheclipse.core.interfaces.IPattern w_Symbol -> w_Symbol
    org.matheclipse.core.interfaces.IPattern x_Symbol -> x_Symbol
    org.matheclipse.core.interfaces.IPattern y_Symbol -> y_Symbol
    org.matheclipse.core.interfaces.IPattern z_Symbol -> z_Symbol
    org.matheclipse.core.interfaces.IPattern a_DEFAULT -> a_DEFAULT
    org.matheclipse.core.interfaces.IPattern b_DEFAULT -> b_DEFAULT
    org.matheclipse.core.interfaces.IPattern c_DEFAULT -> c_DEFAULT
    org.matheclipse.core.interfaces.IPattern d_DEFAULT -> d_DEFAULT
    org.matheclipse.core.interfaces.IPattern e_DEFAULT -> e_DEFAULT
    org.matheclipse.core.interfaces.IPattern f_DEFAULT -> f_DEFAULT
    org.matheclipse.core.interfaces.IPattern g_DEFAULT -> g_DEFAULT
    org.matheclipse.core.interfaces.IPattern h_DEFAULT -> h_DEFAULT
    org.matheclipse.core.interfaces.IPattern i_DEFAULT -> i_DEFAULT
    org.matheclipse.core.interfaces.IPattern j_DEFAULT -> j_DEFAULT
    org.matheclipse.core.interfaces.IPattern k_DEFAULT -> k_DEFAULT
    org.matheclipse.core.interfaces.IPattern l_DEFAULT -> l_DEFAULT
    org.matheclipse.core.interfaces.IPattern m_DEFAULT -> m_DEFAULT
    org.matheclipse.core.interfaces.IPattern n_DEFAULT -> n_DEFAULT
    org.matheclipse.core.interfaces.IPattern o_DEFAULT -> o_DEFAULT
    org.matheclipse.core.interfaces.IPattern p_DEFAULT -> p_DEFAULT
    org.matheclipse.core.interfaces.IPattern q_DEFAULT -> q_DEFAULT
    org.matheclipse.core.interfaces.IPattern r_DEFAULT -> r_DEFAULT
    org.matheclipse.core.interfaces.IPattern s_DEFAULT -> s_DEFAULT
    org.matheclipse.core.interfaces.IPattern t_DEFAULT -> t_DEFAULT
    org.matheclipse.core.interfaces.IPattern u_DEFAULT -> u_DEFAULT
    org.matheclipse.core.interfaces.IPattern v_DEFAULT -> v_DEFAULT
    org.matheclipse.core.interfaces.IPattern w_DEFAULT -> w_DEFAULT
    org.matheclipse.core.interfaces.IPattern x_DEFAULT -> x_DEFAULT
    org.matheclipse.core.interfaces.IPattern y_DEFAULT -> y_DEFAULT
    org.matheclipse.core.interfaces.IPattern z_DEFAULT -> z_DEFAULT
    org.matheclipse.core.interfaces.IPattern A_DEFAULT -> A_DEFAULT
    org.matheclipse.core.interfaces.IPattern B_DEFAULT -> B_DEFAULT
    org.matheclipse.core.interfaces.IPattern C_DEFAULT -> C_DEFAULT
    org.matheclipse.core.interfaces.IPattern F_DEFAULT -> F_DEFAULT
    org.matheclipse.core.interfaces.IPattern G_DEFAULT -> G_DEFAULT
    org.matheclipse.core.expression.IntegerSym C0 -> C0
    org.matheclipse.core.expression.IntegerSym C1 -> C1
    org.matheclipse.core.expression.IntegerSym C2 -> C2
    org.matheclipse.core.expression.IntegerSym C3 -> C3
    org.matheclipse.core.expression.IntegerSym C4 -> C4
    org.matheclipse.core.expression.IntegerSym C5 -> C5
    org.matheclipse.core.expression.IntegerSym C6 -> C6
    org.matheclipse.core.expression.IntegerSym C7 -> C7
    org.matheclipse.core.expression.IntegerSym C8 -> C8
    org.matheclipse.core.expression.IntegerSym C9 -> C9
    org.matheclipse.core.expression.IntegerSym C10 -> C10
    org.matheclipse.core.interfaces.IComplex CI -> CI
    org.matheclipse.core.interfaces.IComplex CNI -> CNI
    org.matheclipse.core.interfaces.IFraction C1D2 -> C1D2
    org.matheclipse.core.interfaces.IFraction CN1D2 -> CN1D2
    org.matheclipse.core.interfaces.IFraction C1D3 -> C1D3
    org.matheclipse.core.interfaces.IFraction CN1D3 -> CN1D3
    org.matheclipse.core.interfaces.IFraction C1D4 -> C1D4
    org.matheclipse.core.interfaces.IFraction CN1D4 -> CN1D4
    org.matheclipse.core.interfaces.INum CD0 -> CD0
    org.matheclipse.core.interfaces.INum CD1 -> CD1
    org.matheclipse.core.interfaces.IAST CInfinity -> CInfinity
    org.matheclipse.core.interfaces.IAST CNInfinity -> CNInfinity
    org.matheclipse.core.interfaces.IAST CIInfinity -> CIInfinity
    org.matheclipse.core.interfaces.IAST CNIInfinity -> CNIInfinity
    org.matheclipse.core.interfaces.IAST CComplexInfinity -> CComplexInfinity
    org.matheclipse.core.interfaces.IAST CSqrt2 -> CSqrt2
    org.matheclipse.core.interfaces.IAST CSqrt3 -> CSqrt3
    org.matheclipse.core.interfaces.IAST CSqrt5 -> CSqrt5
    org.matheclipse.core.interfaces.IAST CSqrt6 -> CSqrt6
    org.matheclipse.core.interfaces.IAST CSqrt7 -> CSqrt7
    org.matheclipse.core.interfaces.IAST CSqrt10 -> CSqrt10
    org.matheclipse.core.interfaces.IAST C1DSqrt2 -> C1DSqrt2
    org.matheclipse.core.interfaces.IAST C1DSqrt3 -> C1DSqrt3
    org.matheclipse.core.interfaces.IAST C1DSqrt5 -> C1DSqrt5
    org.matheclipse.core.interfaces.IAST C1DSqrt6 -> C1DSqrt6
    org.matheclipse.core.interfaces.IAST C1DSqrt7 -> C1DSqrt7
    org.matheclipse.core.interfaces.IAST C1DSqrt10 -> C1DSqrt10
    org.matheclipse.core.interfaces.IAST Slot1 -> Slot1
    org.matheclipse.core.interfaces.IAST Slot2 -> Slot2
    org.matheclipse.core.expression.IntegerSym CN1 -> CN1
    org.matheclipse.core.expression.IntegerSym CN2 -> CN2
    org.matheclipse.core.expression.IntegerSym CN3 -> CN3
    org.matheclipse.core.expression.IntegerSym CN4 -> CN4
    org.matheclipse.core.expression.IntegerSym CN5 -> CN5
    org.matheclipse.core.expression.IntegerSym CN6 -> CN6
    org.matheclipse.core.expression.IntegerSym CN7 -> CN7
    org.matheclipse.core.expression.IntegerSym CN8 -> CN8
    org.matheclipse.core.expression.IntegerSym CN9 -> CN9
    org.matheclipse.core.expression.IntegerSym CN10 -> CN10
    org.matheclipse.core.interfaces.ISymbol AppellF1 -> AppellF1
    org.matheclipse.core.interfaces.ISymbol CosIntegral -> CosIntegral
    org.matheclipse.core.interfaces.ISymbol EllipticE -> EllipticE
    org.matheclipse.core.interfaces.ISymbol EllipticF -> EllipticF
    org.matheclipse.core.interfaces.ISymbol EllipticPi -> EllipticPi
    org.matheclipse.core.interfaces.ISymbol FresnelC -> FresnelC
    org.matheclipse.core.interfaces.ISymbol FresnelS -> FresnelS
    org.matheclipse.core.interfaces.ISymbol HypergeometricPFQ -> HypergeometricPFQ
    org.matheclipse.core.interfaces.ISymbol Hypergeometric2F1 -> Hypergeometric2F1
    org.matheclipse.core.interfaces.ISymbol SinIntegral -> SinIntegral
    org.matheclipse.core.interfaces.ISymbol CoshIntegral -> CoshIntegral
    org.matheclipse.core.interfaces.ISymbol SinhIntegral -> SinhIntegral
    org.matheclipse.core.interfaces.ISymbol ExpIntegralEi -> ExpIntegralEi
    org.matheclipse.core.interfaces.ISymbol LogIntegral -> LogIntegral
    org.matheclipse.core.interfaces.ISymbol PolyLog -> PolyLog
    org.matheclipse.core.interfaces.ISymbol LogGamma -> LogGamma
    org.matheclipse.core.interfaces.ISymbol Zeta -> Zeta
    org.matheclipse.core.interfaces.ISymbol PolyGamma -> PolyGamma
    org.matheclipse.core.interfaces.ISymbol ExpIntegralE -> ExpIntegralE
    java.util.HashMap GLOBAL_IDS_MAP -> GLOBAL_IDS_MAP
    org.matheclipse.core.interfaces.IExpr[] GLOBAL_IDS -> GLOBAL_IDS
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST $(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[]) -> $
    org.matheclipse.core.interfaces.IPattern $b() -> $b
    org.matheclipse.core.interfaces.IPattern $b(org.matheclipse.core.interfaces.IExpr) -> $b
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol) -> $p
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,boolean) -> $p
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> $p
    org.matheclipse.core.interfaces.IPattern $p(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> $p
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String) -> $p
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String,boolean) -> $p
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String,org.matheclipse.core.interfaces.IExpr) -> $p
    org.matheclipse.core.interfaces.IPattern $p(java.lang.String,org.matheclipse.core.interfaces.IExpr,boolean) -> $p
    org.matheclipse.core.interfaces.IPatternSequence $ps(org.matheclipse.core.interfaces.ISymbol) -> $ps
    org.matheclipse.core.interfaces.IPatternSequence $ps(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> $ps
    org.matheclipse.core.interfaces.IPatternSequence $ps(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> $ps
    org.matheclipse.core.interfaces.IPatternSequence $ps(java.lang.String) -> $ps
    org.matheclipse.core.interfaces.ISymbol $s(java.lang.String) -> $s
    org.matheclipse.core.interfaces.ISymbol $s(java.lang.String,boolean) -> $s
    org.matheclipse.core.interfaces.IAST Abs(org.matheclipse.core.interfaces.IExpr) -> Abs
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> and
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> and
    org.matheclipse.core.interfaces.IExpr and(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IExpr and(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IAST And() -> And
    org.matheclipse.core.interfaces.IAST And(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> And
    org.matheclipse.core.interfaces.IAST Alternatives(org.matheclipse.core.interfaces.IExpr[]) -> Alternatives
    org.matheclipse.core.interfaces.IAST Apart(org.matheclipse.core.interfaces.IExpr) -> Apart
    org.matheclipse.core.interfaces.IAST Apart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Apart
    org.matheclipse.core.interfaces.IAST Append(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Append
    org.matheclipse.core.interfaces.IAST Apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Apply
    org.matheclipse.core.interfaces.IAST ArcCos(org.matheclipse.core.interfaces.IExpr) -> ArcCos
    org.matheclipse.core.interfaces.IAST ArcCosh(org.matheclipse.core.interfaces.IExpr) -> ArcCosh
    org.matheclipse.core.interfaces.IAST ArcCot(org.matheclipse.core.interfaces.IExpr) -> ArcCot
    org.matheclipse.core.interfaces.IAST ArcCoth(org.matheclipse.core.interfaces.IExpr) -> ArcCoth
    org.matheclipse.core.interfaces.IAST ArcCsc(org.matheclipse.core.interfaces.IExpr) -> ArcCsc
    org.matheclipse.core.interfaces.IAST ArcCsch(org.matheclipse.core.interfaces.IExpr) -> ArcCsch
    org.matheclipse.core.interfaces.IAST ArcSec(org.matheclipse.core.interfaces.IExpr) -> ArcSec
    org.matheclipse.core.interfaces.IAST ArcSech(org.matheclipse.core.interfaces.IExpr) -> ArcSech
    org.matheclipse.core.interfaces.IAST ArcSin(org.matheclipse.core.interfaces.IExpr) -> ArcSin
    org.matheclipse.core.interfaces.IAST ArcSinh(org.matheclipse.core.interfaces.IExpr) -> ArcSinh
    org.matheclipse.core.interfaces.IAST ArcTan(org.matheclipse.core.interfaces.IExpr) -> ArcTan
    org.matheclipse.core.interfaces.IAST ArcTan(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ArcTan
    org.matheclipse.core.interfaces.IAST ArcTanh(org.matheclipse.core.interfaces.IExpr) -> ArcTanh
    org.matheclipse.core.interfaces.IAST Arg(org.matheclipse.core.interfaces.IExpr) -> Arg
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,int,int) -> ast
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr) -> ast
    org.matheclipse.core.interfaces.IAST headAST0(org.matheclipse.core.interfaces.IExpr) -> headAST0
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr,int,boolean) -> ast
    org.matheclipse.core.interfaces.IAST ast(org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.IExpr) -> ast
    org.matheclipse.core.interfaces.IAST AtomQ(org.matheclipse.core.interfaces.IExpr) -> AtomQ
    org.matheclipse.core.interfaces.IAST BernoulliB(org.matheclipse.core.interfaces.IExpr) -> BernoulliB
    org.matheclipse.core.interfaces.IAST binary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> binary
    org.matheclipse.core.interfaces.IAST binaryAST2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> binaryAST2
    org.matheclipse.core.interfaces.IAST Binomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Binomial
    org.matheclipse.core.interfaces.IAST Block(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Block
    org.matheclipse.core.interfaces.ISymbol bool(boolean) -> bool
    org.matheclipse.core.interfaces.IAST Break() -> Break
    org.matheclipse.core.interfaces.IAST Cancel(org.matheclipse.core.interfaces.IExpr) -> Cancel
    org.matheclipse.core.interfaces.IExpr cast(java.lang.Object) -> cast
    org.matheclipse.core.interfaces.IAST Catch(org.matheclipse.core.interfaces.IExpr) -> Catch
    org.matheclipse.core.interfaces.IComplex CC(org.matheclipse.core.interfaces.IFraction) -> CC
    org.matheclipse.core.interfaces.IComplex CC(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> CC
    org.matheclipse.core.interfaces.IComplex CC(long,long,long,long) -> CC
    org.matheclipse.core.interfaces.IAST Ceiling(org.matheclipse.core.interfaces.IExpr) -> Ceiling
    org.matheclipse.core.interfaces.IAST Clear(org.matheclipse.core.interfaces.IExpr[]) -> Clear
    org.matheclipse.core.interfaces.IAST CNInfinity() -> CNInfinity
    org.matheclipse.core.interfaces.IAST Coefficient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Coefficient
    org.matheclipse.core.interfaces.IAST CoefficientList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> CoefficientList
    org.matheclipse.core.interfaces.IAST Collect(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Collect
    int compareTo(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compareTo
    int compareTo(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> compareTo
    int compareTo(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> compareTo
    int compareTo(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> compareTo
    int compareTo(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.IComplex complex(double,double) -> complex
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IFraction) -> complex
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> complex
    org.matheclipse.core.interfaces.IComplex complex(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> complex
    org.matheclipse.core.interfaces.IComplex complex(long,long,long,long) -> complex
    org.matheclipse.core.interfaces.IComplexNum complexNum(double) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(double,double) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.apache.commons.math3.complex.Complex) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.apfloat.Apfloat,org.apfloat.Apfloat) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.apfloat.Apfloat) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.apfloat.Apcomplex) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IComplex) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IFraction) -> complexNum
    org.matheclipse.core.interfaces.IComplexNum complexNum(org.matheclipse.core.interfaces.IInteger) -> complexNum
    org.matheclipse.core.interfaces.IAST Chop(org.matheclipse.core.interfaces.IExpr) -> Chop
    org.matheclipse.core.interfaces.IAST Complex(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Complex
    org.matheclipse.core.interfaces.IAST CompoundExpression(org.matheclipse.core.interfaces.IExpr[]) -> CompoundExpression
    org.matheclipse.core.interfaces.IAST Condition(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Condition
    org.matheclipse.core.interfaces.IAST Conjugate(org.matheclipse.core.interfaces.IExpr) -> Conjugate
    org.matheclipse.core.interfaces.IAST Continue() -> Continue
    org.matheclipse.core.interfaces.IAST CoprimeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> CoprimeQ
    org.matheclipse.core.interfaces.IAST Cos(org.matheclipse.core.interfaces.IExpr) -> Cos
    org.matheclipse.core.interfaces.IAST Cosh(org.matheclipse.core.interfaces.IExpr) -> Cosh
    org.matheclipse.core.interfaces.IAST Cot(org.matheclipse.core.interfaces.IExpr) -> Cot
    org.matheclipse.core.interfaces.IAST Coth(org.matheclipse.core.interfaces.IExpr) -> Coth
    org.matheclipse.core.interfaces.IAST Count(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Count
    org.matheclipse.core.interfaces.IAST Cross(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Cross
    org.matheclipse.core.interfaces.IAST Csc(org.matheclipse.core.interfaces.IExpr) -> Csc
    org.matheclipse.core.interfaces.IAST Csch(org.matheclipse.core.interfaces.IExpr) -> Csch
    org.matheclipse.core.interfaces.IAST D() -> D
    org.matheclipse.core.interfaces.IAST D(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> D
    org.matheclipse.core.interfaces.IAST Decrement(org.matheclipse.core.interfaces.IExpr) -> Decrement
    org.matheclipse.core.interfaces.IAST Defer(org.matheclipse.core.interfaces.IExpr) -> Defer
    org.matheclipse.core.interfaces.IAST Delete(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Delete
    org.matheclipse.core.interfaces.IAST DeleteCases(org.matheclipse.core.interfaces.IExpr[]) -> DeleteCases
    org.matheclipse.core.interfaces.IAST Denominator(org.matheclipse.core.interfaces.IExpr) -> Denominator
    org.matheclipse.core.interfaces.IAST Depth(org.matheclipse.core.interfaces.IExpr) -> Depth
    org.matheclipse.core.interfaces.IAST Derivative(org.matheclipse.core.interfaces.IExpr[]) -> Derivative
    org.matheclipse.core.interfaces.IAST Det(org.matheclipse.core.interfaces.IExpr) -> Det
    org.matheclipse.core.interfaces.IAST DirectedInfinity(org.matheclipse.core.interfaces.IExpr) -> DirectedInfinity
    org.matheclipse.core.interfaces.IAST Discriminant(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Discriminant
    org.matheclipse.core.interfaces.IAST Distribute(org.matheclipse.core.interfaces.IExpr) -> Distribute
    org.matheclipse.core.interfaces.IAST Distribute(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Distribute
    org.matheclipse.core.interfaces.IAST Distribute(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Distribute
    org.matheclipse.core.interfaces.IExpr div(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> div
    org.matheclipse.core.interfaces.IExpr div(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> div
    org.matheclipse.core.interfaces.IExpr div(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> div
    org.matheclipse.core.interfaces.IExpr div(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> div
    org.matheclipse.core.interfaces.IAST Divide(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Divide
    org.matheclipse.core.interfaces.IAST Divisible(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Divisible
    org.matheclipse.core.interfaces.IAST Do(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Do
    org.matheclipse.core.interfaces.IAST Dot(org.matheclipse.core.interfaces.IExpr[]) -> Dot
    org.matheclipse.core.interfaces.IAST Dot(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Dot
    org.matheclipse.core.interfaces.IAST Drop(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Drop
    org.matheclipse.core.interfaces.IAST Element(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Element
    org.matheclipse.core.interfaces.IAST Equal(org.matheclipse.core.interfaces.IExpr[]) -> Equal
    org.matheclipse.core.interfaces.IAST Equal(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Equal
    boolean equals(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> equals
    boolean equals(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> equals
    boolean equals(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> equals
    boolean equals(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> equals
    boolean equals(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> equals
    org.matheclipse.core.interfaces.IAST Erf(org.matheclipse.core.interfaces.IExpr) -> Erf
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr evalQuiet(org.matheclipse.core.interfaces.IExpr) -> evalQuiet
    org.matheclipse.core.interfaces.IExpr evalQuietNull(org.matheclipse.core.interfaces.IExpr) -> evalQuietNull
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr evalBlock(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> evalBlock
    org.matheclipse.core.interfaces.IExpr evalExpand(org.matheclipse.core.interfaces.IExpr) -> evalExpand
    org.matheclipse.core.interfaces.IExpr expand(org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> expand
    org.matheclipse.core.interfaces.IExpr evalExpandAll(org.matheclipse.core.interfaces.IExpr) -> evalExpandAll
    org.matheclipse.core.interfaces.IExpr expandAll(org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> expandAll
    org.matheclipse.core.interfaces.IExpr evaln(org.matheclipse.core.interfaces.IExpr) -> evaln
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> evalNull
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> evalNull
    org.matheclipse.core.interfaces.IExpr evalNull(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> evalNull
    boolean evalTrue(org.matheclipse.core.interfaces.IExpr) -> evalTrue
    org.matheclipse.core.interfaces.IAST EvenQ(org.matheclipse.core.interfaces.IExpr) -> EvenQ
    org.matheclipse.core.interfaces.IAST Exp(org.matheclipse.core.interfaces.IExpr) -> Exp
    org.matheclipse.core.interfaces.IAST Expand(org.matheclipse.core.interfaces.IExpr) -> Expand
    org.matheclipse.core.interfaces.IAST Expand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Expand
    org.matheclipse.core.interfaces.IAST ExpandAll(org.matheclipse.core.interfaces.IExpr) -> ExpandAll
    org.matheclipse.core.interfaces.IAST Exponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Exponent
    org.matheclipse.core.interfaces.IAST Exponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Exponent
    org.matheclipse.core.interfaces.IAST Extract(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Extract
    org.matheclipse.core.interfaces.IAST Factor(org.matheclipse.core.interfaces.IExpr) -> Factor
    org.matheclipse.core.interfaces.IAST Factorial(org.matheclipse.core.interfaces.IExpr) -> Factorial
    org.matheclipse.core.interfaces.IAST Factorial2(org.matheclipse.core.interfaces.IExpr) -> Factorial2
    org.matheclipse.core.interfaces.IAST FactorInteger(org.matheclipse.core.interfaces.IExpr) -> FactorInteger
    org.matheclipse.core.interfaces.IAST FactorSquareFree(org.matheclipse.core.interfaces.IExpr) -> FactorSquareFree
    org.matheclipse.core.interfaces.IAST FactorSquareFreeList(org.matheclipse.core.interfaces.IExpr) -> FactorSquareFreeList
    org.matheclipse.core.interfaces.IAST Fibonacci(org.matheclipse.core.interfaces.IExpr) -> Fibonacci
    org.matheclipse.core.interfaces.IAST First(org.matheclipse.core.interfaces.IExpr) -> First
    org.matheclipse.core.interfaces.IAST Flatten(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Flatten
    org.matheclipse.core.interfaces.IAST Floor(org.matheclipse.core.interfaces.IExpr) -> Floor
    org.matheclipse.core.interfaces.IFraction fraction(org.apache.commons.math3.fraction.BigFraction) -> fraction
    org.matheclipse.core.interfaces.IFraction fraction(java.math.BigInteger,java.math.BigInteger) -> fraction
    org.matheclipse.core.interfaces.IFraction fraction(double) -> fraction
    org.matheclipse.core.interfaces.IFraction fraction(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> fraction
    org.matheclipse.core.interfaces.IFraction fraction(long,long) -> fraction
    org.matheclipse.core.interfaces.IAST FractionalPart(org.matheclipse.core.interfaces.IExpr) -> FractionalPart
    org.matheclipse.core.interfaces.IAST FreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FreeQ
    org.matheclipse.core.interfaces.IAST FullForm(org.matheclipse.core.interfaces.IExpr) -> FullForm
    org.matheclipse.core.interfaces.IAST FullSimplify(org.matheclipse.core.interfaces.IExpr) -> FullSimplify
    org.matheclipse.core.interfaces.IAST Function(org.matheclipse.core.interfaces.IExpr) -> Function
    org.matheclipse.core.interfaces.IAST Gamma(org.matheclipse.core.interfaces.IExpr) -> Gamma
    org.matheclipse.core.interfaces.IAST Gamma(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Gamma
    org.matheclipse.core.interfaces.IAST GCD(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GCD
    org.matheclipse.core.eval.Namespace getNamespace() -> getNamespace
    org.matheclipse.core.interfaces.IAST Graphics() -> Graphics
    org.matheclipse.core.interfaces.IExpr Greater(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Greater
    org.matheclipse.core.interfaces.IExpr GreaterEqual(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GreaterEqual
    org.matheclipse.core.interfaces.IAST HarmonicNumber(org.matheclipse.core.interfaces.IExpr) -> HarmonicNumber
    org.matheclipse.core.interfaces.IAST HarmonicNumber(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> HarmonicNumber
    org.matheclipse.core.interfaces.IAST Head(org.matheclipse.core.interfaces.IExpr) -> Head
    org.matheclipse.core.interfaces.IAST Hold(org.matheclipse.core.interfaces.IExpr) -> Hold
    org.matheclipse.core.interfaces.IAST HoldForm(org.matheclipse.core.interfaces.IExpr) -> HoldForm
    org.matheclipse.core.interfaces.IAST HurwitzZeta(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> HurwitzZeta
    org.matheclipse.core.interfaces.IAST Identity(org.matheclipse.core.interfaces.IExpr) -> Identity
    org.matheclipse.core.interfaces.IAST If(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> If
    org.matheclipse.core.interfaces.IAST If(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> If
    org.matheclipse.core.interfaces.IExpr Im(org.matheclipse.core.interfaces.IExpr) -> Im
    org.matheclipse.core.interfaces.IAST Increment(org.matheclipse.core.interfaces.IExpr) -> Increment
    org.matheclipse.core.interfaces.ISymbol initFinalSymbol(java.lang.String) -> initFinalSymbol
    org.matheclipse.core.interfaces.ISymbol initFinalSymbol(java.lang.String,org.matheclipse.core.interfaces.IEvaluator) -> initFinalSymbol
    org.matheclipse.core.interfaces.IPattern initPredefinedPattern(org.matheclipse.core.interfaces.ISymbol) -> initPredefinedPattern
    void initSymbols() -> initSymbols
    void initSymbols(java.lang.String,org.matheclipse.core.expression.ISymbolObserver,boolean) -> initSymbols
    void initSymbols(java.io.Reader,org.matheclipse.core.expression.ISymbolObserver) -> initSymbols
    org.matheclipse.core.interfaces.IInteger integer(java.math.BigInteger) -> integer
    org.matheclipse.core.interfaces.IInteger integer(long) -> integer
    org.matheclipse.core.interfaces.IInteger integer(java.lang.String,int) -> integer
    org.matheclipse.core.interfaces.IAST Insert(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Insert
    org.matheclipse.core.interfaces.IAST IntegerPart(org.matheclipse.core.interfaces.IExpr) -> IntegerPart
    org.matheclipse.core.interfaces.IAST IntegerQ(org.matheclipse.core.interfaces.IExpr) -> IntegerQ
    org.matheclipse.core.interfaces.IAST Integrate(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Integrate
    org.matheclipse.core.interfaces.IAST Inverse(org.matheclipse.core.interfaces.IExpr) -> Inverse
    org.matheclipse.core.interfaces.IAST InverseErf(org.matheclipse.core.interfaces.IExpr) -> InverseErf
    org.matheclipse.core.interfaces.IAST InverseFunction(org.matheclipse.core.interfaces.IExpr) -> InverseFunction
    boolean isNumEqualInteger(double,org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumEqualRational(double,org.matheclipse.core.interfaces.IRational) -> isNumEqualRational
    boolean isNumIntValue(double,int) -> isNumIntValue
    boolean isNumIntValue(double) -> isNumIntValue
    boolean isNumIntValue(double,double) -> isNumIntValue
    boolean isZero(double) -> isZero
    boolean isZero(double,double) -> isZero
    org.matheclipse.core.interfaces.IAST Join(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Join
    org.matheclipse.core.interfaces.IAST LaplaceTransform(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LaplaceTransform
    org.matheclipse.core.interfaces.IAST Last(org.matheclipse.core.interfaces.IExpr) -> Last
    org.matheclipse.core.interfaces.IAST LCM(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LCM
    org.matheclipse.core.interfaces.IAST LeafCount(org.matheclipse.core.interfaces.IExpr) -> LeafCount
    org.matheclipse.core.interfaces.IAST Length(org.matheclipse.core.interfaces.IExpr) -> Length
    org.matheclipse.core.interfaces.IExpr Less(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Less
    org.matheclipse.core.interfaces.IExpr LessEqual(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LessEqual
    org.matheclipse.core.interfaces.IAST Limit(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Limit
    org.matheclipse.core.interfaces.IAST Line() -> Line
    org.matheclipse.core.interfaces.IAST LinearSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LinearSolve
    org.matheclipse.core.interfaces.IAST List() -> List
    org.matheclipse.core.interfaces.IAST List(double[]) -> List
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr) -> List
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr[]) -> List
    org.matheclipse.core.interfaces.IAST List(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> List
    org.matheclipse.core.interfaces.IAST List(long[]) -> List
    org.matheclipse.core.interfaces.IAST ListQ(org.matheclipse.core.interfaces.IExpr) -> ListQ
    org.matheclipse.core.interfaces.ISymbol local(java.lang.String) -> local
    org.matheclipse.core.interfaces.ISymbol local(java.lang.String,org.matheclipse.core.interfaces.IExpr) -> local
    org.matheclipse.core.interfaces.IAST Log(org.matheclipse.core.interfaces.IExpr) -> Log
    org.matheclipse.core.interfaces.IAST Log(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Log
    org.matheclipse.core.interfaces.IAST Map(org.matheclipse.core.interfaces.IExpr) -> Map
    org.matheclipse.core.interfaces.IAST Map(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Map
    org.matheclipse.core.interfaces.IAST MapAll(org.matheclipse.core.interfaces.IExpr) -> MapAll
    org.matheclipse.core.interfaces.IAST MatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MatchQ
    org.matheclipse.core.interfaces.IAST MatrixPower(org.matheclipse.core.interfaces.IExpr) -> MatrixPower
    org.matheclipse.core.interfaces.IAST Max() -> Max
    org.matheclipse.core.interfaces.IAST Max(org.matheclipse.core.interfaces.IExpr) -> Max
    org.matheclipse.core.interfaces.IAST Max(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Max
    org.matheclipse.core.interfaces.IAST MemberQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MemberQ
    org.matheclipse.core.interfaces.ISymbol method(java.lang.String,java.lang.String,java.lang.String) -> method
    org.matheclipse.core.interfaces.ISymbol method(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> method
    org.matheclipse.core.interfaces.IAST Min() -> Min
    org.matheclipse.core.interfaces.IAST Min(org.matheclipse.core.interfaces.IExpr) -> Min
    org.matheclipse.core.interfaces.IAST Min(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Min
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> minus
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> minus
    org.matheclipse.core.interfaces.IExpr minus(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr minus(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> mod
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> mod
    org.matheclipse.core.interfaces.IExpr mod(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr mod(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr Mod(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Mod
    org.matheclipse.core.interfaces.IAST Module(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Module
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> multiply
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> multiply
    org.matheclipse.core.interfaces.IExpr multiply(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IExpr multiply(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IAST N(org.matheclipse.core.interfaces.IExpr) -> N
    org.matheclipse.core.interfaces.IExpr Negate(org.matheclipse.core.interfaces.IExpr) -> Negate
    org.matheclipse.core.interfaces.IAST Negative(org.matheclipse.core.interfaces.IExpr) -> Negative
    org.matheclipse.core.interfaces.IAST newInstance(int,org.matheclipse.core.interfaces.IExpr) -> newInstance
    org.matheclipse.core.interfaces.IAST Norm(org.matheclipse.core.interfaces.IExpr) -> Norm
    org.matheclipse.core.interfaces.IAST Not(org.matheclipse.core.interfaces.IExpr) -> Not
    org.matheclipse.core.interfaces.INum num(double) -> num
    org.matheclipse.core.interfaces.INum num(org.matheclipse.core.interfaces.IFraction) -> num
    org.matheclipse.core.interfaces.INum num(org.matheclipse.core.interfaces.IInteger) -> num
    org.matheclipse.core.interfaces.INum num(java.lang.String) -> num
    org.matheclipse.core.interfaces.INum num(org.apfloat.Apfloat) -> num
    org.matheclipse.core.interfaces.IAST NumberQ(org.matheclipse.core.interfaces.IExpr) -> NumberQ
    org.matheclipse.core.interfaces.IAST Numerator(org.matheclipse.core.interfaces.IExpr) -> Numerator
    org.matheclipse.core.interfaces.IAST NumericQ(org.matheclipse.core.interfaces.IExpr) -> NumericQ
    org.matheclipse.core.interfaces.IAST O(org.matheclipse.core.interfaces.IExpr) -> O
    org.matheclipse.core.interfaces.IAST OddQ(org.matheclipse.core.interfaces.IExpr) -> OddQ
    org.matheclipse.core.interfaces.IAST Options(org.matheclipse.core.interfaces.IExpr) -> Options
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> or
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> or
    org.matheclipse.core.interfaces.IExpr or(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IExpr or(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IAST Or() -> Or
    org.matheclipse.core.interfaces.IAST Or(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Or
    org.matheclipse.core.interfaces.IAST Order(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Order
    org.matheclipse.core.interfaces.IAST OrderedQ(org.matheclipse.core.interfaces.IExpr) -> OrderedQ
    org.matheclipse.core.interfaces.IAST Part() -> Part
    org.matheclipse.core.interfaces.IAST Part(org.matheclipse.core.interfaces.IExpr[]) -> Part
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr,java.lang.Integer) -> plus
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr,java.math.BigInteger) -> plus
    org.matheclipse.core.interfaces.IExpr plus(java.lang.Integer,org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr plus(java.math.BigInteger,org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IAST Plus() -> Plus
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr) -> Plus
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr[]) -> Plus
    org.matheclipse.core.interfaces.IAST Plus(long,org.matheclipse.core.interfaces.IExpr[]) -> Plus
    org.matheclipse.core.interfaces.IAST Plus(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Plus
    org.matheclipse.core.interfaces.IAST PolynomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialQ
    org.matheclipse.core.interfaces.IAST PolynomialQuotient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialQuotient
    org.matheclipse.core.interfaces.IAST PolynomialRemainder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialRemainder
    org.matheclipse.core.interfaces.IAST PolynomialQuotientRemainder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialQuotientRemainder
    org.matheclipse.core.interfaces.IAST Position(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Position
    org.matheclipse.core.interfaces.IAST Positive(org.matheclipse.core.interfaces.IExpr) -> Positive
    org.matheclipse.core.interfaces.IAST PossibleZeroQ(org.matheclipse.core.interfaces.IExpr) -> PossibleZeroQ
    org.matheclipse.core.interfaces.IAST Power() -> Power
    org.matheclipse.core.interfaces.IAST Power(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Power
    org.matheclipse.core.interfaces.IExpr Power(org.matheclipse.core.interfaces.IExpr,long) -> Power
    org.matheclipse.core.interfaces.IAST PowerExpand(org.matheclipse.core.interfaces.IExpr) -> PowerExpand
    org.matheclipse.core.interfaces.ISymbol predefinedSymbol(java.lang.String) -> predefinedSymbol
    org.matheclipse.core.interfaces.IAST Prepend(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Prepend
    org.matheclipse.core.interfaces.IAST PrimeQ(org.matheclipse.core.interfaces.IExpr) -> PrimeQ
    org.matheclipse.core.interfaces.IAST Print(org.matheclipse.core.interfaces.IExpr[]) -> Print
    org.matheclipse.core.interfaces.IAST Product(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Product
    org.matheclipse.core.interfaces.IAST ProductLog(org.matheclipse.core.interfaces.IExpr) -> ProductLog
    org.matheclipse.core.interfaces.IAST ProductLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ProductLog
    org.matheclipse.core.interfaces.IFraction QQ(org.apache.commons.math3.fraction.BigFraction) -> QQ
    org.matheclipse.core.interfaces.IFraction QQ(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> QQ
    org.matheclipse.core.interfaces.IFraction QQ(long,long) -> QQ
    org.matheclipse.core.interfaces.IAST quaternary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> quaternary
    org.matheclipse.core.interfaces.IAST quinary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> quinary
    org.matheclipse.core.interfaces.IAST Quiet(org.matheclipse.core.interfaces.IExpr) -> Quiet
    org.matheclipse.core.interfaces.IAST Quotient(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Quotient
    org.matheclipse.core.interfaces.IAST Rational(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Rational
    org.matheclipse.core.interfaces.IExpr Re(org.matheclipse.core.interfaces.IExpr) -> Re
    org.matheclipse.core.interfaces.IAST Reap(org.matheclipse.core.interfaces.IExpr) -> Reap
    org.matheclipse.core.interfaces.IAST Refine(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Refine
    org.matheclipse.core.interfaces.IAST ReplaceAll(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ReplaceAll
    org.matheclipse.core.interfaces.IAST ReplacePart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ReplacePart
    org.matheclipse.core.interfaces.IAST ReplacePart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ReplacePart
    org.matheclipse.core.interfaces.IAST Rest(org.matheclipse.core.interfaces.IExpr) -> Rest
    org.matheclipse.core.interfaces.IAST Resultant(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Resultant
    org.matheclipse.core.interfaces.IAST Return(org.matheclipse.core.interfaces.IExpr) -> Return
    org.matheclipse.core.interfaces.IAST Reverse(org.matheclipse.core.interfaces.IExpr) -> Reverse
    org.matheclipse.core.interfaces.IAST Roots(org.matheclipse.core.interfaces.IExpr) -> Roots
    org.matheclipse.core.interfaces.IAST Round(org.matheclipse.core.interfaces.IExpr) -> Round
    org.matheclipse.core.interfaces.IAST RowReduce(org.matheclipse.core.interfaces.IExpr) -> RowReduce
    org.matheclipse.core.interfaces.IAST Rule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Rule
    org.matheclipse.core.interfaces.IAST RuleDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RuleDelayed
    org.matheclipse.core.interfaces.IAST SameQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SameQ
    org.matheclipse.core.interfaces.IAST Scan(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Scan
    org.matheclipse.core.interfaces.IAST Sec(org.matheclipse.core.interfaces.IExpr) -> Sec
    org.matheclipse.core.interfaces.IAST Sech(org.matheclipse.core.interfaces.IExpr) -> Sech
    org.matheclipse.core.interfaces.IAST senary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> senary
    org.matheclipse.core.interfaces.IAST Select(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Select
    org.matheclipse.core.interfaces.IAST Sequence() -> Sequence
    org.matheclipse.core.interfaces.IAST Sequence(org.matheclipse.core.interfaces.IExpr) -> Sequence
    org.matheclipse.core.interfaces.IAST Sequence(org.matheclipse.core.interfaces.IExpr[]) -> Sequence
    org.matheclipse.core.interfaces.IAST Series(org.matheclipse.core.interfaces.IExpr[]) -> Series
    org.matheclipse.core.interfaces.IAST SeriesData(org.matheclipse.core.interfaces.IExpr[]) -> SeriesData
    org.matheclipse.core.interfaces.IAST SetAttributes(org.matheclipse.core.interfaces.IExpr) -> SetAttributes
    org.matheclipse.core.interfaces.IAST SetAttributes(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SetAttributes
    org.matheclipse.core.interfaces.IAST Set(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Set
    org.matheclipse.core.interfaces.IAST ISet(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ISet
    org.matheclipse.core.interfaces.IAST SetDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SetDelayed
    org.matheclipse.core.interfaces.IAST ISetDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ISetDelayed
    org.matheclipse.core.interfaces.IAST Show(org.matheclipse.core.interfaces.IExpr) -> Show
    org.matheclipse.core.interfaces.IAST Sign(org.matheclipse.core.interfaces.IExpr) -> Sign
    org.matheclipse.core.interfaces.IAST SignCmp(org.matheclipse.core.interfaces.IExpr) -> SignCmp
    org.matheclipse.core.interfaces.IAST Simplify(org.matheclipse.core.interfaces.IExpr) -> Simplify
    org.matheclipse.core.interfaces.IAST Sin(org.matheclipse.core.interfaces.IExpr) -> Sin
    org.matheclipse.core.interfaces.IAST Sinc(org.matheclipse.core.interfaces.IExpr) -> Sinc
    org.matheclipse.core.interfaces.IAST Sinh(org.matheclipse.core.interfaces.IExpr) -> Sinh
    org.matheclipse.core.interfaces.IAST Slot(org.matheclipse.core.interfaces.IExpr) -> Slot
    org.matheclipse.core.interfaces.IAST Slot(int) -> Slot
    org.matheclipse.core.interfaces.IAST Solve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Solve
    org.matheclipse.core.interfaces.IAST Sort(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Sort
    org.matheclipse.core.interfaces.IAST Sow(org.matheclipse.core.interfaces.IExpr) -> Sow
    org.matheclipse.core.interfaces.IAST Sqr(org.matheclipse.core.interfaces.IExpr) -> Sqr
    org.matheclipse.core.interfaces.IAST Sqrt(org.matheclipse.core.interfaces.IExpr) -> Sqrt
    org.matheclipse.core.interfaces.IAST StringJoin(org.matheclipse.core.interfaces.IExpr) -> StringJoin
    org.matheclipse.core.interfaces.IStringX stringx(java.lang.String) -> stringx
    org.matheclipse.core.interfaces.IStringX stringx(java.lang.StringBuffer) -> stringx
    org.matheclipse.core.interfaces.IExpr subst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> subst
    org.matheclipse.core.interfaces.IExpr subst(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> subst
    org.matheclipse.core.interfaces.IExpr subst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> subst
    org.matheclipse.core.interfaces.IAST Subfactorial(org.matheclipse.core.interfaces.IExpr) -> Subfactorial
    org.matheclipse.core.interfaces.IAST Subtract(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Subtract
    org.matheclipse.core.interfaces.IAST Sum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Sum
    org.matheclipse.core.interfaces.IAST SurfaceGraphics() -> SurfaceGraphics
    org.matheclipse.core.interfaces.IAST Take(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Take
    org.matheclipse.core.interfaces.IAST Tan(org.matheclipse.core.interfaces.IExpr) -> Tan
    org.matheclipse.core.interfaces.IAST Tanh(org.matheclipse.core.interfaces.IExpr) -> Tanh
    org.matheclipse.core.interfaces.IAST Taylor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Taylor
    org.matheclipse.core.interfaces.IAST ternary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ternary
    org.matheclipse.core.interfaces.IAST ternaryAST3(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ternaryAST3
    org.matheclipse.core.interfaces.IAST Throw(org.matheclipse.core.interfaces.IExpr) -> Throw
    org.matheclipse.core.interfaces.IAST TimeConstrained(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TimeConstrained
    org.matheclipse.core.interfaces.IAST TimeConstrained(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TimeConstrained
    org.matheclipse.core.interfaces.IAST Times() -> Times
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr) -> Times
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr[]) -> Times
    org.matheclipse.core.interfaces.IAST Times(long,org.matheclipse.core.interfaces.IExpr[]) -> Times
    org.matheclipse.core.interfaces.IAST Times(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Times
    org.matheclipse.core.interfaces.IAST Together(org.matheclipse.core.interfaces.IExpr) -> Together
    org.matheclipse.core.interfaces.IAST Tr(org.matheclipse.core.interfaces.IExpr) -> Tr
    org.matheclipse.core.interfaces.IAST Trace(org.matheclipse.core.interfaces.IExpr) -> Trace
    org.matheclipse.core.interfaces.IAST Transpose(org.matheclipse.core.interfaces.IExpr) -> Transpose
    org.matheclipse.core.interfaces.IAST TrigExpand(org.matheclipse.core.interfaces.IExpr) -> TrigExpand
    org.matheclipse.core.interfaces.IAST TrigReduce(org.matheclipse.core.interfaces.IExpr) -> TrigReduce
    org.matheclipse.core.interfaces.IAST TrigToExp(org.matheclipse.core.interfaces.IExpr) -> TrigToExp
    org.matheclipse.core.interfaces.IAST unary(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> unary
    org.matheclipse.core.interfaces.IAST unaryAST1(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> unaryAST1
    org.matheclipse.core.interfaces.IAST Unequal(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Unequal
    org.matheclipse.core.interfaces.IAST Unevaluated(org.matheclipse.core.interfaces.IExpr) -> Unevaluated
    org.matheclipse.core.interfaces.IAST Unique(org.matheclipse.core.interfaces.IExpr) -> Unique
    org.matheclipse.core.interfaces.IAST UnsameQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UnsameQ
    org.matheclipse.core.interfaces.IAST Unset(org.matheclipse.core.interfaces.IExpr) -> Unset
    org.matheclipse.core.interfaces.IAST UpSet(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UpSet
    org.matheclipse.core.interfaces.IAST UpSetDelayed(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UpSetDelayed
    org.matheclipse.core.interfaces.IAST While(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> While
    org.matheclipse.core.interfaces.IInteger ZZ(java.math.BigInteger) -> ZZ
    org.matheclipse.core.interfaces.IInteger ZZ(long) -> ZZ
    org.matheclipse.core.interfaces.INumber chopNumber(org.matheclipse.core.interfaces.INumber,double) -> chopNumber
    org.matheclipse.core.interfaces.IExpr chopExpr(org.matheclipse.core.interfaces.IExpr,double) -> chopExpr
    org.matheclipse.core.interfaces.IAST AppellF1(org.matheclipse.core.interfaces.IExpr[]) -> AppellF1
    org.matheclipse.core.interfaces.IAST CosIntegral(org.matheclipse.core.interfaces.IExpr) -> CosIntegral
    org.matheclipse.core.interfaces.IAST EllipticE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> EllipticE
    org.matheclipse.core.interfaces.IAST EllipticF(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> EllipticF
    org.matheclipse.core.interfaces.IAST EllipticPi(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> EllipticPi
    org.matheclipse.core.interfaces.IAST FresnelC(org.matheclipse.core.interfaces.IExpr) -> FresnelC
    org.matheclipse.core.interfaces.IAST FresnelS(org.matheclipse.core.interfaces.IExpr) -> FresnelS
    org.matheclipse.core.interfaces.IAST HypergeometricPFQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> HypergeometricPFQ
    org.matheclipse.core.interfaces.IAST Hypergeometric2F1(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Hypergeometric2F1
    org.matheclipse.core.interfaces.IAST SinIntegral(org.matheclipse.core.interfaces.IExpr) -> SinIntegral
    org.matheclipse.core.interfaces.IAST CoshIntegral(org.matheclipse.core.interfaces.IExpr) -> CoshIntegral
    org.matheclipse.core.interfaces.IAST SinhIntegral(org.matheclipse.core.interfaces.IExpr) -> SinhIntegral
    org.matheclipse.core.interfaces.IAST Erfi(org.matheclipse.core.interfaces.IExpr) -> Erfi
    org.matheclipse.core.interfaces.IAST ExpIntegralEi(org.matheclipse.core.interfaces.IExpr) -> ExpIntegralEi
    org.matheclipse.core.interfaces.IAST LogIntegral(org.matheclipse.core.interfaces.IExpr) -> LogIntegral
    org.matheclipse.core.interfaces.IAST PolyLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolyLog
    org.matheclipse.core.interfaces.IAST Erfc(org.matheclipse.core.interfaces.IExpr) -> Erfc
    org.matheclipse.core.interfaces.IAST LogGamma(org.matheclipse.core.interfaces.IExpr) -> LogGamma
    org.matheclipse.core.interfaces.IAST Zeta(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Zeta
    org.matheclipse.core.interfaces.IAST PolyGamma(org.matheclipse.core.interfaces.IExpr) -> PolyGamma
    org.matheclipse.core.interfaces.IAST PolyGamma(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolyGamma
    org.matheclipse.core.interfaces.IAST ExpIntegralE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpIntegralE
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.F$1 -> mH:
    void <init>() -> <init>
    boolean createPredefinedSymbol(java.lang.String) -> createPredefinedSymbol
    void createUserSymbol(org.matheclipse.core.interfaces.ISymbol) -> createUserSymbol
org.matheclipse.core.expression.FractionSym -> org.matheclipse.core.expression.FractionSym:
    long serialVersionUID -> serialVersionUID
    org.apache.commons.math3.fraction.BigFraction fRational -> fRational
    int fHashValue -> a
    org.matheclipse.core.expression.FractionSym newInstance(org.apache.commons.math3.fraction.BigFraction) -> newInstance
    org.matheclipse.core.expression.FractionSym valueOf(java.math.BigInteger) -> valueOf
    org.matheclipse.core.expression.FractionSym valueOf(org.apache.commons.math3.fraction.BigFraction) -> valueOf
    org.matheclipse.core.expression.FractionSym valueOf(java.math.BigInteger,java.math.BigInteger) -> valueOf
    org.matheclipse.core.expression.FractionSym valueOf(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> valueOf
    org.matheclipse.core.expression.FractionSym valueOf(long,long) -> valueOf
    org.matheclipse.core.expression.FractionSym valueOf(double) -> valueOf
    void <init>() -> <init>
    boolean isZero() -> isZero
    boolean isOne() -> isOne
    boolean equalsInt(int) -> equalsInt
    java.math.BigInteger getBigDenominator() -> getBigDenominator
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.apache.commons.math3.fraction.BigFraction getFraction() -> getFraction
    org.matheclipse.core.interfaces.IInteger getDenominator() -> getDenominator
    org.matheclipse.core.interfaces.IInteger getNumerator() -> getNumerator
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IFraction add(org.matheclipse.core.interfaces.IFraction) -> add
    org.matheclipse.core.interfaces.IFraction multiply(org.matheclipse.core.interfaces.IFraction) -> multiply
    boolean isNegative() -> isNegative
    boolean isNumEqualRational(org.matheclipse.core.interfaces.IRational) -> isNumEqualRational
    boolean isPositive() -> isPositive
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    org.matheclipse.core.expression.FractionSym eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    org.apache.commons.math3.fraction.BigFraction add(org.apache.commons.math3.fraction.BigFraction) -> add
    org.apache.commons.math3.fraction.BigFraction divide(org.apache.commons.math3.fraction.BigFraction) -> divide
    java.math.BigInteger[] divideAndRemainder() -> divideAndRemainder
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INumber numericNumber() -> numericNumber
    org.matheclipse.core.interfaces.ISignedNumber normalize() -> normalize
    java.math.BigInteger getDividend() -> getDividend
    java.math.BigInteger getDivisor() -> getDivisor
    int hashCode() -> hashCode
    long longValue() -> longValue
    org.apache.commons.math3.fraction.BigFraction multiply(org.apache.commons.math3.fraction.BigFraction) -> multiply
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    org.matheclipse.core.interfaces.IFraction pow(int) -> pow
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    org.apache.commons.math3.fraction.BigFraction subtract(org.apache.commons.math3.fraction.BigFraction) -> subtract
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    java.lang.String internalFormString(boolean,int) -> internalFormString
    int toInt() -> toInt
    long toLong() -> toLong
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    org.matheclipse.core.interfaces.IExpr gcd(org.matheclipse.core.interfaces.IExpr) -> gcd
    org.apache.commons.math3.fraction.BigFraction getRational() -> getRational
    int sign() -> sign
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IAST factorInteger() -> factorInteger
    org.matheclipse.core.interfaces.IInteger floor() -> floor
    org.matheclipse.core.interfaces.IInteger round() -> round
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISymbol head() -> head
    org.matheclipse.core.interfaces.IFraction abs() -> abs
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    org.apfloat.Apcomplex apcomplexValue(long) -> apcomplexValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    java.lang.Object writeReplace() -> writeReplace
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr abs() -> abs
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    org.matheclipse.core.interfaces.INumber normalize() -> normalize
    org.matheclipse.core.interfaces.IRational abs() -> abs
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.HMArrayList -> org.matheclipse.core.expression.HMArrayList:
    java.io.ObjectStreamField[] serialPersistentFields -> serialPersistentFields
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr[] array -> array
    int firstIndex -> firstIndex
    int lastIndex -> lastIndex
    void <init>() -> <init>
    void <init>(java.util.Collection) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[]) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[]) -> <init>
    void <init>(int) -> <init>
    org.matheclipse.core.interfaces.IExpr arg1() -> arg1
    org.matheclipse.core.interfaces.IExpr arg2() -> arg2
    org.matheclipse.core.interfaces.IExpr arg3() -> arg3
    org.matheclipse.core.interfaces.IExpr arg4() -> arg4
    org.matheclipse.core.interfaces.IExpr arg5() -> arg5
    boolean add(org.matheclipse.core.interfaces.IExpr) -> add
    void add(int,org.matheclipse.core.interfaces.IExpr) -> add
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
    void clear() -> clear
    org.matheclipse.core.interfaces.IAST clone() -> clone
    void ensureCapacity(int) -> ensureCapacity
    org.matheclipse.core.interfaces.IExpr get(int) -> get
    void growAtEnd(int) -> a
    void growAtFront(int) -> b
    void growForInsert(int,int) -> a
    org.matheclipse.core.interfaces.IExpr head() -> head
    void init(org.matheclipse.core.interfaces.IExpr[]) -> init
    void readObject(java.io.ObjectInputStream) -> readObject
    org.matheclipse.core.interfaces.IExpr remove(int) -> remove
    boolean remove(java.lang.Object) -> remove
    void removeRange(int,int) -> removeRange
    org.matheclipse.core.interfaces.IExpr set(int,org.matheclipse.core.interfaces.IExpr) -> set
    int size() -> size
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    void trimToSize() -> trimToSize
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    java.lang.Object remove(int) -> remove
    void add(int,java.lang.Object) -> add
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    boolean add(java.lang.Object) -> add
    java.lang.Object clone() -> clone
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.ISymbolObserver -> org.matheclipse.core.expression.ISymbolObserver:
    boolean createPredefinedSymbol(java.lang.String) -> createPredefinedSymbol
    void createUserSymbol(org.matheclipse.core.interfaces.ISymbol) -> createUserSymbol
org.matheclipse.core.expression.IntegerSym -> org.matheclipse.core.expression.IntegerSym:
    java.math.BigInteger BI_MINUS_ONE -> BI_MINUS_ONE
    long serialVersionUID -> serialVersionUID
    java.math.BigInteger fInteger -> fInteger
    int fHashValue -> a
    org.matheclipse.core.expression.IntegerSym newInstance(java.math.BigInteger) -> newInstance
    org.matheclipse.core.expression.IntegerSym valueOf(long) -> valueOf
    org.matheclipse.core.expression.IntegerSym valueOf(java.lang.String,int) -> valueOf
    void <init>() -> <init>
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INumber numericNumber() -> numericNumber
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IInteger add(org.matheclipse.core.interfaces.IInteger) -> add
    org.matheclipse.core.interfaces.IInteger multiply(org.matheclipse.core.interfaces.IInteger) -> multiply
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.expression.IntegerSym valueOf(java.math.BigInteger) -> valueOf
    org.matheclipse.core.interfaces.IExpr[] egcd(org.matheclipse.core.interfaces.IExpr) -> egcd
    org.matheclipse.core.expression.IntegerSym eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    org.matheclipse.core.expression.IntegerSym add(org.matheclipse.core.expression.IntegerSym) -> add
    int bitLength() -> bitLength
    java.math.BigInteger divide(long) -> divide
    java.math.BigInteger divide(java.math.BigInteger) -> divide
    org.matheclipse.core.expression.IntegerSym quotient(org.matheclipse.core.expression.IntegerSym) -> quotient
    double doubleValue() -> doubleValue
    org.matheclipse.core.expression.IntegerSym gcd(org.matheclipse.core.expression.IntegerSym) -> gcd
    org.matheclipse.core.interfaces.IInteger gcd(org.matheclipse.core.interfaces.IInteger) -> gcd
    org.matheclipse.core.interfaces.IExpr gcd(org.matheclipse.core.interfaces.IExpr) -> gcd
    org.matheclipse.core.expression.IntegerSym lcm(org.matheclipse.core.expression.IntegerSym) -> lcm
    java.math.BigInteger lcm(java.math.BigInteger,java.math.BigInteger) -> lcm
    org.matheclipse.core.interfaces.IInteger lcm(org.matheclipse.core.interfaces.IInteger) -> lcm
    int hashCode() -> hashCode
    boolean isLargerThan(java.math.BigInteger) -> isLargerThan
    boolean isNegative() -> isNegative
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumEqualRational(org.matheclipse.core.interfaces.IRational) -> isNumEqualRational
    boolean isNumIntValue() -> isNumIntValue
    boolean isPositive() -> isPositive
    boolean isProbablePrime() -> isProbablePrime
    boolean isProbablePrime(int) -> isProbablePrime
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isZero() -> isZero
    boolean isOne() -> isOne
    boolean isMinusOne() -> isMinusOne
    int intValue() -> intValue
    long longValue() -> longValue
    org.matheclipse.core.expression.IntegerSym mod(org.matheclipse.core.expression.IntegerSym) -> mod
    org.matheclipse.core.expression.IntegerSym multiply(org.matheclipse.core.expression.IntegerSym) -> multiply
    java.math.BigInteger multiply(long) -> multiply
    org.matheclipse.core.expression.IntegerSym negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    org.matheclipse.core.expression.IntegerSym pow(int) -> pow
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    java.math.BigInteger shiftLeft(int) -> shiftLeft
    java.math.BigInteger shiftRight(int) -> shiftRight
    java.math.BigInteger subtract(java.math.BigInteger) -> subtract
    org.matheclipse.core.interfaces.IInteger subtract(org.matheclipse.core.interfaces.IInteger) -> subtract
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    byte[] toByteArray() -> toByteArray
    java.math.BigInteger getBigDenominator() -> getBigDenominator
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.matheclipse.core.interfaces.IInteger getNumerator() -> getNumerator
    org.matheclipse.core.interfaces.IInteger getDenominator() -> getDenominator
    org.apache.commons.math3.fraction.BigFraction getFraction() -> getFraction
    org.matheclipse.core.interfaces.IAST factorize(org.matheclipse.core.interfaces.IAST) -> factorize
    org.matheclipse.core.interfaces.IExpr exponent(org.matheclipse.core.interfaces.IInteger) -> exponent
    org.matheclipse.core.interfaces.IAST factorInteger() -> factorInteger
    org.matheclipse.core.interfaces.IAST divisors() -> divisors
    org.matheclipse.core.interfaces.IInteger eulerPhi() -> eulerPhi
    org.matheclipse.core.expression.IntegerSym moebiusMu() -> moebiusMu
    org.matheclipse.core.expression.IntegerSym jacobiSymbol(org.matheclipse.core.expression.IntegerSym) -> jacobiSymbol
    org.matheclipse.core.interfaces.IInteger[] primitiveRoots() -> primitiveRoots
    int compareTo(org.matheclipse.core.expression.IntegerSym) -> compareTo
    org.matheclipse.core.interfaces.IInteger[] divideAndRemainder(org.matheclipse.core.interfaces.IInteger) -> divideAndRemainder
    org.matheclipse.core.expression.IntegerSym remainder(org.matheclipse.core.expression.IntegerSym) -> remainder
    org.matheclipse.core.interfaces.IExpr remainder(org.matheclipse.core.interfaces.IExpr) -> remainder
    boolean isEven() -> isEven
    boolean isOdd() -> isOdd
    org.matheclipse.core.expression.IntegerSym modInverse(org.matheclipse.core.expression.IntegerSym) -> modInverse
    org.matheclipse.core.expression.IntegerSym modPow(org.matheclipse.core.expression.IntegerSym,org.matheclipse.core.expression.IntegerSym) -> modPow
    int toInt() -> toInt
    long toLong() -> toLong
    int sign() -> sign
    org.matheclipse.core.interfaces.IInteger sqrt() -> sqrt
    org.matheclipse.core.interfaces.IInteger nthRoot(int) -> nthRoot
    org.matheclipse.core.interfaces.IInteger[] nthRootSplit(int) -> nthRootSplit
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
    org.matheclipse.core.interfaces.IInteger round() -> round
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISymbol head() -> head
    java.lang.String toString() -> toString
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.IRational abs() -> abs
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    org.apfloat.Apcomplex apcomplexValue(long) -> apcomplexValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    java.lang.Object writeReplace() -> writeReplace
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr abs() -> abs
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.RingElem[] egcd(edu.jas.structure.RingElem) -> egcd
    edu.jas.structure.RingElem gcd(edu.jas.structure.RingElem) -> gcd
    edu.jas.structure.AbelianGroupElem abs() -> abs
    edu.jas.structure.AbelianGroupElem negate() -> negate
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    edu.jas.structure.MonoidElem remainder(edu.jas.structure.MonoidElem) -> remainder
    org.matheclipse.core.interfaces.IInteger pow(int) -> pow
    org.matheclipse.core.interfaces.IInteger negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.Matrix -> org.matheclipse.core.expression.Matrix:
    int fColumns -> a
    void <init>(org.matheclipse.core.interfaces.IAST,int) -> <init>
    void <init>(int,int) -> <init>
    void <init>(int[][]) -> <init>
    org.matheclipse.core.interfaces.IAST createAST(int,int) -> createAST
    org.matheclipse.core.interfaces.IAST createAST(int[][]) -> createAST
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr getAt(int,int) -> getAt
    org.matheclipse.core.interfaces.IExpr setAt(int,int,org.matheclipse.core.interfaces.IExpr) -> setAt
    int getColumns() -> getColumns
    int hashCode() -> hashCode
    org.matheclipse.core.expression.Matrix minus(org.matheclipse.core.expression.Matrix) -> minus
    org.matheclipse.core.expression.Matrix multiply(org.matheclipse.core.expression.Matrix) -> multiply
    org.matheclipse.core.expression.Matrix plus(org.matheclipse.core.expression.Matrix) -> plus
    org.matheclipse.core.expression.Matrix power(java.lang.Integer) -> power
org.matheclipse.core.expression.MethodSymbol -> org.matheclipse.core.expression.MethodSymbol:
    long serialVersionUID -> serialVersionUID
    java.lang.reflect.Method fMethod -> fMethod
    void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.String,java.lang.String) -> <init>
    org.matheclipse.core.interfaces.IExpr invoke(org.matheclipse.core.interfaces.IAST) -> invoke
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isTrue() -> isTrue
    boolean isFalse() -> isFalse
    org.matheclipse.core.interfaces.ISymbol head() -> head
    java.lang.String toString() -> toString
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> compareTo
org.matheclipse.core.expression.Num -> org.matheclipse.core.expression.Num:
    long serialVersionUID -> serialVersionUID
    double fDouble -> fDouble
    org.matheclipse.core.expression.Num newInstance(double) -> newInstance
    void <init>(double) -> <init>
    int hierarchy() -> hierarchy
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumEqualRational(org.matheclipse.core.interfaces.IRational) -> isNumEqualRational
    boolean isNumIntValue() -> isNumIntValue
    boolean isNegative() -> isNegative
    boolean isPositive() -> isPositive
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.INum add(org.matheclipse.core.interfaces.INum) -> add
    org.matheclipse.core.interfaces.INum multiply(org.matheclipse.core.interfaces.INum) -> multiply
    org.matheclipse.core.interfaces.INum pow(org.matheclipse.core.interfaces.INum) -> pow
    double valueOf(java.lang.String) -> valueOf
    org.matheclipse.core.expression.Num valueOf(double) -> valueOf
    org.matheclipse.core.expression.Num eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    double plus(double) -> plus
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    int compareTo(double) -> compareTo
    double divide(double) -> divide
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    double exp() -> exp
    int hashCode() -> hashCode
    int intValue() -> intValue
    int toInt() -> toInt
    long toLong() -> toLong
    boolean isInfinite() -> isInfinite
    boolean isNaN() -> isNaN
    double log() -> log
    long longValue() -> longValue
    double times(double) -> times
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    double pow(double) -> pow
    double pow(int) -> pow
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    double sqrt() -> sqrt
    double minus(double) -> minus
    double getRealPart() -> getRealPart
    boolean isE() -> isE
    boolean isOne() -> isOne
    boolean isMinusOne() -> isMinusOne
    boolean isPi() -> isPi
    boolean isZero() -> isZero
    org.matheclipse.core.interfaces.IInteger round() -> round
    int sign() -> sign
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISymbol head() -> head
    java.lang.String toString() -> toString
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    org.apfloat.Apcomplex apcomplexValue(long) -> apcomplexValue
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> negate
    int compareTo(edu.jas.structure.Element) -> compareTo
    edu.jas.structure.MonoidElem inverse() -> inverse
    org.matheclipse.core.interfaces.INumber floor() -> floor
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
org.matheclipse.core.expression.NumberUtil -> org.matheclipse.core.expression.NumberUtil:
    java.math.BigInteger MINUS_ONE -> MINUS_ONE
    boolean[] bad255 -> a
    int[] start -> a
    void <init>() -> <init>
    boolean isZero(org.matheclipse.core.interfaces.IExpr) -> isZero
    boolean isZero(org.apache.commons.math3.fraction.BigFraction) -> isZero
    org.apache.commons.math3.fraction.BigFraction inverse(org.apache.commons.math3.fraction.BigFraction) -> inverse
    boolean isOne(org.matheclipse.core.interfaces.IExpr) -> isOne
    boolean isMinusOne(org.matheclipse.core.interfaces.IExpr) -> isMinusOne
    boolean isLargerThan(java.math.BigInteger,java.math.BigInteger) -> isLargerThan
    boolean isLessThan(java.math.BigInteger,java.math.BigInteger) -> isLessThan
    boolean isNegative(java.math.BigInteger) -> isNegative
    boolean isPositive(java.math.BigInteger) -> isPositive
    boolean isZero(java.math.BigInteger) -> isZero
    boolean isOne(java.math.BigInteger) -> isOne
    boolean isMinusOne(java.math.BigInteger) -> isMinusOne
    boolean isEven(java.math.BigInteger) -> isEven
    boolean isOdd(java.math.BigInteger) -> isOdd
    long toLong(java.math.BigInteger) -> toLong
    int toInt(java.math.BigInteger) -> toInt
    int toInt(double) -> toInt
    long toLong(double) -> toLong
    boolean isLargerThan(org.apache.commons.math3.fraction.BigFraction,org.apache.commons.math3.fraction.BigFraction) -> isLargerThan
    boolean isNegative(org.apache.commons.math3.fraction.BigFraction) -> isNegative
    boolean isPositive(org.apache.commons.math3.fraction.BigFraction) -> isPositive
    java.math.BigInteger floor(org.apache.commons.math3.fraction.BigFraction) -> floor
    java.math.BigInteger ceiling(org.apache.commons.math3.fraction.BigFraction) -> ceiling
    java.math.BigInteger trunc(org.apache.commons.math3.fraction.BigFraction) -> trunc
    java.math.BigInteger integerPart(org.apache.commons.math3.fraction.BigFraction) -> integerPart
    org.apache.commons.math3.fraction.BigFraction fractionalPart(org.apache.commons.math3.fraction.BigFraction) -> fractionalPart
    java.math.BigInteger round(org.apache.commons.math3.fraction.BigFraction,int) -> round
    boolean isPerfectSquare(java.math.BigInteger) -> isPerfectSquare
    boolean isPerfectSquare(org.apache.commons.math3.fraction.BigFraction) -> isPerfectSquare
    boolean isPerfectSquare(long) -> isPerfectSquare
    java.math.BigInteger[] convertToFraction(double) -> convertToFraction
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.Pattern -> org.matheclipse.core.expression.Pattern:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.ISymbol fSymbol -> fSymbol
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol) -> valueOf
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> valueOf
    org.matheclipse.core.interfaces.IPattern valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> valueOf
    void <init>(org.matheclipse.core.interfaces.ISymbol) -> <init>
    void <init>(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> <init>
    void <init>(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> <init>
    int[] addPattern(org.matheclipse.core.patternmatching.PatternMap,java.util.Map) -> addPattern
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean equals(java.lang.Object) -> equals
    boolean equivalent(org.matheclipse.core.interfaces.IPatternObject,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> equivalent
    boolean matchPattern(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap) -> matchPattern
    java.lang.String fullFormString() -> fullFormString
    int getIndex(org.matheclipse.core.patternmatching.PatternMap) -> getIndex
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> getSymbol
    int hashCode() -> hashCode
    org.matheclipse.core.interfaces.ISymbol head() -> head
    int hierarchy() -> hierarchy
    java.lang.String internalFormString(boolean,int) -> internalFormString
    boolean isBlank() -> isBlank
    boolean isPattern() -> isPattern
    java.lang.String toString() -> toString
    java.lang.Object writeReplace() -> writeReplace
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> compareTo
org.matheclipse.core.expression.PatternSequence -> org.matheclipse.core.expression.PatternSequence:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr fCondition -> fCondition
    org.matheclipse.core.interfaces.ISymbol fSymbol -> fSymbol
    boolean fDefault -> fDefault
    org.matheclipse.core.expression.PatternSequence valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,boolean) -> valueOf
    org.matheclipse.core.expression.PatternSequence valueOf(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> valueOf
    org.matheclipse.core.expression.PatternSequence valueOf(org.matheclipse.core.interfaces.ISymbol) -> valueOf
    void <init>() -> <init>
    int[] addPattern(org.matheclipse.core.patternmatching.PatternMap,java.util.Map) -> addPattern
    boolean equals(java.lang.Object) -> equals
    boolean equivalent(org.matheclipse.core.interfaces.IPatternObject,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> equivalent
    boolean matchPattern(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap) -> matchPattern
    boolean matchPatternSequence(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.PatternMap) -> matchPatternSequence
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    int getEvalFlags() -> getEvalFlags
    int getIndex(org.matheclipse.core.patternmatching.PatternMap) -> getIndex
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> getSymbol
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    java.lang.String internalFormString(boolean,int) -> internalFormString
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.ISymbol head() -> head
    boolean isBlank() -> isBlank
    boolean isConditionMatchedSequence(org.matheclipse.core.interfaces.IAST) -> isConditionMatchedSequence
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    boolean isDefault() -> isDefault
    boolean isFreeOfPatterns() -> isFreeOfPatterns
    boolean isPatternExpr() -> isPatternExpr
    boolean isPatternSequence() -> isPatternSequence
    boolean isCase(org.matheclipse.core.interfaces.IExpr) -> isCase
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> compareTo
org.matheclipse.core.expression.Primality -> org.matheclipse.core.expression.Primality:
    java.security.SecureRandom random -> a
    int[] primes -> a
    short[] SHORT_PRIMES -> a
    java.math.BigInteger[] BIprimes -> a
    void <init>() -> <init>
    java.math.BigInteger countPrimes1021(java.math.BigInteger,java.util.Map) -> countPrimes1021
    java.math.BigInteger countPrimes32749(java.math.BigInteger,java.util.Map) -> countPrimes32749
    java.math.BigInteger countExponent(java.math.BigInteger,java.math.BigInteger) -> countExponent
    void pollardRhoFactors(java.math.BigInteger,java.util.Map) -> pollardRhoFactors
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.StringX -> org.matheclipse.core.expression.StringX:
    long serialVersionUID -> serialVersionUID
    java.lang.String fString -> fString
    org.matheclipse.core.expression.StringX newInstance(java.lang.String) -> newInstance
    org.matheclipse.core.expression.StringX copyValueOf(char[]) -> copyValueOf
    org.matheclipse.core.expression.StringX copyValueOf(char[],int,int) -> copyValueOf
    org.matheclipse.core.expression.StringX valueOf(boolean) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(char) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(char[]) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(char[],int,int) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(double) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(float) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(int) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(long) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(java.lang.Object) -> valueOf
    org.matheclipse.core.expression.StringX valueOf(java.lang.StringBuffer) -> valueOf
    void <init>(java.lang.String) -> <init>
    char charAt(int) -> charAt
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    int compareTo(org.matheclipse.core.expression.StringX) -> compareTo
    int compareToIgnoreCase(org.matheclipse.core.expression.StringX) -> compareToIgnoreCase
    java.lang.String concat(org.matheclipse.core.expression.StringX) -> concat
    boolean contentEquals(java.lang.StringBuffer) -> contentEquals
    boolean endsWith(java.lang.String) -> endsWith
    boolean equals(java.lang.Object) -> equals
    boolean equalsIgnoreCase(java.lang.String) -> equalsIgnoreCase
    java.lang.String fullFormString() -> fullFormString
    byte[] getBytes() -> getBytes
    byte[] getBytes(java.lang.String) -> getBytes
    void getChars(int,int,char[],int) -> getChars
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    int indexOf(int) -> indexOf
    int indexOf(int,int) -> indexOf
    int indexOf(java.lang.String) -> indexOf
    int indexOf(java.lang.String,int) -> indexOf
    java.lang.String intern() -> intern
    java.lang.String internalFormString(boolean,int) -> internalFormString
    int lastIndexOf(int) -> lastIndexOf
    int lastIndexOf(int,int) -> lastIndexOf
    int lastIndexOf(java.lang.String) -> lastIndexOf
    int lastIndexOf(java.lang.String,int) -> lastIndexOf
    int length() -> length
    boolean matches(java.lang.String) -> matches
    boolean regionMatches(boolean,int,java.lang.String,int,int) -> regionMatches
    boolean regionMatches(int,java.lang.String,int,int) -> regionMatches
    java.lang.String replace(char,char) -> replace
    java.lang.String replaceFirst(java.lang.String,java.lang.String) -> replaceFirst
    java.lang.String[] split(java.lang.String) -> split
    java.lang.String[] split(java.lang.String,int) -> split
    boolean startsWith(java.lang.String) -> startsWith
    boolean startsWith(java.lang.String,int) -> startsWith
    java.lang.CharSequence subSequence(int,int) -> subSequence
    java.lang.String substring(int) -> substring
    java.lang.String substring(int,int) -> substring
    char[] toCharArray() -> toCharArray
    java.lang.String toLowerCase() -> toLowerCase
    java.lang.String toLowerCase(java.util.Locale) -> toLowerCase
    java.lang.String toUpperCase() -> toUpperCase
    java.lang.String toUpperCase(java.util.Locale) -> toUpperCase
    java.lang.String trim() -> trim
    org.matheclipse.core.interfaces.ISymbol head() -> head
    java.lang.String toString() -> toString
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    int compareTo(edu.jas.structure.Element) -> compareTo
org.matheclipse.core.expression.Symbol -> org.matheclipse.core.expression.Symbol:
    long serialVersionUID -> serialVersionUID
    int fAttributes -> fAttributes
    org.matheclipse.core.interfaces.IEvaluator fEvaluator -> a
    org.matheclipse.core.patternmatching.DownRulesData fDownRulesData -> a
    org.matheclipse.core.patternmatching.UpRulesData fUpRulesData -> a
    org.matheclipse.core.eval.util.OpenIntToIExprHashMap fDefaultValues -> fDefaultValues
    org.matheclipse.core.expression.Symbol$DummyEvaluator DUMMY_EVALUATOR -> DUMMY_EVALUATOR
    java.lang.String fSymbolName -> fSymbolName
    int fHashValue -> fHashValue
    org.matheclipse.core.interfaces.IExpr[] reassignSymbolValue(com.google.common.base.Function,org.matheclipse.core.interfaces.ISymbol) -> reassignSymbolValue
    boolean hasAssignedSymbolValue() -> hasAssignedSymbolValue
    org.matheclipse.core.interfaces.IExpr getAssignedValue() -> getAssignedValue
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,org.matheclipse.core.interfaces.IEvaluator) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr[]) -> apply
    void pushLocalVariable() -> pushLocalVariable
    void pushLocalVariable(org.matheclipse.core.interfaces.IExpr) -> pushLocalVariable
    void popLocalVariable() -> popLocalVariable
    void clear(org.matheclipse.core.eval.EvalEngine) -> clear
    void clearAll(org.matheclipse.core.eval.EvalEngine) -> clearAll
    boolean equals(java.lang.Object) -> equals
    boolean isSymbolName(java.lang.String) -> isSymbolName
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IEvaluationEngine,org.matheclipse.core.interfaces.IExpr) -> evalDownRule
    double evalDouble() -> evalDouble
    org.apache.commons.math3.complex.Complex evalComplex() -> evalComplex
    org.matheclipse.core.interfaces.INumber evalNumber() -> evalNumber
    org.matheclipse.core.interfaces.ISignedNumber evalSignedNumber() -> evalSignedNumber
    org.matheclipse.core.interfaces.IExpr evalUpRule(org.matheclipse.core.interfaces.IEvaluationEngine,org.matheclipse.core.interfaces.IExpr) -> evalUpRule
    int getAttributes() -> getAttributes
    org.matheclipse.core.interfaces.IEvaluator getEvaluator() -> getEvaluator
    boolean hasLocalVariableStack() -> hasLocalVariableStack
    org.matheclipse.core.interfaces.IExpr get() -> get
    void set(org.matheclipse.core.interfaces.IExpr) -> set
    int hashCode() -> hashCode
    int hierarchy() -> hierarchy
    boolean isString(java.lang.String) -> isString
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int,boolean) -> putDownRule
    void removeRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IExpr,boolean) -> removeRule
    org.matheclipse.core.patternmatching.PatternMatcher putDownRule(org.matheclipse.core.patternmatching.PatternMatcherAndInvoker) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> putUpRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> putUpRule
    void setAttributes(int) -> setAttributes
    void setEvaluator(org.matheclipse.core.interfaces.IEvaluator) -> setEvaluator
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    boolean isAtom() -> isAtom
    boolean isConstant() -> isConstant
    boolean isE() -> isE
    boolean isTrue() -> isTrue
    boolean isValue() -> isValue
    boolean isVariable() -> isVariable
    boolean isFalse() -> isFalse
    boolean isIndeterminate() -> isIndeterminate
    boolean isNegative() -> isNegative
    boolean isPi() -> isPi
    boolean isPolynomial(org.matheclipse.core.interfaces.ISymbol) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.IAST) -> isPolynomial
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.ISymbol,long) -> isPolynomialOfMaxDegree
    boolean isPositive() -> isPositive
    org.matheclipse.core.interfaces.ISymbol head() -> head
    java.lang.String getSymbolName() -> getSymbolName
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
    java.lang.String internalFormString(boolean,int) -> internalFormString
    java.lang.String toString() -> toString
    java.lang.String fullFormString() -> fullFormString
    java.util.List definition() -> definition
    org.matheclipse.core.interfaces.IExpr getDefaultValue() -> getDefaultValue
    org.matheclipse.core.interfaces.IExpr getDefaultValue(int) -> getDefaultValue
    void setDefaultValue(org.matheclipse.core.interfaces.IExpr) -> setDefaultValue
    void setDefaultValue(int,org.matheclipse.core.interfaces.IExpr) -> setDefaultValue
    java.lang.String definitionToString() -> definitionToString
    void readObject(java.io.ObjectInputStream) -> readObject
    java.lang.Object writeReplace() -> writeReplace
    void writeObject(java.io.ObjectOutputStream) -> writeObject
    java.lang.Object readResolve() -> readResolve
    void readRules(java.io.ObjectInputStream) -> readRules
    boolean writeRules(java.io.ObjectOutputStream) -> writeRules
    boolean containsRules() -> containsRules
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.IExpr mapConstantDouble(org.matheclipse.core.generic.interfaces.INumericFunction) -> mapConstantDouble
    org.matheclipse.core.interfaces.IExpr negate() -> negate
    org.matheclipse.core.interfaces.IExpr head() -> head
    int compareTo(java.lang.Object) -> compareTo
    edu.jas.structure.AbelianGroupElem negate() -> negate
    int compareTo(edu.jas.structure.Element) -> compareTo
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.patternmatching.PatternMatcherAndInvoker) -> putDownRule
    void <clinit>() -> <clinit>
org.matheclipse.core.expression.Symbol$DummyEvaluator -> mI:
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.expression.Vector -> org.matheclipse.core.expression.Vector:
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    void <init>(int) -> <init>
    void <init>(int[]) -> <init>
    org.matheclipse.core.expression.Vector plus(org.matheclipse.core.expression.Vector) -> plus
    org.matheclipse.core.expression.Vector minus(org.matheclipse.core.expression.Vector) -> minus
    org.matheclipse.core.expression.Vector multiply(org.matheclipse.core.expression.Vector) -> multiply
    org.matheclipse.core.expression.Vector power(java.lang.Integer) -> power
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.core.form.mathml.AbstractConverter -> org.matheclipse.core.form.mathml.AbstractConverter:
    org.matheclipse.core.form.mathml.AbstractMathMLFormFactory fFactory -> fFactory
    void <init>() -> <init>
    org.matheclipse.core.form.mathml.AbstractMathMLFormFactory getFactory() -> getFactory
    void setFactory(org.matheclipse.core.form.mathml.AbstractMathMLFormFactory) -> setFactory
org.matheclipse.core.form.mathml.AbstractMathMLFormFactory -> org.matheclipse.core.form.mathml.AbstractMathMLFormFactory:
    boolean USE_IDENTIFIERS -> USE_IDENTIFIERS
    java.util.Hashtable ENTITY_TABLE -> ENTITY_TABLE
    java.lang.String fTagPrefix -> a
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void entity(java.lang.StringBuffer,java.lang.String) -> entity
    void tag(java.lang.StringBuffer,java.lang.String,java.lang.String) -> tag
    void tagStart(java.lang.StringBuffer,java.lang.String) -> tagStart
    void tagStart(java.lang.StringBuffer,java.lang.String,java.lang.String) -> tagStart
    void tagEnd(java.lang.StringBuffer,java.lang.String) -> tagEnd
    void tagStartEnd(java.lang.StringBuffer,java.lang.String) -> tagStartEnd
    java.lang.String getReflectionNamespace() -> getReflectionNamespace
    org.matheclipse.core.form.mathml.IConverter reflection(java.lang.String) -> reflection
    void convertDouble(java.lang.StringBuffer,org.matheclipse.core.interfaces.INum,int) -> convertDouble
    void convertDoubleComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplexNum,int) -> convertDoubleComplex
    void convertInteger(java.lang.StringBuffer,org.matheclipse.core.interfaces.IInteger,int) -> convertInteger
    void convertFraction(java.lang.StringBuffer,org.matheclipse.core.interfaces.IFraction,int) -> convertFraction
    void convertComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplex,int) -> convertComplex
    void convertString(java.lang.StringBuffer,java.lang.String) -> convertString
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> convertSymbol
    void convertHead(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr) -> convertHead
    void convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> convert
    void <clinit>() -> <clinit>
org.matheclipse.core.form.mathml.AbstractOperator -> org.matheclipse.core.form.mathml.AbstractOperator:
    int fPrecedence -> fPrecedence
    java.lang.String fFirstTag -> fFirstTag
    java.lang.String fOperator -> fOperator
    void <init>(int,java.lang.String,java.lang.String) -> <init>
    void <init>(int,java.lang.String) -> <init>
    void precedenceOpen(java.lang.StringBuffer,int) -> precedenceOpen
    void precedenceClose(java.lang.StringBuffer,int) -> precedenceClose
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.IConverter -> org.matheclipse.core.form.mathml.IConverter:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.MMLContentFunction -> org.matheclipse.core.form.mathml.MMLContentFunction:
    java.lang.String fFunctionName -> a
    void <init>(org.matheclipse.core.form.mathml.MathMLContentFormFactory,java.lang.String) -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.MMLFunction -> org.matheclipse.core.form.mathml.MMLFunction:
    java.lang.String fFunctionName -> a
    void <init>(org.matheclipse.core.form.mathml.MathMLFormFactory,java.lang.String) -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.MMLPostfix -> org.matheclipse.core.form.mathml.MMLPostfix:
    java.lang.String fOperator -> a
    void <init>(org.matheclipse.core.form.mathml.MathMLFormFactory,java.lang.String) -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.MathMLContentFormFactory -> org.matheclipse.core.form.mathml.MathMLContentFormFactory:
    java.util.Hashtable CONSTANT_SYMBOLS -> CONSTANT_SYMBOLS
    java.util.Hashtable operTab -> operTab
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void convertDouble(java.lang.StringBuffer,org.matheclipse.core.interfaces.INum,int) -> convertDouble
    void convertDoubleComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplexNum,int) -> convertDoubleComplex
    void convertInteger(java.lang.StringBuffer,org.matheclipse.core.interfaces.IInteger,int) -> convertInteger
    void convertFraction(java.lang.StringBuffer,org.matheclipse.core.interfaces.IFraction,int) -> convertFraction
    void convertFraction(java.lang.StringBuffer,org.apache.commons.math3.fraction.BigFraction,int) -> convertFraction
    void convertComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplex,int) -> convertComplex
    void convertString(java.lang.StringBuffer,java.lang.String) -> convertString
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> convertSymbol
    void convertHead(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr) -> convertHead
    void convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> convert
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST) -> a
    java.lang.String getReflectionNamespace() -> getReflectionNamespace
    org.matheclipse.core.form.mathml.IConverter reflection(java.lang.String) -> reflection
    void init() -> init
    void <clinit>() -> <clinit>
org.matheclipse.core.form.mathml.MathMLContentFormFactory$Operator -> mJ:
    java.lang.String fOperator -> a
    void <init>(org.matheclipse.core.form.mathml.MathMLContentFormFactory,java.lang.String) -> <init>
    java.lang.String toString() -> toString
org.matheclipse.core.form.mathml.MathMLFormFactory -> org.matheclipse.core.form.mathml.MathMLFormFactory:
    java.util.Hashtable CONSTANT_SYMBOLS -> CONSTANT_SYMBOLS
    java.util.Hashtable CONSTANT_EXPRS -> CONSTANT_EXPRS
    java.util.Hashtable operTab -> operTab
    int plusPrec -> a
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void convertDouble(java.lang.StringBuffer,org.matheclipse.core.interfaces.INum,int) -> convertDouble
    void convertDoubleComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplexNum,int) -> convertDoubleComplex
    void convertInteger(java.lang.StringBuffer,org.matheclipse.core.interfaces.IInteger,int) -> convertInteger
    void convertFraction(java.lang.StringBuffer,org.matheclipse.core.interfaces.IFraction,int) -> convertFraction
    void convertFraction(java.lang.StringBuffer,org.apache.commons.math3.fraction.BigFraction,int) -> convertFraction
    void convertComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplex,int) -> convertComplex
    void convertString(java.lang.StringBuffer,java.lang.String) -> convertString
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> convertSymbol
    void convertHead(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr) -> convertHead
    void convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> convert
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST) -> a
    java.lang.String getReflectionNamespace() -> getReflectionNamespace
    org.matheclipse.core.form.mathml.IConverter reflection(java.lang.String) -> reflection
    void init() -> init
    void <clinit>() -> <clinit>
org.matheclipse.core.form.mathml.MathMLFormFactory$Operator -> mK:
    java.lang.String fOperator -> a
    org.matheclipse.core.form.mathml.MathMLFormFactory this$0 -> a
    void <init>(org.matheclipse.core.form.mathml.MathMLFormFactory,java.lang.String) -> <init>
    java.lang.String toString() -> toString
org.matheclipse.core.form.mathml.reflection.Abs -> org.matheclipse.core.form.mathml.reflection.Abs:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.And -> org.matheclipse.core.form.mathml.reflection.And:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.Binomial -> org.matheclipse.core.form.mathml.reflection.Binomial:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Ceiling -> org.matheclipse.core.form.mathml.reflection.Ceiling:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.CompoundExpression -> org.matheclipse.core.form.mathml.reflection.CompoundExpression:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.D -> org.matheclipse.core.form.mathml.reflection.D:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Equal -> org.matheclipse.core.form.mathml.reflection.Equal:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.Factorial -> org.matheclipse.core.form.mathml.reflection.Factorial:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Factorial2 -> org.matheclipse.core.form.mathml.reflection.Factorial2:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Floor -> org.matheclipse.core.form.mathml.reflection.Floor:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Greater -> org.matheclipse.core.form.mathml.reflection.Greater:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.GreaterEqual -> org.matheclipse.core.form.mathml.reflection.GreaterEqual:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.Integrate -> org.matheclipse.core.form.mathml.reflection.Integrate:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
    boolean iteratorStep(java.lang.StringBuffer,java.lang.String,org.matheclipse.core.interfaces.IAST,int) -> iteratorStep
org.matheclipse.core.form.mathml.reflection.Less -> org.matheclipse.core.form.mathml.reflection.Less:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.LessEqual -> org.matheclipse.core.form.mathml.reflection.LessEqual:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.List -> org.matheclipse.core.form.mathml.reflection.List:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.MatrixForm -> org.matheclipse.core.form.mathml.reflection.MatrixForm:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Not -> org.matheclipse.core.form.mathml.reflection.Not:
    void <init>(org.matheclipse.core.form.mathml.MathMLFormFactory) -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Or -> org.matheclipse.core.form.mathml.reflection.Or:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.Part -> org.matheclipse.core.form.mathml.reflection.Part:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Plus -> org.matheclipse.core.form.mathml.reflection.Plus:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Power -> org.matheclipse.core.form.mathml.reflection.Power:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Product -> org.matheclipse.core.form.mathml.reflection.Product:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Rational -> org.matheclipse.core.form.mathml.reflection.Rational:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Rule -> org.matheclipse.core.form.mathml.reflection.Rule:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.RuleDelayed -> org.matheclipse.core.form.mathml.reflection.RuleDelayed:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.Set -> org.matheclipse.core.form.mathml.reflection.Set:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.SetDelayed -> org.matheclipse.core.form.mathml.reflection.SetDelayed:
    void <init>() -> <init>
org.matheclipse.core.form.mathml.reflection.Sqrt -> org.matheclipse.core.form.mathml.reflection.Sqrt:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.mathml.reflection.Sum -> org.matheclipse.core.form.mathml.reflection.Sum:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
    boolean iteratorStep(java.lang.StringBuffer,java.lang.String,org.matheclipse.core.interfaces.IAST,int) -> iteratorStep
org.matheclipse.core.form.mathml.reflection.Times -> org.matheclipse.core.form.mathml.reflection.Times:
    int NO_SPECIAL_CALL -> NO_SPECIAL_CALL
    int PLUS_CALL -> PLUS_CALL
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
    boolean convertTimesFraction(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int,int) -> convertTimesFraction
    boolean convertTimesOperator(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int,int) -> a
org.matheclipse.core.form.output.IConverter -> org.matheclipse.core.form.output.IConverter:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST) -> convert
org.matheclipse.core.form.output.OutputFormFactory -> org.matheclipse.core.form.output.OutputFormFactory:
    boolean NO_PLUS_CALL -> NO_PLUS_CALL
    boolean PLUS_CALL -> PLUS_CALL
    boolean fRelaxedSyntax -> a
    boolean fPlusReversed -> b
    boolean fIgnoreNewLine -> c
    boolean fEmpty -> d
    int fColumnCounter -> a
    void <init>(boolean,boolean) -> <init>
    org.matheclipse.core.form.output.OutputFormFactory get(boolean) -> get
    org.matheclipse.core.form.output.OutputFormFactory get(boolean,boolean) -> get
    org.matheclipse.core.form.output.OutputFormFactory get() -> get
    void convertDouble(java.lang.Appendable,org.matheclipse.core.interfaces.INum,int,boolean) -> convertDouble
    void convertDoubleValue(java.lang.Appendable,java.lang.String,int,boolean) -> a
    void convertDoubleComplex(java.lang.Appendable,org.matheclipse.core.interfaces.IComplexNum,int,boolean) -> convertDoubleComplex
    void convertApcomplex(java.lang.Appendable,org.apfloat.Apcomplex,int,boolean) -> convertApcomplex
    void convertInteger(java.lang.Appendable,org.matheclipse.core.interfaces.IInteger,int,boolean) -> convertInteger
    void convertFraction(java.lang.Appendable,org.apache.commons.math3.fraction.BigFraction,int,boolean) -> convertFraction
    void convertComplex(java.lang.Appendable,org.matheclipse.core.interfaces.IComplex,int,boolean) -> convertComplex
    void convertString(java.lang.Appendable,java.lang.String) -> convertString
    void convertSymbol(java.lang.Appendable,org.matheclipse.core.interfaces.ISymbol) -> convertSymbol
    void convertPattern(java.lang.Appendable,org.matheclipse.core.interfaces.IPatternObject) -> convertPattern
    void convertHead(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr) -> convertHead
    void convertPlusArgument(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr,boolean) -> convertPlusArgument
    void convertTimesFraction(java.lang.Appendable,org.matheclipse.core.interfaces.IAST,org.matheclipse.parser.client.operator.InfixOperator,int,boolean) -> a
    void convertTimesOperator(java.lang.Appendable,org.matheclipse.core.interfaces.IAST,org.matheclipse.parser.client.operator.InfixOperator,int,boolean) -> b
    void convertPowerOperator(java.lang.Appendable,org.matheclipse.core.interfaces.IAST,org.matheclipse.parser.client.operator.InfixOperator,int) -> convertPowerOperator
    void convertInfixOperator(java.lang.Appendable,org.matheclipse.core.interfaces.IAST,org.matheclipse.parser.client.operator.InfixOperator,int) -> convertInfixOperator
    void convertPrefixOperator(java.lang.Appendable,org.matheclipse.core.interfaces.IAST,org.matheclipse.parser.client.operator.PrefixOperator,int) -> convertPrefixOperator
    void convertPostfixOperator(java.lang.Appendable,org.matheclipse.core.interfaces.IAST,org.matheclipse.parser.client.operator.PostfixOperator,int) -> convertPostfixOperator
    void convert(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr) -> convert
    void convertNumber(java.lang.Appendable,org.matheclipse.core.interfaces.INumber,int,boolean) -> convertNumber
    void convert(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr,int) -> convert
    void convertSlot(java.lang.Appendable,org.matheclipse.core.interfaces.IAST) -> convertSlot
    void convertList(java.lang.Appendable,org.matheclipse.core.interfaces.IAST) -> convertList
    void convertPart(java.lang.Appendable,org.matheclipse.core.interfaces.IAST) -> convertPart
    boolean convertSeriesData(java.lang.Appendable,org.matheclipse.core.interfaces.IAST,int) -> convertSeriesData
    boolean convertSeriesDataArg(java.lang.StringBuilder,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> a
    void convertFunctionArgs(java.lang.Appendable,org.matheclipse.core.interfaces.IAST) -> convertFunctionArgs
    void convertAST(java.lang.Appendable,org.matheclipse.core.interfaces.IAST) -> convertAST
    void convertArgs(java.lang.Appendable,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> convertArgs
    void newLine(java.lang.Appendable) -> a
    void append(java.lang.Appendable,java.lang.String) -> a
    void append(java.lang.Appendable,char) -> a
    void setIgnoreNewLine(boolean) -> setIgnoreNewLine
    void setEmpty(boolean) -> setEmpty
    int getColumnCounter() -> getColumnCounter
    void setColumnCounter(int) -> setColumnCounter
org.matheclipse.core.form.tex.AbstractConverter -> org.matheclipse.core.form.tex.AbstractConverter:
    org.matheclipse.core.form.tex.AbstractTeXFormFactory fFactory -> fFactory
    void <init>() -> <init>
    void <init>(org.matheclipse.core.form.tex.TeXFormFactory) -> <init>
    org.matheclipse.core.form.tex.AbstractTeXFormFactory getFactory() -> getFactory
    void setFactory(org.matheclipse.core.form.tex.AbstractTeXFormFactory) -> setFactory
org.matheclipse.core.form.tex.AbstractOperator -> org.matheclipse.core.form.tex.AbstractOperator:
    int fPrecedence -> fPrecedence
    java.lang.String fOperator -> fOperator
    void <init>(int,java.lang.String) -> <init>
    void <init>(org.matheclipse.core.form.tex.TeXFormFactory,int,java.lang.String) -> <init>
    void precedenceOpen(java.lang.StringBuffer,int) -> precedenceOpen
    void precedenceClose(java.lang.StringBuffer,int) -> precedenceClose
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.AbstractTeXFormFactory -> org.matheclipse.core.form.tex.AbstractTeXFormFactory:
    boolean USE_IDENTIFIERS -> USE_IDENTIFIERS
    void <init>() -> <init>
    java.lang.String getReflectionNamespace() -> getReflectionNamespace
    org.matheclipse.core.form.tex.IConverter reflection(java.lang.String) -> reflection
    void convertDouble(java.lang.StringBuffer,org.matheclipse.core.interfaces.INum,int) -> convertDouble
    void convertDoubleComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplexNum,int) -> convertDoubleComplex
    void convertInteger(java.lang.StringBuffer,org.matheclipse.core.interfaces.IInteger,int) -> convertInteger
    void convertFraction(java.lang.StringBuffer,org.matheclipse.core.interfaces.IFraction,int) -> convertFraction
    void convertComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplex,int) -> convertComplex
    void convertString(java.lang.StringBuffer,java.lang.String) -> convertString
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> convertSymbol
    void convertHead(java.lang.StringBuffer,java.lang.Object) -> convertHead
    void convert(java.lang.StringBuffer,java.lang.Object,int) -> convert
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST) -> convertAST
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,java.lang.String) -> convertAST
    void convertSubExpr(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> convertSubExpr
org.matheclipse.core.form.tex.IConverter -> org.matheclipse.core.form.tex.IConverter:
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.PostOperator -> org.matheclipse.core.form.tex.PostOperator:
    int fPrecedence -> fPrecedence
    java.lang.String fOperator -> fOperator
    void <init>(int,java.lang.String) -> <init>
    void <init>(org.matheclipse.core.form.tex.TeXFormFactory,int,java.lang.String) -> <init>
    void precedenceOpen(java.lang.StringBuffer,int) -> precedenceOpen
    void precedenceClose(java.lang.StringBuffer,int) -> precedenceClose
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.PreOperator -> org.matheclipse.core.form.tex.PreOperator:
    int fPrecedence -> fPrecedence
    java.lang.String fOperator -> fOperator
    void <init>(int,java.lang.String) -> <init>
    void <init>(org.matheclipse.core.form.tex.TeXFormFactory,int,java.lang.String) -> <init>
    void precedenceOpen(java.lang.StringBuffer,int) -> precedenceOpen
    void precedenceClose(java.lang.StringBuffer,int) -> precedenceClose
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.TeXFormFactory -> org.matheclipse.core.form.tex.TeXFormFactory:
    java.util.Hashtable CONSTANT_SYMBOLS -> CONSTANT_SYMBOLS
    java.util.Hashtable CONSTANT_EXPRS -> CONSTANT_EXPRS
    java.util.Hashtable operTab -> operTab
    int plusPrec -> a
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void convertDouble(java.lang.StringBuffer,org.matheclipse.core.interfaces.INum,int) -> convertDouble
    void convertDoubleComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplexNum,int) -> convertDoubleComplex
    void convertInteger(java.lang.StringBuffer,org.matheclipse.core.interfaces.IInteger,int) -> convertInteger
    void convertFraction(java.lang.StringBuffer,org.matheclipse.core.interfaces.IFraction,int) -> convertFraction
    void convertFraction(java.lang.StringBuffer,org.apache.commons.math3.fraction.BigFraction,int) -> convertFraction
    void convertComplex(java.lang.StringBuffer,org.matheclipse.core.interfaces.IComplex,int) -> convertComplex
    void convertString(java.lang.StringBuffer,java.lang.String) -> convertString
    void convertSymbol(java.lang.StringBuffer,org.matheclipse.core.interfaces.ISymbol) -> convertSymbol
    void convertHead(java.lang.StringBuffer,java.lang.Object) -> convertHead
    void convert(java.lang.StringBuffer,java.lang.Object,int) -> convert
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST) -> convertAST
    void convertAST(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,java.lang.String) -> convertAST
    java.lang.String getReflectionNamespace() -> getReflectionNamespace
    org.matheclipse.core.form.tex.IConverter reflection(java.lang.String) -> reflection
    void init() -> init
    void convertSubExpr(java.lang.StringBuffer,org.matheclipse.core.interfaces.IExpr,int) -> convertSubExpr
    void <clinit>() -> <clinit>
org.matheclipse.core.form.tex.TeXFormFactory$Operator -> mL:
    java.lang.String toString() -> toString
org.matheclipse.core.form.tex.TeXFunction -> org.matheclipse.core.form.tex.TeXFunction:
    java.lang.String fFunctionName -> a
    void <init>(org.matheclipse.core.form.tex.TeXFormFactory,java.lang.String) -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.TeXPostfix -> org.matheclipse.core.form.tex.TeXPostfix:
    java.lang.String fOperator -> a
    void <init>(org.matheclipse.core.form.tex.TeXFormFactory,java.lang.String) -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Abs -> org.matheclipse.core.form.tex.reflection.Abs:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Binomial -> org.matheclipse.core.form.tex.reflection.Binomial:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Ceiling -> org.matheclipse.core.form.tex.reflection.Ceiling:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Complex -> org.matheclipse.core.form.tex.reflection.Complex:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.CompoundExpression -> org.matheclipse.core.form.tex.reflection.CompoundExpression:
    void <init>() -> <init>
org.matheclipse.core.form.tex.reflection.D -> org.matheclipse.core.form.tex.reflection.D:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.DirectedInfinity -> org.matheclipse.core.form.tex.reflection.DirectedInfinity:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Floor -> org.matheclipse.core.form.tex.reflection.Floor:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.HarmonicNumber -> org.matheclipse.core.form.tex.reflection.HarmonicNumber:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.HurwitzZeta -> org.matheclipse.core.form.tex.reflection.HurwitzZeta:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Integrate -> org.matheclipse.core.form.tex.reflection.Integrate:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
    boolean iteratorStep(java.lang.StringBuffer,java.lang.String,org.matheclipse.core.interfaces.IAST,int) -> iteratorStep
org.matheclipse.core.form.tex.reflection.Limit -> org.matheclipse.core.form.tex.reflection.Limit:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.List -> org.matheclipse.core.form.tex.reflection.List:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.MatrixForm -> org.matheclipse.core.form.tex.reflection.MatrixForm:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Plus -> org.matheclipse.core.form.tex.reflection.Plus:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Power -> org.matheclipse.core.form.tex.reflection.Power:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Product -> org.matheclipse.core.form.tex.reflection.Product:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Rational -> org.matheclipse.core.form.tex.reflection.Rational:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Sqrt -> org.matheclipse.core.form.tex.reflection.Sqrt:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Subscript -> org.matheclipse.core.form.tex.reflection.Subscript:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Subsuperscript -> org.matheclipse.core.form.tex.reflection.Subsuperscript:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Sum -> org.matheclipse.core.form.tex.reflection.Sum:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
    boolean iteratorStep(java.lang.StringBuffer,java.lang.String,org.matheclipse.core.interfaces.IAST,int) -> iteratorStep
org.matheclipse.core.form.tex.reflection.Superscript -> org.matheclipse.core.form.tex.reflection.Superscript:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.form.tex.reflection.Times -> org.matheclipse.core.form.tex.reflection.Times:
    int NO_SPECIAL_CALL -> NO_SPECIAL_CALL
    int PLUS_CALL -> PLUS_CALL
    org.matheclipse.core.form.tex.reflection.Times CONST -> CONST
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
    boolean convertTimesFraction(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int,int) -> convertTimesFraction
    boolean convertTimesOperator(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int,int) -> a
    void <clinit>() -> <clinit>
org.matheclipse.core.form.tex.reflection.Zeta -> org.matheclipse.core.form.tex.reflection.Zeta:
    void <init>() -> <init>
    boolean convert(java.lang.StringBuffer,org.matheclipse.core.interfaces.IAST,int) -> convert
org.matheclipse.core.generic.BinaryApply -> org.matheclipse.core.generic.BinaryApply:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> apply
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.BinaryBindIth1st -> org.matheclipse.core.generic.BinaryBindIth1st:
    org.matheclipse.core.interfaces.IAST fConstant1 -> fConstant1
    org.matheclipse.core.interfaces.IAST fConstant2 -> fConstant2
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(int,org.matheclipse.core.interfaces.IExpr) -> apply
    java.lang.Object apply(int,java.lang.Object) -> apply
org.matheclipse.core.generic.BinaryEval -> org.matheclipse.core.generic.BinaryEval:
    org.matheclipse.core.eval.EvalEngine fEngine -> fEngine
    org.matheclipse.core.interfaces.IAST fAST -> fAST
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> apply
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.BinaryFunctorImpl -> org.matheclipse.core.generic.BinaryFunctorImpl:
    void <init>() -> <init>
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> apply
    com.google.common.base.Function bind2(java.lang.Object) -> bind2
org.matheclipse.core.generic.BinaryFunctorImpl$1 -> mM:
    org.matheclipse.core.generic.BinaryFunctorImpl val$f2 -> a
    java.lang.Object val$p_param2 -> a
    void <init>(org.matheclipse.core.generic.BinaryFunctorImpl,org.matheclipse.core.generic.BinaryFunctorImpl,java.lang.Object) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.BinaryMap -> org.matheclipse.core.generic.BinaryMap:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> apply
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.BinaryNumerical -> org.matheclipse.core.generic.BinaryNumerical:
    org.matheclipse.core.interfaces.IExpr fun -> a
    org.matheclipse.core.interfaces.ISymbol variable1 -> a
    org.matheclipse.core.interfaces.ISymbol variable2 -> b
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> apply
    double value(double,double) -> value
    org.matheclipse.core.expression.ComplexNum value(org.matheclipse.core.expression.ComplexNum,org.matheclipse.core.expression.ComplexNum) -> value
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.ExprComparator -> org.matheclipse.core.generic.ExprComparator:
    org.matheclipse.core.generic.ExprComparator CONS -> CONS
    void <init>() -> <init>
    int compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
    void <clinit>() -> <clinit>
org.matheclipse.core.generic.Functors -> org.matheclipse.core.generic.Functors:
    com.google.common.base.Predicate PATTERNQ_PREDICATE -> a
    com.google.common.base.Function scan(org.matheclipse.core.interfaces.IAST,java.util.Collection) -> scan
    com.google.common.base.Function append(org.matheclipse.core.interfaces.IAST) -> append
    com.google.common.base.Function evalArg(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.eval.EvalEngine) -> evalArg
    com.google.common.base.Function apply(org.matheclipse.core.interfaces.IExpr) -> apply
    com.google.common.base.Function collect(java.util.Collection) -> collect
    com.google.common.base.Function constant(org.matheclipse.core.interfaces.IExpr) -> constant
    com.google.common.base.Function replaceAll(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> replaceAll
    com.google.common.base.Function replace1st(org.matheclipse.core.interfaces.IAST) -> replace1st
    com.google.common.base.Function replace2nd(org.matheclipse.core.interfaces.IAST) -> replace2nd
    com.google.common.base.Function replaceArg(org.matheclipse.core.interfaces.IAST,int) -> replaceArg
    com.google.common.base.Function rules(java.util.Map) -> rules
    com.google.common.base.Function rules(java.lang.String[]) -> rules
    com.google.common.base.Function rules(org.matheclipse.core.interfaces.IAST) -> rules
    void addRuleToCollection(java.util.Map,java.util.List,org.matheclipse.core.interfaces.IAST) -> a
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.generic.Functors$1 -> mN:
    void <init>() -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$AppendFunctor -> mO:
    org.matheclipse.core.interfaces.IAST fAST -> a
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ApplyFunctor -> mP:
    org.matheclipse.core.interfaces.IExpr fConstant -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$CollectFunctor -> mQ:
    java.util.Collection resultCollection -> a
    void <init>(java.util.Collection) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ConstantFunctor -> mR:
    org.matheclipse.core.interfaces.IExpr fConstant -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$EvalArgFunctor -> mS:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    int fPosition -> a
    void <init>(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.eval.EvalEngine) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ReplaceAllFunctor -> mT:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    org.matheclipse.core.interfaces.IExpr fLHS -> a
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ReplaceArgFunctor -> mU:
    org.matheclipse.core.interfaces.IAST fConstant -> a
    int fPosition -> a
    void <init>(org.matheclipse.core.interfaces.IAST,int) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$RulesFunctor -> mV:
    java.util.Map fEqualRules -> a
    void <init>(java.util.Map) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$RulesPatternFunctor -> mW:
    java.util.Map fEqualRules -> a
    java.util.List fMatchers -> a
    void <init>(java.util.Map,java.util.List) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Functors$ScanFunctor -> mX:
    org.matheclipse.core.interfaces.IAST fAST -> a
    java.util.Collection resultCollection -> a
    void <init>(org.matheclipse.core.interfaces.IAST,java.util.Collection) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.ITernaryComparator -> org.matheclipse.core.generic.ITernaryComparator:
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT -> org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT:
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT TRUE -> TRUE
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT FALSE -> FALSE
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT UNDEFINED -> UNDEFINED
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT[] $VALUES -> a
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT[] values() -> values
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.generic.IsBinaryFalse -> org.matheclipse.core.generic.IsBinaryFalse:
    org.matheclipse.core.eval.EvalEngine fEngine -> fEngine
    org.matheclipse.core.interfaces.IAST fAST -> fAST
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    boolean apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> apply
    int compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
    boolean apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.IsBinaryTrue -> org.matheclipse.core.generic.IsBinaryTrue:
    org.matheclipse.core.eval.EvalEngine fEngine -> fEngine
    org.matheclipse.core.interfaces.IAST fAST -> fAST
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    boolean apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> apply
    int compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
    boolean apply(java.lang.Object,java.lang.Object) -> apply
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.generic.IsLEOrdered -> org.matheclipse.core.generic.IsLEOrdered:
    void <init>() -> <init>
    boolean apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.IsUnaryVariable -> org.matheclipse.core.generic.IsUnaryVariable:
    void <init>() -> <init>
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.IsUnaryVariableOrPattern -> org.matheclipse.core.generic.IsUnaryVariableOrPattern:
    void <init>() -> <init>
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.MultipleArrayFunction -> org.matheclipse.core.generic.MultipleArrayFunction:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fHeadAST -> a
    void <init>(org.matheclipse.core.eval.EvalEngine,org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> evaluate
org.matheclipse.core.generic.MultipleConstArrayFunction -> org.matheclipse.core.generic.MultipleConstArrayFunction:
    org.matheclipse.core.interfaces.IExpr fConstantExpr -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> evaluate
org.matheclipse.core.generic.PositionConverter -> org.matheclipse.core.generic.PositionConverter:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr toObject(int) -> toObject
    int toInt(org.matheclipse.core.interfaces.IExpr) -> toInt
    int toInt(java.lang.Object) -> toInt
    java.lang.Object toObject(int) -> toObject
org.matheclipse.core.generic.Predicates -> org.matheclipse.core.generic.Predicates:
    void <init>() -> <init>
    com.google.common.base.Predicate isTrue(org.matheclipse.core.interfaces.IExpr) -> isTrue
    com.google.common.base.Predicate isTrue(org.matheclipse.core.eval.EvalEngine,org.matheclipse.core.interfaces.IExpr) -> isTrue
    com.google.common.base.Predicate in(org.matheclipse.core.interfaces.IAST) -> in
    com.google.common.base.Predicate in(org.matheclipse.core.interfaces.IExpr) -> in
    com.google.common.base.Predicate isFree(org.matheclipse.core.interfaces.IExpr) -> isFree
    com.google.common.base.Predicate isPattern() -> isPattern
    com.google.common.base.Predicate isNumber() -> isNumber
    com.google.common.base.Predicate isNumeric() -> isNumeric
    com.google.common.base.Predicate isSignedNumber() -> isSignedNumber
    com.google.common.base.Predicate isAST(org.matheclipse.core.interfaces.ISymbol[]) -> isAST
org.matheclipse.core.generic.Predicates$1 -> mY:
    org.matheclipse.core.interfaces.IExpr val$expr -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$2 -> mZ:
    void <init>() -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$3 -> na:
    void <init>() -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$4 -> nb:
    void <init>() -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$5 -> nc:
    void <init>() -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$6 -> nd:
    org.matheclipse.core.interfaces.ISymbol[] val$heads -> a
    void <init>(org.matheclipse.core.interfaces.ISymbol[]) -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.Predicates$InASTPredicate -> org.matheclipse.core.generic.Predicates$InASTPredicate:
    org.matheclipse.core.interfaces.IAST target -> target
    long serialVersionUID -> serialVersionUID
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean apply(java.lang.Object) -> apply
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.Predicates$1) -> <init>
org.matheclipse.core.generic.Predicates$IsUnaryTrue -> ne:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IAST fAST -> a
    void <init>(org.matheclipse.core.eval.EvalEngine,org.matheclipse.core.interfaces.IExpr) -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.generic.UnaryArrayFunction -> org.matheclipse.core.generic.UnaryArrayFunction:
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    org.matheclipse.core.interfaces.IExpr fValue -> a
    void <init>(org.matheclipse.core.eval.EvalEngine,org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> evaluate
org.matheclipse.core.generic.UnaryBindIth -> org.matheclipse.core.generic.UnaryBindIth:
    org.matheclipse.core.interfaces.IAST fConstant -> fConstant
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(int,org.matheclipse.core.interfaces.IExpr) -> apply
    java.lang.Object apply(int,java.lang.Object) -> apply
org.matheclipse.core.generic.UnaryCollect -> org.matheclipse.core.generic.UnaryCollect:
    org.matheclipse.core.interfaces.IAST fAST -> fAST
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr) -> apply
    org.matheclipse.core.interfaces.IAST getCollectedAST() -> getCollectedAST
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.UnaryNumerical -> org.matheclipse.core.generic.UnaryNumerical:
    org.matheclipse.core.interfaces.IExpr fFunction -> a
    org.matheclipse.core.interfaces.ISymbol fVariable -> a
    org.matheclipse.core.eval.EvalEngine fEngine -> a
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.eval.EvalEngine) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr) -> apply
    double value(double) -> value
    org.apache.commons.math3.analysis.UnivariateFunction derivative() -> derivative
    org.matheclipse.core.expression.ComplexNum value(org.matheclipse.core.expression.ComplexNum) -> value
    org.matheclipse.core.interfaces.INum value(org.matheclipse.core.interfaces.INum) -> value
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.UnaryRangeFunction -> org.matheclipse.core.generic.UnaryRangeFunction:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> evaluate
org.matheclipse.core.generic.UnaryVariable2Slot -> org.matheclipse.core.generic.UnaryVariable2Slot:
    java.util.Map fMap -> a
    java.util.List fVariableList -> a
    int fSlotCounter -> a
    void <init>(java.util.Map,java.util.List) -> <init>
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr) -> apply
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.generic.interfaces.BiFunction -> org.matheclipse.core.generic.interfaces.BiFunction:
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.interfaces.BiIndexFunction -> org.matheclipse.core.generic.interfaces.BiIndexFunction:
    java.lang.Object apply(int,java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.interfaces.BiPredicate -> org.matheclipse.core.generic.interfaces.BiPredicate:
    boolean apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.generic.interfaces.IArrayFunction -> org.matheclipse.core.generic.interfaces.IArrayFunction:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IExpr[]) -> evaluate
org.matheclipse.core.generic.interfaces.IIterator -> org.matheclipse.core.generic.interfaces.IIterator:
    boolean setUp() -> setUp
    void tearDown() -> tearDown
org.matheclipse.core.generic.interfaces.INumericFunction -> org.matheclipse.core.generic.interfaces.INumericFunction:
    java.lang.Object apply(double) -> apply
org.matheclipse.core.generic.interfaces.IPositionConverter -> org.matheclipse.core.generic.interfaces.IPositionConverter:
    java.lang.Object toObject(int) -> toObject
    int toInt(java.lang.Object) -> toInt
org.matheclipse.core.generic.interfaces.IUnaryIndexFunction -> org.matheclipse.core.generic.interfaces.IUnaryIndexFunction:
    java.lang.Object apply(int,java.lang.Object) -> apply
org.matheclipse.core.integrate.rubi45.AbortRubi -> org.matheclipse.core.integrate.rubi45.AbortRubi:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.integrate.rubi45.IntRules0 -> org.matheclipse.core.integrate.rubi45.IntRules0:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules1 -> org.matheclipse.core.integrate.rubi45.IntRules1:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules10 -> org.matheclipse.core.integrate.rubi45.IntRules10:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules100 -> org.matheclipse.core.integrate.rubi45.IntRules100:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules101 -> org.matheclipse.core.integrate.rubi45.IntRules101:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules102 -> org.matheclipse.core.integrate.rubi45.IntRules102:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules103 -> org.matheclipse.core.integrate.rubi45.IntRules103:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules104 -> org.matheclipse.core.integrate.rubi45.IntRules104:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules105 -> org.matheclipse.core.integrate.rubi45.IntRules105:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules106 -> org.matheclipse.core.integrate.rubi45.IntRules106:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules107 -> org.matheclipse.core.integrate.rubi45.IntRules107:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules108 -> org.matheclipse.core.integrate.rubi45.IntRules108:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules109 -> org.matheclipse.core.integrate.rubi45.IntRules109:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules11 -> org.matheclipse.core.integrate.rubi45.IntRules11:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules110 -> org.matheclipse.core.integrate.rubi45.IntRules110:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules111 -> org.matheclipse.core.integrate.rubi45.IntRules111:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules112 -> org.matheclipse.core.integrate.rubi45.IntRules112:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules113 -> org.matheclipse.core.integrate.rubi45.IntRules113:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules114 -> org.matheclipse.core.integrate.rubi45.IntRules114:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules115 -> org.matheclipse.core.integrate.rubi45.IntRules115:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules116 -> org.matheclipse.core.integrate.rubi45.IntRules116:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules117 -> org.matheclipse.core.integrate.rubi45.IntRules117:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules118 -> org.matheclipse.core.integrate.rubi45.IntRules118:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules119 -> org.matheclipse.core.integrate.rubi45.IntRules119:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules12 -> org.matheclipse.core.integrate.rubi45.IntRules12:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules120 -> org.matheclipse.core.integrate.rubi45.IntRules120:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules121 -> org.matheclipse.core.integrate.rubi45.IntRules121:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules122 -> org.matheclipse.core.integrate.rubi45.IntRules122:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules123 -> org.matheclipse.core.integrate.rubi45.IntRules123:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules124 -> org.matheclipse.core.integrate.rubi45.IntRules124:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules125 -> org.matheclipse.core.integrate.rubi45.IntRules125:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules126 -> org.matheclipse.core.integrate.rubi45.IntRules126:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules127 -> org.matheclipse.core.integrate.rubi45.IntRules127:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules128 -> org.matheclipse.core.integrate.rubi45.IntRules128:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules129 -> org.matheclipse.core.integrate.rubi45.IntRules129:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules13 -> org.matheclipse.core.integrate.rubi45.IntRules13:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules130 -> org.matheclipse.core.integrate.rubi45.IntRules130:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules131 -> org.matheclipse.core.integrate.rubi45.IntRules131:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules132 -> org.matheclipse.core.integrate.rubi45.IntRules132:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules133 -> org.matheclipse.core.integrate.rubi45.IntRules133:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules134 -> org.matheclipse.core.integrate.rubi45.IntRules134:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules135 -> org.matheclipse.core.integrate.rubi45.IntRules135:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules136 -> org.matheclipse.core.integrate.rubi45.IntRules136:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules137 -> org.matheclipse.core.integrate.rubi45.IntRules137:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules138 -> org.matheclipse.core.integrate.rubi45.IntRules138:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules139 -> org.matheclipse.core.integrate.rubi45.IntRules139:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules14 -> org.matheclipse.core.integrate.rubi45.IntRules14:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules15 -> org.matheclipse.core.integrate.rubi45.IntRules15:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules16 -> org.matheclipse.core.integrate.rubi45.IntRules16:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules17 -> org.matheclipse.core.integrate.rubi45.IntRules17:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules18 -> org.matheclipse.core.integrate.rubi45.IntRules18:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules19 -> org.matheclipse.core.integrate.rubi45.IntRules19:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules2 -> org.matheclipse.core.integrate.rubi45.IntRules2:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules20 -> org.matheclipse.core.integrate.rubi45.IntRules20:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules21 -> org.matheclipse.core.integrate.rubi45.IntRules21:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules22 -> org.matheclipse.core.integrate.rubi45.IntRules22:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules23 -> org.matheclipse.core.integrate.rubi45.IntRules23:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules24 -> org.matheclipse.core.integrate.rubi45.IntRules24:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules25 -> org.matheclipse.core.integrate.rubi45.IntRules25:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules26 -> org.matheclipse.core.integrate.rubi45.IntRules26:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules27 -> org.matheclipse.core.integrate.rubi45.IntRules27:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules28 -> org.matheclipse.core.integrate.rubi45.IntRules28:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules29 -> org.matheclipse.core.integrate.rubi45.IntRules29:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules3 -> org.matheclipse.core.integrate.rubi45.IntRules3:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules30 -> org.matheclipse.core.integrate.rubi45.IntRules30:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules31 -> org.matheclipse.core.integrate.rubi45.IntRules31:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules32 -> org.matheclipse.core.integrate.rubi45.IntRules32:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules33 -> org.matheclipse.core.integrate.rubi45.IntRules33:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules34 -> org.matheclipse.core.integrate.rubi45.IntRules34:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules35 -> org.matheclipse.core.integrate.rubi45.IntRules35:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules36 -> org.matheclipse.core.integrate.rubi45.IntRules36:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules37 -> org.matheclipse.core.integrate.rubi45.IntRules37:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules38 -> org.matheclipse.core.integrate.rubi45.IntRules38:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules39 -> org.matheclipse.core.integrate.rubi45.IntRules39:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules4 -> org.matheclipse.core.integrate.rubi45.IntRules4:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules40 -> org.matheclipse.core.integrate.rubi45.IntRules40:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules41 -> org.matheclipse.core.integrate.rubi45.IntRules41:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules42 -> org.matheclipse.core.integrate.rubi45.IntRules42:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules43 -> org.matheclipse.core.integrate.rubi45.IntRules43:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules44 -> org.matheclipse.core.integrate.rubi45.IntRules44:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules45 -> org.matheclipse.core.integrate.rubi45.IntRules45:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules46 -> org.matheclipse.core.integrate.rubi45.IntRules46:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules47 -> org.matheclipse.core.integrate.rubi45.IntRules47:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules48 -> org.matheclipse.core.integrate.rubi45.IntRules48:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules49 -> org.matheclipse.core.integrate.rubi45.IntRules49:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules5 -> org.matheclipse.core.integrate.rubi45.IntRules5:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules50 -> org.matheclipse.core.integrate.rubi45.IntRules50:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules51 -> org.matheclipse.core.integrate.rubi45.IntRules51:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules52 -> org.matheclipse.core.integrate.rubi45.IntRules52:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules53 -> org.matheclipse.core.integrate.rubi45.IntRules53:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules54 -> org.matheclipse.core.integrate.rubi45.IntRules54:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules55 -> org.matheclipse.core.integrate.rubi45.IntRules55:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules56 -> org.matheclipse.core.integrate.rubi45.IntRules56:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules57 -> org.matheclipse.core.integrate.rubi45.IntRules57:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules58 -> org.matheclipse.core.integrate.rubi45.IntRules58:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules59 -> org.matheclipse.core.integrate.rubi45.IntRules59:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules6 -> org.matheclipse.core.integrate.rubi45.IntRules6:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules60 -> org.matheclipse.core.integrate.rubi45.IntRules60:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules61 -> org.matheclipse.core.integrate.rubi45.IntRules61:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules62 -> org.matheclipse.core.integrate.rubi45.IntRules62:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules63 -> org.matheclipse.core.integrate.rubi45.IntRules63:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules64 -> org.matheclipse.core.integrate.rubi45.IntRules64:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules65 -> org.matheclipse.core.integrate.rubi45.IntRules65:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules66 -> org.matheclipse.core.integrate.rubi45.IntRules66:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules67 -> org.matheclipse.core.integrate.rubi45.IntRules67:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules68 -> org.matheclipse.core.integrate.rubi45.IntRules68:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules69 -> org.matheclipse.core.integrate.rubi45.IntRules69:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules7 -> org.matheclipse.core.integrate.rubi45.IntRules7:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules70 -> org.matheclipse.core.integrate.rubi45.IntRules70:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules71 -> org.matheclipse.core.integrate.rubi45.IntRules71:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules72 -> org.matheclipse.core.integrate.rubi45.IntRules72:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules73 -> org.matheclipse.core.integrate.rubi45.IntRules73:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules74 -> org.matheclipse.core.integrate.rubi45.IntRules74:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules75 -> org.matheclipse.core.integrate.rubi45.IntRules75:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules76 -> org.matheclipse.core.integrate.rubi45.IntRules76:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules77 -> org.matheclipse.core.integrate.rubi45.IntRules77:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules78 -> org.matheclipse.core.integrate.rubi45.IntRules78:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules79 -> org.matheclipse.core.integrate.rubi45.IntRules79:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules8 -> org.matheclipse.core.integrate.rubi45.IntRules8:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules80 -> org.matheclipse.core.integrate.rubi45.IntRules80:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules81 -> org.matheclipse.core.integrate.rubi45.IntRules81:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules82 -> org.matheclipse.core.integrate.rubi45.IntRules82:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules83 -> org.matheclipse.core.integrate.rubi45.IntRules83:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules84 -> org.matheclipse.core.integrate.rubi45.IntRules84:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules85 -> org.matheclipse.core.integrate.rubi45.IntRules85:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules86 -> org.matheclipse.core.integrate.rubi45.IntRules86:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules87 -> org.matheclipse.core.integrate.rubi45.IntRules87:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules88 -> org.matheclipse.core.integrate.rubi45.IntRules88:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules89 -> org.matheclipse.core.integrate.rubi45.IntRules89:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules9 -> org.matheclipse.core.integrate.rubi45.IntRules9:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules90 -> org.matheclipse.core.integrate.rubi45.IntRules90:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules91 -> org.matheclipse.core.integrate.rubi45.IntRules91:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules92 -> org.matheclipse.core.integrate.rubi45.IntRules92:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules93 -> org.matheclipse.core.integrate.rubi45.IntRules93:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules94 -> org.matheclipse.core.integrate.rubi45.IntRules94:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules95 -> org.matheclipse.core.integrate.rubi45.IntRules95:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules96 -> org.matheclipse.core.integrate.rubi45.IntRules96:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules97 -> org.matheclipse.core.integrate.rubi45.IntRules97:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules98 -> org.matheclipse.core.integrate.rubi45.IntRules98:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.IntRules99 -> org.matheclipse.core.integrate.rubi45.IntRules99:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors -> org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors:
    java.lang.String INTEGRATE_PREFIX -> INTEGRATE_PREFIX
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_TRIG_SIMPLIFY -> INTEGRATE_TRIG_SIMPLIFY
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_SMARTLEAFCOUNT -> INTEGRATE_SMARTLEAFCOUNT
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_SMARTNUMERATOR -> INTEGRATE_SMARTNUMERATOR
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_SMARTDENOMINATOR -> INTEGRATE_SMARTDENOMINATOR
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_SIMP -> INTEGRATE_SIMP
    org.matheclipse.core.interfaces.ISymbol INTEGRATE_REAPLIST -> INTEGRATE_REAPLIST
    org.matheclipse.core.interfaces.ISymbol A -> A
    org.matheclipse.core.interfaces.ISymbol B -> B
    org.matheclipse.core.interfaces.ISymbol C -> C
    org.matheclipse.core.interfaces.ISymbol F -> F
    org.matheclipse.core.interfaces.ISymbol G -> G
    org.matheclipse.core.interfaces.ISymbol H -> H
    org.matheclipse.core.interfaces.ISymbol J -> J
    org.matheclipse.core.interfaces.ISymbol K -> K
    org.matheclipse.core.interfaces.ISymbol L -> L
    org.matheclipse.core.interfaces.ISymbol M -> M
    org.matheclipse.core.interfaces.ISymbol O -> O
    org.matheclipse.core.interfaces.ISymbol P -> P
    org.matheclipse.core.interfaces.ISymbol Q -> Q
    org.matheclipse.core.interfaces.ISymbol R -> R
    org.matheclipse.core.interfaces.ISymbol S -> S
    org.matheclipse.core.interfaces.ISymbol T -> T
    org.matheclipse.core.interfaces.ISymbol U -> U
    org.matheclipse.core.interfaces.ISymbol V -> V
    org.matheclipse.core.interfaces.ISymbol W -> W
    org.matheclipse.core.interfaces.ISymbol X -> X
    org.matheclipse.core.interfaces.ISymbol Y -> Y
    org.matheclipse.core.interfaces.ISymbol Z -> Z
    org.matheclipse.core.interfaces.ISymbol AbortRubi -> AbortRubi
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST AbortRubi(org.matheclipse.core.interfaces.IExpr) -> AbortRubi
    org.matheclipse.core.interfaces.IAST F(org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST F(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> F
    org.matheclipse.core.interfaces.IAST G(org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST G(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> G
    org.matheclipse.core.interfaces.IAST H(org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST H(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST H(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> H
    org.matheclipse.core.interfaces.IAST Int(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Int
    org.matheclipse.core.interfaces.IAST Dist(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Dist
    org.matheclipse.core.interfaces.IAST Dist(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Dist
    org.matheclipse.core.interfaces.IAST AbsorbMinusSign(org.matheclipse.core.interfaces.IExpr) -> AbsorbMinusSign
    org.matheclipse.core.interfaces.IAST AbsurdNumberFactors(org.matheclipse.core.interfaces.IExpr) -> AbsurdNumberFactors
    org.matheclipse.core.interfaces.IAST AbsurdNumberGCD(org.matheclipse.core.interfaces.IExpr[]) -> AbsurdNumberGCD
    org.matheclipse.core.interfaces.IAST AbsurdNumberGCDList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> AbsurdNumberGCDList
    org.matheclipse.core.interfaces.IAST AbsurdNumberQ(org.matheclipse.core.interfaces.IExpr) -> AbsurdNumberQ
    org.matheclipse.core.interfaces.IAST ActivateTrig(org.matheclipse.core.interfaces.IExpr) -> ActivateTrig
    org.matheclipse.core.interfaces.IAST AlgebraicFunctionFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> AlgebraicFunctionFactors
    org.matheclipse.core.interfaces.IAST AlgebraicFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> AlgebraicFunctionQ
    org.matheclipse.core.interfaces.IAST AlgebraicTrigFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> AlgebraicTrigFunctionQ
    org.matheclipse.core.interfaces.IAST BinomialDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> BinomialDegree
    org.matheclipse.core.interfaces.IAST BinomialMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> BinomialMatchQ
    org.matheclipse.core.interfaces.IAST BinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> BinomialQ
    org.matheclipse.core.interfaces.IAST BinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> BinomialQ
    org.matheclipse.core.interfaces.IAST BinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> BinomialTest
    org.matheclipse.core.interfaces.IAST CalculusFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> CalculusFreeQ
    org.matheclipse.core.interfaces.IAST CalculusQ(org.matheclipse.core.interfaces.IExpr) -> CalculusQ
    org.matheclipse.core.interfaces.IAST CancelCommonFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> CancelCommonFactors
    org.matheclipse.core.interfaces.IAST CollectReciprocals(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> CollectReciprocals
    org.matheclipse.core.interfaces.IAST CombineExponents(org.matheclipse.core.interfaces.IExpr) -> CombineExponents
    org.matheclipse.core.interfaces.IAST CommonFactors(org.matheclipse.core.interfaces.IExpr) -> CommonFactors
    org.matheclipse.core.interfaces.IAST CommonNumericFactors(org.matheclipse.core.interfaces.IExpr) -> CommonNumericFactors
    org.matheclipse.core.interfaces.IAST ComplexFreeQ(org.matheclipse.core.interfaces.IExpr) -> ComplexFreeQ
    org.matheclipse.core.interfaces.IAST ConstantFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ConstantFactor
    org.matheclipse.core.interfaces.IAST ContentFactor(org.matheclipse.core.interfaces.IExpr) -> ContentFactor
    org.matheclipse.core.interfaces.IAST ContentFactorAux(org.matheclipse.core.interfaces.IExpr) -> ContentFactorAux
    org.matheclipse.core.interfaces.IAST CosQ(org.matheclipse.core.interfaces.IExpr) -> CosQ
    org.matheclipse.core.interfaces.IAST CoshQ(org.matheclipse.core.interfaces.IExpr) -> CoshQ
    org.matheclipse.core.interfaces.IAST CotQ(org.matheclipse.core.interfaces.IExpr) -> CotQ
    org.matheclipse.core.interfaces.IAST CothQ(org.matheclipse.core.interfaces.IExpr) -> CothQ
    org.matheclipse.core.interfaces.IAST CscQ(org.matheclipse.core.interfaces.IExpr) -> CscQ
    org.matheclipse.core.interfaces.IAST CschQ(org.matheclipse.core.interfaces.IExpr) -> CschQ
    org.matheclipse.core.interfaces.IAST CubicMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> CubicMatchQ
    org.matheclipse.core.interfaces.IAST DeactivateTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> DeactivateTrig
    org.matheclipse.core.interfaces.IAST DeactivateTrigAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> DeactivateTrigAux
    org.matheclipse.core.interfaces.IAST DerivativeDivides(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> DerivativeDivides
    org.matheclipse.core.interfaces.IAST Distrib(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Distrib
    org.matheclipse.core.interfaces.IAST DivideDegreesOfFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> DivideDegreesOfFactors
    org.matheclipse.core.interfaces.IAST Divides(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Divides
    org.matheclipse.core.interfaces.IAST EasyDQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> EasyDQ
    org.matheclipse.core.interfaces.IAST EulerIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> EulerIntegrandQ
    org.matheclipse.core.interfaces.IAST EvenQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> EvenQuotientQ
    org.matheclipse.core.interfaces.IAST ExpQ(org.matheclipse.core.interfaces.IExpr) -> ExpQ
    org.matheclipse.core.interfaces.IAST ExpandAlgebraicFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandAlgebraicFunction
    org.matheclipse.core.interfaces.IAST ExpandCleanup(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandCleanup
    org.matheclipse.core.interfaces.IAST ExpandExpression(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandExpression
    org.matheclipse.core.interfaces.IAST ExpandIntegrand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandIntegrand
    org.matheclipse.core.interfaces.IAST ExpandIntegrand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandIntegrand
    org.matheclipse.core.interfaces.IAST ExpandLinearProduct(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandLinearProduct
    org.matheclipse.core.interfaces.IAST ExpandToSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandToSum
    org.matheclipse.core.interfaces.IAST ExpandToSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandToSum
    org.matheclipse.core.interfaces.IAST ExpandTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandTrig
    org.matheclipse.core.interfaces.IAST ExpandTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandTrig
    org.matheclipse.core.interfaces.IAST ExpandTrigExpand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandTrigExpand
    org.matheclipse.core.interfaces.IAST ExpandTrigReduce(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandTrigReduce
    org.matheclipse.core.interfaces.IAST ExpandTrigReduce(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandTrigReduce
    org.matheclipse.core.interfaces.IAST ExpandTrigReduceAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandTrigReduceAux
    org.matheclipse.core.interfaces.IAST ExpandTrigToExp(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandTrigToExp
    org.matheclipse.core.interfaces.IAST ExpandTrigToExp(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExpandTrigToExp
    org.matheclipse.core.interfaces.IAST ExponentIn(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExponentIn
    org.matheclipse.core.interfaces.IAST ExponentInAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ExponentInAux
    org.matheclipse.core.interfaces.IAST FactorAbsurdNumber(org.matheclipse.core.interfaces.IExpr) -> FactorAbsurdNumber
    org.matheclipse.core.interfaces.IAST FactorNumericGcd(org.matheclipse.core.interfaces.IExpr) -> FactorNumericGcd
    org.matheclipse.core.interfaces.IAST FactorOrder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FactorOrder
    org.matheclipse.core.interfaces.IAST FalseQ(org.matheclipse.core.interfaces.IExpr) -> FalseQ
    org.matheclipse.core.interfaces.IAST FindTrigFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FindTrigFactor
    org.matheclipse.core.interfaces.IAST FixInertTrigFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FixInertTrigFunction
    org.matheclipse.core.interfaces.IAST FixIntRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FixIntRule
    org.matheclipse.core.interfaces.IAST FixIntRules(org.matheclipse.core.interfaces.IExpr) -> FixIntRules
    org.matheclipse.core.interfaces.IAST FixRhsIntRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FixRhsIntRule
    org.matheclipse.core.interfaces.IAST FixSimplify(org.matheclipse.core.interfaces.IExpr) -> FixSimplify
    org.matheclipse.core.interfaces.IAST FractionOrNegativeQ(org.matheclipse.core.interfaces.IExpr[]) -> FractionOrNegativeQ
    org.matheclipse.core.interfaces.IAST FractionQ(org.matheclipse.core.interfaces.IExpr[]) -> FractionQ
    org.matheclipse.core.interfaces.IAST FractionalPowerFreeQ(org.matheclipse.core.interfaces.IExpr) -> FractionalPowerFreeQ
    org.matheclipse.core.interfaces.IAST FractionalPowerOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FractionalPowerOfLinear
    org.matheclipse.core.interfaces.IAST FractionalPowerOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FractionalPowerOfQuotientOfLinears
    org.matheclipse.core.interfaces.IAST FractionalPowerOfSquareQ(org.matheclipse.core.interfaces.IExpr) -> FractionalPowerOfSquareQ
    org.matheclipse.core.interfaces.IAST FractionalPowerQ(org.matheclipse.core.interfaces.IExpr) -> FractionalPowerQ
    org.matheclipse.core.interfaces.IAST FractionalPowerSubexpressionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FractionalPowerSubexpressionQ
    org.matheclipse.core.interfaces.IAST FreeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FreeFactors
    org.matheclipse.core.interfaces.IAST FreeTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FreeTerms
    org.matheclipse.core.interfaces.IAST FunctionOfCosQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfCosQ
    org.matheclipse.core.interfaces.IAST FunctionOfCoshQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfCoshQ
    org.matheclipse.core.interfaces.IAST FunctionOfDensePolynomialsQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfDensePolynomialsQ
    org.matheclipse.core.interfaces.IAST FunctionOfExpnQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfExpnQ
    org.matheclipse.core.interfaces.IAST FunctionOfExponential(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfExponential
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfExponentialFunction
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialFunctionAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfExponentialFunctionAux
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfExponentialQ
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfExponentialTest
    org.matheclipse.core.interfaces.IAST FunctionOfExponentialTestAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfExponentialTestAux
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfHyperbolic
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfHyperbolic
    org.matheclipse.core.interfaces.IAST FunctionOfHyperbolicQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfHyperbolicQ
    org.matheclipse.core.interfaces.IAST FunctionOfInverseLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfInverseLinear
    org.matheclipse.core.interfaces.IAST FunctionOfInverseLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfInverseLinear
    org.matheclipse.core.interfaces.IAST FunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfLinear
    org.matheclipse.core.interfaces.IAST FunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfLinear
    org.matheclipse.core.interfaces.IAST FunctionOfLinearSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfLinearSubst
    org.matheclipse.core.interfaces.IAST FunctionOfLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfLog
    org.matheclipse.core.interfaces.IAST FunctionOfLog(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfLog
    org.matheclipse.core.interfaces.IAST FunctionOfQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfQ
    org.matheclipse.core.interfaces.IAST FunctionOfQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfQ
    org.matheclipse.core.interfaces.IAST FunctionOfSinQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfSinQ
    org.matheclipse.core.interfaces.IAST FunctionOfSinhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfSinhQ
    org.matheclipse.core.interfaces.IAST FunctionOfSquareRootOfQuadratic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfSquareRootOfQuadratic
    org.matheclipse.core.interfaces.IAST FunctionOfSquareRootOfQuadratic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfSquareRootOfQuadratic
    org.matheclipse.core.interfaces.IAST FunctionOfTanQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfTanQ
    org.matheclipse.core.interfaces.IAST FunctionOfTanWeight(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfTanWeight
    org.matheclipse.core.interfaces.IAST FunctionOfTanhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfTanhQ
    org.matheclipse.core.interfaces.IAST FunctionOfTanhWeight(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfTanhWeight
    org.matheclipse.core.interfaces.IAST FunctionOfTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfTrig
    org.matheclipse.core.interfaces.IAST FunctionOfTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfTrig
    org.matheclipse.core.interfaces.IAST FunctionOfTrigOfLinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfTrigOfLinearQ
    org.matheclipse.core.interfaces.IAST FunctionOfTrigQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> FunctionOfTrigQ
    org.matheclipse.core.interfaces.IAST GE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GE
    org.matheclipse.core.interfaces.IAST GE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GE
    org.matheclipse.core.interfaces.IAST GT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GT
    org.matheclipse.core.interfaces.IAST GT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GT
    org.matheclipse.core.interfaces.IAST Gcd(org.matheclipse.core.interfaces.IExpr[]) -> Gcd
    org.matheclipse.core.interfaces.IAST Gcd(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Gcd
    org.matheclipse.core.interfaces.IAST GeneralizedBinomialDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GeneralizedBinomialDegree
    org.matheclipse.core.interfaces.IAST GeneralizedBinomialMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GeneralizedBinomialMatchQ
    org.matheclipse.core.interfaces.IAST GeneralizedBinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GeneralizedBinomialQ
    org.matheclipse.core.interfaces.IAST GeneralizedBinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GeneralizedBinomialTest
    org.matheclipse.core.interfaces.IAST GeneralizedTrinomialDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GeneralizedTrinomialDegree
    org.matheclipse.core.interfaces.IAST GeneralizedTrinomialMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GeneralizedTrinomialMatchQ
    org.matheclipse.core.interfaces.IAST GeneralizedTrinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GeneralizedTrinomialQ
    org.matheclipse.core.interfaces.IAST GeneralizedTrinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GeneralizedTrinomialTest
    org.matheclipse.core.interfaces.IAST GensymSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> GensymSubst
    org.matheclipse.core.interfaces.IAST HeldFormQ(org.matheclipse.core.interfaces.IExpr) -> HeldFormQ
    org.matheclipse.core.interfaces.IAST HyperbolicQ(org.matheclipse.core.interfaces.IExpr) -> HyperbolicQ
    org.matheclipse.core.interfaces.IAST ImaginaryNumericQ(org.matheclipse.core.interfaces.IExpr) -> ImaginaryNumericQ
    org.matheclipse.core.interfaces.IAST ImaginaryQ(org.matheclipse.core.interfaces.IExpr) -> ImaginaryQ
    org.matheclipse.core.interfaces.IAST IndependentQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> IndependentQ
    org.matheclipse.core.interfaces.IAST InertReciprocalQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> InertReciprocalQ
    org.matheclipse.core.interfaces.IAST InertTrigFreeQ(org.matheclipse.core.interfaces.IExpr) -> InertTrigFreeQ
    org.matheclipse.core.interfaces.IAST InertTrigQ(org.matheclipse.core.interfaces.IExpr) -> InertTrigQ
    org.matheclipse.core.interfaces.IAST InertTrigQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> InertTrigQ
    org.matheclipse.core.interfaces.IAST InertTrigQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> InertTrigQ
    org.matheclipse.core.interfaces.IAST InertTrigSumQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> InertTrigSumQ
    org.matheclipse.core.interfaces.IAST IntSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> IntSum
    org.matheclipse.core.interfaces.IAST IntTerm(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> IntTerm
    org.matheclipse.core.interfaces.IAST IntegerPowerQ(org.matheclipse.core.interfaces.IExpr) -> IntegerPowerQ
    org.matheclipse.core.interfaces.IAST IntegerQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> IntegerQuotientQ
    org.matheclipse.core.interfaces.IAST IntegersQ(org.matheclipse.core.interfaces.IExpr[]) -> IntegersQ
    org.matheclipse.core.interfaces.IAST InverseFunctionFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> InverseFunctionFreeQ
    org.matheclipse.core.interfaces.IAST InverseFunctionOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> InverseFunctionOfLinear
    org.matheclipse.core.interfaces.IAST InverseFunctionOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> InverseFunctionOfQuotientOfLinears
    org.matheclipse.core.interfaces.IAST InverseFunctionQ(org.matheclipse.core.interfaces.IExpr) -> InverseFunctionQ
    org.matheclipse.core.interfaces.IAST InverseHyperbolicQ(org.matheclipse.core.interfaces.IExpr) -> InverseHyperbolicQ
    org.matheclipse.core.interfaces.IAST InverseTrigQ(org.matheclipse.core.interfaces.IExpr) -> InverseTrigQ
    org.matheclipse.core.interfaces.IAST KernelSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> KernelSubst
    org.matheclipse.core.interfaces.IAST KnownCotangentIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> KnownCotangentIntegrandQ
    org.matheclipse.core.interfaces.IAST KnownSecantIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> KnownSecantIntegrandQ
    org.matheclipse.core.interfaces.IAST KnownSineIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> KnownSineIntegrandQ
    org.matheclipse.core.interfaces.IAST KnownTangentIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> KnownTangentIntegrandQ
    org.matheclipse.core.interfaces.IAST KnownTrigIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> KnownTrigIntegrandQ
    org.matheclipse.core.interfaces.IAST LE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LE
    org.matheclipse.core.interfaces.IAST LE(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LE
    org.matheclipse.core.interfaces.IAST LT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LT
    org.matheclipse.core.interfaces.IAST LT(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LT
    org.matheclipse.core.interfaces.IAST LeadBase(org.matheclipse.core.interfaces.IExpr) -> LeadBase
    org.matheclipse.core.interfaces.IAST LeadDegree(org.matheclipse.core.interfaces.IExpr) -> LeadDegree
    org.matheclipse.core.interfaces.IAST LeadFactor(org.matheclipse.core.interfaces.IExpr) -> LeadFactor
    org.matheclipse.core.interfaces.IAST LeadTerm(org.matheclipse.core.interfaces.IExpr) -> LeadTerm
    org.matheclipse.core.interfaces.IAST LinearMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LinearMatchQ
    org.matheclipse.core.interfaces.IAST LinearPairQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LinearPairQ
    org.matheclipse.core.interfaces.IAST LinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> LinearQ
    org.matheclipse.core.interfaces.IAST LogQ(org.matheclipse.core.interfaces.IExpr) -> LogQ
    org.matheclipse.core.interfaces.IAST MakeAssocList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MakeAssocList
    org.matheclipse.core.interfaces.IAST MakeAssocList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MakeAssocList
    org.matheclipse.core.interfaces.IAST Map2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Map2
    org.matheclipse.core.interfaces.IAST MapAnd(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MapAnd
    org.matheclipse.core.interfaces.IAST MapAnd(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MapAnd
    org.matheclipse.core.interfaces.IAST MapOr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MapOr
    org.matheclipse.core.interfaces.IAST MergeFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MergeFactor
    org.matheclipse.core.interfaces.IAST MergeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MergeFactors
    org.matheclipse.core.interfaces.IAST MergeMonomials(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MergeMonomials
    org.matheclipse.core.interfaces.IAST MergeableFactorQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MergeableFactorQ
    org.matheclipse.core.interfaces.IAST MinimumDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MinimumDegree
    org.matheclipse.core.interfaces.IAST MinimumMonomialExponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MinimumMonomialExponent
    org.matheclipse.core.interfaces.IAST MonomialExponent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MonomialExponent
    org.matheclipse.core.interfaces.IAST MonomialFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MonomialFactor
    org.matheclipse.core.interfaces.IAST MonomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MonomialQ
    org.matheclipse.core.interfaces.IAST MonomialSumQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> MonomialSumQ
    org.matheclipse.core.interfaces.IAST MostMainFactorPosition(org.matheclipse.core.interfaces.IExpr) -> MostMainFactorPosition
    org.matheclipse.core.interfaces.IAST NegQ(org.matheclipse.core.interfaces.IExpr) -> NegQ
    org.matheclipse.core.interfaces.IAST NegativeCoefficientQ(org.matheclipse.core.interfaces.IExpr) -> NegativeCoefficientQ
    org.matheclipse.core.interfaces.IAST NegativeIntegerQ(org.matheclipse.core.interfaces.IExpr[]) -> NegativeIntegerQ
    org.matheclipse.core.interfaces.IAST NegativeOrZeroQ(org.matheclipse.core.interfaces.IExpr) -> NegativeOrZeroQ
    org.matheclipse.core.interfaces.IAST NegativeQ(org.matheclipse.core.interfaces.IExpr) -> NegativeQ
    org.matheclipse.core.interfaces.IAST NiceSqrtAuxQ(org.matheclipse.core.interfaces.IExpr) -> NiceSqrtAuxQ
    org.matheclipse.core.interfaces.IAST NiceSqrtQ(org.matheclipse.core.interfaces.IExpr) -> NiceSqrtQ
    org.matheclipse.core.interfaces.IAST NonabsurdNumberFactors(org.matheclipse.core.interfaces.IExpr) -> NonabsurdNumberFactors
    org.matheclipse.core.interfaces.IAST NonalgebraicFunctionFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NonalgebraicFunctionFactors
    org.matheclipse.core.interfaces.IAST NonfreeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NonfreeFactors
    org.matheclipse.core.interfaces.IAST NonfreeTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NonfreeTerms
    org.matheclipse.core.interfaces.IAST NonnumericFactors(org.matheclipse.core.interfaces.IExpr) -> NonnumericFactors
    org.matheclipse.core.interfaces.IAST NonpolynomialTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NonpolynomialTerms
    org.matheclipse.core.interfaces.IAST NonpositiveFactors(org.matheclipse.core.interfaces.IExpr) -> NonpositiveFactors
    org.matheclipse.core.interfaces.IAST NonrationalFunctionFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NonrationalFunctionFactors
    org.matheclipse.core.interfaces.IAST NonsumQ(org.matheclipse.core.interfaces.IExpr) -> NonsumQ
    org.matheclipse.core.interfaces.IAST NonzeroQ(org.matheclipse.core.interfaces.IExpr) -> NonzeroQ
    org.matheclipse.core.interfaces.IAST NormalizeIntegrand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NormalizeIntegrand
    org.matheclipse.core.interfaces.IAST NormalizeIntegrandAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NormalizeIntegrandAux
    org.matheclipse.core.interfaces.IAST NormalizeIntegrandFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NormalizeIntegrandFactor
    org.matheclipse.core.interfaces.IAST NormalizeIntegrandFactorBase(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NormalizeIntegrandFactorBase
    org.matheclipse.core.interfaces.IAST NormalizeLeadTermSigns(org.matheclipse.core.interfaces.IExpr) -> NormalizeLeadTermSigns
    org.matheclipse.core.interfaces.IAST NormalizePowerOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NormalizePowerOfLinear
    org.matheclipse.core.interfaces.IAST NormalizeSumFactors(org.matheclipse.core.interfaces.IExpr) -> NormalizeSumFactors
    org.matheclipse.core.interfaces.IAST NormalizeTogether(org.matheclipse.core.interfaces.IExpr) -> NormalizeTogether
    org.matheclipse.core.interfaces.IAST NormalizeTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NormalizeTrig
    org.matheclipse.core.interfaces.IAST NotFalseQ(org.matheclipse.core.interfaces.IExpr) -> NotFalseQ
    org.matheclipse.core.interfaces.IAST NotIntegrableQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> NotIntegrableQ
    org.matheclipse.core.interfaces.IAST NumericFactor(org.matheclipse.core.interfaces.IExpr) -> NumericFactor
    org.matheclipse.core.interfaces.IAST OddHyperbolicPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> OddHyperbolicPowerQ
    org.matheclipse.core.interfaces.IAST OddQuotientQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> OddQuotientQ
    org.matheclipse.core.interfaces.IAST OddTrigPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> OddTrigPowerQ
    org.matheclipse.core.interfaces.IAST OneQ(org.matheclipse.core.interfaces.IExpr) -> OneQ
    org.matheclipse.core.interfaces.IAST OneQ(org.matheclipse.core.interfaces.IExpr[]) -> OneQ
    org.matheclipse.core.interfaces.IAST PerfectPowerTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PerfectPowerTest
    org.matheclipse.core.interfaces.IAST PerfectSquareQ(org.matheclipse.core.interfaces.IExpr) -> PerfectSquareQ
    org.matheclipse.core.interfaces.IAST PiecewiseLinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PiecewiseLinearQ
    org.matheclipse.core.interfaces.IAST PiecewiseLinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PiecewiseLinearQ
    org.matheclipse.core.interfaces.IAST PolyQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolyQ
    org.matheclipse.core.interfaces.IAST PolynomialDivide(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialDivide
    org.matheclipse.core.interfaces.IAST PolynomialDivide(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialDivide
    org.matheclipse.core.interfaces.IAST PolynomialInAuxQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialInAuxQ
    org.matheclipse.core.interfaces.IAST PolynomialInQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialInQ
    org.matheclipse.core.interfaces.IAST PolynomialInSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialInSubst
    org.matheclipse.core.interfaces.IAST PolynomialInSubstAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialInSubstAux
    org.matheclipse.core.interfaces.IAST PolynomialTermQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialTermQ
    org.matheclipse.core.interfaces.IAST PolynomialTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PolynomialTerms
    org.matheclipse.core.interfaces.IAST PosAux(org.matheclipse.core.interfaces.IExpr) -> PosAux
    org.matheclipse.core.interfaces.IAST PosQ(org.matheclipse.core.interfaces.IExpr) -> PosQ
    org.matheclipse.core.interfaces.IAST PositiveFactors(org.matheclipse.core.interfaces.IExpr) -> PositiveFactors
    org.matheclipse.core.interfaces.IAST PositiveIntegerPowerQ(org.matheclipse.core.interfaces.IExpr) -> PositiveIntegerPowerQ
    org.matheclipse.core.interfaces.IAST PositiveIntegerQ(org.matheclipse.core.interfaces.IExpr[]) -> PositiveIntegerQ
    org.matheclipse.core.interfaces.IAST PositiveOrZeroQ(org.matheclipse.core.interfaces.IExpr) -> PositiveOrZeroQ
    org.matheclipse.core.interfaces.IAST PositiveQ(org.matheclipse.core.interfaces.IExpr) -> PositiveQ
    org.matheclipse.core.interfaces.IAST PowerOfLinearMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PowerOfLinearMatchQ
    org.matheclipse.core.interfaces.IAST PowerOfLinearQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PowerOfLinearQ
    org.matheclipse.core.interfaces.IAST PowerQ(org.matheclipse.core.interfaces.IExpr) -> PowerQ
    org.matheclipse.core.interfaces.IAST PowerVariableDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PowerVariableDegree
    org.matheclipse.core.interfaces.IAST PowerVariableExpn(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PowerVariableExpn
    org.matheclipse.core.interfaces.IAST PowerVariableSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PowerVariableSubst
    org.matheclipse.core.interfaces.IAST ProductOfLinearPowersQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> ProductOfLinearPowersQ
    org.matheclipse.core.interfaces.IAST ProductQ(org.matheclipse.core.interfaces.IExpr) -> ProductQ
    org.matheclipse.core.interfaces.IAST PureFunctionOfCosQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PureFunctionOfCosQ
    org.matheclipse.core.interfaces.IAST PureFunctionOfCoshQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PureFunctionOfCoshQ
    org.matheclipse.core.interfaces.IAST PureFunctionOfCotQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PureFunctionOfCotQ
    org.matheclipse.core.interfaces.IAST PureFunctionOfCothQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PureFunctionOfCothQ
    org.matheclipse.core.interfaces.IAST PureFunctionOfSinQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PureFunctionOfSinQ
    org.matheclipse.core.interfaces.IAST PureFunctionOfSinhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PureFunctionOfSinhQ
    org.matheclipse.core.interfaces.IAST PureFunctionOfTanQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PureFunctionOfTanQ
    org.matheclipse.core.interfaces.IAST PureFunctionOfTanhQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> PureFunctionOfTanhQ
    org.matheclipse.core.interfaces.IAST QuadraticMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> QuadraticMatchQ
    org.matheclipse.core.interfaces.IAST QuadraticQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> QuadraticQ
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> QuotientOfLinearsMatchQ
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsP(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> QuotientOfLinearsP
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsParts(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> QuotientOfLinearsParts
    org.matheclipse.core.interfaces.IAST QuotientOfLinearsQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> QuotientOfLinearsQ
    org.matheclipse.core.interfaces.IAST RationalFunctionExpand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RationalFunctionExpand
    org.matheclipse.core.interfaces.IAST RationalFunctionExponents(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RationalFunctionExponents
    org.matheclipse.core.interfaces.IAST RationalFunctionFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RationalFunctionFactors
    org.matheclipse.core.interfaces.IAST RationalFunctionQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RationalFunctionQ
    org.matheclipse.core.interfaces.IAST RationalPowerQ(org.matheclipse.core.interfaces.IExpr) -> RationalPowerQ
    org.matheclipse.core.interfaces.IAST RationalQ(org.matheclipse.core.interfaces.IExpr[]) -> RationalQ
    org.matheclipse.core.interfaces.IAST RealNumericQ(org.matheclipse.core.interfaces.IExpr) -> RealNumericQ
    org.matheclipse.core.interfaces.IAST RealQ(org.matheclipse.core.interfaces.IExpr) -> RealQ
    org.matheclipse.core.interfaces.IAST ReapList(org.matheclipse.core.interfaces.IExpr) -> ReapList
    org.matheclipse.core.interfaces.IAST RectifyCotangent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RectifyCotangent
    org.matheclipse.core.interfaces.IAST RectifyCotangent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RectifyCotangent
    org.matheclipse.core.interfaces.IAST RectifyTangent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RectifyTangent
    org.matheclipse.core.interfaces.IAST RectifyTangent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RectifyTangent
    org.matheclipse.core.interfaces.IAST RemainingFactors(org.matheclipse.core.interfaces.IExpr) -> RemainingFactors
    org.matheclipse.core.interfaces.IAST RemainingTerms(org.matheclipse.core.interfaces.IExpr) -> RemainingTerms
    org.matheclipse.core.interfaces.IAST RemoveContent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RemoveContent
    org.matheclipse.core.interfaces.IAST Rt(org.matheclipse.core.interfaces.IExpr) -> Rt
    org.matheclipse.core.interfaces.IAST Rt(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Rt
    org.matheclipse.core.interfaces.IAST RtAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> RtAux
    org.matheclipse.core.interfaces.IAST SecQ(org.matheclipse.core.interfaces.IExpr) -> SecQ
    org.matheclipse.core.interfaces.IAST SechQ(org.matheclipse.core.interfaces.IExpr) -> SechQ
    org.matheclipse.core.interfaces.IAST SignOfFactor(org.matheclipse.core.interfaces.IExpr) -> SignOfFactor
    org.matheclipse.core.interfaces.IAST Simp(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Simp
    org.matheclipse.core.interfaces.IAST SimpFixFactor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimpFixFactor
    org.matheclipse.core.interfaces.IAST SimpHelp(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimpHelp
    org.matheclipse.core.interfaces.IAST SimplerIntegrandQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimplerIntegrandQ
    org.matheclipse.core.interfaces.IAST SimplerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimplerQ
    org.matheclipse.core.interfaces.IAST SimplerSqrtQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimplerSqrtQ
    org.matheclipse.core.interfaces.IAST SimplifyAntiderivative(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimplifyAntiderivative
    org.matheclipse.core.interfaces.IAST SimplifyAntiderivativeSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimplifyAntiderivativeSum
    org.matheclipse.core.interfaces.IAST SimplifyIntegrand(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimplifyIntegrand
    org.matheclipse.core.interfaces.IAST SimplifyTerm(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SimplifyTerm
    org.matheclipse.core.interfaces.IAST SinCosQ(org.matheclipse.core.interfaces.IExpr) -> SinCosQ
    org.matheclipse.core.interfaces.IAST SinQ(org.matheclipse.core.interfaces.IExpr) -> SinQ
    org.matheclipse.core.interfaces.IAST SinhCoshQ(org.matheclipse.core.interfaces.IExpr) -> SinhCoshQ
    org.matheclipse.core.interfaces.IAST SinhQ(org.matheclipse.core.interfaces.IExpr) -> SinhQ
    org.matheclipse.core.interfaces.IAST Smallest(org.matheclipse.core.interfaces.IExpr) -> Smallest
    org.matheclipse.core.interfaces.IAST Smallest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Smallest
    org.matheclipse.core.interfaces.IAST SmartApart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SmartApart
    org.matheclipse.core.interfaces.IAST SmartApart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SmartApart
    org.matheclipse.core.interfaces.IAST SmartDenominator(org.matheclipse.core.interfaces.IExpr) -> SmartDenominator
    org.matheclipse.core.interfaces.IAST SmartNumerator(org.matheclipse.core.interfaces.IExpr) -> SmartNumerator
    org.matheclipse.core.interfaces.IAST SmartSimplify(org.matheclipse.core.interfaces.IExpr) -> SmartSimplify
    org.matheclipse.core.interfaces.IAST SplitFreeFactors(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SplitFreeFactors
    org.matheclipse.core.interfaces.IAST SqrtNumberQ(org.matheclipse.core.interfaces.IExpr) -> SqrtNumberQ
    org.matheclipse.core.interfaces.IAST SqrtNumberSumQ(org.matheclipse.core.interfaces.IExpr) -> SqrtNumberSumQ
    org.matheclipse.core.interfaces.IAST SqrtQ(org.matheclipse.core.interfaces.IExpr) -> SqrtQ
    org.matheclipse.core.interfaces.IAST SquareRootOfQuadraticSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SquareRootOfQuadraticSubst
    org.matheclipse.core.interfaces.IAST Subst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> Subst
    org.matheclipse.core.interfaces.IAST SubstAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstAux
    org.matheclipse.core.interfaces.IAST SubstFor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstFor
    org.matheclipse.core.interfaces.IAST SubstFor(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstFor
    org.matheclipse.core.interfaces.IAST SubstForAux(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForAux
    org.matheclipse.core.interfaces.IAST SubstForExpn(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForExpn
    org.matheclipse.core.interfaces.IAST SubstForFractionalPower(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForFractionalPower
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerAuxQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForFractionalPowerAuxQ
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerOfLinear(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForFractionalPowerOfLinear
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForFractionalPowerOfQuotientOfLinears
    org.matheclipse.core.interfaces.IAST SubstForFractionalPowerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForFractionalPowerQ
    org.matheclipse.core.interfaces.IAST SubstForHyperbolic(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForHyperbolic
    org.matheclipse.core.interfaces.IAST SubstForInverseFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForInverseFunction
    org.matheclipse.core.interfaces.IAST SubstForInverseFunction(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForInverseFunction
    org.matheclipse.core.interfaces.IAST SubstForInverseFunctionOfQuotientOfLinears(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForInverseFunctionOfQuotientOfLinears
    org.matheclipse.core.interfaces.IAST SubstForTrig(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SubstForTrig
    org.matheclipse.core.interfaces.IAST SumQ(org.matheclipse.core.interfaces.IExpr) -> SumQ
    org.matheclipse.core.interfaces.IAST SumSimplerAuxQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SumSimplerAuxQ
    org.matheclipse.core.interfaces.IAST SumSimplerQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> SumSimplerQ
    org.matheclipse.core.interfaces.IAST TanQ(org.matheclipse.core.interfaces.IExpr) -> TanQ
    org.matheclipse.core.interfaces.IAST TanhQ(org.matheclipse.core.interfaces.IExpr) -> TanhQ
    org.matheclipse.core.interfaces.IAST TogetherSimplify(org.matheclipse.core.interfaces.IExpr) -> TogetherSimplify
    org.matheclipse.core.interfaces.IAST TrigHyperbolicFreeQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TrigHyperbolicFreeQ
    org.matheclipse.core.interfaces.IAST TrigQ(org.matheclipse.core.interfaces.IExpr) -> TrigQ
    org.matheclipse.core.interfaces.IAST TrigSimplify(org.matheclipse.core.interfaces.IExpr) -> TrigSimplify
    org.matheclipse.core.interfaces.IAST TrigSimplifyAux(org.matheclipse.core.interfaces.IExpr) -> TrigSimplifyAux
    org.matheclipse.core.interfaces.IAST TrigSimplifyQ(org.matheclipse.core.interfaces.IExpr) -> TrigSimplifyQ
    org.matheclipse.core.interfaces.IAST TrigSimplifyRecur(org.matheclipse.core.interfaces.IExpr) -> TrigSimplifyRecur
    org.matheclipse.core.interfaces.IAST TrinomialDegree(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TrinomialDegree
    org.matheclipse.core.interfaces.IAST TrinomialMatchQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TrinomialMatchQ
    org.matheclipse.core.interfaces.IAST TrinomialQ(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TrinomialQ
    org.matheclipse.core.interfaces.IAST TrinomialTest(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TrinomialTest
    org.matheclipse.core.interfaces.IAST TryPureTanSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TryPureTanSubst
    org.matheclipse.core.interfaces.IAST TryPureTanhSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TryPureTanhSubst
    org.matheclipse.core.interfaces.IAST TryTanhSubst(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> TryTanhSubst
    org.matheclipse.core.interfaces.IAST UnifyNegativeBaseFactors(org.matheclipse.core.interfaces.IExpr) -> UnifyNegativeBaseFactors
    org.matheclipse.core.interfaces.IAST UnifySum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UnifySum
    org.matheclipse.core.interfaces.IAST UnifyTerm(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UnifyTerm
    org.matheclipse.core.interfaces.IAST UnifyTerms(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> UnifyTerms
    org.matheclipse.core.interfaces.IAST ZeroQ(org.matheclipse.core.interfaces.IExpr) -> ZeroQ
    org.matheclipse.core.interfaces.IAST ZeroQ(org.matheclipse.core.interfaces.IExpr[]) -> ZeroQ
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctions -> org.matheclipse.core.integrate.rubi45.UtilityFunctions:
    java.lang.String INTEGRATE_PREFIX -> INTEGRATE_PREFIX
    org.matheclipse.core.interfaces.ISymbol pa -> pa
    org.matheclipse.core.interfaces.ISymbol pb -> pb
    org.matheclipse.core.interfaces.ISymbol pc -> pc
    org.matheclipse.core.interfaces.ISymbol pd -> pd
    org.matheclipse.core.interfaces.ISymbol pe -> pe
    org.matheclipse.core.interfaces.ISymbol pf -> pf
    org.matheclipse.core.interfaces.ISymbol pg -> pg
    org.matheclipse.core.interfaces.ISymbol ph -> ph
    org.matheclipse.core.interfaces.ISymbol pi -> pi
    org.matheclipse.core.interfaces.ISymbol pj -> pj
    org.matheclipse.core.interfaces.ISymbol pk -> pk
    org.matheclipse.core.interfaces.ISymbol pl -> pl
    org.matheclipse.core.interfaces.ISymbol pm -> pm
    org.matheclipse.core.interfaces.ISymbol pn -> pn
    org.matheclipse.core.interfaces.ISymbol po -> po
    org.matheclipse.core.interfaces.ISymbol pp -> pp
    org.matheclipse.core.interfaces.ISymbol pq -> pq
    org.matheclipse.core.interfaces.ISymbol pr -> pr
    org.matheclipse.core.interfaces.ISymbol ps -> ps
    org.matheclipse.core.interfaces.ISymbol pt -> pt
    org.matheclipse.core.interfaces.ISymbol pu -> pu
    org.matheclipse.core.interfaces.ISymbol pv -> pv
    org.matheclipse.core.interfaces.ISymbol pw -> pw
    org.matheclipse.core.interfaces.ISymbol px -> px
    org.matheclipse.core.interfaces.ISymbol py -> py
    org.matheclipse.core.interfaces.ISymbol pz -> pz
    org.matheclipse.core.interfaces.IPattern pa_ -> pa_
    org.matheclipse.core.interfaces.IPattern pb_ -> pb_
    org.matheclipse.core.interfaces.IPattern pc_ -> pc_
    org.matheclipse.core.interfaces.IPattern pd_ -> pd_
    org.matheclipse.core.interfaces.IPattern pe_ -> pe_
    org.matheclipse.core.interfaces.IPattern pf_ -> pf_
    org.matheclipse.core.interfaces.IPattern pg_ -> pg_
    org.matheclipse.core.interfaces.IPattern ph_ -> ph_
    org.matheclipse.core.interfaces.IPattern pi_ -> pi_
    org.matheclipse.core.interfaces.IPattern pj_ -> pj_
    org.matheclipse.core.interfaces.IPattern pk_ -> pk_
    org.matheclipse.core.interfaces.IPattern pl_ -> pl_
    org.matheclipse.core.interfaces.IPattern pm_ -> pm_
    org.matheclipse.core.interfaces.IPattern pn_ -> pn_
    org.matheclipse.core.interfaces.IPattern po_ -> po_
    org.matheclipse.core.interfaces.IPattern pp_ -> pp_
    org.matheclipse.core.interfaces.IPattern pq_ -> pq_
    org.matheclipse.core.interfaces.IPattern pr_ -> pr_
    org.matheclipse.core.interfaces.IPattern ps_ -> ps_
    org.matheclipse.core.interfaces.IPattern pt_ -> pt_
    org.matheclipse.core.interfaces.IPattern pu_ -> pu_
    org.matheclipse.core.interfaces.IPattern pv_ -> pv_
    org.matheclipse.core.interfaces.IPattern pw_ -> pw_
    org.matheclipse.core.interfaces.IPattern px_ -> px_
    org.matheclipse.core.interfaces.IPattern py_ -> py_
    org.matheclipse.core.interfaces.IPattern pz_ -> pz_
    org.matheclipse.core.interfaces.IPattern pa_DEFAULT -> pa_DEFAULT
    org.matheclipse.core.interfaces.IPattern pb_DEFAULT -> pb_DEFAULT
    org.matheclipse.core.interfaces.IPattern pc_DEFAULT -> pc_DEFAULT
    org.matheclipse.core.interfaces.IPattern pd_DEFAULT -> pd_DEFAULT
    org.matheclipse.core.interfaces.IPattern pe_DEFAULT -> pe_DEFAULT
    org.matheclipse.core.interfaces.IPattern pf_DEFAULT -> pf_DEFAULT
    org.matheclipse.core.interfaces.IPattern pg_DEFAULT -> pg_DEFAULT
    org.matheclipse.core.interfaces.IPattern ph_DEFAULT -> ph_DEFAULT
    org.matheclipse.core.interfaces.IPattern pi_DEFAULT -> pi_DEFAULT
    org.matheclipse.core.interfaces.IPattern pj_DEFAULT -> pj_DEFAULT
    org.matheclipse.core.interfaces.IPattern pk_DEFAULT -> pk_DEFAULT
    org.matheclipse.core.interfaces.IPattern pl_DEFAULT -> pl_DEFAULT
    org.matheclipse.core.interfaces.IPattern pm_DEFAULT -> pm_DEFAULT
    org.matheclipse.core.interfaces.IPattern pn_DEFAULT -> pn_DEFAULT
    org.matheclipse.core.interfaces.IPattern po_DEFAULT -> po_DEFAULT
    org.matheclipse.core.interfaces.IPattern pp_DEFAULT -> pp_DEFAULT
    org.matheclipse.core.interfaces.IPattern pq_DEFAULT -> pq_DEFAULT
    org.matheclipse.core.interfaces.IPattern pr_DEFAULT -> pr_DEFAULT
    org.matheclipse.core.interfaces.IPattern ps_DEFAULT -> ps_DEFAULT
    org.matheclipse.core.interfaces.IPattern pt_DEFAULT -> pt_DEFAULT
    org.matheclipse.core.interfaces.IPattern pu_DEFAULT -> pu_DEFAULT
    org.matheclipse.core.interfaces.IPattern pv_DEFAULT -> pv_DEFAULT
    org.matheclipse.core.interfaces.IPattern pw_DEFAULT -> pw_DEFAULT
    org.matheclipse.core.interfaces.IPattern px_DEFAULT -> px_DEFAULT
    org.matheclipse.core.interfaces.IPattern py_DEFAULT -> py_DEFAULT
    org.matheclipse.core.interfaces.IPattern pz_DEFAULT -> pz_DEFAULT
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void init() -> init
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctions0 -> org.matheclipse.core.integrate.rubi45.UtilityFunctions0:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctions1 -> org.matheclipse.core.integrate.rubi45.UtilityFunctions1:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctions2 -> org.matheclipse.core.integrate.rubi45.UtilityFunctions2:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctions3 -> org.matheclipse.core.integrate.rubi45.UtilityFunctions3:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctions4 -> org.matheclipse.core.integrate.rubi45.UtilityFunctions4:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctions5 -> org.matheclipse.core.integrate.rubi45.UtilityFunctions5:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.integrate.rubi45.UtilityFunctions6 -> org.matheclipse.core.integrate.rubi45.UtilityFunctions6:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.interfaces.AbstractEvalStepListener -> org.matheclipse.core.interfaces.AbstractEvalStepListener:
    void <init>() -> <init>
    void setUp(org.matheclipse.core.interfaces.IExpr,int) -> setUp
    void tearDown(int) -> tearDown
    void add(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int,long,java.lang.String) -> add
org.matheclipse.core.interfaces.IAST -> org.matheclipse.core.interfaces.IAST:
    int NO_FLAG -> NO_FLAG
    int CONTAINS_PATTERN -> CONTAINS_PATTERN
    int CONTAINS_PATTERN_SEQUENCE -> CONTAINS_PATTERN_SEQUENCE
    int CONTAINS_DEFAULT_PATTERN -> CONTAINS_DEFAULT_PATTERN
    int CONTAINS_NO_PATTERN -> CONTAINS_NO_PATTERN
    int CONTAINS_PATTERN_EXPR -> CONTAINS_PATTERN_EXPR
    int CONTAINS_NO_DEFAULT_PATTERN_MASK -> CONTAINS_NO_DEFAULT_PATTERN_MASK
    int IS_MATRIX -> IS_MATRIX
    int IS_VECTOR -> IS_VECTOR
    int IS_MATRIX_OR_VECTOR -> IS_MATRIX_OR_VECTOR
    int IS_DECOMPOSED_PARTIAL_FRACTION -> IS_DECOMPOSED_PARTIAL_FRACTION
    int IS_FLATTENED -> IS_FLATTENED
    int IS_SORTED -> IS_SORTED
    int IS_LISTABLE_THREADED -> IS_LISTABLE_THREADED
    int IS_FLATTENED_OR_SORTED_MASK -> IS_FLATTENED_OR_SORTED_MASK
    int IS_EVALED -> IS_EVALED
    int IS_EXPANDED -> IS_EXPANDED
    int IS_ALL_EXPANDED -> IS_ALL_EXPANDED
    boolean addAll(java.util.List) -> addAll
    boolean addAll(java.util.List,int,int) -> addAll
    org.matheclipse.core.interfaces.IAST addAtClone(int,org.matheclipse.core.interfaces.IExpr) -> addAtClone
    void addEvalFlags(int) -> addEvalFlags
    org.matheclipse.core.interfaces.IAST addOneIdentity(org.matheclipse.core.interfaces.IAST) -> addOneIdentity
    org.matheclipse.core.interfaces.IAST appendClone(org.matheclipse.core.interfaces.IExpr) -> appendClone
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr) -> apply
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr,int) -> apply
    org.matheclipse.core.interfaces.IAST apply(org.matheclipse.core.interfaces.IExpr,int,int) -> apply
    org.matheclipse.core.interfaces.IExpr arg1() -> arg1
    org.matheclipse.core.interfaces.IExpr arg2() -> arg2
    org.matheclipse.core.interfaces.IExpr arg3() -> arg3
    org.matheclipse.core.interfaces.IExpr arg4() -> arg4
    org.matheclipse.core.interfaces.IExpr arg5() -> arg5
    org.matheclipse.core.expression.ASTRange args() -> args
    org.matheclipse.core.interfaces.IAST clone() -> clone
    org.matheclipse.core.interfaces.IAST copyHead() -> copyHead
    org.matheclipse.core.interfaces.IAST copyUntil(int) -> copyUntil
    boolean equalsAt(int,org.matheclipse.core.interfaces.IExpr) -> equalsAt
    int findFirstEquals(org.matheclipse.core.interfaces.IExpr) -> findFirstEquals
    org.matheclipse.core.interfaces.IAST[] filter(com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST filter(org.matheclipse.core.interfaces.IAST,com.google.common.base.Predicate,int) -> filter
    org.matheclipse.core.interfaces.IAST[] filter(com.google.common.base.Predicate) -> filter
    org.matheclipse.core.interfaces.IAST getAST(int) -> getAST
    int getEvalFlags() -> getEvalFlags
    org.matheclipse.core.interfaces.IInteger getInt(int) -> getInt
    org.matheclipse.core.interfaces.IAST getList(int) -> getList
    org.matheclipse.core.interfaces.INumber getNumber(int) -> getNumber
    org.matheclipse.core.interfaces.IExpr getOneIdentity(org.matheclipse.core.interfaces.IExpr) -> getOneIdentity
    org.matheclipse.core.interfaces.IExpr getPart(int[]) -> getPart
    org.matheclipse.core.interfaces.IExpr getPart(java.util.List) -> getPart
    boolean isEvalFlagOff(int) -> isEvalFlagOff
    boolean isEvalFlagOn(int) -> isEvalFlagOn
    boolean isFreeAt(int,org.matheclipse.core.interfaces.IExpr) -> isFreeAt
    boolean isList() -> isList
    boolean isPlus() -> isPlus
    boolean isPower() -> isPower
    boolean isTimes() -> isTimes
    java.util.Iterator iterator() -> iterator
    java.util.Iterator iterator0() -> iterator0
    org.matheclipse.core.interfaces.IExpr last() -> last
    org.matheclipse.core.interfaces.IAST map(com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.generic.interfaces.BiFunction) -> map
    org.matheclipse.core.interfaces.IAST map(org.matheclipse.core.interfaces.IExpr,com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST mapAt(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int) -> mapAt
    org.matheclipse.core.interfaces.IAST mapAt(org.matheclipse.core.interfaces.IAST,int) -> mapAt
    int patternHashCode() -> patternHashCode
    org.matheclipse.core.interfaces.IAST prependClone(org.matheclipse.core.interfaces.IExpr) -> prependClone
    org.matheclipse.core.expression.ASTRange range() -> range
    org.matheclipse.core.expression.ASTRange range(int) -> range
    org.matheclipse.core.expression.ASTRange range(int,int) -> range
    org.matheclipse.core.interfaces.IAST removeAtClone(int) -> removeAtClone
    org.matheclipse.core.interfaces.IAST setAtClone(int,org.matheclipse.core.interfaces.IExpr) -> setAtClone
    void setEvalFlags(int) -> setEvalFlags
    org.matheclipse.core.interfaces.ISymbol topHead() -> topHead
org.matheclipse.core.interfaces.IAST$PROPERTY -> org.matheclipse.core.interfaces.IAST$PROPERTY:
    org.matheclipse.core.interfaces.IAST$PROPERTY CSS -> CSS
    org.matheclipse.core.interfaces.IAST$PROPERTY[] $VALUES -> a
    org.matheclipse.core.interfaces.IAST$PROPERTY[] values() -> values
    org.matheclipse.core.interfaces.IAST$PROPERTY valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.interfaces.IBigNumber -> org.matheclipse.core.interfaces.IBigNumber:
    org.matheclipse.core.interfaces.INumber numericNumber() -> numericNumber
org.matheclipse.core.interfaces.IComplex -> org.matheclipse.core.interfaces.IComplex:
    org.matheclipse.core.interfaces.IComplex add(org.matheclipse.core.interfaces.IComplex) -> add
    org.apache.commons.math3.fraction.BigFraction getImaginaryPart() -> getImaginaryPart
    org.apache.commons.math3.fraction.BigFraction getRealPart() -> getRealPart
    org.matheclipse.core.interfaces.IComplex multiply(org.matheclipse.core.interfaces.IComplex) -> multiply
    org.matheclipse.core.interfaces.IComplex pow(int) -> pow
    org.matheclipse.core.interfaces.INumber normalize() -> normalize
org.matheclipse.core.interfaces.IComplexNum -> org.matheclipse.core.interfaces.IComplexNum:
    double dabs() -> dabs
    double getRealPart() -> getRealPart
    double getImaginaryPart() -> getImaginaryPart
    org.matheclipse.core.interfaces.IComplexNum conjugate() -> conjugate
    org.matheclipse.core.interfaces.IComplexNum add(org.matheclipse.core.interfaces.IComplexNum) -> add
    org.matheclipse.core.interfaces.IComplexNum multiply(org.matheclipse.core.interfaces.IComplexNum) -> multiply
    org.matheclipse.core.interfaces.IComplexNum pow(org.matheclipse.core.interfaces.IComplexNum) -> pow
org.matheclipse.core.interfaces.IEvalStepListener -> org.matheclipse.core.interfaces.IEvalStepListener:
    void setUp(org.matheclipse.core.interfaces.IExpr,int) -> setUp
    void tearDown(int) -> tearDown
    void add(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int,long,java.lang.String) -> add
org.matheclipse.core.interfaces.IEvaluationEngine -> org.matheclipse.core.interfaces.IEvaluationEngine:
    org.matheclipse.core.interfaces.IExpr evalWithoutNumericReset(org.matheclipse.core.interfaces.IExpr) -> evalWithoutNumericReset
    void init() -> init
org.matheclipse.core.interfaces.IEvaluator -> org.matheclipse.core.interfaces.IEvaluator:
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.interfaces.IExpr -> org.matheclipse.core.interfaces.IExpr:
    int ASTID -> ASTID
    int BLANKID -> BLANKID
    int COMPLEXID -> COMPLEXID
    int DOUBLECOMPLEXID -> DOUBLECOMPLEXID
    int DOUBLEID -> DOUBLEID
    int FRACTIONID -> FRACTIONID
    int INTEGERID -> INTEGERID
    int METHODSYMBOLID -> METHODSYMBOLID
    int PATTERNID -> PATTERNID
    int STRINGID -> STRINGID
    int SYMBOLID -> SYMBOLID
    java.lang.Object accept(org.matheclipse.core.visit.IVisitor) -> accept
    boolean accept(org.matheclipse.core.visit.IVisitorBoolean) -> accept
    int accept(org.matheclipse.core.visit.IVisitorInt) -> accept
    long accept(org.matheclipse.core.visit.IVisitorLong) -> accept
    org.matheclipse.core.interfaces.IExpr and(org.matheclipse.core.interfaces.IExpr) -> and
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr[]) -> apply
    org.matheclipse.core.interfaces.IExpr apply(java.util.List) -> apply
    java.lang.Object asType(java.lang.Class) -> asType
    int compareTo(org.matheclipse.core.interfaces.IExpr) -> compareTo
    org.matheclipse.core.interfaces.IExpr dec() -> dec
    org.matheclipse.core.interfaces.IExpr divide(org.matheclipse.core.interfaces.IExpr) -> divide
    org.apache.commons.math3.complex.Complex evalComplex() -> evalComplex
    double evalDouble() -> evalDouble
    org.matheclipse.core.interfaces.INumber evalNumber() -> evalNumber
    org.matheclipse.core.interfaces.ISignedNumber evalSignedNumber() -> evalSignedNumber
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.eval.EvalEngine) -> evaluate
    java.lang.String fullFormString() -> fullFormString
    org.matheclipse.core.interfaces.IExpr getAt(int) -> getAt
    org.matheclipse.core.interfaces.IExpr head() -> head
    int hierarchy() -> hierarchy
    org.matheclipse.core.interfaces.IExpr inc() -> inc
    java.lang.String internalFormString(boolean,int) -> internalFormString
    org.matheclipse.core.interfaces.IExpr inverse() -> inverse
    boolean isAllExpanded() -> isAllExpanded
    boolean isAnd() -> isAnd
    boolean isArcCos() -> isArcCos
    boolean isArcCosh() -> isArcCosh
    boolean isArcSin() -> isArcSin
    boolean isArcSinh() -> isArcSinh
    boolean isArcTan() -> isArcTan
    boolean isArcTanh() -> isArcTanh
    boolean isAST() -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,org.matheclipse.core.interfaces.IExpr[]) -> isAST
    boolean isAST(org.matheclipse.core.interfaces.IExpr,int,int) -> isAST
    boolean isAST(java.lang.String) -> isAST
    boolean isAST(java.lang.String,int) -> isAST
    boolean isASTSizeGE(org.matheclipse.core.interfaces.IExpr,int) -> isASTSizeGE
    boolean isAtom() -> isAtom
    boolean isBlank() -> isBlank
    boolean isComplex() -> isComplex
    boolean isComplexInfinity() -> isComplexInfinity
    boolean isComplexNumeric() -> isComplexNumeric
    boolean isCondition() -> isCondition
    boolean isConstant() -> isConstant
    boolean isCos() -> isCos
    boolean isCosh() -> isCosh
    org.matheclipse.core.interfaces.IAST[] isDerivative() -> isDerivative
    boolean isDirectedInfinity() -> isDirectedInfinity
    boolean isE() -> isE
    boolean isExpanded() -> isExpanded
    boolean isFalse() -> isFalse
    boolean isFlatAST() -> isFlatAST
    boolean isFraction() -> isFraction
    boolean isFree(org.matheclipse.core.interfaces.IExpr) -> isFree
    boolean isFree(org.matheclipse.core.interfaces.IExpr,boolean) -> isFree
    boolean isFree(com.google.common.base.Predicate,boolean) -> isFree
    boolean isFreeAST(org.matheclipse.core.interfaces.IExpr) -> isFreeAST
    boolean isFreeAST(com.google.common.base.Predicate) -> isFreeAST
    boolean isFreeOfPatterns() -> isFreeOfPatterns
    boolean isFunction() -> isFunction
    boolean isGEOrdered(org.matheclipse.core.interfaces.IExpr) -> isGEOrdered
    boolean isGTOrdered(org.matheclipse.core.interfaces.IExpr) -> isGTOrdered
    boolean isIndeterminate() -> isIndeterminate
    boolean isInfinity() -> isInfinity
    boolean isInteger() -> isInteger
    boolean isIntegerResult() -> isIntegerResult
    boolean isLEOrdered(org.matheclipse.core.interfaces.IExpr) -> isLEOrdered
    boolean isList() -> isList
    boolean isListOfLists() -> isListOfLists
    boolean isLog() -> isLog
    boolean isLTOrdered(org.matheclipse.core.interfaces.IExpr) -> isLTOrdered
    int[] isMatrix() -> isMatrix
    boolean isMember(org.matheclipse.core.interfaces.IExpr,boolean) -> isMember
    boolean isMember(com.google.common.base.Predicate,boolean) -> isMember
    boolean isMinusOne() -> isMinusOne
    boolean isModule() -> isModule
    boolean isNegative() -> isNegative
    boolean isNegativeInfinity() -> isNegativeInfinity
    boolean isNegativeResult() -> isNegativeResult
    boolean isNonNegativeResult() -> isNonNegativeResult
    boolean isNot() -> isNot
    boolean isNumber() -> isNumber
    boolean isNumEqualInteger(org.matheclipse.core.interfaces.IInteger) -> isNumEqualInteger
    boolean isNumEqualRational(org.matheclipse.core.interfaces.IRational) -> isNumEqualRational
    boolean isNumeric() -> isNumeric
    boolean isNumericFunction() -> isNumericFunction
    boolean isNumericMode() -> isNumericMode
    boolean isNumIntValue() -> isNumIntValue
    boolean isOne() -> isOne
    boolean isONE() -> isONE
    boolean isOr() -> isOr
    boolean isOrderlessAST() -> isOrderlessAST
    boolean isPattern() -> isPattern
    boolean isPatternDefault() -> isPatternDefault
    boolean isPatternExpr() -> isPatternExpr
    boolean isPatternSequence() -> isPatternSequence
    boolean isPi() -> isPi
    boolean isPlus() -> isPlus
    boolean isPlusTimesPower() -> isPlusTimesPower
    boolean isPolynomial(org.matheclipse.core.interfaces.IAST) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.ISymbol) -> isPolynomial
    boolean isPolynomialOfMaxDegree(org.matheclipse.core.interfaces.ISymbol,long) -> isPolynomialOfMaxDegree
    boolean isPositive() -> isPositive
    boolean isPositiveResult() -> isPositiveResult
    boolean isPower() -> isPower
    boolean isRational() -> isRational
    boolean isRationalResult() -> isRationalResult
    boolean isRationalValue(org.matheclipse.core.interfaces.IRational) -> isRationalValue
    boolean isRealResult() -> isRealResult
    boolean isRuleAST() -> isRuleAST
    boolean isSame(org.matheclipse.core.interfaces.IExpr) -> isSame
    boolean isSame(org.matheclipse.core.interfaces.IExpr,double) -> isSame
    boolean isSequence() -> isSequence
    boolean isSignedNumber() -> isSignedNumber
    boolean isSin() -> isSin
    boolean isSinh() -> isSinh
    boolean isSlot() -> isSlot
    boolean isSlotSequence() -> isSlotSequence
    boolean isSymbol() -> isSymbol
    boolean isTan() -> isTan
    boolean isTanh() -> isTanh
    boolean isTimes() -> isTimes
    boolean isTrue() -> isTrue
    boolean isValue() -> isValue
    boolean isVariable() -> isVariable
    int isVector() -> isVector
    boolean isZero() -> isZero
    boolean isZERO() -> isZERO
    long leafCount() -> leafCount
    java.util.List leaves() -> leaves
    org.matheclipse.core.interfaces.IExpr minus(org.matheclipse.core.interfaces.IExpr) -> minus
    org.matheclipse.core.interfaces.IExpr mod(org.matheclipse.core.interfaces.IExpr) -> mod
    org.matheclipse.core.interfaces.IExpr multiply(org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.interfaces.IExpr negative() -> negative
    org.matheclipse.core.interfaces.IExpr opposite() -> opposite
    org.matheclipse.core.interfaces.IExpr optional(org.matheclipse.core.interfaces.IExpr) -> optional
    org.matheclipse.core.interfaces.IExpr or(org.matheclipse.core.interfaces.IExpr) -> or
    org.matheclipse.core.interfaces.IExpr plus(org.matheclipse.core.interfaces.IExpr) -> plus
    org.matheclipse.core.interfaces.IExpr power(org.matheclipse.core.interfaces.IExpr) -> power
    org.matheclipse.core.interfaces.IExpr power(long) -> power
    org.matheclipse.core.interfaces.IExpr replaceAll(com.google.common.base.Function) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replaceAll(org.matheclipse.core.interfaces.IAST) -> replaceAll
    org.matheclipse.core.interfaces.IExpr replacePart(org.matheclipse.core.interfaces.IAST) -> replacePart
    org.matheclipse.core.interfaces.IExpr replaceRepeated(com.google.common.base.Function) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceRepeated(org.matheclipse.core.interfaces.IAST) -> replaceRepeated
    org.matheclipse.core.interfaces.IExpr replaceSlots(org.matheclipse.core.interfaces.IAST) -> replaceSlots
    int signum() -> signum
    org.matheclipse.core.interfaces.IExpr times(org.matheclipse.core.interfaces.IExpr) -> times
    org.matheclipse.core.interfaces.ISymbol topHead() -> topHead
    org.matheclipse.core.interfaces.IExpr variables2Slots(java.util.Map,java.util.List) -> variables2Slots
org.matheclipse.core.interfaces.IFraction -> org.matheclipse.core.interfaces.IFraction:
    org.matheclipse.core.interfaces.IFraction abs() -> abs
    org.matheclipse.core.interfaces.IFraction add(org.matheclipse.core.interfaces.IFraction) -> add
    java.math.BigInteger[] divideAndRemainder() -> divideAndRemainder
    org.apache.commons.math3.fraction.BigFraction getRational() -> getRational
    java.math.BigInteger getBigDenominator() -> getBigDenominator
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.matheclipse.core.interfaces.IFraction multiply(org.matheclipse.core.interfaces.IFraction) -> multiply
    org.matheclipse.core.interfaces.IFraction pow(int) -> pow
    org.matheclipse.core.interfaces.INumber normalize() -> normalize
org.matheclipse.core.interfaces.IInteger -> org.matheclipse.core.interfaces.IInteger:
    int PRIME_CERTAINTY -> PRIME_CERTAINTY
    org.matheclipse.core.interfaces.IInteger add(org.matheclipse.core.interfaces.IInteger) -> add
    org.matheclipse.core.interfaces.IInteger negate() -> negate
    org.matheclipse.core.interfaces.IInteger[] divideAndRemainder(org.matheclipse.core.interfaces.IInteger) -> divideAndRemainder
    org.matheclipse.core.interfaces.IExpr exponent(org.matheclipse.core.interfaces.IInteger) -> exponent
    boolean isEven() -> isEven
    boolean isOdd() -> isOdd
    boolean isProbablePrime() -> isProbablePrime
    boolean isProbablePrime(int) -> isProbablePrime
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.matheclipse.core.interfaces.IInteger multiply(org.matheclipse.core.interfaces.IInteger) -> multiply
    org.matheclipse.core.interfaces.IInteger subtract(org.matheclipse.core.interfaces.IInteger) -> subtract
    org.matheclipse.core.interfaces.IInteger pow(int) -> pow
    int intValue() -> intValue
    long longValue() -> longValue
    org.matheclipse.core.interfaces.IInteger gcd(org.matheclipse.core.interfaces.IInteger) -> gcd
    org.matheclipse.core.interfaces.IInteger lcm(org.matheclipse.core.interfaces.IInteger) -> lcm
    org.matheclipse.core.interfaces.IInteger nthRoot(int) -> nthRoot
    org.matheclipse.core.interfaces.IInteger[] nthRootSplit(int) -> nthRootSplit
org.matheclipse.core.interfaces.INum -> org.matheclipse.core.interfaces.INum:
    double Catalan -> Catalan
    double Degree -> Degree
    double EulerGamma -> EulerGamma
    double Glaisher -> Glaisher
    double GoldenRatio -> GoldenRatio
    double Khinchin -> Khinchin
    double getRealPart() -> getRealPart
    org.matheclipse.core.interfaces.INum add(org.matheclipse.core.interfaces.INum) -> add
    org.matheclipse.core.interfaces.INum multiply(org.matheclipse.core.interfaces.INum) -> multiply
    org.matheclipse.core.interfaces.INum pow(org.matheclipse.core.interfaces.INum) -> pow
    boolean isNumIntValue() -> isNumIntValue
    int intValue() -> intValue
    int toInt() -> toInt
org.matheclipse.core.interfaces.INumber -> org.matheclipse.core.interfaces.INumber:
    org.matheclipse.core.interfaces.INumber conjugate() -> conjugate
    org.matheclipse.core.expression.ApcomplexNum apcomplexNumValue(long) -> apcomplexNumValue
    org.matheclipse.core.expression.ComplexNum complexNumValue() -> complexNumValue
    int complexSign() -> complexSign
    org.matheclipse.core.interfaces.IExpr eabs() -> eabs
    int compareAbsValueToOne() -> compareAbsValueToOne
    boolean equalsInt(int) -> equalsInt
    org.matheclipse.core.interfaces.INumber opposite() -> opposite
    org.matheclipse.core.interfaces.ISignedNumber getIm() -> getIm
    org.matheclipse.core.interfaces.ISignedNumber getRe() -> getRe
    org.matheclipse.core.interfaces.INumber ceil() -> ceil
    org.matheclipse.core.interfaces.INumber floor() -> floor
org.matheclipse.core.interfaces.IPattern -> org.matheclipse.core.interfaces.IPattern:
    boolean isConditionMatched(org.matheclipse.core.interfaces.IExpr) -> isConditionMatched
org.matheclipse.core.interfaces.IPatternObject -> org.matheclipse.core.interfaces.IPatternObject:
    int[] addPattern(org.matheclipse.core.patternmatching.PatternMap,java.util.Map) -> addPattern
    boolean equivalent(org.matheclipse.core.interfaces.IPatternObject,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> equivalent
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    int getEvalFlags() -> getEvalFlags
    int getIndex(org.matheclipse.core.patternmatching.PatternMap) -> getIndex
    org.matheclipse.core.interfaces.ISymbol getSymbol() -> getSymbol
    boolean matchPattern(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap) -> matchPattern
org.matheclipse.core.interfaces.IPatternSequence -> org.matheclipse.core.interfaces.IPatternSequence:
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    boolean matchPatternSequence(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.PatternMap) -> matchPatternSequence
    boolean isConditionMatchedSequence(org.matheclipse.core.interfaces.IAST) -> isConditionMatchedSequence
    boolean isDefault() -> isDefault
org.matheclipse.core.interfaces.IRational -> org.matheclipse.core.interfaces.IRational:
    org.matheclipse.core.interfaces.IRational abs() -> abs
    org.matheclipse.core.interfaces.IAST factorInteger() -> factorInteger
    java.math.BigInteger getBigDenominator() -> getBigDenominator
    java.math.BigInteger getBigNumerator() -> getBigNumerator
    org.matheclipse.core.interfaces.IInteger getDenominator() -> getDenominator
    org.apache.commons.math3.fraction.BigFraction getFraction() -> getFraction
    org.matheclipse.core.interfaces.IInteger getNumerator() -> getNumerator
org.matheclipse.core.interfaces.ISignedNumber -> org.matheclipse.core.interfaces.ISignedNumber:
    org.matheclipse.core.expression.ApfloatNum apfloatNumValue(long) -> apfloatNumValue
    org.matheclipse.core.expression.Num numValue() -> numValue
    boolean isNegative() -> isNegative
    boolean isPositive() -> isPositive
    boolean isZero() -> isZero
    boolean isLessThan(org.matheclipse.core.interfaces.ISignedNumber) -> isLessThan
    boolean isGreaterThan(org.matheclipse.core.interfaces.ISignedNumber) -> isGreaterThan
    org.matheclipse.core.interfaces.ISignedNumber negate() -> negate
    org.matheclipse.core.interfaces.ISignedNumber divideBy(org.matheclipse.core.interfaces.ISignedNumber) -> divideBy
    org.matheclipse.core.interfaces.ISignedNumber subtractFrom(org.matheclipse.core.interfaces.ISignedNumber) -> subtractFrom
    int sign() -> sign
    int toInt() -> toInt
    long toLong() -> toLong
    org.matheclipse.core.interfaces.IInteger round() -> round
    org.matheclipse.core.interfaces.ISignedNumber inverse() -> inverse
    org.matheclipse.core.interfaces.ISignedNumber opposite() -> opposite
    double doubleValue() -> doubleValue
    org.matheclipse.core.interfaces.IInteger ceil() -> ceil
    org.matheclipse.core.interfaces.IInteger floor() -> floor
org.matheclipse.core.interfaces.IStringX -> org.matheclipse.core.interfaces.IStringX:
org.matheclipse.core.interfaces.ISymbol -> org.matheclipse.core.interfaces.ISymbol:
    int CONSOLE_OUTPUT -> CONSOLE_OUTPUT
    int CONSTANT -> CONSTANT
    int FLAT -> FLAT
    int HOLDFIRST -> HOLDFIRST
    int HOLDREST -> HOLDREST
    int HOLDALL -> HOLDALL
    int LISTABLE -> LISTABLE
    int NHOLDFIRST -> NHOLDFIRST
    int NHOLDREST -> NHOLDREST
    int NHOLDALL -> NHOLDALL
    int NOATTRIBUTE -> NOATTRIBUTE
    int NUMERICFUNCTION -> NUMERICFUNCTION
    int PACKAGE_LOADED -> PACKAGE_LOADED
    int ONEIDENTITY -> ONEIDENTITY
    int ORDERLESS -> ORDERLESS
    int FLATORDERLESS -> FLATORDERLESS
    org.matheclipse.core.interfaces.IEvaluator getEvaluator() -> getEvaluator
    java.lang.String getSymbolName() -> getSymbolName
    void setEvaluator(org.matheclipse.core.interfaces.IEvaluator) -> setEvaluator
    boolean isString(java.lang.String) -> isString
    boolean isSymbolName(java.lang.String) -> isSymbolName
    org.matheclipse.core.interfaces.IExpr mapConstantDouble(org.matheclipse.core.generic.interfaces.INumericFunction) -> mapConstantDouble
    int getAttributes() -> getAttributes
    void setAttributes(int) -> setAttributes
    void pushLocalVariable() -> pushLocalVariable
    void pushLocalVariable(org.matheclipse.core.interfaces.IExpr) -> pushLocalVariable
    void popLocalVariable() -> popLocalVariable
    boolean hasAssignedSymbolValue() -> hasAssignedSymbolValue
    boolean hasLocalVariableStack() -> hasLocalVariableStack
    org.matheclipse.core.interfaces.IExpr get() -> get
    void set(org.matheclipse.core.interfaces.IExpr) -> set
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int,boolean) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.patternmatching.PatternMatcherAndInvoker) -> putDownRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> putUpRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> putUpRule
    void removeRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IExpr,boolean) -> removeRule
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IEvaluationEngine,org.matheclipse.core.interfaces.IExpr) -> evalDownRule
    org.matheclipse.core.interfaces.IExpr evalUpRule(org.matheclipse.core.interfaces.IEvaluationEngine,org.matheclipse.core.interfaces.IExpr) -> evalUpRule
    org.matheclipse.core.interfaces.IExpr getDefaultValue() -> getDefaultValue
    org.matheclipse.core.interfaces.IExpr getDefaultValue(int) -> getDefaultValue
    void setDefaultValue(org.matheclipse.core.interfaces.IExpr) -> setDefaultValue
    void setDefaultValue(int,org.matheclipse.core.interfaces.IExpr) -> setDefaultValue
    org.matheclipse.core.interfaces.IExpr getAssignedValue() -> getAssignedValue
    org.matheclipse.core.interfaces.IExpr[] reassignSymbolValue(com.google.common.base.Function,org.matheclipse.core.interfaces.ISymbol) -> reassignSymbolValue
    void clear(org.matheclipse.core.eval.EvalEngine) -> clear
    void clearAll(org.matheclipse.core.eval.EvalEngine) -> clearAll
    boolean containsRules() -> containsRules
    java.util.List definition() -> definition
    java.lang.String definitionToString() -> definitionToString
    void readRules(java.io.ObjectInputStream) -> readRules
    boolean writeRules(java.io.ObjectOutputStream) -> writeRules
org.matheclipse.core.interfaces.ISymbol$RuleType -> org.matheclipse.core.interfaces.ISymbol$RuleType:
    org.matheclipse.core.interfaces.ISymbol$RuleType SET -> SET
    org.matheclipse.core.interfaces.ISymbol$RuleType SET_DELAYED -> SET_DELAYED
    org.matheclipse.core.interfaces.ISymbol$RuleType UPSET -> UPSET
    org.matheclipse.core.interfaces.ISymbol$RuleType UPSET_DELAYED -> UPSET_DELAYED
    org.matheclipse.core.interfaces.ISymbol$RuleType[] $VALUES -> a
    org.matheclipse.core.interfaces.ISymbol$RuleType[] values() -> values
    org.matheclipse.core.interfaces.ISymbol$RuleType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
org.matheclipse.core.patternmatching.AbstractHashedPatternRules -> org.matheclipse.core.patternmatching.AbstractHashedPatternRules:
    int hash1 -> hash1
    int hash2 -> hash2
    int hashSum -> hashSum
    org.matheclipse.core.patternmatching.DownRulesData fRulesData -> fRulesData
    org.matheclipse.core.interfaces.IExpr fLHSPattern1 -> fLHSPattern1
    org.matheclipse.core.interfaces.IExpr fLHSPattern2 -> fLHSPattern2
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> <init>
    int hashCode() -> hashCode
    int calculateHashcode(int,int) -> calculateHashcode
    int getHash1() -> getHash1
    int getHash2() -> getHash2
    boolean isPattern1() -> isPattern1
    boolean isPattern2() -> isPattern2
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> evalDownRule
org.matheclipse.core.patternmatching.DownRulesData -> org.matheclipse.core.patternmatching.DownRulesData:
    long serialVersionUID -> serialVersionUID
    java.util.Map fEqualDownRules -> fEqualDownRules
    com.google.common.collect.TreeMultimap fSimplePatternDownRules -> fSimplePatternDownRules
    com.google.common.collect.TreeMultimap fSimpleOrderlesPatternDownRules -> fSimpleOrderlesPatternDownRules
    java.util.TreeSet fPatternDownRules -> fPatternDownRules
    void <init>() -> <init>
    void clear() -> clear
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IExpr) -> evalDownRule
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IEvaluationEngine,org.matheclipse.core.interfaces.IExpr) -> evalDownRule
    org.matheclipse.core.interfaces.IExpr evalSimpleRatternRule(com.google.common.collect.TreeMultimap,java.lang.Integer,org.matheclipse.core.interfaces.IAST,boolean) -> evalSimpleRatternRule
    org.matheclipse.core.patternmatching.IPatternMatcher putDownRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> putDownRule
    org.matheclipse.core.patternmatching.PatternMatcher addSimplePatternDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher) -> a
    org.matheclipse.core.patternmatching.PatternMatcher addSimpleOrderlessPatternDownRule$5c12c4d9(java.util.Set,org.matheclipse.core.patternmatching.PatternMatcher) -> a
    org.matheclipse.core.patternmatching.PatternMatcher putDownRule(org.matheclipse.core.patternmatching.PatternMatcherAndInvoker) -> putDownRule
    boolean isComplicatedPatternRule(org.matheclipse.core.interfaces.IExpr,java.util.Set) -> a
    boolean containsOrderlessASTOrDefaultPattern(org.matheclipse.core.interfaces.IAST) -> containsOrderlessASTOrDefaultPattern
    java.util.Map getEqualDownRules() -> getEqualDownRules
    java.util.TreeSet getPatternDownRules() -> a
    com.google.common.collect.TreeMultimap getSimplePatternDownRules() -> a
    com.google.common.collect.TreeMultimap getSimpleOrderlessPatternDownRules() -> b
    java.util.List definition() -> definition
    void removeRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IExpr) -> removeRule
    java.lang.String toString() -> toString
org.matheclipse.core.patternmatching.FlatOrderlessStepVisitor -> org.matheclipse.core.patternmatching.FlatOrderlessStepVisitor:
    int[] multiset -> multiset
    void <init>(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher,org.matheclipse.core.patternmatching.PatternMap) -> <init>
    int[] getMultisetArray() -> getMultisetArray
org.matheclipse.core.patternmatching.FlatStepVisitor -> org.matheclipse.core.patternmatching.FlatStepVisitor:
    org.matheclipse.core.interfaces.ISymbol fSymbol -> fSymbol
    org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher stackMatcher -> stackMatcher
    org.matheclipse.core.patternmatching.PatternMap fPatternMap -> fPatternMap
    org.matheclipse.core.interfaces.IExpr[] patternValues -> patternValues
    org.matheclipse.core.interfaces.IAST fLhsPatternAST -> fLhsPatternAST
    boolean fOneIdentity -> fOneIdentity
    void <init>(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher,org.matheclipse.core.patternmatching.PatternMap) -> <init>
    boolean visit(int[][]) -> visit
    boolean matchSinglePartition(int[][],org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> matchSinglePartition
org.matheclipse.core.patternmatching.HashedOrderlessMatcher -> org.matheclipse.core.patternmatching.HashedOrderlessMatcher:
    com.google.common.collect.ArrayListMultimap fHashRuleMap -> a
    com.google.common.collect.ArrayListMultimap fPatternHashRuleMap -> b
    void <init>() -> <init>
    void defineHashRule(java.lang.String,java.lang.String,java.lang.String) -> defineHashRule
    void defineHashRule(java.lang.String,java.lang.String,org.matheclipse.core.generic.BinaryFunctorImpl) -> defineHashRule
    void defineHashRule(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> defineHashRule
    void defineHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> defineHashRule
    void defineHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> defineHashRule
    void defineHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.generic.BinaryFunctorImpl) -> defineHashRule
    void definePatternHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> definePatternHashRule
    void definePatternHashRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> definePatternHashRule
    org.matheclipse.core.interfaces.IAST evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST evaluateHashedValues(org.matheclipse.core.interfaces.IAST,com.google.common.collect.ArrayListMultimap,int[]) -> a
    boolean updateHashValues(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.AbstractHashedPatternRules,int[],int,int) -> a
org.matheclipse.core.patternmatching.HashedPatternFunction -> org.matheclipse.core.patternmatching.HashedPatternFunction:
    org.matheclipse.core.generic.BinaryFunctorImpl function -> a
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.generic.BinaryFunctorImpl,boolean) -> <init>
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.generic.BinaryFunctorImpl getFunction() -> getFunction
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> evalDownRule
org.matheclipse.core.patternmatching.HashedPatternRules -> org.matheclipse.core.patternmatching.HashedPatternRules:
    org.matheclipse.core.interfaces.IExpr fCondition -> a
    org.matheclipse.core.interfaces.IExpr fRHS -> b
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,boolean) -> <init>
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr getRHS() -> getRHS
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    org.matheclipse.core.patternmatching.DownRulesData getRulesData() -> getRulesData
    org.matheclipse.core.interfaces.IExpr evalDownRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> evalDownRule
org.matheclipse.core.patternmatching.IPatternMatcher -> org.matheclipse.core.patternmatching.IPatternMatcher:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr fLhsPatternExpr -> fLhsPatternExpr
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IExpr getLHS() -> getLHS
    org.matheclipse.core.interfaces.IExpr getRHS() -> getRHS
    void getPatterns(java.util.List,org.matheclipse.core.interfaces.IExpr) -> getPatterns
    int getPriority() -> getPriority
    boolean isRuleWithoutPatterns() -> isRuleWithoutPatterns
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    java.lang.Object clone() -> clone
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.patternmatching.ISymbol2IntMap -> org.matheclipse.core.patternmatching.ISymbol2IntMap:
    int size() -> size
    boolean isEmpty() -> isEmpty
    int get(org.matheclipse.core.interfaces.ISymbol) -> get
org.matheclipse.core.patternmatching.OrderlessStepVisitor -> org.matheclipse.core.patternmatching.OrderlessStepVisitor:
    void <init>(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher,org.matheclipse.core.patternmatching.PatternMap) -> <init>
    boolean matchSinglePartition(int[][],org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> matchSinglePartition
org.matheclipse.core.patternmatching.PatternComparator -> org.matheclipse.core.patternmatching.PatternComparator:
    org.matheclipse.core.patternmatching.PatternComparator CONST -> CONST
    void <init>() -> <init>
    int compare(org.matheclipse.core.interfaces.IPatternObject,org.matheclipse.core.interfaces.IPatternObject) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
    void <clinit>() -> <clinit>
org.matheclipse.core.patternmatching.PatternMap -> org.matheclipse.core.patternmatching.PatternMap:
    long serialVersionUID -> serialVersionUID
    int fPriority -> fPriority
    int fPatternCounter -> fPatternCounter
    boolean fRuleWithoutPattern -> fRuleWithoutPattern
    org.matheclipse.core.interfaces.ISymbol[] fSymbolsArray -> fSymbolsArray
    org.matheclipse.core.interfaces.IExpr[] fPatternValuesArray -> fPatternValuesArray
    int DEFAULT_RULE_PRIORITY -> DEFAULT_RULE_PRIORITY
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr[]) -> <init>
    void addPattern(java.util.Map,org.matheclipse.core.interfaces.IPatternObject) -> addPattern
    void addSinglePattern(org.matheclipse.core.interfaces.IPatternObject) -> addSinglePattern
    org.matheclipse.core.patternmatching.PatternMap clone() -> clone
    org.matheclipse.core.interfaces.IExpr[] copyPattern() -> copyPattern
    void copyPatternValuesFromPatternMatcher(org.matheclipse.core.patternmatching.PatternMap) -> copyPatternValuesFromPatternMatcher
    int determinePatterns(org.matheclipse.core.interfaces.IExpr) -> determinePatterns
    int determinePatternsRecursive(java.util.Map,org.matheclipse.core.interfaces.IAST,int) -> a
    int get(org.matheclipse.core.interfaces.ISymbol) -> get
    int getPriority() -> getPriority
    org.matheclipse.core.interfaces.IExpr getValue(int) -> getValue
    org.matheclipse.core.interfaces.IExpr getValue(org.matheclipse.core.interfaces.IPatternObject) -> getValue
    java.util.List getValuesAsList() -> getValuesAsList
    void initPattern() -> initPattern
    boolean isAllPatternsAssigned() -> isAllPatternsAssigned
    boolean isEmpty() -> isEmpty
    boolean isRuleWithoutPatterns() -> isRuleWithoutPatterns
    void resetPattern(org.matheclipse.core.interfaces.IExpr[]) -> resetPattern
    void setValue(org.matheclipse.core.interfaces.IPatternObject,org.matheclipse.core.interfaces.IExpr) -> setValue
    int size() -> size
    org.matheclipse.core.interfaces.IExpr substitutePatternSymbols(org.matheclipse.core.interfaces.IExpr) -> substitutePatternSymbols
    java.lang.Object clone() -> clone
org.matheclipse.core.patternmatching.PatternMatcher -> org.matheclipse.core.patternmatching.PatternMatcher:
    long serialVersionUID -> serialVersionUID
    int fPriority -> fPriority
    org.matheclipse.core.interfaces.IExpr fPatternCondition -> fPatternCondition
    org.matheclipse.core.patternmatching.PatternMap fPatternMap -> fPatternMap
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    void init(org.matheclipse.core.interfaces.IExpr) -> init
    boolean checkRHSCondition(org.matheclipse.core.eval.EvalEngine) -> checkRHSCondition
    boolean checkCondition() -> checkCondition
    boolean equivalent(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> equivalent
    void getPatterns(java.util.List,org.matheclipse.core.interfaces.IExpr) -> getPatterns
    org.matheclipse.core.interfaces.IExpr getPatternValue0() -> getPatternValue0
    int getPriority() -> getPriority
    boolean isRuleWithoutPatterns() -> isRuleWithoutPatterns
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean matchExpr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> matchExpr
    boolean matchExpr(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> matchExpr
    boolean matchFlatAndFlatOrderlessAST(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    boolean matchAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> matchAST
    boolean matchASTSequence(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> a
    org.matheclipse.core.interfaces.IExpr evalAST(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> evalAST
    void logConditionFalse(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> logConditionFalse
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object clone() -> clone
    org.matheclipse.core.interfaces.IExpr getCondition() -> getCondition
    void setCondition(org.matheclipse.core.interfaces.IExpr) -> setCondition
    org.matheclipse.core.interfaces.IExpr evalLeftHandSide(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.eval.EvalEngine) -> evalLeftHandSide
    org.matheclipse.core.interfaces.IExpr evalLeftHandSide(org.matheclipse.core.interfaces.IAST) -> evalLeftHandSide
    int compareTo(org.matheclipse.core.patternmatching.IPatternMatcher) -> compareTo
    int equivalent(org.matheclipse.core.patternmatching.IPatternMatcher) -> equivalent
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    boolean apply(java.lang.Object) -> apply
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.patternmatching.PatternMatcher$Entry -> nf:
    org.matheclipse.core.interfaces.IExpr fPatternExpr -> a
    org.matheclipse.core.interfaces.IExpr fEvalExpr -> b
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> <init>
org.matheclipse.core.patternmatching.PatternMatcher$OrderlessMatcher -> org.matheclipse.core.patternmatching.PatternMatcher$OrderlessMatcher:
    org.matheclipse.core.interfaces.IAST fLHSPatternAST -> a
    org.matheclipse.core.interfaces.IAST fLHSEvalAST -> b
    int[] fUsedIndex -> a
    org.matheclipse.core.patternmatching.PatternMatcher this$0 -> a
    void <init>(org.matheclipse.core.patternmatching.PatternMatcher,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> <init>
    boolean matchOrderlessAST(int,org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher) -> matchOrderlessAST
    void filterResult(org.matheclipse.core.interfaces.IAST) -> filterResult
org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher -> org.matheclipse.core.patternmatching.PatternMatcher$StackMatcher:
    java.util.ArrayList fStack -> a
    org.matheclipse.core.patternmatching.PatternMatcher this$0 -> a
    void <init>(org.matheclipse.core.patternmatching.PatternMatcher) -> <init>
    org.matheclipse.core.patternmatching.PatternMatcher$Entry peek() -> peek
    org.matheclipse.core.patternmatching.PatternMatcher$Entry pop() -> pop
    void removeFrom(int) -> removeFrom
    boolean push(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> push
    boolean matchRest() -> matchRest
    boolean isEmpty() -> isEmpty
    int size() -> size
org.matheclipse.core.patternmatching.PatternMatcherAndEvaluator -> org.matheclipse.core.patternmatching.PatternMatcherAndEvaluator:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr fRightHandSide -> fRightHandSide
    org.matheclipse.core.interfaces.ISymbol$RuleType fSetSymbol -> fSetSymbol
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.ISymbol$RuleType,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    boolean equivalentRHS(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.patternmatching.PatternMap,org.matheclipse.core.patternmatching.PatternMap) -> a
    int hashCode() -> hashCode
    boolean checkRHSCondition(org.matheclipse.core.eval.EvalEngine) -> checkRHSCondition
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    org.matheclipse.core.interfaces.IExpr getRHS() -> getRHS
    org.matheclipse.core.interfaces.IAST getAsAST() -> getAsAST
    org.matheclipse.core.interfaces.ISymbol getSetSymbol() -> getSetSymbol
    int equivalent(org.matheclipse.core.patternmatching.IPatternMatcher) -> equivalent
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
org.matheclipse.core.patternmatching.PatternMatcherAndInvoker -> org.matheclipse.core.patternmatching.PatternMatcherAndInvoker:
    long serialVersionUID -> serialVersionUID
    java.lang.reflect.Method fMethod -> a
    java.lang.reflect.Type[] fTypes -> a
    org.matheclipse.core.eval.interfaces.IFunctionEvaluator fInstance -> a
    java.lang.Object clone() -> clone
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.interfaces.IFunctionEvaluator,java.lang.String) -> <init>
    void <init>(java.lang.String,org.matheclipse.core.eval.interfaces.IFunctionEvaluator,java.lang.String) -> <init>
    void initInvoker(org.matheclipse.core.eval.interfaces.IFunctionEvaluator,java.lang.String) -> a
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.core.patternmatching.PatternMatcherEquals -> org.matheclipse.core.patternmatching.PatternMatcherEquals:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.interfaces.IExpr fRightHandSide -> fRightHandSide
    org.matheclipse.core.interfaces.ISymbol$RuleType fSetSymbol -> fSetSymbol
    void <init>() -> <init>
    void <init>(org.matheclipse.core.interfaces.ISymbol$RuleType,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> <init>
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.core.interfaces.IExpr eval(org.matheclipse.core.interfaces.IExpr) -> eval
    void getPatterns(java.util.List,org.matheclipse.core.interfaces.IExpr) -> getPatterns
    org.matheclipse.core.interfaces.IExpr getRHS() -> getRHS
    org.matheclipse.core.interfaces.ISymbol getSetSymbol() -> getSetSymbol
    int hashCode() -> hashCode
    boolean isRuleWithoutPatterns() -> isRuleWithoutPatterns
    void setRHS(org.matheclipse.core.interfaces.IExpr) -> setRHS
    int compareTo(org.matheclipse.core.patternmatching.IPatternMatcher) -> compareTo
    int getPriority() -> getPriority
    org.matheclipse.core.interfaces.IAST getAsAST() -> getAsAST
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    boolean apply(java.lang.Object) -> apply
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.patternmatching.UpRulesData -> org.matheclipse.core.patternmatching.UpRulesData:
    long serialVersionUID -> serialVersionUID
    java.util.Map fEqualUpRules -> fEqualUpRules
    com.google.common.collect.TreeMultimap fSimplePatternUpRules -> fSimplePatternUpRules
    void <init>() -> <init>
    void clear() -> clear
    org.matheclipse.core.interfaces.IExpr evalUpRule(org.matheclipse.core.interfaces.IEvaluationEngine,org.matheclipse.core.interfaces.IExpr) -> evalUpRule
    org.matheclipse.core.patternmatching.IPatternMatcher putUpRule(org.matheclipse.core.interfaces.ISymbol$RuleType,boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> putUpRule
    java.util.Map getEqualUpRules() -> getEqualUpRules
    java.util.List definition() -> definition
    java.lang.String toString() -> toString
org.matheclipse.core.polynomials.AlgebraicNotInvertibleException -> org.matheclipse.core.polynomials.AlgebraicNotInvertibleException:
    org.matheclipse.core.polynomials.ExprPolynomial f -> f
    org.matheclipse.core.polynomials.ExprPolynomial f1 -> f1
    org.matheclipse.core.polynomials.ExprPolynomial f2 -> f2
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.Throwable) -> <init>
    void <init>(org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial) -> <init>
    void <init>(java.lang.String,org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial) -> <init>
    void <init>(java.lang.String,java.lang.Throwable,org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial) -> <init>
    void <init>(java.lang.Throwable,org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial) -> <init>
    java.lang.String toString() -> toString
org.matheclipse.core.polynomials.ExpVectorLong -> org.matheclipse.core.polynomials.ExpVectorLong:
    long[] val -> a
    int hash -> a
    void <init>(int) -> <init>
    void <init>(int,int,long) -> <init>
    void <init>(long[]) -> <init>
    void <init>(java.lang.String) -> <init>
    org.matheclipse.core.polynomials.ExpVectorLong copy() -> copy
    org.matheclipse.core.polynomials.ExpVectorLong create(java.util.Collection) -> create
    long[] getVal() -> getVal
    long getVal(int) -> getVal
    long setVal(int,long) -> setVal
    boolean isZero() -> isZero
    boolean isFinite() -> isFinite
    org.matheclipse.core.interfaces.IAST stdVars() -> stdVars
    org.matheclipse.core.interfaces.IAST stdVars(java.lang.String) -> stdVars
    org.matheclipse.core.interfaces.IAST STDVARS(int) -> STDVARS
    org.matheclipse.core.interfaces.IAST STDVARS(java.lang.String,int) -> STDVARS
    int length() -> length
    org.matheclipse.core.polynomials.ExpVectorLong extend(int,int,long) -> extend
    org.matheclipse.core.polynomials.ExpVectorLong extendLower(int,int,long) -> extendLower
    org.matheclipse.core.polynomials.ExpVectorLong contract(int,int) -> contract
    org.matheclipse.core.polynomials.ExpVectorLong reverse() -> reverse
    org.matheclipse.core.polynomials.ExpVectorLong reverse(int) -> reverse
    org.matheclipse.core.polynomials.ExpVectorLong reverseUpper(int) -> reverseUpper
    org.matheclipse.core.polynomials.ExpVectorLong combine(org.matheclipse.core.polynomials.ExpVectorLong) -> combine
    org.matheclipse.core.polynomials.ExpVectorLong permutation(java.util.List) -> permutation
    java.lang.String toString() -> toString
    java.lang.String toString(org.matheclipse.core.interfaces.IAST) -> toString
    java.lang.String varsToString(org.matheclipse.core.interfaces.IAST) -> varsToString
    java.lang.String toScript() -> toScript
    java.lang.String toScript(org.matheclipse.core.interfaces.IAST) -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.matheclipse.core.polynomials.ExpVectorLong abs() -> abs
    org.matheclipse.core.polynomials.ExpVectorLong negate() -> negate
    org.matheclipse.core.polynomials.ExpVectorLong sum(org.matheclipse.core.polynomials.ExpVectorLong) -> sum
    org.matheclipse.core.polynomials.ExpVectorLong subtract(org.matheclipse.core.polynomials.ExpVectorLong) -> subtract
    org.matheclipse.core.polynomials.ExpVectorLong subst(int,long) -> subst
    int signum() -> signum
    long totalDeg() -> totalDeg
    long maxDeg() -> maxDeg
    long weightDeg(long[][]) -> weightDeg
    org.matheclipse.core.polynomials.ExpVectorLong lcm(org.matheclipse.core.polynomials.ExpVectorLong) -> lcm
    org.matheclipse.core.polynomials.ExpVectorLong gcd(org.matheclipse.core.polynomials.ExpVectorLong) -> gcd
    int[] dependencyOnVariables() -> dependencyOnVariables
    boolean multipleOf(org.matheclipse.core.polynomials.ExpVectorLong) -> multipleOf
    int compareTo(org.matheclipse.core.polynomials.ExpVectorLong) -> compareTo
    int EVILCP(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> EVILCP
    int EVILCP(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> EVILCP
    int EVIGLC(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> EVIGLC
    int EVIGLC(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> EVIGLC
    int EVRILCP(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> EVRILCP
    int EVRILCP(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> EVRILCP
    int EVRIGLC(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> EVRIGLC
    int EVRIGLC(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> EVRIGLC
    int EVIWLC(long[][],org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> EVIWLC
    int EVIWLC(long[][],org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> EVIWLC
    int invLexCompareTo(org.matheclipse.core.polynomials.ExpVectorLong) -> invLexCompareTo
    int invLexCompareTo(org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> invLexCompareTo
    int invGradCompareTo(org.matheclipse.core.polynomials.ExpVectorLong) -> invGradCompareTo
    int invGradCompareTo(org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> invGradCompareTo
    int revInvLexCompareTo(org.matheclipse.core.polynomials.ExpVectorLong) -> revInvLexCompareTo
    int revInvLexCompareTo(org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> revInvLexCompareTo
    int revInvGradCompareTo(org.matheclipse.core.polynomials.ExpVectorLong) -> revInvGradCompareTo
    int revInvGradCompareTo(org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> revInvGradCompareTo
    int invWeightCompareTo(long[][],org.matheclipse.core.polynomials.ExpVectorLong) -> invWeightCompareTo
    int invWeightCompareTo(long[][],org.matheclipse.core.polynomials.ExpVectorLong,int,int) -> invWeightCompareTo
org.matheclipse.core.polynomials.ExprMonomial -> org.matheclipse.core.polynomials.ExprMonomial:
    org.matheclipse.core.polynomials.ExpVectorLong e -> e
    org.matheclipse.core.interfaces.IExpr c -> c
    void <init>(java.util.Map$Entry) -> <init>
    void <init>(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.polynomials.ExpVectorLong exponent() -> exponent
    org.matheclipse.core.interfaces.IExpr coefficient() -> coefficient
    java.lang.String toString() -> toString
org.matheclipse.core.polynomials.ExprPolyIterator -> org.matheclipse.core.polynomials.ExprPolyIterator:
    java.util.Iterator ms -> ms
    void <init>(java.util.SortedMap) -> <init>
    boolean hasNext() -> hasNext
    org.matheclipse.core.polynomials.ExprMonomial next() -> next
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.polynomials.ExprPolynomial -> org.matheclipse.core.polynomials.ExprPolynomial:
    org.matheclipse.core.polynomials.ExprPolynomialRing ring -> ring
    java.util.SortedMap val -> val
    org.apache.log4j.Logger logger -> a
    boolean debug -> a
    boolean $assertionsDisabled -> b
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing,java.util.TreeMap) -> <init>
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing) -> <init>
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong) -> <init>
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing,org.matheclipse.core.interfaces.IExpr) -> <init>
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing,org.matheclipse.core.polynomials.ExpVectorLong) -> <init>
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing,java.util.SortedMap) -> <init>
    org.matheclipse.core.polynomials.ExprPolynomialRing factory() -> factory
    org.matheclipse.core.polynomials.ExprPolynomial copy() -> copy
    int length() -> length
    java.util.SortedMap getMap() -> getMap
    void doPutToMap(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.interfaces.IExpr) -> doPutToMap
    void doRemoveFromMap(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.interfaces.IExpr) -> doRemoveFromMap
    void doPutToMap(java.util.SortedMap) -> doPutToMap
    java.lang.String toString() -> toString
    java.lang.String toString(org.matheclipse.core.interfaces.IAST) -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScriptFactory() -> toScriptFactory
    boolean isZero() -> isZero
    boolean isOne() -> isOne
    boolean isUnit() -> isUnit
    boolean isConstant() -> isConstant
    boolean isHomogeneous() -> isHomogeneous
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(org.matheclipse.core.polynomials.ExprPolynomial) -> compareTo
    int signum() -> signum
    int numberOfVariables() -> numberOfVariables
    java.util.Map$Entry leadingMonomial() -> leadingMonomial
    org.matheclipse.core.polynomials.ExpVectorLong leadingExpVectorLong() -> leadingExpVectorLong
    org.matheclipse.core.polynomials.ExpVectorLong trailingExpVectorLong() -> trailingExpVectorLong
    org.matheclipse.core.interfaces.IExpr leadingBaseCoefficient() -> leadingBaseCoefficient
    org.matheclipse.core.interfaces.IExpr trailingBaseCoefficient() -> trailingBaseCoefficient
    org.matheclipse.core.interfaces.IExpr coefficient(org.matheclipse.core.polynomials.ExpVectorLong) -> coefficient
    org.matheclipse.core.polynomials.ExprPolynomial reductum() -> reductum
    long degree(int) -> degree
    long degree() -> degree
    long totalDegree() -> totalDegree
    org.matheclipse.core.polynomials.ExpVectorLong degreeVector() -> degreeVector
    org.matheclipse.core.interfaces.IExpr maxNorm() -> maxNorm
    org.matheclipse.core.interfaces.IExpr sumNorm() -> sumNorm
    org.matheclipse.core.polynomials.ExprPolynomial sum(org.matheclipse.core.polynomials.ExprPolynomial) -> sum
    org.matheclipse.core.polynomials.ExprPolynomial sum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong) -> sum
    org.matheclipse.core.polynomials.ExprPolynomial sum(org.matheclipse.core.interfaces.IExpr) -> sum
    void doAddTo(org.matheclipse.core.polynomials.ExprPolynomial) -> doAddTo
    void doAddTo(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong) -> doAddTo
    void doAddTo(org.matheclipse.core.interfaces.IExpr) -> doAddTo
    org.matheclipse.core.polynomials.ExprPolynomial subtract(org.matheclipse.core.polynomials.ExprPolynomial) -> subtract
    org.matheclipse.core.polynomials.ExprPolynomial subtract(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong) -> subtract
    org.matheclipse.core.polynomials.ExprPolynomial subtract(org.matheclipse.core.interfaces.IExpr) -> subtract
    org.matheclipse.core.polynomials.ExprPolynomial subtractMultiple(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExprPolynomial) -> subtractMultiple
    org.matheclipse.core.polynomials.ExprPolynomial subtractMultiple(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExprPolynomial) -> subtractMultiple
    org.matheclipse.core.polynomials.ExprPolynomial scaleSubtractMultiple(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExprPolynomial) -> scaleSubtractMultiple
    org.matheclipse.core.polynomials.ExprPolynomial scaleSubtractMultiple(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExprPolynomial) -> scaleSubtractMultiple
    org.matheclipse.core.polynomials.ExprPolynomial scaleSubtractMultiple(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExprPolynomial) -> scaleSubtractMultiple
    org.matheclipse.core.polynomials.ExprPolynomial negate() -> negate
    org.matheclipse.core.polynomials.ExprPolynomial abs() -> abs
    org.matheclipse.core.polynomials.ExprPolynomial multiply(org.matheclipse.core.polynomials.ExprPolynomial) -> multiply
    org.matheclipse.core.polynomials.ExprPolynomial multiply(org.matheclipse.core.interfaces.IExpr) -> multiply
    org.matheclipse.core.polynomials.ExprPolynomial monic() -> monic
    org.matheclipse.core.polynomials.ExprPolynomial multiply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong) -> multiply
    org.matheclipse.core.polynomials.ExprPolynomial multiply(org.matheclipse.core.polynomials.ExpVectorLong) -> multiply
    org.matheclipse.core.polynomials.ExprPolynomial multiply(java.util.Map$Entry) -> multiply
    org.matheclipse.core.polynomials.ExprPolynomial divide(org.matheclipse.core.interfaces.IExpr) -> divide
    org.matheclipse.core.polynomials.ExprPolynomial[] quotientRemainder(org.matheclipse.core.polynomials.ExprPolynomial) -> quotientRemainder
    org.matheclipse.core.polynomials.ExprPolynomial[] divideAndRemainder(org.matheclipse.core.polynomials.ExprPolynomial) -> divideAndRemainder
    org.matheclipse.core.polynomials.ExprPolynomial divide(org.matheclipse.core.polynomials.ExprPolynomial) -> divide
    org.matheclipse.core.polynomials.ExprPolynomial remainder(org.matheclipse.core.polynomials.ExprPolynomial) -> remainder
    org.matheclipse.core.polynomials.ExprPolynomial gcd(org.matheclipse.core.polynomials.ExprPolynomial) -> gcd
    org.matheclipse.core.polynomials.ExprPolynomial[] egcd(org.matheclipse.core.polynomials.ExprPolynomial) -> egcd
    org.matheclipse.core.polynomials.ExprPolynomial[] hegcd(org.matheclipse.core.polynomials.ExprPolynomial) -> hegcd
    org.matheclipse.core.polynomials.ExprPolynomial inverse() -> inverse
    org.matheclipse.core.polynomials.ExprPolynomial modInverse(org.matheclipse.core.polynomials.ExprPolynomial) -> modInverse
    org.matheclipse.core.polynomials.ExprPolynomial extend(org.matheclipse.core.polynomials.ExprPolynomialRing,int,long) -> extend
    org.matheclipse.core.polynomials.ExprPolynomial extendLower(org.matheclipse.core.polynomials.ExprPolynomialRing,int,long) -> extendLower
    java.util.Map contract(org.matheclipse.core.polynomials.ExprPolynomialRing) -> contract
    org.matheclipse.core.polynomials.ExprPolynomial contractCoeff(org.matheclipse.core.polynomials.ExprPolynomialRing) -> contractCoeff
    org.matheclipse.core.polynomials.ExprPolynomial extendUnivariate(org.matheclipse.core.polynomials.ExprPolynomialRing,int) -> extendUnivariate
    org.matheclipse.core.polynomials.ExprPolynomial homogenize(org.matheclipse.core.polynomials.ExprPolynomialRing) -> homogenize
    org.matheclipse.core.polynomials.ExprPolynomial deHomogenize(org.matheclipse.core.polynomials.ExprPolynomialRing) -> deHomogenize
    org.matheclipse.core.polynomials.ExprPolynomial reverse(org.matheclipse.core.polynomials.ExprPolynomialRing) -> reverse
    java.util.Iterator coefficientIterator() -> coefficientIterator
    java.util.Iterator exponentIterator() -> exponentIterator
    java.util.Iterator iterator() -> iterator
    org.matheclipse.core.polynomials.ExprPolynomial map(com.google.common.base.Function) -> map
    org.matheclipse.core.interfaces.IAST monomialList() -> monomialList
    org.matheclipse.core.interfaces.IAST coefficientList() -> coefficientList
    org.matheclipse.core.polynomials.ExprPolynomial derivative() -> derivative
    org.matheclipse.core.interfaces.IExpr getExpr() -> getExpr
    org.matheclipse.core.interfaces.IExpr getExpr(org.matheclipse.core.interfaces.IExpr) -> getExpr
    void <clinit>() -> <clinit>
org.matheclipse.core.polynomials.ExprPolynomialComparator -> org.matheclipse.core.polynomials.ExprPolynomialComparator:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.polynomials.ExprTermOrder tord -> tord
    boolean reverse -> reverse
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder,boolean) -> <init>
    int compare(org.matheclipse.core.polynomials.ExprPolynomial,org.matheclipse.core.polynomials.ExprPolynomial) -> compare
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprPolynomialRing -> org.matheclipse.core.polynomials.ExprPolynomialRing:
    org.matheclipse.core.expression.ExprRingFactory coFac -> coFac
    int nvar -> nvar
    org.matheclipse.core.polynomials.ExprTermOrder tord -> tord
    boolean partial -> partial
    org.matheclipse.core.interfaces.IAST vars -> vars
    java.util.Set knownVars -> a
    org.matheclipse.core.polynomials.ExprPolynomial ZERO -> ZERO
    org.matheclipse.core.polynomials.ExprPolynomial ONE -> ONE
    org.matheclipse.core.polynomials.ExpVectorLong evzero -> evzero
    java.util.Random random -> random
    int isField -> isField
    org.apache.log4j.Logger logger -> a
    int creations -> creations
    boolean checkPreempt -> a
    boolean numericFunction -> b
    void <init>(org.matheclipse.core.expression.ExprRingFactory,int) -> <init>
    void <init>(org.matheclipse.core.expression.ExprRingFactory,int,org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    void <init>(org.matheclipse.core.expression.ExprRingFactory,org.matheclipse.core.interfaces.IAST) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    void <init>(org.matheclipse.core.expression.ExprRingFactory,org.matheclipse.core.interfaces.IAST,int) -> <init>
    void <init>(org.matheclipse.core.expression.ExprRingFactory,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    void <init>(org.matheclipse.core.expression.ExprRingFactory,org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    void <init>(org.matheclipse.core.expression.ExprRingFactory,org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.polynomials.ExprTermOrder,boolean) -> <init>
    void <init>(org.matheclipse.core.expression.ExprRingFactory,org.matheclipse.core.polynomials.ExprPolynomialRing) -> <init>
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing,org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    org.matheclipse.core.polynomials.ExprPolynomialRing copy() -> copy
    org.matheclipse.core.polynomials.ExprPolynomial create(org.matheclipse.core.interfaces.IExpr) -> create
    org.matheclipse.core.polynomials.ExprPolynomial create(org.matheclipse.core.interfaces.IExpr,boolean) -> create
    boolean isPolynomial(org.matheclipse.core.interfaces.IExpr) -> isPolynomial
    boolean isPolynomial(org.matheclipse.core.interfaces.IExpr,boolean) -> isPolynomial
    java.lang.String toString() -> toString
    java.lang.String toScript() -> toScript
    java.lang.String toScript(org.matheclipse.core.polynomials.ExpVectorLong) -> toScript
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int getCreations() -> getCreations
    org.matheclipse.core.interfaces.IAST getVars() -> getVars
    org.matheclipse.core.interfaces.IAST setVars(org.matheclipse.core.interfaces.IAST) -> setVars
    java.lang.String varsToString() -> varsToString
    org.matheclipse.core.interfaces.IExpr getZEROCoefficient() -> getZEROCoefficient
    org.matheclipse.core.interfaces.IExpr getONECoefficient() -> getONECoefficient
    org.matheclipse.core.polynomials.ExprPolynomial getZero() -> getZero
    org.matheclipse.core.polynomials.ExprPolynomial getOne() -> getOne
    boolean isCommutative() -> isCommutative
    boolean isAssociative() -> isAssociative
    boolean isField() -> isField
    java.math.BigInteger characteristic() -> characteristic
    org.matheclipse.core.polynomials.ExprPolynomial valueOf(org.matheclipse.core.interfaces.IExpr) -> valueOf
    org.matheclipse.core.polynomials.ExprPolynomial valueOf(org.matheclipse.core.polynomials.ExpVectorLong) -> valueOf
    org.matheclipse.core.polynomials.ExprPolynomial valueOf(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.polynomials.ExpVectorLong) -> valueOf
    org.matheclipse.core.polynomials.ExprPolynomial fromInteger(long) -> fromInteger
    org.matheclipse.core.polynomials.ExprPolynomial fromInteger(java.math.BigInteger) -> fromInteger
    org.matheclipse.core.polynomials.ExprPolynomial copy(org.matheclipse.core.polynomials.ExprPolynomial) -> copy
    org.matheclipse.core.polynomials.ExprPolynomial univariate(int) -> univariate
    org.matheclipse.core.polynomials.ExprPolynomial univariate(int,long) -> univariate
    org.matheclipse.core.polynomials.ExprPolynomial univariate(int,int,long) -> univariate
    java.util.List getGenerators() -> getGenerators
    java.util.List generators() -> generators
    java.util.List generators(int) -> generators
    boolean isFinite() -> isFinite
    java.util.List univariateList() -> univariateList
    java.util.List univariateList(int) -> univariateList
    java.util.List univariateList(int,long) -> univariateList
    org.matheclipse.core.polynomials.ExprPolynomialRing extend(int) -> extend
    org.matheclipse.core.polynomials.ExprPolynomialRing extend(org.matheclipse.core.interfaces.IAST) -> extend
    org.matheclipse.core.polynomials.ExprPolynomialRing extendLower(int) -> extendLower
    org.matheclipse.core.polynomials.ExprPolynomialRing extendLower(org.matheclipse.core.interfaces.IAST) -> extendLower
    org.matheclipse.core.polynomials.ExprPolynomialRing distribute() -> distribute
    org.matheclipse.core.polynomials.ExprPolynomialComparator getComparator() -> getComparator
    org.matheclipse.core.polynomials.ExprPolynomialComparator getComparator(boolean) -> getComparator
    org.matheclipse.core.interfaces.IAST newVars(java.lang.String,int) -> newVars
    org.matheclipse.core.interfaces.IAST newVars(java.lang.String) -> newVars
    org.matheclipse.core.interfaces.IAST newVars(int) -> newVars
    org.matheclipse.core.interfaces.IAST newVars() -> newVars
    void addVars(org.matheclipse.core.interfaces.IAST) -> addVars
    java.lang.String[] permuteVars(java.util.List,java.lang.String[]) -> permuteVars
    java.util.Iterator iterator() -> iterator
    void <clinit>() -> <clinit>
org.matheclipse.core.polynomials.ExprPolynomialRing$1 -> ng:
    int[] $SwitchMap$edu$jas$kern$Scripting$Lang -> a
    void <clinit>() -> <clinit>
org.matheclipse.core.polynomials.ExprTermOrder -> org.matheclipse.core.polynomials.ExprTermOrder:
    int LEX -> LEX
    int INVLEX -> INVLEX
    int GRLEX -> GRLEX
    int IGRLEX -> IGRLEX
    int REVLEX -> REVLEX
    int REVILEX -> REVILEX
    int REVTDEG -> REVTDEG
    int REVITDG -> REVITDG
    int DEFAULT_EVORD -> DEFAULT_EVORD
    int evord -> evord
    int evord2 -> evord2
    int evbeg1 -> evbeg1
    int evend1 -> evend1
    int evbeg2 -> evbeg2
    int evend2 -> evend2
    org.apache.log4j.Logger logger -> a
    boolean debug -> debug
    long[][] weight -> weight
    org.matheclipse.core.polynomials.ExprTermOrder$EVComparator horder -> horder
    org.matheclipse.core.polynomials.ExprTermOrder$EVComparator lorder -> lorder
    org.matheclipse.core.polynomials.ExprTermOrder$EVComparator sugar -> sugar
    void <init>() -> <init>
    void <init>(int) -> <init>
    void <init>(long[]) -> <init>
    void <init>(long[][]) -> <init>
    void <init>(int,int) -> <init>
    void <init>(int,int,int,int) -> <init>
    int getEvord() -> getEvord
    int getEvord2() -> getEvord2
    int getSplit() -> getSplit
    long[][] getWeight() -> getWeight
    org.matheclipse.core.polynomials.ExprTermOrder$EVComparator getDescendComparator() -> getDescendComparator
    org.matheclipse.core.polynomials.ExprTermOrder$EVComparator getAscendComparator() -> getAscendComparator
    org.matheclipse.core.polynomials.ExprTermOrder$EVComparator getSugarComparator() -> getSugarComparator
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String weightToString() -> weightToString
    java.lang.String toString() -> toString
    org.matheclipse.core.polynomials.ExprTermOrder extend(int,int) -> extend
    org.matheclipse.core.polynomials.ExprTermOrder extendLower(int,int) -> extendLower
    org.matheclipse.core.polynomials.ExprTermOrder contract(int,int) -> contract
    org.matheclipse.core.polynomials.ExprTermOrder reverse() -> reverse
    org.matheclipse.core.polynomials.ExprTermOrder reverse(boolean) -> reverse
    int revert(int) -> revert
    long[] longArrayPermutation(java.util.List,long[]) -> longArrayPermutation
    org.matheclipse.core.polynomials.ExprTermOrder permutation(java.util.List) -> permutation
    org.matheclipse.core.polynomials.ExprTermOrder$EVComparator access$000(org.matheclipse.core.polynomials.ExprTermOrder) -> access$000
    long[][] access$100(org.matheclipse.core.polynomials.ExprTermOrder) -> access$100
    int access$200(org.matheclipse.core.polynomials.ExprTermOrder) -> access$200
    int access$300(org.matheclipse.core.polynomials.ExprTermOrder) -> access$300
    int access$400(org.matheclipse.core.polynomials.ExprTermOrder) -> access$400
    int access$500(org.matheclipse.core.polynomials.ExprTermOrder) -> access$500
    void <clinit>() -> <clinit>
org.matheclipse.core.polynomials.ExprTermOrder$1 -> org.matheclipse.core.polynomials.ExprTermOrder$1:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$10 -> org.matheclipse.core.polynomials.ExprTermOrder$10:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$11 -> org.matheclipse.core.polynomials.ExprTermOrder$11:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$12 -> org.matheclipse.core.polynomials.ExprTermOrder$12:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$13 -> org.matheclipse.core.polynomials.ExprTermOrder$13:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$14 -> org.matheclipse.core.polynomials.ExprTermOrder$14:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$15 -> org.matheclipse.core.polynomials.ExprTermOrder$15:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$16 -> org.matheclipse.core.polynomials.ExprTermOrder$16:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$17 -> org.matheclipse.core.polynomials.ExprTermOrder$17:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$18 -> org.matheclipse.core.polynomials.ExprTermOrder$18:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$19 -> org.matheclipse.core.polynomials.ExprTermOrder$19:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$2 -> org.matheclipse.core.polynomials.ExprTermOrder$2:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$20 -> org.matheclipse.core.polynomials.ExprTermOrder$20:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$21 -> org.matheclipse.core.polynomials.ExprTermOrder$21:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$22 -> org.matheclipse.core.polynomials.ExprTermOrder$22:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$23 -> org.matheclipse.core.polynomials.ExprTermOrder$23:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$24 -> org.matheclipse.core.polynomials.ExprTermOrder$24:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$25 -> org.matheclipse.core.polynomials.ExprTermOrder$25:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$26 -> org.matheclipse.core.polynomials.ExprTermOrder$26:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$27 -> org.matheclipse.core.polynomials.ExprTermOrder$27:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$28 -> org.matheclipse.core.polynomials.ExprTermOrder$28:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$29 -> org.matheclipse.core.polynomials.ExprTermOrder$29:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$3 -> org.matheclipse.core.polynomials.ExprTermOrder$3:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$30 -> org.matheclipse.core.polynomials.ExprTermOrder$30:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$31 -> org.matheclipse.core.polynomials.ExprTermOrder$31:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$32 -> org.matheclipse.core.polynomials.ExprTermOrder$32:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$33 -> org.matheclipse.core.polynomials.ExprTermOrder$33:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$34 -> org.matheclipse.core.polynomials.ExprTermOrder$34:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$35 -> org.matheclipse.core.polynomials.ExprTermOrder$35:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$36 -> org.matheclipse.core.polynomials.ExprTermOrder$36:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$37 -> org.matheclipse.core.polynomials.ExprTermOrder$37:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$38 -> org.matheclipse.core.polynomials.ExprTermOrder$38:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$39 -> org.matheclipse.core.polynomials.ExprTermOrder$39:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$4 -> org.matheclipse.core.polynomials.ExprTermOrder$4:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$40 -> org.matheclipse.core.polynomials.ExprTermOrder$40:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$41 -> org.matheclipse.core.polynomials.ExprTermOrder$41:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$42 -> org.matheclipse.core.polynomials.ExprTermOrder$42:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$43 -> org.matheclipse.core.polynomials.ExprTermOrder$43:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$44 -> org.matheclipse.core.polynomials.ExprTermOrder$44:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$45 -> org.matheclipse.core.polynomials.ExprTermOrder$45:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$46 -> org.matheclipse.core.polynomials.ExprTermOrder$46:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$47 -> org.matheclipse.core.polynomials.ExprTermOrder$47:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$48 -> org.matheclipse.core.polynomials.ExprTermOrder$48:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$49 -> org.matheclipse.core.polynomials.ExprTermOrder$49:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$5 -> org.matheclipse.core.polynomials.ExprTermOrder$5:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$50 -> org.matheclipse.core.polynomials.ExprTermOrder$50:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$51 -> org.matheclipse.core.polynomials.ExprTermOrder$51:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$52 -> org.matheclipse.core.polynomials.ExprTermOrder$52:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$53 -> org.matheclipse.core.polynomials.ExprTermOrder$53:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$54 -> org.matheclipse.core.polynomials.ExprTermOrder$54:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$55 -> org.matheclipse.core.polynomials.ExprTermOrder$55:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$56 -> org.matheclipse.core.polynomials.ExprTermOrder$56:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$57 -> org.matheclipse.core.polynomials.ExprTermOrder$57:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$58 -> org.matheclipse.core.polynomials.ExprTermOrder$58:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$59 -> org.matheclipse.core.polynomials.ExprTermOrder$59:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$6 -> org.matheclipse.core.polynomials.ExprTermOrder$6:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$60 -> org.matheclipse.core.polynomials.ExprTermOrder$60:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$61 -> org.matheclipse.core.polynomials.ExprTermOrder$61:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$62 -> org.matheclipse.core.polynomials.ExprTermOrder$62:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$63 -> org.matheclipse.core.polynomials.ExprTermOrder$63:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$64 -> org.matheclipse.core.polynomials.ExprTermOrder$64:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$65 -> org.matheclipse.core.polynomials.ExprTermOrder$65:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$66 -> org.matheclipse.core.polynomials.ExprTermOrder$66:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$67 -> org.matheclipse.core.polynomials.ExprTermOrder$67:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$68 -> org.matheclipse.core.polynomials.ExprTermOrder$68:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$69 -> org.matheclipse.core.polynomials.ExprTermOrder$69:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$7 -> org.matheclipse.core.polynomials.ExprTermOrder$7:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$70 -> org.matheclipse.core.polynomials.ExprTermOrder$70:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$8 -> org.matheclipse.core.polynomials.ExprTermOrder$8:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$9 -> org.matheclipse.core.polynomials.ExprTermOrder$9:
    org.matheclipse.core.polynomials.ExprTermOrder this$0 -> this$0
    void <init>(org.matheclipse.core.polynomials.ExprTermOrder) -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.ExprTermOrder$EVComparator -> org.matheclipse.core.polynomials.ExprTermOrder$EVComparator:
    void <init>() -> <init>
    int compare(org.matheclipse.core.polynomials.ExpVectorLong,org.matheclipse.core.polynomials.ExpVectorLong) -> compare
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.GenPolynomialIterator -> nh:
    org.matheclipse.core.polynomials.ExprPolynomialRing ring -> a
    java.util.Iterator eviter -> a
    java.util.List powers -> a
    java.util.List coeffiter -> b
    java.util.Iterator itercoeff -> b
    org.matheclipse.core.polynomials.ExprPolynomial current -> a
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing) -> <init>
    boolean hasNext() -> hasNext
    org.matheclipse.core.polynomials.ExprPolynomial next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.polynomials.GenPolynomialMonomialIterator -> ni:
    org.matheclipse.core.polynomials.ExprPolynomialRing ring -> a
    java.util.Iterator iter -> a
    org.matheclipse.core.polynomials.ExprPolynomial current -> a
    void <init>(org.matheclipse.core.polynomials.ExprPolynomialRing) -> <init>
    boolean hasNext() -> hasNext
    org.matheclipse.core.polynomials.ExprPolynomial next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.polynomials.HornerScheme -> org.matheclipse.core.polynomials.HornerScheme:
    java.util.TreeMap map -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST generate(boolean,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol) -> generate
    org.matheclipse.core.interfaces.IExpr getCoefficient(org.matheclipse.core.interfaces.ISignedNumber) -> a
    org.matheclipse.core.interfaces.IAST addToMap(org.matheclipse.core.interfaces.ISignedNumber,org.matheclipse.core.interfaces.IExpr) -> addToMap
org.matheclipse.core.polynomials.HornerScheme$1 -> nj:
    void <init>(org.matheclipse.core.polynomials.HornerScheme) -> <init>
    int compare(java.lang.Object,java.lang.Object) -> compare
org.matheclipse.core.polynomials.IPartialFractionGenerator -> org.matheclipse.core.polynomials.IPartialFractionGenerator:
    void setJAS(org.matheclipse.core.convert.JASConvert) -> setJAS
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> addNonFractionalPart
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> addSinglePartialFraction
org.matheclipse.core.polynomials.PartialFractionGenerator -> org.matheclipse.core.polynomials.PartialFractionGenerator:
    org.matheclipse.core.interfaces.IAST result -> a
    org.matheclipse.core.convert.JASConvert jas -> a
    void <init>() -> <init>
    void setJAS(org.matheclipse.core.convert.JASConvert) -> setJAS
    org.matheclipse.core.interfaces.IAST getResult() -> getResult
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> addNonFractionalPart
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> addSinglePartialFraction
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
org.matheclipse.core.polynomials.PartialFractionIntegrateGenerator -> org.matheclipse.core.polynomials.PartialFractionIntegrateGenerator:
    org.matheclipse.core.interfaces.IAST result -> a
    org.matheclipse.core.convert.JASConvert jas -> a
    org.matheclipse.core.interfaces.ISymbol x -> a
    void <init>(org.matheclipse.core.interfaces.ISymbol) -> <init>
    void setJAS(org.matheclipse.core.convert.JASConvert) -> setJAS
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
    void addNonFractionalPart(edu.jas.poly.GenPolynomial) -> addNonFractionalPart
    void addSinglePartialFraction(edu.jas.poly.GenPolynomial,edu.jas.poly.GenPolynomial,int) -> addSinglePartialFraction
    boolean isQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigRational[]) -> isQuadratic
    boolean isQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger[]) -> isQuadratic
org.matheclipse.core.polynomials.PolynomialsUtils -> org.matheclipse.core.polynomials.PolynomialsUtils:
    java.util.List CHEBYSHEV_COEFFICIENTS -> a
    java.util.List HERMITE_COEFFICIENTS -> b
    java.util.List LAGUERRE_COEFFICIENTS -> c
    java.util.List LEGENDRE_COEFFICIENTS -> d
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST createChebyshevPolynomial(int,org.matheclipse.core.interfaces.IExpr) -> createChebyshevPolynomial
    org.matheclipse.core.interfaces.IAST createHermitePolynomial(int,org.matheclipse.core.interfaces.IExpr) -> createHermitePolynomial
    org.matheclipse.core.interfaces.IAST createLaguerrePolynomial(int,org.matheclipse.core.interfaces.IExpr) -> createLaguerrePolynomial
    org.matheclipse.core.interfaces.IAST createLegendrePolynomial(int,org.matheclipse.core.interfaces.IExpr) -> createLegendrePolynomial
    org.matheclipse.core.interfaces.IAST buildPolynomial(int,org.matheclipse.core.interfaces.IExpr,java.util.List,org.matheclipse.core.polynomials.PolynomialsUtils$RecurrenceCoefficientsGenerator) -> buildPolynomial
    void <clinit>() -> <clinit>
org.matheclipse.core.polynomials.PolynomialsUtils$1 -> nk:
    org.apache.commons.math3.fraction.BigFraction[] coeffs -> a
    void <init>() -> <init>
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> generate
org.matheclipse.core.polynomials.PolynomialsUtils$2 -> nl:
    void <init>() -> <init>
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> generate
org.matheclipse.core.polynomials.PolynomialsUtils$3 -> nm:
    void <init>() -> <init>
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> generate
org.matheclipse.core.polynomials.PolynomialsUtils$4 -> nn:
    void <init>() -> <init>
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> generate
org.matheclipse.core.polynomials.PolynomialsUtils$RecurrenceCoefficientsGenerator -> org.matheclipse.core.polynomials.PolynomialsUtils$RecurrenceCoefficientsGenerator:
    org.apache.commons.math3.fraction.BigFraction[] generate(int) -> generate
org.matheclipse.core.polynomials.QuarticSolver -> org.matheclipse.core.polynomials.QuarticSolver:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST solve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> solve
    boolean convertTerm2Coefficients(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr[]) -> a
    org.matheclipse.core.interfaces.IAST quarticSolveN(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> quarticSolveN
    org.matheclipse.core.interfaces.IAST quarticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> quarticSolve
    org.matheclipse.core.interfaces.IAST depressedQuarticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> depressedQuarticSolve
    org.matheclipse.core.interfaces.IAST cubicSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> cubicSolve
    org.matheclipse.core.interfaces.IAST createSet(org.matheclipse.core.interfaces.IAST) -> createSet
    org.matheclipse.core.interfaces.IAST quadraticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> quadraticSolve
    org.matheclipse.core.interfaces.IAST biQuadraticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> biQuadraticSolve
    org.matheclipse.core.interfaces.IAST quasiSymmetricQuarticSolve(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> quasiSymmetricQuarticSolve
org.matheclipse.core.reflection.system.Abs -> org.matheclipse.core.reflection.system.Abs:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Abs$AbsNumericFunction -> no:
    org.matheclipse.core.interfaces.ISymbol symbol -> a
    void <init>(org.matheclipse.core.reflection.system.Abs,org.matheclipse.core.interfaces.ISymbol) -> <init>
    java.lang.Object apply(double) -> apply
org.matheclipse.core.reflection.system.Abs$AbsTimesFunction -> np:
    void <init>(org.matheclipse.core.reflection.system.Abs) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
    void <init>(org.matheclipse.core.reflection.system.Abs,byte) -> <init>
org.matheclipse.core.reflection.system.AddTo -> org.matheclipse.core.reflection.system.AddTo:
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> getFunction
    void <init>() -> <init>
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> getFunctionSymbol
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.AddTo$AddToFunction -> nq:
    org.matheclipse.core.interfaces.IExpr value -> a
    void <init>(org.matheclipse.core.reflection.system.AddTo,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Apart -> org.matheclipse.core.reflection.system.Apart:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST partialFractionDecompositionInteger(org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.IAST) -> partialFractionDecompositionInteger
    org.matheclipse.core.interfaces.IExpr partialFractionDecompositionRational(org.matheclipse.core.polynomials.IPartialFractionGenerator,org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.ISymbol) -> partialFractionDecompositionRational
    org.matheclipse.core.interfaces.IExpr[] getFractionalPartsRational(org.matheclipse.core.interfaces.IExpr) -> getFractionalPartsRational
    org.matheclipse.core.interfaces.IExpr[] getFractionalParts(org.matheclipse.core.interfaces.IExpr) -> getFractionalParts
    org.matheclipse.core.interfaces.IExpr[] getFractionalPartsTimes(org.matheclipse.core.interfaces.IAST,boolean,boolean,boolean) -> getFractionalPartsTimes
    org.matheclipse.core.interfaces.IExpr getFractionalPartsPower(org.matheclipse.core.interfaces.IAST) -> getFractionalPartsPower
org.matheclipse.core.reflection.system.ArcCos -> org.matheclipse.core.reflection.system.ArcCos:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcCosh -> org.matheclipse.core.reflection.system.ArcCosh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcCot -> org.matheclipse.core.reflection.system.ArcCot:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcCoth -> org.matheclipse.core.reflection.system.ArcCoth:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcCsc -> org.matheclipse.core.reflection.system.ArcCsc:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcCsch -> org.matheclipse.core.reflection.system.ArcCsch:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcSec -> org.matheclipse.core.reflection.system.ArcSec:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcSech -> org.matheclipse.core.reflection.system.ArcSech:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcSin -> org.matheclipse.core.reflection.system.ArcSin:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcSinh -> org.matheclipse.core.reflection.system.ArcSinh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcTan -> org.matheclipse.core.reflection.system.ArcTan:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> e1DblComArg
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> e2DblArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArcTanh -> org.matheclipse.core.reflection.system.ArcTanh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Arg -> org.matheclipse.core.reflection.system.Arg:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ArrayDepth -> org.matheclipse.core.reflection.system.ArrayDepth:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.BernoulliB -> org.matheclipse.core.reflection.system.BernoulliB:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IFraction bernoulliNumber(org.matheclipse.core.interfaces.IInteger) -> bernoulliNumber
    org.apache.commons.math3.fraction.BigFraction bernoulliNumber(java.math.BigInteger) -> bernoulliNumber
    org.apache.commons.math3.fraction.BigFraction bernoulliNumber(int) -> bernoulliNumber
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Binomial -> org.matheclipse.core.reflection.system.Binomial:
    java.math.BigInteger binomial(java.math.BigInteger,java.math.BigInteger) -> binomial
    java.math.BigInteger binomial(int,int) -> binomial
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
org.matheclipse.core.reflection.system.Boole -> org.matheclipse.core.reflection.system.Boole:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.BooleanConvert -> org.matheclipse.core.reflection.system.BooleanConvert:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.BooleanConvert$BooleanConvertVisitor -> nr:
    void <init>(org.matheclipse.core.reflection.system.BooleanConvert) -> <init>
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> visitAST
    org.matheclipse.core.interfaces.IAST convertNand(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST convertNor(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IAST convertXor(org.matheclipse.core.interfaces.IAST) -> c
org.matheclipse.core.reflection.system.BooleanMinimize -> org.matheclipse.core.reflection.system.BooleanMinimize:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Cancel -> org.matheclipse.core.reflection.system.Cancel:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr cancelPowerTimes(org.matheclipse.core.interfaces.IExpr) -> cancelPowerTimes
    org.matheclipse.core.interfaces.IExpr[] cancelGCD(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> cancelGCD
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Cancel$PolynomialPredicate -> ns:
    void <init>() -> <init>
    boolean apply(java.lang.Object) -> apply
    void <init>(byte) -> <init>
org.matheclipse.core.reflection.system.CartesianProduct -> org.matheclipse.core.reflection.system.CartesianProduct:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.CartesianProduct$CartesianProductIterator -> nt:
    java.util.List comps -> a
    java.util.List compit -> b
    org.matheclipse.core.interfaces.IAST current -> a
    boolean empty -> a
    void <init>(org.matheclipse.core.reflection.system.CartesianProduct,java.util.List,org.matheclipse.core.interfaces.IAST) -> <init>
    boolean hasNext() -> hasNext
    org.matheclipse.core.interfaces.IAST next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.CartesianProduct$CartesianProductList -> nu:
    java.util.List comps -> a
    org.matheclipse.core.interfaces.IAST fEmptyResultList -> a
    org.matheclipse.core.reflection.system.CartesianProduct this$0 -> a
    void <init>(org.matheclipse.core.reflection.system.CartesianProduct,java.util.List,org.matheclipse.core.interfaces.IAST) -> <init>
    java.util.Iterator iterator() -> iterator
org.matheclipse.core.reflection.system.CatalanNumber -> org.matheclipse.core.reflection.system.CatalanNumber:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    java.math.BigInteger catalanNumber(java.math.BigInteger) -> catalanNumber
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Ceiling -> org.matheclipse.core.reflection.system.Ceiling:
    void <init>() -> <init>
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evalCeiling(org.matheclipse.core.interfaces.IExpr) -> evalCeiling
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Ceiling$CeilingPlusFunction -> nv:
    void <init>(org.matheclipse.core.reflection.system.Ceiling) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
    void <init>(org.matheclipse.core.reflection.system.Ceiling,byte) -> <init>
org.matheclipse.core.reflection.system.CharacteristicPolynomial -> org.matheclipse.core.reflection.system.CharacteristicPolynomial:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.ChebyshevT -> org.matheclipse.core.reflection.system.ChebyshevT:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.ChessboardDistance -> org.matheclipse.core.reflection.system.ChessboardDistance:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Coefficient -> org.matheclipse.core.reflection.system.Coefficient:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.CoefficientList -> org.matheclipse.core.reflection.system.CoefficientList:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    double[] coefficientList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> coefficientList
    long univariateCoefficientList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,java.util.List) -> univariateCoefficientList
    long univariateCoefficientList(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,java.util.List,java.util.List) -> univariateCoefficientList
org.matheclipse.core.reflection.system.Complement -> org.matheclipse.core.reflection.system.Complement:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.ComplexExpand -> org.matheclipse.core.reflection.system.ComplexExpand:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr complexExpand(org.matheclipse.core.interfaces.IExpr) -> c
    org.matheclipse.core.interfaces.IExpr complexExpandNull(org.matheclipse.core.interfaces.IExpr) -> d
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr access$000(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr access$100(org.matheclipse.core.interfaces.IExpr) -> b
org.matheclipse.core.reflection.system.ComplexExpand$ComplexExpandVisitor -> nw:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> visit2
org.matheclipse.core.reflection.system.ComposeList -> org.matheclipse.core.reflection.system.ComposeList:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateComposeList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evaluateComposeList
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Conjugate -> org.matheclipse.core.reflection.system.Conjugate:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr conjugate(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    double evalReal(double[],int,int) -> evalReal
org.matheclipse.core.reflection.system.ConjugateTranspose -> org.matheclipse.core.reflection.system.ConjugateTranspose:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr transform(org.matheclipse.core.interfaces.IExpr) -> transform
org.matheclipse.core.reflection.system.ConstantArray -> org.matheclipse.core.reflection.system.ConstantArray:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateArray(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evaluateArray
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ConstantArray$ArrayIterator -> org.matheclipse.core.reflection.system.ConstantArray$ArrayIterator:
    int fCurrent -> a
    int fFrom -> b
    int fTo -> c
    void <init>(int) -> <init>
    void <init>(int,int) -> <init>
    boolean setUp() -> setUp
    void tearDown() -> tearDown
    boolean hasNext() -> hasNext
    org.matheclipse.core.interfaces.IExpr next() -> next
    void remove() -> remove
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.ContinuedFraction -> org.matheclipse.core.reflection.system.ContinuedFraction:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.CoprimeQ -> org.matheclipse.core.reflection.system.CoprimeQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Cos -> org.matheclipse.core.reflection.system.Cos:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.CosIntegral -> org.matheclipse.core.reflection.system.CosIntegral:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Cosh -> org.matheclipse.core.reflection.system.Cosh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Cot -> org.matheclipse.core.reflection.system.Cot:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Coth -> org.matheclipse.core.reflection.system.Coth:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Cross -> org.matheclipse.core.reflection.system.Cross:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Csc -> org.matheclipse.core.reflection.system.Csc:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Csch -> org.matheclipse.core.reflection.system.Csch:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Curl -> org.matheclipse.core.reflection.system.Curl:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.D -> org.matheclipse.core.reflection.system.D:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST createDerivative(int,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Decrement -> org.matheclipse.core.reflection.system.Decrement:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
    com.google.common.base.Function getFunction() -> getFunction
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> getFunctionSymbol
    org.matheclipse.core.interfaces.IExpr getResult(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> getResult
    org.matheclipse.core.interfaces.IExpr apply(org.matheclipse.core.interfaces.IExpr) -> apply
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Decrement$DecrementFunction -> nx:
    void <init>(org.matheclipse.core.reflection.system.Decrement) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Default -> org.matheclipse.core.reflection.system.Default:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.DeleteDuplicates -> org.matheclipse.core.reflection.system.DeleteDuplicates:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Denominator -> org.matheclipse.core.reflection.system.Denominator:
    org.matheclipse.core.interfaces.ISymbol[] NUMERATOR_SYMBOLS -> a
    org.matheclipse.core.interfaces.ISymbol[] DENOMINATOR_SYMBOLS -> b
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IAST getDenominatorForm(org.matheclipse.core.interfaces.IAST) -> getDenominatorForm
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.Derivative -> org.matheclipse.core.reflection.system.Derivative:
    java.util.Map DERIVATIVE_1_MAP -> a
    java.util.Map DERIVATIVE_2_MAP -> b
    java.util.Map DERIVATIVE_N_MAP -> c
    java.util.Map DERIVATIVE_N_M_MAP -> d
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr derivative(int,org.matheclipse.core.interfaces.ISymbol) -> derivative
    org.matheclipse.core.interfaces.IExpr derivative(int,int,org.matheclipse.core.interfaces.ISymbol) -> derivative
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.Det -> org.matheclipse.core.reflection.system.Det:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr matrixEval(org.matheclipse.commons.math.linear.FieldMatrix) -> matrixEval
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> realMatrixEval
org.matheclipse.core.reflection.system.DiagonalMatrix -> org.matheclipse.core.reflection.system.DiagonalMatrix:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.DigitQ -> org.matheclipse.core.reflection.system.DigitQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Dimensions -> org.matheclipse.core.reflection.system.Dimensions:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.util.ArrayList getDimensions(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int) -> getDimensions
    java.util.ArrayList getDimensions(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,int,java.util.ArrayList) -> getDimensions
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Discriminant -> org.matheclipse.core.reflection.system.Discriminant:
    org.matheclipse.core.interfaces.IExpr QUADRATIC -> a
    org.matheclipse.core.interfaces.IExpr CUBIC -> b
    org.matheclipse.core.interfaces.IExpr QUARTIC -> c
    org.matheclipse.core.interfaces.IExpr QUINTIC -> d
    org.matheclipse.core.interfaces.ISymbol[] vars -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.Distribute -> org.matheclipse.core.reflection.system.Distribute:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void distributePosition(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
org.matheclipse.core.reflection.system.Divergence -> org.matheclipse.core.reflection.system.Divergence:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.DivideBy -> org.matheclipse.core.reflection.system.DivideBy:
    void <init>() -> <init>
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> getFunction
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> getFunctionSymbol
org.matheclipse.core.reflection.system.DivideBy$DivideByFunction -> ny:
    org.matheclipse.core.interfaces.IExpr value -> a
    void <init>(org.matheclipse.core.reflection.system.DivideBy,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Divisible -> org.matheclipse.core.reflection.system.Divisible:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr isSignedNumberDivisible(org.matheclipse.core.interfaces.ISignedNumber) -> a
org.matheclipse.core.reflection.system.Divisors -> org.matheclipse.core.reflection.system.Divisors:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Dot -> org.matheclipse.core.reflection.system.Dot:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Eigenvalues -> org.matheclipse.core.reflection.system.Eigenvalues:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> realMatrixEval
    org.matheclipse.core.interfaces.IExpr matrixEval(org.matheclipse.commons.math.linear.FieldMatrix) -> matrixEval
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> realMatrixEval
org.matheclipse.core.reflection.system.Eigenvectors -> org.matheclipse.core.reflection.system.Eigenvectors:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> realMatrixEval
    org.matheclipse.core.interfaces.IExpr matrixEval(org.matheclipse.commons.math.linear.FieldMatrix) -> matrixEval
    org.matheclipse.core.interfaces.IExpr realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> realMatrixEval
org.matheclipse.core.reflection.system.Eliminate -> org.matheclipse.core.reflection.system.Eliminate:
    org.matheclipse.core.interfaces.IExpr extractVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,com.google.common.base.Predicate,org.matheclipse.core.interfaces.ISymbol) -> extractVariable
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST eliminateOneVariable(java.util.ArrayList,org.matheclipse.core.interfaces.ISymbol) -> eliminateOneVariable
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Eliminate$VariableCounterVisitor -> nz:
    int fVariableCounter -> a
    int fNodeCounter -> b
    int fMaxVariableDepth -> c
    int fCurrentDepth -> d
    org.matheclipse.core.interfaces.IExpr fVariable -> a
    org.matheclipse.core.interfaces.IAST fExpr -> a
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> <init>
    boolean visit(org.matheclipse.core.interfaces.IAST) -> visit
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> visit
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> visit
    boolean visit(org.matheclipse.core.interfaces.INum) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    boolean visit(org.matheclipse.core.interfaces.IPattern) -> visit
    boolean visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    boolean visit(org.matheclipse.core.interfaces.IStringX) -> visit
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.Equal -> org.matheclipse.core.reflection.system.Equal:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr createComparatorResult(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> simplifyCompare
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Equivalent -> org.matheclipse.core.reflection.system.Equivalent:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Erf -> org.matheclipse.core.reflection.system.Erf:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.EuclidianDistance -> org.matheclipse.core.reflection.system.EuclidianDistance:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.EulerE -> org.matheclipse.core.reflection.system.EulerE:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void set(java.util.ArrayList,int) -> set
    java.math.BigInteger eulerE(java.util.ArrayList,int) -> eulerE
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.EulerPhi -> org.matheclipse.core.reflection.system.EulerPhi:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Exp -> org.matheclipse.core.reflection.system.Exp:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
    double evalReal(double[],int,int) -> evalReal
org.matheclipse.core.reflection.system.Expand -> org.matheclipse.core.reflection.system.Expand:
    org.matheclipse.core.interfaces.IExpr expand(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> expand
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Expand$Expander -> nA:
    boolean expandNegativePowers -> a
    boolean distributePlus -> b
    org.matheclipse.core.interfaces.IExpr pattern -> a
    void <init>(org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> <init>
    org.matheclipse.core.interfaces.IExpr expandAST(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr setExpanded(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr expandPowerNull(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr expandPower(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr expandTimes(org.matheclipse.core.interfaces.IAST) -> c
    org.matheclipse.core.interfaces.IExpr expandExprTimesPlus(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
    void evalAndExpandAST(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.Expand$NumberPartititon -> nB:
    org.matheclipse.core.interfaces.IAST expandedResult -> a
    int m -> b
    int n -> a
    int[] parts -> a
    org.matheclipse.core.interfaces.IAST precalculatedPowerASTs -> b
    void <init>(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST) -> <init>
    void partition(int,int,int) -> a
org.matheclipse.core.reflection.system.ExpandAll -> org.matheclipse.core.reflection.system.ExpandAll:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr expandAll(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> expandAll
    org.matheclipse.core.interfaces.IExpr setAllExpanded(org.matheclipse.core.interfaces.IExpr,boolean,boolean) -> a
org.matheclipse.core.reflection.system.ExtendedGCD -> org.matheclipse.core.reflection.system.ExtendedGCD:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.lang.Object[] extendedGCD(java.math.BigInteger,java.math.BigInteger) -> extendedGCD
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Extract -> org.matheclipse.core.reflection.system.Extract:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr extract(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> extract
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr extract(org.matheclipse.core.interfaces.IAST,java.util.List,org.matheclipse.core.generic.interfaces.IPositionConverter,int) -> extract
org.matheclipse.core.reflection.system.Factor -> org.matheclipse.core.reflection.system.Factor:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr factor(org.matheclipse.core.interfaces.IExpr,java.util.List,boolean) -> factor
    org.matheclipse.core.interfaces.IExpr factorList(org.matheclipse.core.interfaces.IExpr,java.util.List,boolean) -> factorList
    org.matheclipse.core.interfaces.IExpr factorWithOption(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,java.util.List,boolean) -> factorWithOption
    org.matheclipse.core.interfaces.IAST factorComplex(org.matheclipse.core.interfaces.IExpr,java.util.List,org.matheclipse.core.interfaces.ISymbol,boolean,boolean) -> factorComplex
    org.matheclipse.core.interfaces.IAST factorComplex(edu.jas.poly.GenPolynomial,org.matheclipse.core.convert.JASConvert,java.util.List,org.matheclipse.core.interfaces.ISymbol,boolean) -> factorComplex
    org.matheclipse.core.interfaces.IAST factorModulus(org.matheclipse.core.interfaces.IExpr,java.util.List,boolean,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IAST factorModulus(org.matheclipse.core.convert.JASModInteger,edu.jas.arith.ModLongRing,edu.jas.poly.GenPolynomial,boolean) -> factorModulus
org.matheclipse.core.reflection.system.FactorInteger -> org.matheclipse.core.reflection.system.FactorInteger:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.FactorSquareFree -> org.matheclipse.core.reflection.system.FactorSquareFree:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.FactorSquareFreeList -> org.matheclipse.core.reflection.system.FactorSquareFreeList:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.FactorTerms -> org.matheclipse.core.reflection.system.FactorTerms:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Factorial -> org.matheclipse.core.reflection.system.Factorial:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IInteger factorial(org.matheclipse.core.interfaces.IInteger) -> factorial
    java.math.BigInteger factorial(java.math.BigInteger) -> factorial
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Factorial2 -> org.matheclipse.core.reflection.system.Factorial2:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IInteger factorial2(org.matheclipse.core.interfaces.IInteger) -> factorial2
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Fibonacci -> org.matheclipse.core.reflection.system.Fibonacci:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IInteger fibonacci(org.matheclipse.core.interfaces.IInteger) -> fibonacci
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.FindRoot -> org.matheclipse.core.reflection.system.FindRoot:
    org.matheclipse.core.interfaces.ISymbol Newton -> Newton
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.Fit -> org.matheclipse.core.reflection.system.Fit:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.reflection.system.Floor -> org.matheclipse.core.reflection.system.Floor:
    void <init>() -> <init>
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evalFloor(org.matheclipse.core.interfaces.IExpr) -> evalFloor
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Floor$FloorPlusFunction -> nC:
    void <init>(org.matheclipse.core.reflection.system.Floor) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
    void <init>(org.matheclipse.core.reflection.system.Floor,byte) -> <init>
org.matheclipse.core.reflection.system.FractionalPart -> org.matheclipse.core.reflection.system.FractionalPart:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.FresnelC -> org.matheclipse.core.reflection.system.FresnelC:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.FresnelS -> org.matheclipse.core.reflection.system.FresnelS:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.FrobeniusSolve -> org.matheclipse.core.reflection.system.FrobeniusSolve:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.FromCharacterCode -> org.matheclipse.core.reflection.system.FromCharacterCode:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    java.util.List fromCharcterCode(java.lang.String,java.lang.String,java.util.List) -> fromCharcterCode
org.matheclipse.core.reflection.system.FromContinuedFraction -> org.matheclipse.core.reflection.system.FromContinuedFraction:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.FullSimplify -> org.matheclipse.core.reflection.system.FullSimplify:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.GCD -> org.matheclipse.core.reflection.system.GCD:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> e2FraArg
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Gamma -> org.matheclipse.core.reflection.system.Gamma:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    java.math.BigInteger gamma(java.math.BigInteger) -> gamma
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.GeometricMean -> org.matheclipse.core.reflection.system.GeometricMean:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.reflection.system.Greater -> org.matheclipse.core.reflection.system.Greater:
    org.matheclipse.core.reflection.system.Greater CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> simplifyCompare
    org.matheclipse.core.interfaces.IAST simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> simplifyCompare
    org.matheclipse.core.interfaces.IAST createComparatorResult(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,boolean,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.ISymbol) -> a
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr checkAssumptions(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> checkAssumptions
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT prepareCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> prepareCompare
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.GreaterEqual -> org.matheclipse.core.reflection.system.GreaterEqual:
    org.matheclipse.core.reflection.system.GreaterEqual CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr checkAssumptions(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> checkAssumptions
    org.matheclipse.core.interfaces.IAST simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> simplifyCompare
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.GroebnerBasis -> org.matheclipse.core.reflection.system.GroebnerBasis:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.HarmonicNumber -> org.matheclipse.core.reflection.system.HarmonicNumber:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    org.apache.commons.math3.fraction.BigFraction harmonicNumber(int) -> harmonicNumber
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Haversine -> org.matheclipse.core.reflection.system.Haversine:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.HermiteH -> org.matheclipse.core.reflection.system.HermiteH:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.HilbertMatrix -> org.matheclipse.core.reflection.system.HilbertMatrix:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.HilbertMatrix$HilbertFunctionDiagonal -> org.matheclipse.core.reflection.system.HilbertMatrix$HilbertFunctionDiagonal:
    void <init>(org.matheclipse.core.reflection.system.HilbertMatrix) -> <init>
    org.matheclipse.core.interfaces.IFraction evaluate(int[]) -> evaluate
    java.lang.Object evaluate(int[]) -> evaluate
org.matheclipse.core.reflection.system.Horner -> org.matheclipse.core.reflection.system.Horner:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.HornerForm -> org.matheclipse.core.reflection.system.HornerForm:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.IdentityMatrix -> org.matheclipse.core.reflection.system.IdentityMatrix:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST diagonalMatrix(org.matheclipse.core.interfaces.IExpr[],int) -> diagonalMatrix
org.matheclipse.core.reflection.system.Im -> org.matheclipse.core.reflection.system.Im:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr imPowerComplex(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Increment -> org.matheclipse.core.reflection.system.Increment:
    void <init>() -> <init>
    com.google.common.base.Function getFunction() -> getFunction
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> getFunctionSymbol
org.matheclipse.core.reflection.system.Increment$IncrementFunction -> nD:
    void <init>(org.matheclipse.core.reflection.system.Increment) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Inner -> org.matheclipse.core.reflection.system.Inner:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Inner$InnerAlgorithm -> nE:
    org.matheclipse.core.interfaces.IExpr f -> a
    org.matheclipse.core.interfaces.IExpr g -> b
    org.matheclipse.core.interfaces.IExpr head -> c
    org.matheclipse.core.interfaces.IAST list1 -> a
    org.matheclipse.core.interfaces.IAST list2 -> b
    int list2Dim0 -> a
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IAST recursion(java.util.ArrayList,java.util.ArrayList,java.util.List,java.util.List) -> a
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,byte) -> <init>
org.matheclipse.core.reflection.system.IntegerExponent -> org.matheclipse.core.reflection.system.IntegerExponent:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.IntegerPart -> org.matheclipse.core.reflection.system.IntegerPart:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.IntegerPartitions -> org.matheclipse.core.reflection.system.IntegerPartitions:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.IntegerPartitions$NumberPartitionsIterable -> org.matheclipse.core.reflection.system.IntegerPartitions$NumberPartitionsIterable:
    int n -> a
    int len -> b
    int[] fPartititionsIndex -> a
    int i -> c
    int k -> d
    int[] fCopiedResultIndex -> b
    int[] fResultIndex -> c
    void <init>(int) -> <init>
    void <init>(int,int) -> <init>
    int[] nextBeforehand() -> a
    int[] next() -> next
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.Integrate -> org.matheclipse.core.reflection.system.Integrate:
    org.matheclipse.core.reflection.system.Integrate CONST -> CONST
    boolean INITIALIZED -> INITIALIZED
    java.util.Set INT_RUBI_FUNCTIONS -> INT_RUBI_FUNCTIONS
    java.util.Set INT_FUNCTIONS -> INT_FUNCTIONS
    java.util.Set DEBUG_EXPR -> DEBUG_EXPR
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr integrate1ArgumentFunctions(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    boolean isQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigRational[]) -> isQuadratic
    boolean isQuadratic(edu.jas.poly.GenPolynomial,edu.jas.arith.BigInteger[]) -> isQuadratic
    org.matheclipse.core.interfaces.IExpr integrateByRubiRules(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr integrateByParts(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> a
    void collectPolynomialTerms(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    org.matheclipse.core.interfaces.IAST getUtilityFunctionsRuleAST() -> getUtilityFunctionsRuleAST
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void initSerializedRules(org.matheclipse.core.interfaces.ISymbol) -> initSerializedRules
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.Integrate$1 -> nF:
    org.matheclipse.core.interfaces.ISymbol val$x -> a
    void <init>(org.matheclipse.core.reflection.system.Integrate,org.matheclipse.core.interfaces.ISymbol) -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.InterpolatingFunction -> org.matheclipse.core.reflection.system.InterpolatingFunction:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.InterpolatingPolynomial -> org.matheclipse.core.reflection.system.InterpolatingPolynomial:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr[] computeDividedDifference(org.matheclipse.core.interfaces.IExpr[],org.matheclipse.core.interfaces.IExpr[]) -> computeDividedDifference
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Intersection -> org.matheclipse.core.reflection.system.Intersection:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Inverse -> org.matheclipse.core.reflection.system.Inverse:
    void <init>() -> <init>
    org.matheclipse.commons.math.linear.FieldMatrix matrixEval(org.matheclipse.commons.math.linear.FieldMatrix) -> matrixEval
    org.apache.commons.math3.linear.RealMatrix realMatrixEval(org.apache.commons.math3.linear.RealMatrix) -> realMatrixEval
org.matheclipse.core.reflection.system.InverseErf -> org.matheclipse.core.reflection.system.InverseErf:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.InverseFunction -> org.matheclipse.core.reflection.system.InverseFunction:
    java.util.Map UNARY_INVERSE_FUNCTIONS -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.ISymbol getUnaryInverseFunction(org.matheclipse.core.interfaces.ISymbol) -> getUnaryInverseFunction
    org.matheclipse.core.interfaces.IAST getUnaryInverseFunction(org.matheclipse.core.interfaces.IAST) -> getUnaryInverseFunction
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.InverseHaversine -> org.matheclipse.core.reflection.system.InverseHaversine:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.JacobiMatrix -> org.matheclipse.core.reflection.system.JacobiMatrix:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.JacobiSymbol -> org.matheclipse.core.reflection.system.JacobiSymbol:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Join -> org.matheclipse.core.reflection.system.Join:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.KOrderlessPartitions -> org.matheclipse.core.reflection.system.KOrderlessPartitions:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.KPartitions -> org.matheclipse.core.reflection.system.KPartitions:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.KPartitions$KPartitionsIterable -> org.matheclipse.core.reflection.system.KPartitions$KPartitionsIterable:
    int fLength -> a
    int fNumberOfParts -> b
    int[] fPartitionsIndex -> a
    int[] fCopiedResultIndex -> b
    int[] fResultIndex -> c
    void <init>(int,int) -> <init>
    void reset() -> reset
    int[] nextBeforehand() -> a
    int[] next() -> next
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.KPartitions$KPartitionsList -> org.matheclipse.core.reflection.system.KPartitions$KPartitionsList:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    org.matheclipse.core.reflection.system.KPartitions$KPartitionsIterable fIterable -> a
    void <init>(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,int) -> <init>
    org.matheclipse.core.interfaces.IAST next() -> next
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.LCM -> org.matheclipse.core.reflection.system.LCM:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.LUDecomposition -> org.matheclipse.core.reflection.system.LUDecomposition:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.reflection.system.LaguerreL -> org.matheclipse.core.reflection.system.LaguerreL:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.LegendreP -> org.matheclipse.core.reflection.system.LegendreP:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Less -> org.matheclipse.core.reflection.system.Less:
    org.matheclipse.core.reflection.system.Less CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr checkAssumptions(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> checkAssumptions
    org.matheclipse.core.interfaces.IAST simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> simplifyCompare
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.LessEqual -> org.matheclipse.core.reflection.system.LessEqual:
    org.matheclipse.core.reflection.system.LessEqual CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr checkAssumptions(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> checkAssumptions
    org.matheclipse.core.interfaces.IAST simplifyCompare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> simplifyCompare
    org.matheclipse.core.generic.ITernaryComparator$COMPARE_RESULT compare(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> compare
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.LetterQ -> org.matheclipse.core.reflection.system.LetterQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Level -> org.matheclipse.core.reflection.system.Level:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Limit -> org.matheclipse.core.reflection.system.Limit:
    int DIRECTION_FROM_LARGER_VALUES -> DIRECTION_FROM_LARGER_VALUES
    int DIRECTION_AUTOMATIC -> DIRECTION_AUTOMATIC
    int DIRECTION_FROM_SMALLER_VALUES -> DIRECTION_FROM_SMALLER_VALUES
    org.matheclipse.core.interfaces.IExpr evalLimitQuiet(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.reflection.system.Limit$LimitData) -> a
    org.matheclipse.core.interfaces.IExpr evalLimit(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.reflection.system.Limit$LimitData,boolean) -> a
    org.matheclipse.core.interfaces.IExpr lHospitalesRule(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.reflection.system.Limit$LimitData) -> a
    org.matheclipse.core.interfaces.IExpr mapLimit(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr numeratorDenominatorLimit(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.reflection.system.Limit$LimitData) -> b
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
org.matheclipse.core.reflection.system.Limit$LimitData -> nG:
    org.matheclipse.core.interfaces.ISymbol symbol -> a
    org.matheclipse.core.interfaces.IExpr limitValue -> a
    org.matheclipse.core.interfaces.IAST rule -> a
    int direction -> a
    void <init>(org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> <init>
    java.lang.Object clone() -> clone
org.matheclipse.core.reflection.system.LinearProgramming -> org.matheclipse.core.reflection.system.LinearProgramming:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.reflection.system.LinearSolve -> org.matheclipse.core.reflection.system.LinearSolve:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.reflection.system.Log -> org.matheclipse.core.reflection.system.Log:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> e1DblComArg
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> e2DblArg
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    org.matheclipse.core.interfaces.IExpr baseBLog(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> baseBLog
    org.matheclipse.core.generic.BinaryFunctorImpl getFunction() -> getFunction
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
org.matheclipse.core.reflection.system.Log$1 -> nH:
    void <init>() -> <init>
    java.lang.Object apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Log10 -> org.matheclipse.core.reflection.system.Log10:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
    double evalReal(double[],int,int) -> evalReal
org.matheclipse.core.reflection.system.Log2 -> org.matheclipse.core.reflection.system.Log2:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
    double evalReal(double[],int,int) -> evalReal
org.matheclipse.core.reflection.system.LowerCaseQ -> org.matheclipse.core.reflection.system.LowerCaseQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.ManhattanDistance -> org.matheclipse.core.reflection.system.ManhattanDistance:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Map -> org.matheclipse.core.reflection.system.Map:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.MapAll -> org.matheclipse.core.reflection.system.MapAll:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.MapThread -> org.matheclipse.core.reflection.system.MapThread:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.MapThread$UnaryMapThread -> nI:
    org.matheclipse.core.interfaces.IExpr fConstant -> a
    void <init>(org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.MatrixPower -> org.matheclipse.core.reflection.system.MatrixPower:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.MatrixQ -> org.matheclipse.core.reflection.system.MatrixQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.MatrixRank -> org.matheclipse.core.reflection.system.MatrixRank:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Max -> org.matheclipse.core.reflection.system.Max:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Mean -> org.matheclipse.core.reflection.system.Mean:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Median -> org.matheclipse.core.reflection.system.Median:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Min -> org.matheclipse.core.reflection.system.Min:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Mod -> org.matheclipse.core.reflection.system.Mod:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
org.matheclipse.core.reflection.system.MoebiusMu -> org.matheclipse.core.reflection.system.MoebiusMu:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.MonomialList -> org.matheclipse.core.reflection.system.MonomialList:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST monomialListModulus$3f73e28d(org.matheclipse.core.interfaces.IExpr,java.util.List,org.matheclipse.core.interfaces.IExpr) -> a
org.matheclipse.core.reflection.system.Most -> org.matheclipse.core.reflection.system.Most:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Multinomial -> org.matheclipse.core.reflection.system.Multinomial:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.math.BigInteger multinomial(java.util.List) -> multinomial
    java.math.BigInteger multinomial(int[],int) -> multinomial
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.NFourierTransform -> org.matheclipse.core.reflection.system.NFourierTransform:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.NIntegrate -> org.matheclipse.core.reflection.system.NIntegrate:
    org.matheclipse.core.interfaces.ISymbol LegendreGauss -> LegendreGauss
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    double integrate(java.lang.String,org.matheclipse.core.interfaces.IAST,double,double,org.matheclipse.core.interfaces.IExpr) -> integrate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.NMaximize -> org.matheclipse.core.reflection.system.NMaximize:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.reflection.system.NMinimize -> org.matheclipse.core.reflection.system.NMinimize:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    org.apache.commons.math3.optim.linear.LinearObjectiveFunction getObjectiveFunction(org.matheclipse.core.convert.VariablesSet,org.matheclipse.core.interfaces.IExpr) -> getObjectiveFunction
    java.util.List getConstraints(org.matheclipse.core.convert.VariablesSet,org.matheclipse.core.interfaces.IExpr) -> getConstraints
    org.matheclipse.core.interfaces.IExpr simplexSolver$6b3c7cdb(org.matheclipse.core.convert.VariablesSet,org.apache.commons.math3.optim.linear.LinearObjectiveFunction,org.apache.commons.math3.analysis.DifferentiableUnivariateFunction[]) -> simplexSolver$6b3c7cdb
org.matheclipse.core.reflection.system.NRoots -> org.matheclipse.core.reflection.system.NRoots:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST roots(org.matheclipse.core.interfaces.IAST) -> roots
    org.matheclipse.core.interfaces.IAST rootsUp2Degree3(double[]) -> rootsUp2Degree3
    org.matheclipse.core.interfaces.IAST rootsOfVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> rootsOfVariable
    org.matheclipse.core.interfaces.IAST quadratic(double,double,double) -> a
org.matheclipse.core.reflection.system.NSolve -> org.matheclipse.core.reflection.system.NSolve:
    org.matheclipse.core.interfaces.IAST analyzeSublist(java.util.ArrayList,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.NSolve$ExprAnalyzer -> nJ:
    int equationType -> a
    org.matheclipse.core.interfaces.IExpr expr -> a
    org.matheclipse.core.interfaces.IExpr numer -> b
    org.matheclipse.core.interfaces.IExpr denom -> c
    int leafCount -> b
    org.matheclipse.core.interfaces.IAST row -> a
    java.util.HashSet symbolSet -> a
    org.matheclipse.core.interfaces.IAST value -> b
    org.matheclipse.core.interfaces.IAST vars -> c
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> <init>
    void analyze() -> a
    void getPlusEquationType(org.matheclipse.core.interfaces.IExpr) -> a
    void getTimesEquationType(org.matheclipse.core.interfaces.IExpr) -> b
    void reset() -> b
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.NSolve$NoSolution -> org.matheclipse.core.reflection.system.NSolve$NoSolution:
    int NO_SOLUTION_FOUND -> NO_SOLUTION_FOUND
    int WRONG_SOLUTION -> WRONG_SOLUTION
    int solType -> solType
    void <init>(int) -> <init>
    int getType() -> getType
org.matheclipse.core.reflection.system.Negative -> org.matheclipse.core.reflection.system.Negative:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.NextPrime -> org.matheclipse.core.reflection.system.NextPrime:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.NonCommutativeMultiply -> org.matheclipse.core.reflection.system.NonCommutativeMultiply:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.NonNegative -> org.matheclipse.core.reflection.system.NonNegative:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Norm -> org.matheclipse.core.reflection.system.Norm:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Normalize -> org.matheclipse.core.reflection.system.Normalize:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Not -> org.matheclipse.core.reflection.system.Not:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
org.matheclipse.core.reflection.system.NullSpace -> org.matheclipse.core.reflection.system.NullSpace:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.reflection.system.Numerator -> org.matheclipse.core.reflection.system.Numerator:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Order -> org.matheclipse.core.reflection.system.Order:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.OrderedQ -> org.matheclipse.core.reflection.system.OrderedQ:
    org.matheclipse.core.reflection.system.OrderedQ CONST -> CONST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean apply(org.matheclipse.core.interfaces.IAST) -> apply
    boolean apply(java.lang.Object) -> apply
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.Out -> org.matheclipse.core.reflection.system.Out:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1IntArg(org.matheclipse.core.interfaces.IInteger) -> e1IntArg
org.matheclipse.core.reflection.system.Outer -> org.matheclipse.core.reflection.system.Outer:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Outer$OuterAlgorithm -> nK:
    org.matheclipse.core.interfaces.IAST ast -> a
    org.matheclipse.core.interfaces.IExpr f -> a
    org.matheclipse.core.interfaces.IExpr head -> b
    void <init>(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> <init>
    org.matheclipse.core.interfaces.IAST outer(int,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> a
org.matheclipse.core.reflection.system.PadLeft -> org.matheclipse.core.reflection.system.PadLeft:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr padLeftAtom(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IExpr) -> padLeftAtom
    org.matheclipse.core.interfaces.IAST padLeftAST(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST) -> padLeftAST
org.matheclipse.core.reflection.system.PadRight -> org.matheclipse.core.reflection.system.PadRight:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr padRightAtom(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IExpr) -> padRightAtom
    org.matheclipse.core.interfaces.IAST padRightAST(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST) -> padRightAST
org.matheclipse.core.reflection.system.Part -> org.matheclipse.core.reflection.system.Part:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr getPart(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr getIndex(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Partition -> org.matheclipse.core.reflection.system.Partition:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Permutations -> org.matheclipse.core.reflection.system.Permutations:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Permutations$KPermutationsIterable -> org.matheclipse.core.reflection.system.Permutations$KPermutationsIterable:
    int n -> a
    int k -> b
    int[] fPermutationsIndex -> a
    int[] y -> b
    boolean first -> a
    int h -> c
    int i -> d
    int m -> e
    int[] fCopiedResultIndex -> c
    int[] fResultIndex -> d
    void <init>(int[],int) -> <init>
    void <init>(int[],int,int) -> <init>
    void <init>(java.util.List,int,int) -> <init>
    int[] nextBeforehand() -> a
    int[] next() -> next
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.Permutations$KPermutationsList -> org.matheclipse.core.reflection.system.Permutations$KPermutationsList:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    org.matheclipse.core.reflection.system.Permutations$KPermutationsIterable fIterable -> a
    void <init>(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,int) -> <init>
    org.matheclipse.core.interfaces.IAST next() -> next
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.Piecewise -> org.matheclipse.core.reflection.system.Piecewise:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Plus -> org.matheclipse.core.reflection.system.Plus:
    org.matheclipse.core.reflection.system.Plus CONST -> CONST
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> e2ComArg
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> e2DblArg
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> e2DblComArg
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> e2FraArg
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> eComIntArg
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> getHashRuleMap
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.Pochhammer -> org.matheclipse.core.reflection.system.Pochhammer:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
    org.apache.commons.math3.fraction.BigFraction pochhammer(org.apache.commons.math3.fraction.BigFraction,java.math.BigInteger) -> pochhammer
    org.apache.commons.math3.fraction.BigFraction pochhammer(org.apache.commons.math3.fraction.BigFraction,int) -> pochhammer
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.PolynomialExtendedGCD -> org.matheclipse.core.reflection.system.PolynomialExtendedGCD:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.PolynomialGCD -> org.matheclipse.core.reflection.system.PolynomialGCD:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr modulusGCD(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.convert.VariablesSet,org.matheclipse.core.interfaces.IExpr) -> a
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.PolynomialLCM -> org.matheclipse.core.reflection.system.PolynomialLCM:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.PolynomialQ -> org.matheclipse.core.reflection.system.PolynomialQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    edu.jas.poly.GenPolynomial polynomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,boolean) -> polynomial
    edu.jas.poly.GenPolynomial polynomial(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,boolean) -> polynomial
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object,java.lang.Object) -> apply
org.matheclipse.core.reflection.system.PolynomialQuotient -> org.matheclipse.core.reflection.system.PolynomialQuotient:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.PolynomialQuotientRemainder -> org.matheclipse.core.reflection.system.PolynomialQuotientRemainder:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr[] quotientRemainder(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> quotientRemainder
    org.matheclipse.core.interfaces.IExpr[] quotientRemainderModInteger(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr) -> quotientRemainderModInteger
org.matheclipse.core.reflection.system.PolynomialRemainder -> org.matheclipse.core.reflection.system.PolynomialRemainder:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Positive -> org.matheclipse.core.reflection.system.Positive:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.PossibleZeroQ -> org.matheclipse.core.reflection.system.PossibleZeroQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean possibleZeroQ(org.matheclipse.core.interfaces.IExpr) -> possibleZeroQ
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Power -> org.matheclipse.core.reflection.system.Power:
    org.matheclipse.core.reflection.system.Power CONST -> CONST
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2ApcomplexArg(org.matheclipse.core.expression.ApcomplexNum,org.matheclipse.core.expression.ApcomplexNum) -> e2ApcomplexArg
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> e2DblComArg
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> e2ComArg
    org.matheclipse.core.interfaces.IExpr e2ApfloatArg(org.matheclipse.core.expression.ApfloatNum,org.matheclipse.core.expression.ApfloatNum) -> e2ApfloatArg
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> e2DblArg
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
    org.matheclipse.core.interfaces.IExpr e2NumberDirectedInfinity(org.matheclipse.core.interfaces.INumber,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> e2FraArg
    org.matheclipse.core.interfaces.IInteger[] calculateRoot(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> eComIntArg
    org.matheclipse.core.interfaces.IExpr eComFraArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IFraction) -> eComFraArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    double evalReal(double[],int,int) -> evalReal
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.PowerExpand -> org.matheclipse.core.reflection.system.PowerExpand:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr powerExpand(org.matheclipse.core.interfaces.IAST,boolean) -> powerExpand
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.PowerExpand$PowerExpandVisitor -> nL:
    boolean assumptions -> a
    void <init>(boolean) -> <init>
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> visit2
    org.matheclipse.core.interfaces.IExpr visit3(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> visit3
org.matheclipse.core.reflection.system.PowerMod -> org.matheclipse.core.reflection.system.PowerMod:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.math.BigInteger powerMod(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger) -> powerMod
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.PreDecrement -> org.matheclipse.core.reflection.system.PreDecrement:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr getResult(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> getResult
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> getFunctionSymbol
org.matheclipse.core.reflection.system.PreIncrement -> org.matheclipse.core.reflection.system.PreIncrement:
    void <init>() -> <init>
    com.google.common.base.Function getFunction() -> getFunction
    org.matheclipse.core.interfaces.ISymbol getFunctionSymbol() -> getFunctionSymbol
org.matheclipse.core.reflection.system.PreIncrement$IncrementFunction -> nM:
    void <init>(org.matheclipse.core.reflection.system.PreIncrement) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Prime -> org.matheclipse.core.reflection.system.Prime:
    int popCount(int) -> popCount
    long nthPrime(long) -> nthPrime
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.PrimeQ -> org.matheclipse.core.reflection.system.PrimeQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.PrimitiveRoots -> org.matheclipse.core.reflection.system.PrimitiveRoots:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Product -> org.matheclipse.core.reflection.system.Product:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.ProductLog -> org.matheclipse.core.reflection.system.ProductLog:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1DblArg(org.matheclipse.core.interfaces.INum) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1DblComArg(org.matheclipse.core.interfaces.IComplexNum) -> e1DblComArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Quotient -> org.matheclipse.core.reflection.system.Quotient:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
org.matheclipse.core.reflection.system.RandomInteger -> org.matheclipse.core.reflection.system.RandomInteger:
    java.util.Random RANDOM -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.RandomReal -> org.matheclipse.core.reflection.system.RandomReal:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.RandomSample -> org.matheclipse.core.reflection.system.RandomSample:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST shuffle(org.matheclipse.core.interfaces.IAST) -> shuffle
org.matheclipse.core.reflection.system.Range -> org.matheclipse.core.reflection.system.Range:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateTable(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evaluateTable
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Rationalize -> org.matheclipse.core.reflection.system.Rationalize:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Re -> org.matheclipse.core.reflection.system.Re:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr rePowerComplex(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ReplaceAll -> org.matheclipse.core.reflection.system.ReplaceAll:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ReplacePart -> org.matheclipse.core.reflection.system.ReplacePart:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ReplaceRepeated -> org.matheclipse.core.reflection.system.ReplaceRepeated:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Resultant -> org.matheclipse.core.reflection.system.Resultant:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr resultant(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> resultant
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Reverse -> org.matheclipse.core.reflection.system.Reverse:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.RootIntervals -> org.matheclipse.core.reflection.system.RootIntervals:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST croots(org.matheclipse.core.interfaces.IExpr,boolean) -> croots
org.matheclipse.core.reflection.system.Roots -> org.matheclipse.core.reflection.system.Roots:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST roots(org.matheclipse.core.interfaces.IAST,boolean) -> roots
    org.matheclipse.core.interfaces.IAST findRoots(double[]) -> findRoots
    org.matheclipse.core.interfaces.IAST rootsOfVariable(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST,boolean) -> rootsOfVariable
    org.matheclipse.core.interfaces.IAST rootsOfExprPolynomial(org.matheclipse.core.interfaces.IExpr,java.util.List) -> rootsOfExprPolynomial
org.matheclipse.core.reflection.system.Round -> org.matheclipse.core.reflection.system.Round:
    void <init>() -> <init>
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Round$RoundPlusFunction -> nN:
    void <init>(org.matheclipse.core.reflection.system.Round) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
    void <init>(org.matheclipse.core.reflection.system.Round,byte) -> <init>
org.matheclipse.core.reflection.system.RowReduce -> org.matheclipse.core.reflection.system.RowReduce:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    org.matheclipse.core.interfaces.IAST rowReduced2List(org.matheclipse.commons.math.linear.FieldMatrix) -> rowReduced2List
    org.matheclipse.core.interfaces.IAST rowReduced2RulesList(org.matheclipse.commons.math.linear.FieldMatrix,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> rowReduced2RulesList
org.matheclipse.core.reflection.system.SameQ -> org.matheclipse.core.reflection.system.SameQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Scan -> org.matheclipse.core.reflection.system.Scan:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Sec -> org.matheclipse.core.reflection.system.Sec:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Sech -> org.matheclipse.core.reflection.system.Sech:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Select -> org.matheclipse.core.reflection.system.Select:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Sign -> org.matheclipse.core.reflection.system.Sign:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numberSign(org.matheclipse.core.interfaces.INumber) -> numberSign
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.SignCmp -> org.matheclipse.core.reflection.system.SignCmp:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Simplify -> org.matheclipse.core.reflection.system.Simplify:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Simplify$IsBasicExpressionVisitor -> org.matheclipse.core.reflection.system.Simplify$IsBasicExpressionVisitor:
    void <init>() -> <init>
    boolean visit(org.matheclipse.core.interfaces.IAST) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> visit
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> visit
    boolean visit(org.matheclipse.core.interfaces.INum) -> visit
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> visit
org.matheclipse.core.reflection.system.Simplify$SimplifyVisitor -> nO:
    org.matheclipse.core.reflection.system.Simplify$IsBasicExpressionVisitor isBasicAST -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr tryExpandAllTransformation(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr tryTransformations(org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> visit
    org.matheclipse.core.interfaces.IExpr tryExpandAll(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,int) -> a
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.reflection.system.Sin -> org.matheclipse.core.reflection.system.Sin:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.SinIntegral -> org.matheclipse.core.reflection.system.SinIntegral:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Sinc -> org.matheclipse.core.reflection.system.Sinc:
    void <init>() -> <init>
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.SingularValueDecomposition -> org.matheclipse.core.reflection.system.SingularValueDecomposition:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
org.matheclipse.core.reflection.system.Sinh -> org.matheclipse.core.reflection.system.Sinh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Solve -> org.matheclipse.core.reflection.system.Solve:
    org.matheclipse.core.interfaces.IAST analyzeSublist(java.util.ArrayList,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Solve$ExprAnalyzer -> nP:
    int fEquationType -> a
    org.matheclipse.core.interfaces.IExpr fExpr -> a
    org.matheclipse.core.interfaces.IExpr fNumer -> b
    org.matheclipse.core.interfaces.IExpr fDenom -> c
    long fLeafCount -> a
    java.util.HashSet fSymbolSet -> a
    org.matheclipse.core.interfaces.IAST fMatrixRow -> a
    org.matheclipse.core.interfaces.IAST fPlusAST -> b
    org.matheclipse.core.interfaces.IAST vars -> c
    void <init>(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> <init>
    void simplifyAndAnalyze() -> a
    org.matheclipse.core.interfaces.IExpr rewriteInverseFunction(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    void getPlusArgumentEquationType(org.matheclipse.core.interfaces.IExpr) -> a
    void getTimesArgumentEquationType(org.matheclipse.core.interfaces.IExpr) -> b
    void reset() -> b
    int compareTo(java.lang.Object) -> compareTo
org.matheclipse.core.reflection.system.Solve$IsWrongSolveExpression -> nQ:
    org.matheclipse.core.interfaces.IExpr wrongExpr -> a
    void <init>(org.matheclipse.core.reflection.system.Solve) -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Solve$NoSolution -> org.matheclipse.core.reflection.system.Solve$NoSolution:
    int NO_SOLUTION_FOUND -> NO_SOLUTION_FOUND
    int WRONG_SOLUTION -> WRONG_SOLUTION
    int solType -> solType
    void <init>(int) -> <init>
    int getType() -> getType
org.matheclipse.core.reflection.system.Sort -> org.matheclipse.core.reflection.system.Sort:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Sqrt -> org.matheclipse.core.reflection.system.Sqrt:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e1ObjArg(org.matheclipse.core.interfaces.IExpr) -> e1ObjArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.SquareFreeQ -> org.matheclipse.core.reflection.system.SquareFreeQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    boolean isSquarefree(org.matheclipse.core.interfaces.IExpr,java.util.List) -> isSquarefree
    boolean isSquarefreeWithOption(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,java.util.List) -> isSquarefreeWithOption
org.matheclipse.core.reflection.system.SquaredEuclidianDistance -> org.matheclipse.core.reflection.system.SquaredEuclidianDistance:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.StirlingS2 -> org.matheclipse.core.reflection.system.StirlingS2:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.StringDrop -> org.matheclipse.core.reflection.system.StringDrop:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.StringJoin -> org.matheclipse.core.reflection.system.StringJoin:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.StringLength -> org.matheclipse.core.reflection.system.StringLength:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.StringTake -> org.matheclipse.core.reflection.system.StringTake:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Subfactorial -> org.matheclipse.core.reflection.system.Subfactorial:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Subsets -> org.matheclipse.core.reflection.system.Subsets:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.reflection.system.Subsets$KSubsetsList createKSubsets(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,int) -> createKSubsets
org.matheclipse.core.reflection.system.Subsets$KSubsetsIterable -> org.matheclipse.core.reflection.system.Subsets$KSubsetsIterable:
    int n -> a
    int k -> b
    int[] x -> a
    long bin -> a
    boolean first -> a
    void <init>(int,int) -> <init>
    int[] next() -> next
    long binomial(long,long) -> binomial
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.Subsets$KSubsetsList -> org.matheclipse.core.reflection.system.Subsets$KSubsetsList:
    org.matheclipse.core.interfaces.IAST fList -> a
    org.matheclipse.core.interfaces.IAST fResultList -> b
    int fOffset -> a
    java.util.Iterator fIterable -> a
    int fK -> b
    void <init>(java.util.Iterator,org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST) -> <init>
    void <init>(java.util.Iterator,org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,int) -> <init>
    org.matheclipse.core.interfaces.IAST next() -> next
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.util.Iterator iterator() -> iterator
    java.lang.Object next() -> next
org.matheclipse.core.reflection.system.SubtractFrom -> org.matheclipse.core.reflection.system.SubtractFrom:
    void <init>() -> <init>
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> getFunction
org.matheclipse.core.reflection.system.SubtractFrom$SubtractFromFunction -> nR:
    org.matheclipse.core.interfaces.IExpr value -> a
    void <init>(org.matheclipse.core.reflection.system.SubtractFrom,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Sum -> org.matheclipse.core.reflection.system.Sum:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr definiteSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.util.Iterator,org.matheclipse.core.interfaces.IAST) -> definiteSum
    org.matheclipse.core.interfaces.IExpr indefiniteSum(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.ISymbol) -> indefiniteSum
    org.matheclipse.core.interfaces.IExpr sumPower(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.ISymbol,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> sumPower
    org.matheclipse.core.interfaces.IExpr sumPowerFormula(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IInteger) -> sumPowerFormula
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Sum$1 -> nS:
    org.matheclipse.core.interfaces.ISymbol val$var -> a
    void <init>(org.matheclipse.core.reflection.system.Sum,org.matheclipse.core.interfaces.ISymbol) -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Sum$2 -> nT:
    org.matheclipse.core.interfaces.ISymbol val$var -> a
    void <init>(org.matheclipse.core.reflection.system.Sum,org.matheclipse.core.interfaces.ISymbol) -> <init>
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Surd -> org.matheclipse.core.reflection.system.Surd:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2ApfloatArg(org.matheclipse.core.expression.ApfloatNum,org.matheclipse.core.expression.ApfloatNum) -> e2ApfloatArg
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> e2DblArg
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    double evalReal(double[],int,int) -> evalReal
org.matheclipse.core.reflection.system.SyntaxLength -> org.matheclipse.core.reflection.system.SyntaxLength:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.SyntaxQ -> org.matheclipse.core.reflection.system.SyntaxQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(java.lang.String) -> apply
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Table -> org.matheclipse.core.reflection.system.Table:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluateTable(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> evaluateTable
    org.matheclipse.core.interfaces.IExpr evaluateLast(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.eval.util.Iterator,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> evaluateLast
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.interfaces.IAST determineIteratorVariables(org.matheclipse.core.interfaces.IAST) -> determineIteratorVariables
    org.matheclipse.core.convert.VariablesSet determineIteratorExprVariables(org.matheclipse.core.interfaces.IAST) -> determineIteratorExprVariables
    org.matheclipse.core.interfaces.IExpr evalBlockWithoutReap(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IAST) -> evalBlockWithoutReap
org.matheclipse.core.reflection.system.Take -> org.matheclipse.core.reflection.system.Take:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST take(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.eval.util.ISequence[]) -> take
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Tan -> org.matheclipse.core.reflection.system.Tan:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Tanh -> org.matheclipse.core.reflection.system.Tanh:
    org.matheclipse.core.interfaces.IAST getRuleAST() -> getRuleAST
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluateArg1(org.matheclipse.core.interfaces.IExpr) -> evaluateArg1
    org.matheclipse.core.interfaces.IExpr e1DblArg(double) -> e1DblArg
    org.matheclipse.core.interfaces.IExpr e1ComplexArg(org.apache.commons.math3.complex.Complex) -> e1ComplexArg
    org.matheclipse.core.interfaces.IExpr e1ApfloatArg(org.apfloat.Apfloat) -> e1ApfloatArg
    org.matheclipse.core.interfaces.IExpr e1ApcomplexArg(org.apfloat.Apcomplex) -> e1ApcomplexArg
    double evalReal(double[],int,int) -> evalReal
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Taylor -> org.matheclipse.core.reflection.system.Taylor:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Thread -> org.matheclipse.core.reflection.system.Thread:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IAST threadList(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> threadList
org.matheclipse.core.reflection.system.Through -> org.matheclipse.core.reflection.system.Through:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Times -> org.matheclipse.core.reflection.system.Times:
    org.matheclipse.core.reflection.system.Times CONST -> CONST
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher getHashRuleMap() -> getHashRuleMap
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr e2ComArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IComplex) -> e2ComArg
    org.matheclipse.core.interfaces.IExpr e2DblArg(org.matheclipse.core.interfaces.INum,org.matheclipse.core.interfaces.INum) -> e2DblArg
    org.matheclipse.core.interfaces.IExpr e2DblComArg(org.matheclipse.core.interfaces.IComplexNum,org.matheclipse.core.interfaces.IComplexNum) -> e2DblComArg
    org.matheclipse.core.interfaces.IExpr e2FraArg(org.matheclipse.core.interfaces.IFraction,org.matheclipse.core.interfaces.IFraction) -> e2FraArg
    org.matheclipse.core.interfaces.IExpr e2IntArg(org.matheclipse.core.interfaces.IInteger,org.matheclipse.core.interfaces.IInteger) -> e2IntArg
    org.matheclipse.core.interfaces.IExpr e2ObjArg(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> e2ObjArg
    org.matheclipse.core.interfaces.IExpr eInfinity(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IExpr) -> a
    org.matheclipse.core.interfaces.IExpr eComIntArg(org.matheclipse.core.interfaces.IComplex,org.matheclipse.core.interfaces.IInteger) -> eComIntArg
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    double evalReal(double[],int,int) -> evalReal
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.TimesBy -> org.matheclipse.core.reflection.system.TimesBy:
    void <init>() -> <init>
    com.google.common.base.Function getFunction(org.matheclipse.core.interfaces.IExpr) -> getFunction
org.matheclipse.core.reflection.system.TimesBy$TimesByFunction -> nU:
    org.matheclipse.core.interfaces.IExpr value -> a
    void <init>(org.matheclipse.core.reflection.system.TimesBy,org.matheclipse.core.interfaces.IExpr) -> <init>
    java.lang.Object apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.Timing -> org.matheclipse.core.reflection.system.Timing:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.ToCharacterCode -> org.matheclipse.core.reflection.system.ToCharacterCode:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    java.util.List toCharacterCode(java.lang.String,java.lang.String,java.util.List) -> toCharacterCode
org.matheclipse.core.reflection.system.ToString -> org.matheclipse.core.reflection.system.ToString:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    java.lang.String outputForm(org.matheclipse.core.interfaces.IExpr) -> outputForm
org.matheclipse.core.reflection.system.ToUnicode -> org.matheclipse.core.reflection.system.ToUnicode:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    java.lang.String toUnicodeString(java.lang.String,java.lang.String) -> toUnicodeString
org.matheclipse.core.reflection.system.Together -> org.matheclipse.core.reflection.system.Together:
    org.matheclipse.core.interfaces.IExpr together(org.matheclipse.core.interfaces.IAST) -> together
    org.matheclipse.core.interfaces.IAST togetherForEach(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr togetherNull(org.matheclipse.core.interfaces.IAST) -> a
    org.matheclipse.core.interfaces.IExpr togetherPlus(org.matheclipse.core.interfaces.IAST) -> b
    org.matheclipse.core.interfaces.IExpr togetherPlusTimesPower(org.matheclipse.core.interfaces.IAST) -> c
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Total -> org.matheclipse.core.reflection.system.Total:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Tr -> org.matheclipse.core.reflection.system.Tr:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Transpose -> org.matheclipse.core.reflection.system.Transpose:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr transform(org.matheclipse.core.interfaces.IExpr) -> transform
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.TrigExpand -> org.matheclipse.core.reflection.system.TrigExpand:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr expandSinPlus(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr expandCosPlus(org.matheclipse.core.interfaces.IAST,int) -> b
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.TrigReduce -> org.matheclipse.core.reflection.system.TrigReduce:
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher ORDERLESS_MATCHER -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    org.matheclipse.core.patternmatching.HashedOrderlessMatcher access$000() -> a
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.TrigReduce$TrigReduceVisitor -> nV:
    void <init>(org.matheclipse.core.reflection.system.TrigReduce) -> <init>
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.reflection.system.TrigToExp -> org.matheclipse.core.reflection.system.TrigToExp:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.TrigToExp$TrigToExpVisitor -> nW:
    void <init>(org.matheclipse.core.reflection.system.TrigToExp) -> <init>
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> visit2
org.matheclipse.core.reflection.system.TrueQ -> org.matheclipse.core.reflection.system.TrueQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Tuples -> org.matheclipse.core.reflection.system.Tuples:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void tuples(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> a
    void tuplesOfLists(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> b
org.matheclipse.core.reflection.system.Unequal -> org.matheclipse.core.reflection.system.Unequal:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.Union -> org.matheclipse.core.reflection.system.Union:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.UnitStep -> org.matheclipse.core.reflection.system.UnitStep:
    void <init>() -> <init>
    double evalReal(double[],int,int) -> evalReal
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr numericEval(org.matheclipse.core.interfaces.IAST) -> numericEval
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.UnitVector -> org.matheclipse.core.reflection.system.UnitVector:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.UnsameQ -> org.matheclipse.core.reflection.system.UnsameQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.UpperCaseQ -> org.matheclipse.core.reflection.system.UpperCaseQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
    boolean apply(org.matheclipse.core.interfaces.IExpr) -> apply
    boolean apply(java.lang.Object) -> apply
org.matheclipse.core.reflection.system.VandermondeMatrix -> org.matheclipse.core.reflection.system.VandermondeMatrix:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.VandermondeMatrix$1 -> nX:
    org.matheclipse.core.interfaces.IAST val$lst -> a
    void <init>(org.matheclipse.core.reflection.system.VandermondeMatrix,org.matheclipse.core.interfaces.IAST) -> <init>
    java.lang.Object evaluate(int[]) -> evaluate
org.matheclipse.core.reflection.system.Variables -> org.matheclipse.core.reflection.system.Variables:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.VectorAngle -> org.matheclipse.core.reflection.system.VectorAngle:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.reflection.system.VectorQ -> org.matheclipse.core.reflection.system.VectorQ:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.Xor -> org.matheclipse.core.reflection.system.Xor:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    void setUp(org.matheclipse.core.interfaces.ISymbol) -> setUp
org.matheclipse.core.reflection.system.rules.AbsRules -> org.matheclipse.core.reflection.system.rules.AbsRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcCosRules -> org.matheclipse.core.reflection.system.rules.ArcCosRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcCoshRules -> org.matheclipse.core.reflection.system.rules.ArcCoshRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcCotRules -> org.matheclipse.core.reflection.system.rules.ArcCotRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcCothRules -> org.matheclipse.core.reflection.system.rules.ArcCothRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcCscRules -> org.matheclipse.core.reflection.system.rules.ArcCscRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcCschRules -> org.matheclipse.core.reflection.system.rules.ArcCschRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcSecRules -> org.matheclipse.core.reflection.system.rules.ArcSecRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcSechRules -> org.matheclipse.core.reflection.system.rules.ArcSechRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcSinRules -> org.matheclipse.core.reflection.system.rules.ArcSinRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcSinhRules -> org.matheclipse.core.reflection.system.rules.ArcSinhRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcTanRules -> org.matheclipse.core.reflection.system.rules.ArcTanRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ArcTanhRules -> org.matheclipse.core.reflection.system.rules.ArcTanhRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.CosRules -> org.matheclipse.core.reflection.system.rules.CosRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.CoshRules -> org.matheclipse.core.reflection.system.rules.CoshRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.CotRules -> org.matheclipse.core.reflection.system.rules.CotRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.CothRules -> org.matheclipse.core.reflection.system.rules.CothRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.CscRules -> org.matheclipse.core.reflection.system.rules.CscRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.CschRules -> org.matheclipse.core.reflection.system.rules.CschRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.DerivativeRules -> org.matheclipse.core.reflection.system.rules.DerivativeRules:
    org.matheclipse.core.interfaces.IAST RULES1 -> RULES1
    org.matheclipse.core.interfaces.IAST RULES2 -> RULES2
    org.matheclipse.core.interfaces.IAST RULES3 -> RULES3
    org.matheclipse.core.interfaces.IAST RULES4 -> RULES4
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.LimitRules -> org.matheclipse.core.reflection.system.rules.LimitRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.LogRules -> org.matheclipse.core.reflection.system.rules.LogRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.PowerRules -> org.matheclipse.core.reflection.system.rules.PowerRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ProductLogRules -> org.matheclipse.core.reflection.system.rules.ProductLogRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.ProductRules -> org.matheclipse.core.reflection.system.rules.ProductRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.SecRules -> org.matheclipse.core.reflection.system.rules.SecRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.SechRules -> org.matheclipse.core.reflection.system.rules.SechRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.SinRules -> org.matheclipse.core.reflection.system.rules.SinRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.SincRules -> org.matheclipse.core.reflection.system.rules.SincRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.SinhRules -> org.matheclipse.core.reflection.system.rules.SinhRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.SumRules -> org.matheclipse.core.reflection.system.rules.SumRules:
    org.matheclipse.core.interfaces.IAST RULES1 -> RULES1
    org.matheclipse.core.interfaces.IAST RULES2 -> RULES2
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.TanRules -> org.matheclipse.core.reflection.system.rules.TanRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.reflection.system.rules.TanhRules -> org.matheclipse.core.reflection.system.rules.TanhRules:
    org.matheclipse.core.interfaces.IAST RULES -> RULES
    void <clinit>() -> <clinit>
org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic -> org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> evaluate
    long getN() -> getN
    void clear() -> clear
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
    void increment(org.matheclipse.core.interfaces.IExpr) -> increment
    void incrementAll(org.matheclipse.core.interfaces.IAST) -> incrementAll
    void incrementAll(org.matheclipse.core.interfaces.IAST,int,int) -> incrementAll
    boolean test(org.matheclipse.core.interfaces.IAST,int,int) -> test
    boolean test(org.matheclipse.core.interfaces.IAST,int,int,boolean) -> test
    boolean test(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,int) -> test
    boolean test(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,int,boolean) -> test
org.matheclipse.core.stat.descriptive.StorelessSymbolicUnivariateStatistic -> org.matheclipse.core.stat.descriptive.StorelessSymbolicUnivariateStatistic:
    void increment(org.matheclipse.core.interfaces.IExpr) -> increment
    void incrementAll(org.matheclipse.core.interfaces.IAST) -> incrementAll
    void incrementAll(org.matheclipse.core.interfaces.IAST,int,int) -> incrementAll
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
org.matheclipse.core.stat.descriptive.SymbolicGeometricMean -> org.matheclipse.core.stat.descriptive.SymbolicGeometricMean:
    long serialVersionUID -> serialVersionUID
    org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic product -> product
    void <init>() -> <init>
    void <init>(org.matheclipse.core.stat.descriptive.summary.SymbolicSumOfLogs) -> <init>
    void increment(org.matheclipse.core.interfaces.IExpr) -> increment
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
    void clear() -> clear
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> evaluate
    long getN() -> getN
    void setSumLogImpl(org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic) -> setSumLogImpl
    org.matheclipse.core.stat.descriptive.AbstractSymbolicStorelessUnivariateStatistic getSumLogImpl() -> getSumLogImpl
org.matheclipse.core.stat.descriptive.SymbolicStatUtils -> org.matheclipse.core.stat.descriptive.SymbolicStatUtils:
    org.matheclipse.core.stat.descriptive.SymbolicGeometricMean GEOMETRIC_MEAN -> a
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr geometricMean(org.matheclipse.core.interfaces.IAST) -> geometricMean
    void <clinit>() -> <clinit>
org.matheclipse.core.stat.descriptive.SymbolicUnivariateStatistic -> org.matheclipse.core.stat.descriptive.SymbolicUnivariateStatistic:
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> evaluate
org.matheclipse.core.stat.descriptive.summary.SymbolicProduct -> org.matheclipse.core.stat.descriptive.summary.SymbolicProduct:
    long serialVersionUID -> serialVersionUID
    long n -> n
    org.matheclipse.core.interfaces.IExpr value -> value
    void <init>() -> <init>
    void increment(org.matheclipse.core.interfaces.IExpr) -> increment
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,int) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.stat.descriptive.summary.SymbolicSum -> org.matheclipse.core.stat.descriptive.summary.SymbolicSum:
    long serialVersionUID -> serialVersionUID
    long n -> n
    org.matheclipse.core.interfaces.IExpr value -> value
    void <init>() -> <init>
    void increment(org.matheclipse.core.interfaces.IExpr) -> increment
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST,int,int) -> evaluate
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,org.matheclipse.core.interfaces.IAST) -> evaluate
org.matheclipse.core.stat.descriptive.summary.SymbolicSumOfLogs -> org.matheclipse.core.stat.descriptive.summary.SymbolicSumOfLogs:
    long serialVersionUID -> serialVersionUID
    int n -> n
    org.matheclipse.core.interfaces.IExpr value -> value
    void <init>() -> <init>
    void increment(org.matheclipse.core.interfaces.IExpr) -> increment
    org.matheclipse.core.interfaces.IExpr getResult() -> getResult
    long getN() -> getN
    void clear() -> clear
    org.matheclipse.core.interfaces.IExpr evaluate(org.matheclipse.core.interfaces.IAST,int,int) -> evaluate
org.matheclipse.core.visit.AbstractVisitor -> org.matheclipse.core.visit.AbstractVisitor:
    void <init>() -> <init>
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> visit
org.matheclipse.core.visit.AbstractVisitorBoolean -> org.matheclipse.core.visit.AbstractVisitorBoolean:
    void <init>() -> <init>
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> visit
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> visit
    boolean visit(org.matheclipse.core.interfaces.INum) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    boolean visit(org.matheclipse.core.interfaces.IPattern) -> visit
    boolean visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    boolean visit(org.matheclipse.core.interfaces.IStringX) -> visit
org.matheclipse.core.visit.AbstractVisitorInt -> org.matheclipse.core.visit.AbstractVisitorInt:
    void <init>() -> <init>
    int visit(org.matheclipse.core.interfaces.IInteger) -> visit
    int visit(org.matheclipse.core.interfaces.IFraction) -> visit
    int visit(org.matheclipse.core.interfaces.IComplex) -> visit
    int visit(org.matheclipse.core.interfaces.INum) -> visit
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    int visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    int visit(org.matheclipse.core.interfaces.IPattern) -> visit
    int visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    int visit(org.matheclipse.core.interfaces.IStringX) -> visit
org.matheclipse.core.visit.AbstractVisitorLong -> org.matheclipse.core.visit.AbstractVisitorLong:
    void <init>() -> <init>
    long visit(org.matheclipse.core.interfaces.IInteger) -> visit
    long visit(org.matheclipse.core.interfaces.IFraction) -> visit
    long visit(org.matheclipse.core.interfaces.IComplex) -> visit
    long visit(org.matheclipse.core.interfaces.INum) -> visit
    long visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    long visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    long visit(org.matheclipse.core.interfaces.IPattern) -> visit
    long visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    long visit(org.matheclipse.core.interfaces.IStringX) -> visit
org.matheclipse.core.visit.HashValueVisitor -> org.matheclipse.core.visit.HashValueVisitor:
    void <init>() -> <init>
    void setUp() -> setUp
    int visit(org.matheclipse.core.interfaces.IAST) -> visit
    int visit(org.matheclipse.core.interfaces.IComplex) -> visit
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    int visit(org.matheclipse.core.interfaces.IFraction) -> visit
    int visit(org.matheclipse.core.interfaces.IInteger) -> visit
    int visit(org.matheclipse.core.interfaces.INum) -> visit
    int visit(org.matheclipse.core.interfaces.IPattern) -> visit
    int visit(org.matheclipse.core.interfaces.IStringX) -> visit
    int visit(org.matheclipse.core.interfaces.ISymbol) -> visit
org.matheclipse.core.visit.IVisitor -> org.matheclipse.core.visit.IVisitor:
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.IVisitorBoolean -> org.matheclipse.core.visit.IVisitorBoolean:
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> visit
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> visit
    boolean visit(org.matheclipse.core.interfaces.INum) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    boolean visit(org.matheclipse.core.interfaces.IPattern) -> visit
    boolean visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    boolean visit(org.matheclipse.core.interfaces.IStringX) -> visit
    boolean visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.IVisitorInt -> org.matheclipse.core.visit.IVisitorInt:
    int visit(org.matheclipse.core.interfaces.IInteger) -> visit
    int visit(org.matheclipse.core.interfaces.IFraction) -> visit
    int visit(org.matheclipse.core.interfaces.IComplex) -> visit
    int visit(org.matheclipse.core.interfaces.INum) -> visit
    int visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    int visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    int visit(org.matheclipse.core.interfaces.IPattern) -> visit
    int visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    int visit(org.matheclipse.core.interfaces.IStringX) -> visit
    int visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.IVisitorLong -> org.matheclipse.core.visit.IVisitorLong:
    long visit(org.matheclipse.core.interfaces.IInteger) -> visit
    long visit(org.matheclipse.core.interfaces.IFraction) -> visit
    long visit(org.matheclipse.core.interfaces.IComplex) -> visit
    long visit(org.matheclipse.core.interfaces.INum) -> visit
    long visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    long visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    long visit(org.matheclipse.core.interfaces.IPattern) -> visit
    long visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    long visit(org.matheclipse.core.interfaces.IStringX) -> visit
    long visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorCollectionBoolean -> org.matheclipse.core.visit.VisitorCollectionBoolean:
    int fHeadOffset -> fHeadOffset
    java.util.Collection fCollection -> fCollection
    void <init>(java.util.Collection) -> <init>
    void <init>(int,java.util.Collection) -> <init>
    boolean visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorExpr -> org.matheclipse.core.visit.VisitorExpr:
    void <init>() -> <init>
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IInteger) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IFraction) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplex) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.INum) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPattern) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IStringX) -> visit
    org.matheclipse.core.interfaces.IExpr visit1(org.matheclipse.core.interfaces.IExpr) -> visit1
    org.matheclipse.core.interfaces.IExpr visit2(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> visit2
    org.matheclipse.core.interfaces.IExpr visit3(org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr,org.matheclipse.core.interfaces.IExpr) -> visit3
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> visit
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> visitAST
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorFunction -> org.matheclipse.core.visit.VisitorFunction:
    int fHeadOffset -> a
    com.google.common.base.Function fFunction -> a
    void <init>(com.google.common.base.Function) -> <init>
    void <init>(int,com.google.common.base.Function) -> <init>
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorLevelSpecification -> org.matheclipse.core.visit.VisitorLevelSpecification:
    com.google.common.base.Function fFunction -> fFunction
    int fFromLevel -> fFromLevel
    int fToLevel -> fToLevel
    int fFromDepth -> fFromDepth
    int fToDepth -> fToDepth
    boolean fIncludeHeads -> fIncludeHeads
    int fCurrentLevel -> fCurrentLevel
    int fCurrentDepth -> fCurrentDepth
    void <init>(com.google.common.base.Function,org.matheclipse.core.interfaces.IExpr,boolean) -> <init>
    void <init>(com.google.common.base.Function,int) -> <init>
    void <init>(com.google.common.base.Function,int,boolean) -> <init>
    void <init>(com.google.common.base.Function,int,int) -> <init>
    void <init>(com.google.common.base.Function,int,int,boolean) -> <init>
    void <init>(com.google.common.base.Function,int,int,int,int,boolean) -> <init>
    void incCurrentLevel() -> incCurrentLevel
    void decCurrentLevel() -> decCurrentLevel
    boolean isInRange(int,int) -> isInRange
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IInteger) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IFraction) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplex) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.INum) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPattern) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IStringX) -> visit
    org.matheclipse.core.interfaces.IExpr visitExpr(org.matheclipse.core.interfaces.IExpr) -> visitExpr
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorPredicate -> org.matheclipse.core.visit.VisitorPredicate:
    int fHeadOffset -> a
    com.google.common.base.Predicate fMatcher -> a
    void <init>(com.google.common.base.Predicate) -> <init>
    void <init>(int,com.google.common.base.Predicate) -> <init>
    boolean visit(org.matheclipse.core.interfaces.IInteger) -> visit
    boolean visit(org.matheclipse.core.interfaces.IFraction) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplex) -> visit
    boolean visit(org.matheclipse.core.interfaces.INum) -> visit
    boolean visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    boolean visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    boolean visit(org.matheclipse.core.interfaces.IPattern) -> visit
    boolean visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    boolean visit(org.matheclipse.core.interfaces.IStringX) -> visit
    boolean visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorRemoveLevelSpecification -> org.matheclipse.core.visit.VisitorRemoveLevelSpecification:
    int maximumRemoved -> a
    int removedCounter -> b
    void <init>(com.google.common.base.Function,org.matheclipse.core.interfaces.IExpr,int,boolean) -> <init>
    void <init>(com.google.common.base.Function,int) -> <init>
    void <init>(com.google.common.base.Function,int,boolean) -> <init>
    void <init>(com.google.common.base.Function,int,int) -> <init>
    void <init>(com.google.common.base.Function,int,int,boolean) -> <init>
    void <init>(com.google.common.base.Function,int,int,int,int,int,boolean) -> <init>
    int getRemovedCounter() -> getRemovedCounter
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IInteger) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IFraction) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplex) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.INum) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPattern) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IStringX) -> visit
    org.matheclipse.core.interfaces.IExpr visitExpr(org.matheclipse.core.interfaces.IExpr) -> visitExpr
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPatternSequence) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorRemoveLevelSpecification$StopException -> org.matheclipse.core.visit.VisitorRemoveLevelSpecification$StopException:
    void <init>() -> <init>
org.matheclipse.core.visit.VisitorReplaceAll -> org.matheclipse.core.visit.VisitorReplaceAll:
    com.google.common.base.Function fFunction -> a
    int fOffset -> a
    void <init>(com.google.common.base.Function) -> <init>
    void <init>(com.google.common.base.Function,int) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    void <init>(org.matheclipse.core.interfaces.IAST,int) -> <init>
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IInteger) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IFraction) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplex) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.INum) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IPattern) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IStringX) -> visit
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> visit
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> visitAST
    java.lang.Object visit(org.matheclipse.core.interfaces.IStringX) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IPattern) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.ISymbol) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplexNum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.INum) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IComplex) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IFraction) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IInteger) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorReplacePart -> org.matheclipse.core.visit.VisitorReplacePart:
    org.matheclipse.core.interfaces.IExpr fReplaceExpr -> a
    int[] fPositions -> a
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.interfaces.IExpr visitIndex(org.matheclipse.core.interfaces.IAST,int) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> visit
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.core.visit.VisitorReplaceSlots -> org.matheclipse.core.visit.VisitorReplaceSlots:
    org.matheclipse.core.interfaces.IAST astSlots -> a
    void <init>(org.matheclipse.core.interfaces.IAST) -> <init>
    org.matheclipse.core.interfaces.IExpr getSlot(org.matheclipse.core.interfaces.IInteger) -> a
    int getSlotSequence(org.matheclipse.core.interfaces.IAST,int,org.matheclipse.core.interfaces.IInteger) -> a
    org.matheclipse.core.interfaces.IExpr visit(org.matheclipse.core.interfaces.IAST) -> visit
    org.matheclipse.core.interfaces.IExpr visitAST(org.matheclipse.core.interfaces.IAST) -> visitAST
    java.lang.Object visit(org.matheclipse.core.interfaces.IAST) -> visit
org.matheclipse.parser.client.Parser -> org.matheclipse.parser.client.Parser:
    boolean fRelaxedSyntax -> a
    boolean fPackageMode -> b
    java.util.List fNodeList -> a
    org.matheclipse.parser.client.ast.SymbolNode DERIVATIVE -> DERIVATIVE
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    void <init>(boolean,boolean) -> <init>
    void <init>(org.matheclipse.parser.client.ast.IParserFactory,boolean) -> <init>
    void <init>(org.matheclipse.parser.client.ast.IParserFactory,boolean,boolean) -> <init>
    void setFactory(org.matheclipse.parser.client.ast.IParserFactory) -> setFactory
    org.matheclipse.parser.client.ast.IParserFactory getFactory() -> getFactory
    void getArguments(org.matheclipse.parser.client.ast.FunctionNode) -> a
    org.matheclipse.parser.client.operator.PostfixOperator determinePostfixOperator() -> a
    org.matheclipse.parser.client.operator.InfixOperator determineBinaryOperator() -> a
    org.matheclipse.parser.client.ast.ASTNode parseArguments(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.ASTNode parsePrimary() -> a
    org.matheclipse.parser.client.ast.ASTNode parseLookaheadOperator(int) -> a
    org.matheclipse.parser.client.ast.ASTNode parseOperators(org.matheclipse.parser.client.ast.ASTNode,int) -> a
    org.matheclipse.parser.client.ast.ASTNode parse(java.lang.String) -> parse
    java.util.List parseList(java.lang.String) -> parseList
    org.matheclipse.parser.client.ast.ASTNode getNumber(boolean) -> a
    int getIntegerNumber() -> a
    org.matheclipse.parser.client.ast.SymbolNode getSymbol() -> a
    org.matheclipse.parser.client.ast.FunctionNode getFunctionArguments(org.matheclipse.parser.client.ast.ASTNode) -> a
    org.matheclipse.parser.client.ast.ASTNode getPart() -> b
    void <clinit>() -> <clinit>
org.matheclipse.parser.client.Scanner -> org.matheclipse.parser.client.Scanner:
    java.lang.String fInputString -> fInputString
    char fLastChar -> fLastChar
    char fCurrentChar -> fCurrentChar
    int fCurrentPosition -> fCurrentPosition
    int fToken -> fToken
    java.lang.String fOperatorString -> fOperatorString
    java.util.List fOperList -> fOperList
    int rowCount -> rowCount
    int fCurrentColumnStartPosition -> fCurrentColumnStartPosition
    int TT_EOF -> TT_EOF
    int TT_FLOATING_POINT -> TT_FLOATING_POINT
    int TT_ARGUMENTS_OPEN -> TT_ARGUMENTS_OPEN
    int TT_ARGUMENTS_CLOSE -> TT_ARGUMENTS_CLOSE
    int TT_PRECEDENCE_OPEN -> TT_PRECEDENCE_OPEN
    int TT_PRECEDENCE_CLOSE -> TT_PRECEDENCE_CLOSE
    int TT_LIST_OPEN -> TT_LIST_OPEN
    int TT_LIST_CLOSE -> TT_LIST_CLOSE
    int TT_PARTOPEN -> TT_PARTOPEN
    int TT_PARTCLOSE -> TT_PARTCLOSE
    int TT_OPERATOR -> TT_OPERATOR
    int TT_COMMA -> TT_COMMA
    int TT_PERCENT -> TT_PERCENT
    int TT_STRING -> TT_STRING
    int TT_BLANK -> TT_BLANK
    int TT_IDENTIFIER -> TT_IDENTIFIER
    int TT_DIGIT -> TT_DIGIT
    int TT_SLOT -> TT_SLOT
    int TT_SLOTSEQUENCE -> TT_SLOTSEQUENCE
    int TT_BLANK_BLANK -> TT_BLANK_BLANK
    int TT_BLANK_BLANK_BLANK -> TT_BLANK_BLANK_BLANK
    int TT_BLANK_OPTIONAL -> TT_BLANK_OPTIONAL
    int TT_DERIVATIVE -> TT_DERIVATIVE
    int numFormat -> numFormat
    org.matheclipse.parser.client.ast.IParserFactory fFactory -> fFactory
    java.util.HashMap CHAR_MAP -> a
    void <init>() -> <init>
    void initialize(java.lang.String) -> initialize
    void initializeNullScanner() -> a
    void getChar() -> b
    void getNextChar() -> c
    java.util.List getOperator() -> getOperator
    void getNextToken() -> getNextToken
    void throwSyntaxError(java.lang.String) -> throwSyntaxError
    void throwSyntaxError(java.lang.String,int) -> throwSyntaxError
    java.lang.String getErrorLine() -> a
    java.lang.String getIdentifier() -> getIdentifier
    java.lang.Object[] getNumberString() -> getNumberString
    java.lang.StringBuffer getStringBuffer() -> getStringBuffer
    void <clinit>() -> <clinit>
org.matheclipse.parser.client.SyntaxError -> org.matheclipse.parser.client.SyntaxError:
    long serialVersionUID -> serialVersionUID
    int fStartOffset -> fStartOffset
    int fRowIndex -> fRowIndex
    int fColumnIndex -> fColumnIndex
    int fLength -> fLength
    java.lang.String fCurrentLine -> fCurrentLine
    java.lang.String fError -> fError
    void <init>(int,int,int,java.lang.String,java.lang.String,int) -> <init>
    java.lang.String getMessage() -> getMessage
    int getStartOffset() -> getStartOffset
    int getColumnIndex() -> getColumnIndex
    java.lang.String getCurrentLine() -> getCurrentLine
    java.lang.String getError() -> getError
    int getLength() -> getLength
    int getRowIndex() -> getRowIndex
org.matheclipse.parser.client.ast.ASTNode -> org.matheclipse.parser.client.ast.ASTNode:
    java.lang.String fStringValue -> fStringValue
    void <init>(java.lang.String) -> <init>
    java.lang.String getString() -> getString
    java.lang.String toString() -> toString
    boolean dependsOn(java.lang.String) -> dependsOn
    boolean isFree(org.matheclipse.parser.client.ast.ASTNode) -> isFree
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FloatNode -> org.matheclipse.parser.client.ast.FloatNode:
    void <init>(java.lang.String) -> <init>
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FractionNode -> org.matheclipse.parser.client.ast.FractionNode:
    org.matheclipse.parser.client.ast.IntegerNode fNumerator -> fNumerator
    org.matheclipse.parser.client.ast.IntegerNode fDenominator -> fDenominator
    void <init>(org.matheclipse.parser.client.ast.IntegerNode,org.matheclipse.parser.client.ast.IntegerNode) -> <init>
    org.matheclipse.parser.client.ast.IntegerNode getDenominator() -> getDenominator
    org.matheclipse.parser.client.ast.IntegerNode getNumerator() -> getNumerator
    java.lang.String toString() -> toString
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.FunctionNode -> org.matheclipse.parser.client.ast.FunctionNode:
    java.util.ArrayList fNodesList -> a
    void <init>(org.matheclipse.parser.client.ast.ASTNode) -> <init>
    void <init>(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> <init>
    void <init>(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> <init>
    void add(int,org.matheclipse.parser.client.ast.ASTNode) -> add
    boolean add(org.matheclipse.parser.client.ast.ASTNode) -> add
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    void ensureCapacity(int) -> ensureCapacity
    boolean equals(java.lang.Object) -> equals
    org.matheclipse.parser.client.ast.ASTNode get(int) -> get
    org.matheclipse.parser.client.ast.ASTNode getNode(int) -> getNode
    int hashCode() -> hashCode
    int indexOf(java.lang.Object) -> indexOf
    boolean isEmpty() -> isEmpty
    boolean isFree(org.matheclipse.parser.client.ast.ASTNode) -> isFree
    java.util.Iterator iterator() -> iterator
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.util.ListIterator listIterator() -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
    org.matheclipse.parser.client.ast.ASTNode remove(int) -> remove
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    org.matheclipse.parser.client.ast.ASTNode set(int,org.matheclipse.parser.client.ast.ASTNode) -> set
    int size() -> size
    java.util.List subList(int,int) -> subList
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    java.lang.String toString() -> toString
    void trimToSize() -> trimToSize
    boolean dependsOn(java.lang.String) -> dependsOn
    java.lang.Object remove(int) -> remove
    void add(int,java.lang.Object) -> add
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    boolean add(java.lang.Object) -> add
org.matheclipse.parser.client.ast.IConstantOperators -> org.matheclipse.parser.client.ast.IConstantOperators:
    java.lang.String List -> List
    java.lang.String Out -> Out
    java.lang.String Part -> Part
    java.lang.String Slot -> Slot
    java.lang.String SlotSequence -> SlotSequence
org.matheclipse.parser.client.ast.IParserFactory -> org.matheclipse.parser.client.ast.IParserFactory:
    java.lang.String DEFAULT_OPERATOR_CHARACTERS -> DEFAULT_OPERATOR_CHARACTERS
    java.lang.String getOperatorCharacters() -> getOperatorCharacters
    java.util.Map getIdentifier2OperatorMap() -> getIdentifier2OperatorMap
    java.util.Map getOperator2ListMap() -> getOperator2ListMap
    org.matheclipse.parser.client.operator.Operator get(java.lang.String) -> get
    java.util.List getOperatorList(java.lang.String) -> getOperatorList
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode) -> createFunction
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
    org.matheclipse.parser.client.ast.FunctionNode createAST(org.matheclipse.parser.client.ast.ASTNode) -> createAST
    org.matheclipse.parser.client.ast.ASTNode createDouble(java.lang.String) -> createDouble
    org.matheclipse.parser.client.ast.IntegerNode createInteger(java.lang.String,int) -> createInteger
    org.matheclipse.parser.client.ast.IntegerNode createInteger(int) -> createInteger
    org.matheclipse.parser.client.ast.FractionNode createFraction(org.matheclipse.parser.client.ast.IntegerNode,org.matheclipse.parser.client.ast.IntegerNode) -> createFraction
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> createPattern
    org.matheclipse.parser.client.ast.PatternNode createPattern2(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> createPattern2
    org.matheclipse.parser.client.ast.PatternNode createPattern3(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> createPattern3
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> createPattern
    org.matheclipse.parser.client.ast.StringNode createString(java.lang.StringBuffer) -> createString
    org.matheclipse.parser.client.ast.SymbolNode createSymbol(java.lang.String) -> createSymbol
    boolean isValidIdentifier(java.lang.String) -> isValidIdentifier
org.matheclipse.parser.client.ast.IntegerNode -> org.matheclipse.parser.client.ast.IntegerNode:
    org.matheclipse.parser.client.ast.IntegerNode C1 -> C1
    int fNumberFormat -> a
    int fIntValue -> b
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,int) -> <init>
    void <init>(int) -> <init>
    java.lang.String toString() -> toString
    int getNumberFormat() -> getNumberFormat
    int getIntValue() -> getIntValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    void <clinit>() -> <clinit>
org.matheclipse.parser.client.ast.NumberNode -> org.matheclipse.parser.client.ast.NumberNode:
    boolean sign -> sign
    void <init>(java.lang.String) -> <init>
    void toggleSign() -> toggleSign
    java.lang.String getString() -> getString
    java.lang.String toString() -> toString
    boolean isSign() -> isSign
    double doubleValue() -> doubleValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.Pattern2Node -> org.matheclipse.parser.client.ast.Pattern2Node:
    void <init>(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> <init>
    void <init>(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> <init>
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.Pattern3Node -> org.matheclipse.parser.client.ast.Pattern3Node:
    void <init>(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> <init>
    void <init>(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> <init>
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.PatternNode -> org.matheclipse.parser.client.ast.PatternNode:
    org.matheclipse.parser.client.ast.SymbolNode fSymbol -> fSymbol
    boolean fDefault -> fDefault
    org.matheclipse.parser.client.ast.ASTNode fConstraint -> fConstraint
    void <init>(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> <init>
    void <init>(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> <init>
    org.matheclipse.parser.client.ast.ASTNode getConstraint() -> getConstraint
    org.matheclipse.parser.client.ast.SymbolNode getSymbol() -> getSymbol
    boolean isDefault() -> isDefault
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.ast.StringNode -> org.matheclipse.parser.client.ast.StringNode:
    void <init>(java.lang.String) -> <init>
org.matheclipse.parser.client.ast.SymbolNode -> org.matheclipse.parser.client.ast.SymbolNode:
    void <init>(java.lang.String) -> <init>
    boolean dependsOn(java.lang.String) -> dependsOn
org.matheclipse.parser.client.eval.BooleanVariable -> org.matheclipse.parser.client.eval.BooleanVariable:
    boolean value -> a
    void <init>(boolean) -> <init>
    boolean getValue() -> getValue
    void setValue(boolean) -> setValue
org.matheclipse.parser.client.eval.ComplexEvalVisitor -> org.matheclipse.parser.client.eval.ComplexEvalVisitor:
    boolean DEBUG -> DEBUG
    java.util.Map SYMBOL_MAP -> a
    java.util.Map SYMBOL_BOOLEAN_MAP -> b
    java.util.Map FUNCTION_MAP -> c
    java.util.Map FUNCTION_BOOLEAN_MAP -> d
    java.util.Map fVariableMap -> e
    java.util.Map fBooleanVariables -> f
    boolean fRelaxedSyntax -> a
    void <init>(boolean) -> <init>
    org.matheclipse.parser.client.math.Complex getResult() -> getResult
    void setUp(org.matheclipse.parser.client.math.Complex) -> setUp
    void tearDown() -> tearDown
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.eval.ComplexNode) -> visit
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.eval.DoubleNode) -> visit
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.ast.FloatNode) -> visit
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.ast.FractionNode) -> visit
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.ast.FunctionNode) -> visit
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.ast.IntegerNode) -> visit
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.ast.PatternNode) -> visit
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.ast.StringNode) -> visit
    org.matheclipse.parser.client.math.Complex visit(org.matheclipse.parser.client.ast.SymbolNode) -> visit
    boolean evaluateNodeLogical(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNodeLogical
    boolean evaluateFunctionLogical(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunctionLogical
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.ComplexVariable) -> defineVariable
    org.matheclipse.parser.client.eval.ComplexVariable getVariable(java.lang.String) -> getVariable
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.BooleanVariable) -> defineVariable
    void clearVariables() -> clearVariables
    org.matheclipse.parser.client.ast.ASTNode optimizeFunction(org.matheclipse.parser.client.ast.FunctionNode) -> optimizeFunction
    java.lang.Object visit(org.matheclipse.parser.client.ast.SymbolNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.StringNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.PatternNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.IntegerNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.FractionNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.FloatNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.eval.DoubleNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.eval.ComplexNode) -> visit
    void setUp(java.lang.Object) -> setUp
    java.lang.Object visit(org.matheclipse.parser.client.ast.FunctionNode) -> visit
    java.lang.Object getVariable(java.lang.String) -> getVariable
    void defineVariable(java.lang.String,java.lang.Object) -> defineVariable
    void <clinit>() -> <clinit>
org.matheclipse.parser.client.eval.ComplexEvalVisitor$1 -> nY:
    void <init>() -> <init>
    boolean evaluate(boolean,boolean) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$10 -> nZ:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$11 -> oa:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$12 -> ob:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$13 -> oc:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$14 -> od:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$15 -> oe:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$16 -> of:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$17 -> og:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$2 -> oh:
    void <init>() -> <init>
    boolean evaluate(boolean) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$3 -> oi:
    void <init>() -> <init>
    boolean evaluate(boolean,boolean) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$4 -> oj:
    void <init>() -> <init>
    boolean evaluate(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$5 -> ok:
    void <init>() -> <init>
    boolean evaluate(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$6 -> ol:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate() -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$7 -> om:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$8 -> on:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$9 -> oo:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$ArcTanFunction -> op:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$CompoundExpressionFunction -> oq:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.eval.api.IEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$LogFunction -> or:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$PlusFunction -> os:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> evaluate
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.eval.api.IEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$SetFunction -> ot:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.eval.api.IEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvalVisitor$TimesFunction -> ou:
    void <init>() -> <init>
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> evaluate
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.eval.api.IEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.ComplexEvaluator -> org.matheclipse.parser.client.eval.ComplexEvaluator:
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    void <init>(org.matheclipse.parser.client.eval.api.IASTVisitor,boolean) -> <init>
    java.lang.String toString(org.matheclipse.parser.client.math.Complex) -> toString
org.matheclipse.parser.client.eval.ComplexNode -> org.matheclipse.parser.client.eval.ComplexNode:
    org.matheclipse.parser.client.math.Complex value -> a
    void <init>(org.matheclipse.parser.client.math.Complex) -> <init>
    void <init>(double) -> <init>
    void <init>(double,double) -> <init>
    org.matheclipse.parser.client.math.Complex complexValue() -> complexValue
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.eval.ComplexVariable -> org.matheclipse.parser.client.eval.ComplexVariable:
    org.matheclipse.parser.client.math.Complex value -> a
    void <init>(double) -> <init>
    void <init>(org.matheclipse.parser.client.math.Complex) -> <init>
    org.matheclipse.parser.client.math.Complex getValue() -> getValue
    void setValue(double) -> setValue
    void setValue(org.matheclipse.parser.client.math.Complex) -> setValue
org.matheclipse.parser.client.eval.DoubleEvaluator -> org.matheclipse.parser.client.eval.DoubleEvaluator:
    double EPSILON -> EPSILON
    java.util.Map SYMBOL_DOUBLE_MAP -> a
    java.util.Map SYMBOL_BOOLEAN_MAP -> b
    java.util.Map FUNCTION_DOUBLE_MAP -> c
    java.util.Map FUNCTION_BOOLEAN_MAP -> d
    org.matheclipse.parser.client.eval.IDoubleCallbackFunction fCallbackFunction -> a
    java.util.Map fVariableMap -> e
    java.util.Map fBooleanVariables -> f
    org.matheclipse.parser.client.ast.ASTNode fNode -> a
    boolean fRelaxedSyntax -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory fASTFactory -> a
    org.matheclipse.parser.client.eval.IDoubleCallbackFunction getCallbackFunction() -> getCallbackFunction
    void setCallbackFunction(org.matheclipse.parser.client.eval.IDoubleCallbackFunction) -> setCallbackFunction
    void <init>() -> <init>
    void <init>(boolean) -> <init>
    void <init>(org.matheclipse.parser.client.ast.ASTNode,boolean) -> <init>
    org.matheclipse.parser.client.ast.ASTNode parse(java.lang.String) -> parse
    org.matheclipse.parser.client.ast.ASTNode parseNode(java.lang.String,boolean) -> parseNode
    double evaluate(java.lang.String) -> evaluate
    double evaluate() -> evaluate
    double evaluateNode(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNode
    double evaluateFunction(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunction
    boolean isSymbol(org.matheclipse.parser.client.ast.SymbolNode,java.lang.String) -> isSymbol
    boolean isSymbol(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.SymbolNode) -> isSymbol
    org.matheclipse.parser.client.ast.ASTNode derivative(org.matheclipse.parser.client.ast.ASTNode,java.lang.String) -> derivative
    org.matheclipse.parser.client.ast.ASTNode derivative(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.SymbolNode) -> derivative
    org.matheclipse.parser.client.ast.ASTNode getDerivativeResult(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.FunctionNode) -> a
    boolean evaluateNodeLogical(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNodeLogical
    boolean evaluateFunctionLogical(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunctionLogical
    org.matheclipse.parser.client.ast.ASTNode optimizeFunction(org.matheclipse.parser.client.ast.FunctionNode) -> optimizeFunction
    void defineVariable(java.lang.String,double) -> defineVariable
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.IDoubleValue) -> defineVariable
    void defineVariable(java.lang.String) -> defineVariable
    org.matheclipse.parser.client.eval.IDoubleValue getVariable(java.lang.String) -> getVariable
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.BooleanVariable) -> defineVariable
    void clearVariables() -> clearVariables
    void getVariables(java.lang.String,java.util.Set) -> getVariables
    void getVariables(java.lang.String,java.util.Set,boolean) -> getVariables
    void getVariables(org.matheclipse.parser.client.ast.ASTNode,java.util.Set) -> getVariables
    void <clinit>() -> <clinit>
org.matheclipse.parser.client.eval.DoubleEvaluator$1 -> ov:
    void <init>() -> <init>
    boolean evaluate(boolean,boolean) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$10 -> ow:
    void <init>() -> <init>
    double evaluate() -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$11 -> ox:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$12 -> oy:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$13 -> oz:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$14 -> oA:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$15 -> oB:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$16 -> oC:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$17 -> oD:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$18 -> oE:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$19 -> oF:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$2 -> oG:
    void <init>() -> <init>
    boolean evaluate(boolean) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$20 -> oH:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$21 -> oI:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$22 -> oJ:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$23 -> oK:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$24 -> oL:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$25 -> oM:
    void <init>() -> <init>
    double evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$3 -> oN:
    void <init>() -> <init>
    boolean evaluate(boolean,boolean) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$4 -> oO:
    void <init>() -> <init>
    boolean evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$5 -> oP:
    void <init>() -> <init>
    boolean evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$6 -> oQ:
    void <init>() -> <init>
    boolean evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$7 -> oR:
    void <init>() -> <init>
    boolean evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$8 -> oS:
    void <init>() -> <init>
    boolean evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$9 -> oT:
    void <init>() -> <init>
    boolean evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$ArcTanFunction -> oU:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
    double evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$CompoundExpressionFunction -> oV:
    void <init>() -> <init>
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$LogFunction -> oW:
    void <init>() -> <init>
    double evaluate(double) -> evaluate
    double evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$MaxFunction -> oX:
    void <init>() -> <init>
    double evaluate(double,double) -> evaluate
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$MinFunction -> oY:
    void <init>() -> <init>
    double evaluate(double,double) -> evaluate
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$PlusFunction -> oZ:
    void <init>() -> <init>
    double evaluate(double,double) -> evaluate
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$SetFunction -> pa:
    void <init>() -> <init>
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.DoubleEvaluator$TimesFunction -> pb:
    void <init>() -> <init>
    double evaluate(double,double) -> evaluate
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.DoubleNode -> org.matheclipse.parser.client.eval.DoubleNode:
    double value -> a
    void <init>(double) -> <init>
    double doubleValue() -> doubleValue
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.eval.DoubleVariable -> org.matheclipse.parser.client.eval.DoubleVariable:
    double value -> a
    void <init>(double) -> <init>
    double getValue() -> getValue
    void setValue(double) -> setValue
org.matheclipse.parser.client.eval.IBooleanBoolean1Function -> org.matheclipse.parser.client.eval.IBooleanBoolean1Function:
    boolean evaluate(boolean) -> evaluate
org.matheclipse.parser.client.eval.IBooleanBoolean2Function -> org.matheclipse.parser.client.eval.IBooleanBoolean2Function:
    boolean evaluate(boolean,boolean) -> evaluate
org.matheclipse.parser.client.eval.IBooleanComplex2Function -> org.matheclipse.parser.client.eval.IBooleanComplex2Function:
    boolean evaluate(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.IBooleanDouble2Function -> org.matheclipse.parser.client.eval.IBooleanDouble2Function:
    boolean evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.IComplex0Function -> org.matheclipse.parser.client.eval.IComplex0Function:
    org.matheclipse.parser.client.math.Complex evaluate() -> evaluate
org.matheclipse.parser.client.eval.IComplex1Function -> org.matheclipse.parser.client.eval.IComplex1Function:
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.IComplex2Function -> org.matheclipse.parser.client.eval.IComplex2Function:
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> evaluate
org.matheclipse.parser.client.eval.IComplexFunction -> org.matheclipse.parser.client.eval.IComplexFunction:
    org.matheclipse.parser.client.math.Complex evaluate(org.matheclipse.parser.client.eval.api.IEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.IDouble0Function -> org.matheclipse.parser.client.eval.IDouble0Function:
    double evaluate() -> evaluate
org.matheclipse.parser.client.eval.IDouble1Function -> org.matheclipse.parser.client.eval.IDouble1Function:
    double evaluate(double) -> evaluate
org.matheclipse.parser.client.eval.IDouble2Function -> org.matheclipse.parser.client.eval.IDouble2Function:
    double evaluate(double,double) -> evaluate
org.matheclipse.parser.client.eval.IDoubleCallbackFunction -> org.matheclipse.parser.client.eval.IDoubleCallbackFunction:
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode,double[]) -> evaluate
org.matheclipse.parser.client.eval.IDoubleFunction -> org.matheclipse.parser.client.eval.IDoubleFunction:
    double evaluate(org.matheclipse.parser.client.eval.DoubleEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.IDoubleValue -> org.matheclipse.parser.client.eval.IDoubleValue:
    double getValue() -> getValue
    void setValue(double) -> setValue
org.matheclipse.parser.client.eval.api.AbstractASTVisitor -> org.matheclipse.parser.client.eval.api.AbstractASTVisitor:
    void <init>() -> <init>
    void setUp(java.lang.Object) -> setUp
    void tearDown() -> tearDown
    java.lang.Object visit(org.matheclipse.parser.client.eval.ComplexNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.eval.DoubleNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.FloatNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.FractionNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.IntegerNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.PatternNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.StringNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.SymbolNode) -> visit
    java.lang.Object evaluateNode(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNode
org.matheclipse.parser.client.eval.api.IASTVisitor -> org.matheclipse.parser.client.eval.api.IASTVisitor:
    void setUp(java.lang.Object) -> setUp
    void tearDown() -> tearDown
    java.lang.Object visit(org.matheclipse.parser.client.eval.ComplexNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.eval.DoubleNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.FunctionNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.FloatNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.FractionNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.IntegerNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.PatternNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.StringNode) -> visit
    java.lang.Object visit(org.matheclipse.parser.client.ast.SymbolNode) -> visit
org.matheclipse.parser.client.eval.api.IEvaluator -> org.matheclipse.parser.client.eval.api.IEvaluator:
    void clearVariables() -> clearVariables
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.BooleanVariable) -> defineVariable
    void defineVariable(java.lang.String,java.lang.Object) -> defineVariable
    java.lang.Object evaluateNode(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNode
    java.lang.Object getVariable(java.lang.String) -> getVariable
    org.matheclipse.parser.client.ast.ASTNode optimizeFunction(org.matheclipse.parser.client.ast.FunctionNode) -> optimizeFunction
org.matheclipse.parser.client.eval.api.ObjectEvaluator -> org.matheclipse.parser.client.eval.api.ObjectEvaluator:
    org.matheclipse.parser.client.ast.ASTNode fNode -> fNode
    org.matheclipse.parser.client.eval.api.IASTVisitor fVisitor -> fVisitor
    boolean fRelaxedSyntax -> fRelaxedSyntax
    void <init>(org.matheclipse.parser.client.eval.api.IASTVisitor,boolean) -> <init>
    java.lang.Object evaluateNode(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNode
    java.lang.Object evaluateNode(org.matheclipse.parser.client.ast.ASTNode,java.lang.Object) -> evaluateNode
    void defineVariable(java.lang.String,java.lang.Object) -> defineVariable
    java.lang.Object getVariable(java.lang.String) -> getVariable
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.BooleanVariable) -> defineVariable
    void clearVariables() -> clearVariables
    org.matheclipse.parser.client.ast.ASTNode optimizeFunction(org.matheclipse.parser.client.ast.FunctionNode) -> optimizeFunction
    java.lang.Object evaluate(java.lang.String) -> evaluate
    java.lang.Object evaluate() -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator -> org.matheclipse.parser.client.eval.dfp.DfpEvaluator:
    java.util.Map SYMBOL_DFP_MAP -> a
    java.util.Map SYMBOL_BOOLEAN_MAP -> b
    java.util.Map FUNCTION_DFP_MAP -> c
    java.util.Map FUNCTION_BOOLEAN_MAP -> d
    org.matheclipse.parser.client.eval.dfp.IDfpCallbackFunction fCallbackFunction -> a
    java.util.Map fVariableMap -> e
    java.util.Map fBooleanVariables -> f
    org.apache.commons.math3.dfp.DfpField fDfpField -> a
    org.matheclipse.parser.client.eval.dfp.DfpNode fZERO -> a
    org.matheclipse.parser.client.ast.ASTNode fNode -> a
    boolean fRelaxedSyntax -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory fASTFactory -> a
    org.matheclipse.parser.client.eval.dfp.IDfpCallbackFunction getCallbackFunction() -> getCallbackFunction
    void setCallbackFunction(org.matheclipse.parser.client.eval.dfp.IDfpCallbackFunction) -> setCallbackFunction
    void <init>(int) -> <init>
    void <init>(int,boolean) -> <init>
    void <init>(int,org.matheclipse.parser.client.ast.ASTNode,boolean) -> <init>
    org.matheclipse.parser.client.ast.ASTNode parse(java.lang.String) -> parse
    org.matheclipse.parser.client.ast.ASTNode parseNode(int,java.lang.String,boolean) -> parseNode
    org.apache.commons.math3.dfp.Dfp evaluate(java.lang.String) -> evaluate
    org.apache.commons.math3.dfp.Dfp evaluate() -> evaluate
    org.apache.commons.math3.dfp.Dfp evaluateNode(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNode
    org.apache.commons.math3.dfp.Dfp evaluateFunction(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunction
    boolean isSymbol(org.matheclipse.parser.client.ast.SymbolNode,java.lang.String) -> isSymbol
    boolean isSymbol(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.SymbolNode) -> isSymbol
    org.matheclipse.parser.client.ast.ASTNode derivative(org.matheclipse.parser.client.ast.ASTNode,java.lang.String) -> derivative
    org.matheclipse.parser.client.ast.ASTNode derivative(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.SymbolNode) -> derivative
    org.matheclipse.parser.client.ast.ASTNode getDerivativeResult(org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.FunctionNode) -> a
    boolean evaluateNodeLogical(org.matheclipse.parser.client.ast.ASTNode) -> evaluateNodeLogical
    boolean evaluateFunctionLogical(org.matheclipse.parser.client.ast.FunctionNode) -> evaluateFunctionLogical
    org.matheclipse.parser.client.ast.ASTNode optimizeFunction(org.matheclipse.parser.client.ast.FunctionNode) -> optimizeFunction
    void defineVariable(java.lang.String,org.apache.commons.math3.dfp.Dfp) -> defineVariable
    org.matheclipse.parser.client.eval.dfp.IDfpValue defineVariable(java.lang.String,org.matheclipse.parser.client.eval.dfp.IDfpValue) -> defineVariable
    org.matheclipse.parser.client.eval.dfp.IDfpValue defineVariable(java.lang.String,double) -> defineVariable
    void setValue(org.matheclipse.parser.client.eval.dfp.IDfpValue,double) -> setValue
    void defineVariable(java.lang.String) -> defineVariable
    org.matheclipse.parser.client.eval.dfp.IDfpValue getVariable(java.lang.String) -> getVariable
    void defineVariable(java.lang.String,org.matheclipse.parser.client.eval.BooleanVariable) -> defineVariable
    void clearVariables() -> clearVariables
    void getVariables(java.lang.String,java.util.Set) -> getVariables
    void getVariables(java.lang.String,java.util.Set,boolean) -> getVariables
    void getVariables(org.matheclipse.parser.client.ast.ASTNode,java.util.Set) -> getVariables
    org.apache.commons.math3.dfp.DfpField access$000(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> a
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$1 -> pc:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(boolean,boolean) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$10 -> pd:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$11 -> pe:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$12 -> pf:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$13 -> pg:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$14 -> ph:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$15 -> pi:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$16 -> pj:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$17 -> pk:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$18 -> pl:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$19 -> pm:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$2 -> pn:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(boolean) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$20 -> po:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$21 -> pp:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$22 -> pq:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$23 -> pr:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$3 -> ps:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(boolean,boolean) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$4 -> pt:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$5 -> pu:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$6 -> pv:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$7 -> pw:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$8 -> px:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$9 -> py:
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    boolean evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$ArcTanFunction -> pz:
    void <init>() -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$CompoundExpressionFunction -> pA:
    void <init>() -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.matheclipse.parser.client.eval.dfp.DfpEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$LogFunction -> pB:
    void <init>() -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$MaxFunction -> pC:
    void <init>() -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
    org.apache.commons.math3.dfp.Dfp evaluate(org.matheclipse.parser.client.eval.dfp.DfpEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$MinFunction -> pD:
    void <init>() -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
    org.apache.commons.math3.dfp.Dfp evaluate(org.matheclipse.parser.client.eval.dfp.DfpEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$PlusFunction -> pE:
    org.matheclipse.parser.client.eval.dfp.DfpEvaluator this$0 -> a
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
    org.apache.commons.math3.dfp.Dfp evaluate(org.matheclipse.parser.client.eval.dfp.DfpEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$SetFunction -> pF:
    void <init>() -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.matheclipse.parser.client.eval.dfp.DfpEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpEvaluator$TimesFunction -> pG:
    org.matheclipse.parser.client.eval.dfp.DfpEvaluator this$0 -> a
    void <init>(org.matheclipse.parser.client.eval.dfp.DfpEvaluator) -> <init>
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
    org.apache.commons.math3.dfp.Dfp evaluate(org.matheclipse.parser.client.eval.dfp.DfpEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.dfp.DfpNode -> org.matheclipse.parser.client.eval.dfp.DfpNode:
    org.apache.commons.math3.dfp.Dfp value -> a
    void <init>(org.apache.commons.math3.dfp.Dfp) -> <init>
    org.apache.commons.math3.dfp.Dfp getDfpValue() -> getDfpValue
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.matheclipse.parser.client.eval.dfp.DfpVariable -> org.matheclipse.parser.client.eval.dfp.DfpVariable:
    org.apache.commons.math3.dfp.Dfp value -> a
    void <init>(org.apache.commons.math3.dfp.Dfp) -> <init>
    org.apache.commons.math3.dfp.Dfp getValue() -> getValue
    void setValue(org.apache.commons.math3.dfp.Dfp) -> setValue
org.matheclipse.parser.client.eval.dfp.IBooleanDfp2Function -> org.matheclipse.parser.client.eval.dfp.IBooleanDfp2Function:
    boolean evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.IDfp0Function -> org.matheclipse.parser.client.eval.dfp.IDfp0Function:
    org.apache.commons.math3.dfp.Dfp evaluate() -> evaluate
org.matheclipse.parser.client.eval.dfp.IDfp1Function -> org.matheclipse.parser.client.eval.dfp.IDfp1Function:
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.IDfp2Function -> org.matheclipse.parser.client.eval.dfp.IDfp2Function:
    org.apache.commons.math3.dfp.Dfp evaluate(org.apache.commons.math3.dfp.Dfp,org.apache.commons.math3.dfp.Dfp) -> evaluate
org.matheclipse.parser.client.eval.dfp.IDfpCallbackFunction -> org.matheclipse.parser.client.eval.dfp.IDfpCallbackFunction:
    org.apache.commons.math3.dfp.Dfp evaluate(org.matheclipse.parser.client.eval.dfp.DfpEvaluator,org.matheclipse.parser.client.ast.FunctionNode,org.apache.commons.math3.dfp.Dfp[]) -> evaluate
org.matheclipse.parser.client.eval.dfp.IDfpFunction -> org.matheclipse.parser.client.eval.dfp.IDfpFunction:
    org.apache.commons.math3.dfp.Dfp evaluate(org.matheclipse.parser.client.eval.dfp.DfpEvaluator,org.matheclipse.parser.client.ast.FunctionNode) -> evaluate
org.matheclipse.parser.client.eval.dfp.IDfpValue -> org.matheclipse.parser.client.eval.dfp.IDfpValue:
    org.apache.commons.math3.dfp.Dfp getValue() -> getValue
    void setValue(org.apache.commons.math3.dfp.Dfp) -> setValue
org.matheclipse.parser.client.math.ArithmeticMathException -> org.matheclipse.parser.client.math.ArithmeticMathException:
    long serialVersionUID -> serialVersionUID
    void <init>(java.lang.String) -> <init>
org.matheclipse.parser.client.math.Complex -> org.matheclipse.parser.client.math.Complex:
    org.matheclipse.parser.client.math.Complex I -> I
    org.matheclipse.parser.client.math.Complex NaN -> NaN
    org.matheclipse.parser.client.math.Complex INF -> INF
    org.matheclipse.parser.client.math.Complex ONE -> ONE
    org.matheclipse.parser.client.math.Complex ZERO -> ZERO
    long serialVersionUID -> serialVersionUID
    double imaginary -> imaginary
    double real -> real
    boolean isNaN -> a
    boolean isInfinite -> b
    void <init>(double) -> <init>
    void <init>(double,double) -> <init>
    double abs() -> abs
    org.matheclipse.parser.client.math.Complex add(org.matheclipse.parser.client.math.Complex) -> add
    org.matheclipse.parser.client.math.Complex add(double) -> add
    org.matheclipse.parser.client.math.Complex conjugate() -> conjugate
    org.matheclipse.parser.client.math.Complex divide(org.matheclipse.parser.client.math.Complex) -> divide
    org.matheclipse.parser.client.math.Complex divide(double) -> divide
    org.matheclipse.parser.client.math.Complex reciprocal() -> reciprocal
    boolean equals(java.lang.Object) -> equals
    boolean equals(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex,int) -> equals
    boolean equals(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex) -> equals
    boolean equals(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex,double) -> equals
    boolean equalsWithRelativeTolerance(org.matheclipse.parser.client.math.Complex,org.matheclipse.parser.client.math.Complex,double) -> equalsWithRelativeTolerance
    int hashCode() -> hashCode
    double getImaginary() -> getImaginary
    double getReal() -> getReal
    boolean isNaN() -> isNaN
    boolean isInfinite() -> isInfinite
    org.matheclipse.parser.client.math.Complex multiply(org.matheclipse.parser.client.math.Complex) -> multiply
    org.matheclipse.parser.client.math.Complex multiply(int) -> multiply
    org.matheclipse.parser.client.math.Complex multiply(double) -> multiply
    org.matheclipse.parser.client.math.Complex negate() -> negate
    org.matheclipse.parser.client.math.Complex subtract(org.matheclipse.parser.client.math.Complex) -> subtract
    org.matheclipse.parser.client.math.Complex subtract(double) -> subtract
    org.matheclipse.parser.client.math.Complex acos() -> acos
    org.matheclipse.parser.client.math.Complex asin() -> asin
    org.matheclipse.parser.client.math.Complex atan() -> atan
    org.matheclipse.parser.client.math.Complex cos() -> cos
    org.matheclipse.parser.client.math.Complex cosh() -> cosh
    org.matheclipse.parser.client.math.Complex exp() -> exp
    org.matheclipse.parser.client.math.Complex log() -> log
    org.matheclipse.parser.client.math.Complex pow(org.matheclipse.parser.client.math.Complex) -> pow
    org.matheclipse.parser.client.math.Complex pow(double) -> pow
    org.matheclipse.parser.client.math.Complex sin() -> sin
    org.matheclipse.parser.client.math.Complex sinh() -> sinh
    org.matheclipse.parser.client.math.Complex sqrt() -> sqrt
    org.matheclipse.parser.client.math.Complex sqrt1z() -> sqrt1z
    org.matheclipse.parser.client.math.Complex tan() -> tan
    org.matheclipse.parser.client.math.Complex tanh() -> tanh
    double getArgument() -> getArgument
    java.util.List nthRoot(int) -> nthRoot
    org.matheclipse.parser.client.math.Complex createComplex(double,double) -> createComplex
    org.matheclipse.parser.client.math.Complex valueOf(double,double) -> valueOf
    org.matheclipse.parser.client.math.Complex valueOf(double) -> valueOf
    java.lang.Object readResolve() -> readResolve
    java.lang.String toString() -> toString
    void <clinit>() -> <clinit>
org.matheclipse.parser.client.math.MathException -> org.matheclipse.parser.client.math.MathException:
    long serialVersionUID -> serialVersionUID
    void <init>() -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.Throwable) -> <init>
org.matheclipse.parser.client.math.MathUtils -> org.matheclipse.parser.client.math.MathUtils:
    void <init>() -> <init>
    int addAndCheck(int,int) -> addAndCheck
    long addAndCheck(long,long) -> addAndCheck
    long addAndCheck(long,long,java.lang.String) -> a
    long binomialCoefficient(int,int) -> binomialCoefficient
    double binomialCoefficientDouble(int,int) -> binomialCoefficientDouble
    double binomialCoefficientLog(int,int) -> binomialCoefficientLog
    double cosh(double) -> cosh
    boolean equals(double,double) -> equals
    boolean equals(double[],double[]) -> equals
    long factorial(int) -> factorial
    double factorialDouble(int) -> factorialDouble
    double factorialLog(int) -> factorialLog
    int gcd(int,int) -> gcd
    int hash(double) -> hash
    int hash(double[]) -> hash
    byte indicator(byte) -> indicator
    double indicator(double) -> indicator
    float indicator(float) -> indicator
    int indicator(int) -> indicator
    long indicator(long) -> indicator
    short indicator(short) -> indicator
    int lcm(int,int) -> lcm
    double log(double,double) -> log
    int mulAndCheck(int,int) -> mulAndCheck
    long mulAndCheck(long,long) -> mulAndCheck
    double normalizeAngle(double,double) -> normalizeAngle
    byte sign(byte) -> sign
    double sign(double) -> sign
    float sign(float) -> sign
    int sign(int) -> sign
    long sign(long) -> sign
    short sign(short) -> sign
    double sinh(double) -> sinh
    int subAndCheck(int,int) -> subAndCheck
    long subAndCheck(long,long) -> subAndCheck
org.matheclipse.parser.client.operator.ASTNodeFactory -> org.matheclipse.parser.client.operator.ASTNodeFactory:
    int PLUS_PRECEDENCE -> PLUS_PRECEDENCE
    int TIMES_PRECEDENCE -> TIMES_PRECEDENCE
    int DIVIDE_PRECEDENCE -> DIVIDE_PRECEDENCE
    int POWER_PRECEDENCE -> POWER_PRECEDENCE
    java.lang.String[] HEADER_STRINGS -> a
    java.lang.String[] OPERATOR_STRINGS -> b
    org.matheclipse.parser.client.operator.Operator[] OPERATORS -> a
    org.matheclipse.parser.client.operator.ASTNodeFactory MMA_STYLE_FACTORY -> MMA_STYLE_FACTORY
    org.matheclipse.parser.client.operator.ASTNodeFactory RELAXED_STYLE_FACTORY -> RELAXED_STYLE_FACTORY
    java.util.HashMap fOperatorMap -> a
    java.util.HashMap fOperatorTokenStartSet -> b
    boolean fIgnoreCase -> a
    void <init>(boolean) -> <init>
    void addOperator(java.util.Map,java.util.Map,java.lang.String,java.lang.String,org.matheclipse.parser.client.operator.Operator) -> addOperator
    java.lang.String getOperatorCharacters() -> getOperatorCharacters
    java.util.Map getIdentifier2OperatorMap() -> getIdentifier2OperatorMap
    org.matheclipse.parser.client.operator.Operator get(java.lang.String) -> get
    java.util.Map getOperator2ListMap() -> getOperator2ListMap
    java.util.List getOperatorList(java.lang.String) -> getOperatorList
    org.matheclipse.parser.client.operator.InfixOperator createInfixOperator(java.lang.String,java.lang.String,int,int) -> createInfixOperator
    org.matheclipse.parser.client.operator.PrefixOperator createPrefixOperator(java.lang.String,java.lang.String,int) -> createPrefixOperator
    org.matheclipse.parser.client.operator.PostfixOperator createPostfixOperator(java.lang.String,java.lang.String,int) -> createPostfixOperator
    org.matheclipse.parser.client.ast.ASTNode createDouble(java.lang.String) -> createDouble
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode) -> createFunction
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
    org.matheclipse.parser.client.ast.FunctionNode createFunction(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
    org.matheclipse.parser.client.ast.FunctionNode createAST(org.matheclipse.parser.client.ast.ASTNode) -> createAST
    org.matheclipse.parser.client.ast.IntegerNode createInteger(java.lang.String,int) -> createInteger
    org.matheclipse.parser.client.ast.IntegerNode createInteger(int) -> createInteger
    org.matheclipse.parser.client.ast.FractionNode createFraction(org.matheclipse.parser.client.ast.IntegerNode,org.matheclipse.parser.client.ast.IntegerNode) -> createFraction
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> createPattern
    org.matheclipse.parser.client.ast.PatternNode createPattern(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode,boolean) -> createPattern
    org.matheclipse.parser.client.ast.PatternNode createPattern2(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> createPattern2
    org.matheclipse.parser.client.ast.PatternNode createPattern3(org.matheclipse.parser.client.ast.SymbolNode,org.matheclipse.parser.client.ast.ASTNode) -> createPattern3
    org.matheclipse.parser.client.ast.StringNode createString(java.lang.StringBuffer) -> createString
    org.matheclipse.parser.client.ast.SymbolNode createSymbol(java.lang.String) -> createSymbol
    boolean isValidIdentifier(java.lang.String) -> isValidIdentifier
    void <clinit>() -> <clinit>
org.matheclipse.parser.client.operator.DivideOperator -> org.matheclipse.parser.client.operator.DivideOperator:
    void <init>(java.lang.String,java.lang.String,int,int) -> <init>
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
org.matheclipse.parser.client.operator.InfixOperator -> org.matheclipse.parser.client.operator.InfixOperator:
    int fGrouping -> a
    int NONE -> NONE
    int RIGHT_ASSOCIATIVE -> RIGHT_ASSOCIATIVE
    int LEFT_ASSOCIATIVE -> LEFT_ASSOCIATIVE
    void <init>(java.lang.String,java.lang.String,int,int) -> <init>
    int getGrouping() -> getGrouping
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
org.matheclipse.parser.client.operator.Operator -> org.matheclipse.parser.client.operator.Operator:
    java.lang.String fFunctionName -> fFunctionName
    java.lang.String fOperatorString -> fOperatorString
    int fPrecedence -> fPrecedence
    void <init>(java.lang.String,java.lang.String,int) -> <init>
    boolean equals(java.lang.Object) -> equals
    java.lang.String getFunctionName() -> getFunctionName
    java.lang.String getOperatorString() -> getOperatorString
    int getPrecedence() -> getPrecedence
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.matheclipse.parser.client.operator.PostfixOperator -> org.matheclipse.parser.client.operator.PostfixOperator:
    void <init>(java.lang.String,java.lang.String,int) -> <init>
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
org.matheclipse.parser.client.operator.PreMinusOperator -> org.matheclipse.parser.client.operator.PreMinusOperator:
    void <init>(java.lang.String,java.lang.String,int) -> <init>
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
org.matheclipse.parser.client.operator.PrePlusOperator -> org.matheclipse.parser.client.operator.PrePlusOperator:
    void <init>(java.lang.String,java.lang.String,int) -> <init>
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
org.matheclipse.parser.client.operator.PrefixOperator -> org.matheclipse.parser.client.operator.PrefixOperator:
    void <init>(java.lang.String,java.lang.String,int) -> <init>
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
org.matheclipse.parser.client.operator.SubtractOperator -> org.matheclipse.parser.client.operator.SubtractOperator:
    void <init>(java.lang.String,java.lang.String,int,int) -> <init>
    org.matheclipse.parser.client.ast.ASTNode createFunction(org.matheclipse.parser.client.ast.IParserFactory,org.matheclipse.parser.client.ast.ASTNode,org.matheclipse.parser.client.ast.ASTNode) -> createFunction
org.matheclipse.parser.server.util.Console -> org.matheclipse.parser.server.util.Console:
    java.io.File fFile -> a
    boolean fComplexEvaluatorMode -> a
    void main(java.lang.String[]) -> main
    void printUsage() -> a
    void <init>() -> <init>
    java.lang.String interpreter(java.lang.String) -> interpreter
    void printPrompt(java.io.PrintStream,java.lang.String) -> printPrompt
    java.lang.String readString(java.io.PrintStream) -> readString
    java.lang.String readString(java.io.PrintStream,java.lang.String) -> readString
    void setFile(java.io.File) -> setFile
    java.io.File getFile() -> getFile
org.matheclipse.parser.server.util.GenerateOperatorArrays -> org.matheclipse.parser.server.util.GenerateOperatorArrays:
    void <init>() -> <init>
    void main(java.lang.String[]) -> main
    void generateOperatorTable(java.io.InputStream,java.util.HashMap,java.util.HashMap) -> generateOperatorTable
